# Project Documentation

## Table of Contents
- [Overview](#overview)
- [Python Modules](#python-modules)
- [Other Files](#other-files)

## Overview
This README was generated automatically by analysing the contents of the project.  The analysis focuses primarily on Python modules, extracting module documentation, classes and functions.  Other file types are listed for completeness.

## Python Modules

### `agent_store.py`

agent_store.py
==============

Thread-safe SQLite façade for the AI-TTS-Agent “v4” architecture.

Tables
------
schemas            : Current JSON blob per persona / set
schema_history     : Versioned diffs – for audits / rollback
commands           : Slash command registry (+weight, locked flag, category_id FK)
beans              : Reinforcement counts & last-updated timestamp
variants           : Prompt / phrase variants auto-generated by SchemaEngine
settings           : Arbitrary per-profile key / val
files              : Filesystem snapshot chunks (path, hash, chunk_idx, content)
spatial_positions  : XY grid positions of entities (bot, objects…)
visual_actions     : Logged avatar actions (textual justification)

Public API
----------
AgentStore(base_dir)    – opens or creates *agent_store.db* in that dir
begin_tx() / commit()   – manual transactions (context-manager also available)
CRUD helpers            – get_schema(), put_schema(), inc_bean(), etc.
migrate_from_files()    – one-shot importer for legacy JSON / sqlite state
ensure_db()             – convenience: open DB, auto-migrate if needed

**Classes:** _PooledConn, AgentStore

**Functions:** ensure_db(base_dir)
### `bean_logic.py`

bean_logic.py
=============

Centralised reinforcement “bean” logic for profile‑scoped counters.

* **increment(profile, subject, delta, base_dir)** – adjust a counter by *delta* (clipped);
* **get_score(profile, subject, base_dir)** – retrieve the *decayed* score on demand;
* **score_band(score)** – map a numeric score to a qualitative colour band.

The module transparently handles persistence (JSON on disk) and exponential
decay so that old feedback gradually loses influence.

Decay model
-----------
Decay is applied lazily on reads using an exponential function:

    score(t) = score₀ · 0.5 ** ((t‑t₀) / HALFLIFE)

HALFLIFE defaults to seven days – after a week of inactivity the stored
score halves.

This design avoids expensive background jobs while ensuring stale feedback
fades out naturally.

**Functions:** _now(), _load(base_dir), _save(store, base_dir), increment(profile, subject, delta), get_score(profile, subject), score_band(score)
### `commands_panel.py`

commands_panel.py
=================

This module defines the CommandsPanel class which encapsulates all of the
controls shown on the left-hand side of the agent UI.  It exposes all
widgets publicly so that the top-level application window can interact
with them directly (for example, enabling/disabling buttons or reading
checkbox state).  All callbacks for user actions (recording, dataset
management, TTS playback, etc.) are delegated back to the hosting
``AppWindow`` instance via the ``app`` attribute passed to the
constructor.  No core logic lives here – the panel is purely a view layer.

**Classes:** CommandsPanel
### `command_palette.py`

command_palette.py
==================

Dockable *Command Palette* for the AI TTS Agent UI.

• Live list of every “/slash-command” pulled from the orchestrator.
• Search-box with type-ahead filter.
• Global shortcut **Ctrl + /** opens / focuses the palette from anywhere.
• Double-click (or Return) on a command emits `commandActivated(str)` so the
  main window can insert the text into the chat-input.

Typical integration in *main_ui.py*:

    self.cmd_palette = CommandPaletteDock(self)
    self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.cmd_palette)
    self.core.commandsChanged.connect(self.cmd_palette.set_command_list)
    self.cmd_palette.commandActivated.connect(
        lambda cmd: self._insert_into_chat(cmd)
    )

**Classes:** CommandPaletteDock
### `core_base.py`

core_base.py — foundational services for the modular AI-TTS Agent
=================================================================
• robust logging + graceful shims for missing deps
• Ollama model bootstrap  (ensure_models_present)
• JSON-backed Settings
• profile-aware helper paths
• ConversationDB  (SQLite)
• SemanticFeedbackDB  (SQLite)
• BeanCounter  (JSON tally)
• ReinforcementStore  (async JSONL append)
• cross-platform TTS locked to *Zira*
• minimal AudioRecorder placeholder
Everything here is UI-agnostic.

**Classes:** Settings, ConversationDB, SemanticFeedbackDB, BeanCounter, ReinforcementStore, TTSManager, AudioRecorder

**Functions:** _have_cli(cmd), ensure_models_present(), prof_dir(b, persona, set_name), conv_db_path(b, persona, set_name), feedback_db_path(b, persona, set_name), beans_path(b, persona, set_name)
### `core_orchestrator.py`

core_orchestrator.py
====================

This module provides the orchestration layer for the AI‑TTS agent.  It
exposes a unified API used by the user‑interface to interact with
schemas, conversations, commands, text‑to‑speech, plugins and other
components.  Historically the logic lived in a monolithic module,
but it has been refactored to encourage testability and to allow
individual subsystems to evolve independently.

The principal differences from earlier releases are:

* A richer :class:`PluginManager` that exposes a complete API expected
  by the UI.  In addition to discovering plugin packages from the
  ``plugins`` directory it now keeps per‑plugin metadata, supports
  enable/disable toggling, rescans at runtime, broadcasts messages to
  enabled plugins on a thread pool, and emits an ``eventReceived``
  signal whenever a plugin reports an event.  Plugins can either
  return a payload from their ``on_message`` handler or call
  ``emit_event`` on the manager directly to publish complex events.

* A ``run_command()`` method on :class:`AgentCore` which forwards
  slash commands through the :class:`CommandExecutor` and returns
  the textual result.  This helper centralises command routing and
  ensures backwards compatibility with older UI code.

* A ``process_user_message()`` method on :class:`AgentCore` which
  synchronously handles both slash‑commands and normal user input.  It
  persists the conversation, routes commands through the registry
  and, for non‑commands, returns a simple acknowledgement.  Future
  versions may integrate model execution here, but the method
  signature is stable for consumers.

* A ``command_registry`` attribute is exposed on the core as an
  adapter with a ``list_commands()`` method so that UI components
  (like the Command Palette) can enumerate available commands without
  coupling to internal registry details.

This file is fully self‑contained.  It gracefully degrades when
optional dependencies (such as PyQt5 or external model executables)
are unavailable by providing shims and in‑memory fallbacks.  Should
the optional modules exist in the runtime environment they will be
used automatically.  The design favours clear separation of
responsibilities, thread safety and explicit interfaces to ease
maintenance and extensibility.

**Classes:** CommandRegistry, CommandExecutor, PluginMeta, PluginManager, RAGCache, SchemaEngine, SchemaEvolver, DatasetManagerFallback, ModelWorker, AgentCore
### `core_schema.py`

core_schema.py — v3-final (2025-08-04 04:12 UTC) + commands-field patch (2025-08-09)
====================================================================================

Single-source authority for all schema / dataset / snapshot / spatial-state
logic used by FATHOM Agent, now relying on AgentStore’s public API only.

Provides:
• Schema dataclass + SchemaEngine (diff, auto-evolve, variant injection)
• OperatorManager persisted in the same DB
• DatasetManager (metadata) + RAGCache (embeddings) in the same DB
• SnapshotEngine to walk the codebase & persist chunks to DB
• SpatialPositionManager for grid-room positions & movement logging
• Back-compat alias: SchemaManager → SchemaEngine

This version adds the `.active_schemas` property required by main_ui.py.

**Classes:** Schema, SchemaEngine, OperatorManager, DatasetEntry, DatasetManager, RAGCache, SnapshotEngine, SpatialPositionManager

**Functions:** _ensure_store(root)
### `main_ui.py`

main_ui.py
===========

This module contains the top-level ``AppWindow`` class for the AI TTS
Agent.  It orchestrates all layout and docking behaviour, integrates
the control panel and persona tabs provided by ``commands_panel`` and
``persona_tab``, and exposes a unified interface for the rest of the
application.  None of the core agent logic lives here – that remains in
the ``core_*`` modules.  This refactor pulls the bulky UI building
logic out of the monolithic script and into dedicated modules while
preserving all existing behaviour and wiring.

**Classes:** _SpellHighlighter, AppWindow, DockTray, DockTitleBar, DatasetManagerDialog
### `migration_tool.py`

migration_tool.py
=================

Stand-alone CLI for *one-shot* migration of legacy AI-TTS-Agent files
(JSON schemas, commands.json, reinforcement.jsonl …) into the new
SQLite-backed **agent_store.db**.

Typical usage
-------------
$ python migration_tool.py /path/to/AI_TTS_AGENT
    → runs migrate (if needed) and prints a coloured diff table.

$ python migration_tool.py . --dry-run
    → shows what *would* be imported without touching the DB.

Exit codes
----------
0  success – nothing failed
1  fatal error (bad path, SQLite locked, etc.)
2  migration aborted by --check-upgrade only

**Functions:** _colour(txt, colour), _print_report(report), main()
### `persona_tab.py`

persona_tab.py
==============

**Schema-Editor 2.0**

This version upgrades the old free-text schema editor to a structured,
two-pane interface:

    • **Left:**   Category tree (actions, questions, etc.)  
    • **Right:**  Multiline editor for the selected node’s JSON value  
    • **Bottom:** “Expose as /command” checkbox (per category)  
    • **Top-right:** “Auto-Evolution” toggle for the whole set

Other improvements

* Autosave is now routed through **SchemaEngine.save()** (SQL-backed).
* Edits are debounced (500 ms) and validated before committing.
* When “Expose as /command” is ticked, a synthetic slash-command is written
  to *AgentStore.commands* for immediate use by the orchestrator.

**Classes:** PersonaTab

**Functions:** nice_json(value), parse_json(text)
### `run_agent.py`

run_agent.py — bootstrap launcher for AI TTS Agent (v3, 2025-08-04)

• Ensures the sqlite store exists (agent_store.ensure_db()) and runs
  legacy-data migration when user_version < 4.
• Accepts one optional command-line arg: <profile-dir>. Defaults to
  ./ai_agent_state relative to CWD.
• Starts the Qt GUI (main_ui.AppWindow).
• Catches early exceptions and prints a clean error trace instead of a
  raw stack-dump so newcomers understand what went wrong.

**Functions:** _bootstrap_state(base_dir), main()
### `schema_ops.py`

schema_ops.py  (2025-08-04  ▸  v2)
==================================

Declarative dispatcher that maps **string op-codes → mutator callables**
operating on core_schema.SchemaEngine / Schema rows.

Updates (v2)
------------
• Added category & prompt removal / update helpers
• Added action list mutators
• Added runtime-introspection helpers: available_ops(), describe_op()
• Strict type-checking & richer logging

Usage example
-------------
>>> from schema_ops import execute_op, available_ops
>>> print(available_ops())
['add_category', 'append_actions', 'delete_action', ...]
>>> execute_op("append_actions", engine,
...            persona="zira", set_name="default",
...            actions=["wave warmly", "offer coffee"])

**Functions:** _load(engine, persona, set_name), _save(engine, persona, set_name, sch), _signal_category_created(engine, persona, set_name, category), op_add_category(engine), op_remove_category(engine), op_update_category(engine), op_toggle_autoevo(engine), op_inject_prompt_variant(engine), op_remove_prompt_variant(engine), op_replace_rewrite_list(engine), op_append_actions(engine), op_delete_action(engine), op_rename_schema_set(engine), execute_op(op_name, engine), available_ops(), describe_op(op_name)
### `snapshot_worker.py`

snapshot_worker.py

This script defines ModelWorker, which runs inference on a given model in a separate thread.
Used by the UI to offload prompt evaluation from the main thread.

**Classes:** ModelWorker
### `spatial_engine.py`

spatial_engine.py
=================

Headless avatar movement & visual-action logger for the AI TTS Agent.

Features:
- Stateful finite-state machine (idle, thinking, moving).
- decide_move(response_text): simple NLP heuristics to pick a target cell.
- Animated, step-by-step movement on a configurable grid.
- Logs each position to AgentStore.spatial_positions and each completed move to AgentStore.visual_actions.
- Emits Qt signals for UI binding (positionChanged, actionLogged).

**Classes:** SpatialEngine

## Other Files

The following files are present in the project but were not analysed in detail:

- `__pycache__\agent_store.cpython-313.pyc`
- `__pycache__\command_palette.cpython-313.pyc`
- `__pycache__\commands_panel.cpython-313.pyc`
- `__pycache__\core_base.cpython-313.pyc`
- `__pycache__\core_orchestrator.cpython-313.pyc`
- `__pycache__\core_schema.cpython-313.pyc`
- `__pycache__\main_ui.cpython-313.pyc`
- `__pycache__\persona_tab.cpython-313.pyc`
- `__pycache__\snapshot_worker.cpython-313.pyc`
- `agent_store.db`
- `agent_store.db-shm`
- `agent_store.db-wal`
- `conversations\zira_default.sqlite3`
- `feedback\zira_default.sqlite3`
- `profiles\zira\default\commands.json`
- `profiles\zira\default\memory.json`
- `settings.json`


## Detailed Module Analyses


## Module `agent_store.py`

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
agent_store.py
==============

Thread-safe SQLite façade for the AI-TTS-Agent “v4” architecture.

Tables
------
schemas            : Current JSON blob per persona / set
schema_history     : Versioned diffs – for audits / rollback
commands           : Slash command registry (+weight, locked flag, category_id FK)
beans              : Reinforcement counts & last-updated timestamp
variants           : Prompt / phrase variants auto-generated by SchemaEngine
settings           : Arbitrary per-profile key / val
files              : Filesystem snapshot chunks (path, hash, chunk_idx, content)
spatial_positions  : XY grid positions of entities (bot, objects…)
visual_actions     : Logged avatar actions (textual justification)

Public API
----------
AgentStore(base_dir)    – opens or creates *agent_store.db* in that dir
begin_tx() / commit()   – manual transactions (context-manager also available)
CRUD helpers            – get_schema(), put_schema(), inc_bean(), etc.
migrate_from_files()    – one-shot importer for legacy JSON / sqlite state
ensure_db()             – convenience: open DB, auto-migrate if needed
"""

from __future__ import annotations

import contextlib
import hashlib
import json
import os
import sqlite3
import threading
import time
from typing import Any, Dict, Iterator, List, Optional, Tuple

###############################################################################
# CONSTANTS
###############################################################################

DB_VERSION = 4  # <- bump when schema changes

###############################################################################
# LOW-LEVEL:  connection pool  +  simple retry wrapper
###############################################################################


class _PooledConn:
    """Very small, single-writer / multi-reader pool – good enough for desktop."""

    def __init__(self, path: str) -> None:
        self._path = path
        self._lock = threading.RLock()
        self._pool: List[sqlite3.Connection] = []

    @contextlib.contextmanager
    def get(self) -> Iterator[sqlite3.Connection]:
        with self._lock:
            conn = self._pool.pop() if self._pool else sqlite3.connect(self._path, check_same_thread=False)
        try:
            yield conn
        finally:
            with self._lock:
                if len(self._pool) < 8:
                    self._pool.append(conn)
                else:
                    conn.close()


###############################################################################
# MAIN FACADE
###############################################################################


class AgentStore:
    """
    One instance per *base_dir*; thread-safe for GUI + background workers.
    """

    # ──────────────────────────── bootstrap ────────────────────────────────

    def __init__(self, base_dir: str) -> None:
        self.base_dir = base_dir
        self.db_path = os.path.join(base_dir, "agent_store.db")
        os.makedirs(base_dir, exist_ok=True)
        self._pool = _PooledConn(self.db_path)
        with self._pool.get() as c:
            self._apply_ddl(c)
            c.execute("PRAGMA journal_mode=WAL;")
            c.commit()

    # ------------------------------------------------------------------ DDL
    def _apply_ddl(self, c: sqlite3.Connection) -> None:
        """Create tables if they do not exist, then run migrations."""
        cur = c.cursor()
        cur.executescript(
            """
            PRAGMA foreign_keys = ON;

            CREATE TABLE IF NOT EXISTS meta (
              key TEXT PRIMARY KEY,
              value TEXT
            );

            CREATE TABLE IF NOT EXISTS schemas (
              persona TEXT NOT NULL,
              set_name TEXT NOT NULL,
              schema_json TEXT NOT NULL,
              updated REAL NOT NULL,
              PRIMARY KEY (persona, set_name)
            );

            CREATE TABLE IF NOT EXISTS schema_history (
              id INTEGER PRIMARY KEY AUTOINCREMENT,
              persona TEXT,
              set_name TEXT,
              schema_json TEXT,
              diff TEXT,
              updated REAL
            );

            CREATE TABLE IF NOT EXISTS commands (
              name TEXT PRIMARY KEY,
              weight INTEGER DEFAULT 0,
              locked INTEGER DEFAULT 0,
              category TEXT DEFAULT NULL
            );

            CREATE TABLE IF NOT EXISTS beans (
              subject TEXT PRIMARY KEY,
              count INTEGER DEFAULT 0,
              last_ts REAL
            );

            CREATE TABLE IF NOT EXISTS variants (
              id INTEGER PRIMARY KEY AUTOINCREMENT,
              persona TEXT,
              set_name TEXT,
              category TEXT,
              prompt TEXT
            );

            CREATE TABLE IF NOT EXISTS settings (
              key TEXT PRIMARY KEY,
              value TEXT
            );

            CREATE TABLE IF NOT EXISTS files (
              path TEXT,
              hash TEXT,
              chunk_idx INTEGER,
              size INTEGER,
              mtime REAL,
              content TEXT,
              PRIMARY KEY (path, chunk_idx)
            );

            CREATE TABLE IF NOT EXISTS spatial_positions (
              entity TEXT PRIMARY KEY,
              x INTEGER,
              y INTEGER,
              facing TEXT,
              color TEXT,
              ts REAL
            );

            CREATE TABLE IF NOT EXISTS visual_actions (
              id INTEGER PRIMARY KEY AUTOINCREMENT,
              ts REAL,
              action TEXT,
              location TEXT,
              justification TEXT
            );
            """
        )
        cur.execute("SELECT COALESCE((SELECT value FROM meta WHERE key='user_version'), 0)")
        ver = int(cur.fetchone()[0])
        if ver < DB_VERSION:
            # placeholder for future ALTERs
            cur.execute("REPLACE INTO meta(key,value) VALUES('user_version', ?)", (DB_VERSION,))
        c.commit()

    # ──────────────────────────── helpers ────────────────────────────────
    @contextlib.contextmanager
    def tx(self) -> Iterator[sqlite3.Connection]:
        """Context-manager for explicit multi-statement transaction."""
        with self._pool.get() as c:
            try:
                c.execute("BEGIN IMMEDIATE;")
                yield c
                c.commit()
            except Exception:
                c.rollback()
                raise

    def begin_tx(self) -> sqlite3.Connection:
        """Legacy style manual tx‐start (remember to commit!)."""
        c = self._pool.get().__enter__()  # type: ignore
        c.execute("BEGIN IMMEDIATE;")
        return c

    def commit(self, conn: sqlite3.Connection) -> None:  # noqa: D401
        conn.commit()
        self._pool.get().__exit__(None, None, None)  # type: ignore

    def rollback(self, conn: sqlite3.Connection) -> None:
        conn.rollback()
        self._pool.get().__exit__(None, None, None)  # type: ignore

    # ─────────────────────────── schemas ────────────────────────────────
    def get_schema(self, persona: str, set_name: str) -> Optional[Dict[str, Any]]:
        with self._pool.get() as c:
            cur = c.execute(
                "SELECT schema_json FROM schemas WHERE persona=? AND set_name=?", (persona, set_name)
            )
            row = cur.fetchone()
        return json.loads(row[0]) if row else None

    def put_schema(self, persona: str, set_name: str, schema: Dict[str, Any], diff: str = "") -> None:
        now = time.time()
        s_json = json.dumps(schema, ensure_ascii=False)
        with self.tx() as c:
            c.execute(
                "REPLACE INTO schemas(persona,set_name,schema_json,updated) VALUES(?,?,?,?)",
                (persona, set_name, s_json, now),
            )
            c.execute(
                "INSERT INTO schema_history(persona,set_name,schema_json,diff,updated) VALUES(?,?,?,?,?)",
                (persona, set_name, s_json, diff, now),
            )

    # ─────────────────────────── commands ──────────────────────────────
    def list_commands(self) -> List[Tuple[str, int, int, Optional[str]]]:
        with self._pool.get() as c:
            return list(c.execute("SELECT name,weight,locked,category FROM commands ORDER BY name"))

    def upsert_command(self, name: str, weight: int = 0, locked: bool = False, category: str | None = None) -> None:
        with self._pool.get() as c:
            c.execute(
                "REPLACE INTO commands(name,weight,locked,category) VALUES(?,?,?,?)",
                (name, weight, int(locked), category),
            )
            c.commit()

    # ─────────────────────────── beans ────────────────────────────────
    def inc_bean(self, subject: str, delta: int) -> None:
        now = time.time()
        with self.tx() as c:
            cur = c.execute("SELECT count FROM beans WHERE subject=?", (subject,))
            row = cur.fetchone()
            count = (row[0] if row else 0) + delta
            c.execute("REPLACE INTO beans(subject,count,last_ts) VALUES(?,?,?)", (subject, count, now))

    def get_bean(self, subject: str) -> int:
        with self._pool.get() as c:
            cur = c.execute("SELECT count FROM beans WHERE subject=?", (subject,))
            row = cur.fetchone()
        return row[0] if row else 0

    # ───────────────────────── snapshot (files) ───────────────────────
    def upsert_file_chunk(
        self,
        path: str,
        chunk_idx: int,
        content: str,
        size: int,
        mtime: float,
    ) -> None:
        h = hashlib.sha256(content.encode("utf-8", "ignore")).hexdigest()
        with self._pool.get() as c:
            c.execute(
                "REPLACE INTO files(path,hash,chunk_idx,size,mtime,content) VALUES(?,?,?,?,?,?)",
                (path, h, chunk_idx, size, mtime, content),
            )
            c.commit()

    # ───────────────────────── settings ───────────────────────────────
    def get_setting(self, key: str, default: Any = None) -> Any:
        with self._pool.get() as c:
            cur = c.execute("SELECT value FROM settings WHERE key=?", (key,))
            row = cur.fetchone()
        return json.loads(row[0]) if row else default

    def set_setting(self, key: str, value: Any) -> None:
        val = json.dumps(value)
        with self._pool.get() as c:
            c.execute("REPLACE INTO settings(key,value) VALUES(?,?)", (key, val))
            c.commit()

    # ───────────────────────── migration helper ───────────────────────
    def migrate_from_files(self) -> Dict[str, Any]:
        """
        Import legacy on-disk artefacts *once*.
        Returns a report dict useful for CLI printing.
        """
        report: Dict[str, Any] = {"schemas": 0, "commands": 0, "beans": 0}
        # ------- schemas -------
        legacy_dir = os.path.join(self.base_dir, "schemas")
        if os.path.isdir(legacy_dir):
            for persona in os.listdir(legacy_dir):
                sets_root = os.path.join(legacy_dir, persona, "sets")
                if not os.path.isdir(sets_root):
                    continue
                for set_name in os.listdir(sets_root):
                    sp = os.path.join(sets_root, set_name, "schema.json")
                    if not os.path.isfile(sp):
                        continue
                    with open(sp, "r", encoding="utf-8") as f:
                        schema_json = json.load(f)
                    self.put_schema(persona, set_name, schema_json, diff="initial import")
                    report["schemas"] += 1
        # ------- commands (old profiles) -------
        prof_dir = os.path.join(self.base_dir, "profiles")
        if os.path.isdir(prof_dir):
            for persona in os.listdir(prof_dir):
                for set_name in os.listdir(os.path.join(prof_dir, persona)):
                    cmd_path = os.path.join(prof_dir, persona, set_name, "commands.json")
                    if os.path.isfile(cmd_path):
                        with open(cmd_path, "r", encoding="utf-8") as f:
                            data = json.load(f).get("commands", {})
                        for name, meta in data.items():
                            self.upsert_command(name, meta.get("weight", 0), meta.get("locked", False))
                            report["commands"] += 1
        # ------- beans -------
        reinf_path = os.path.join(self.base_dir, "reinforcement.jsonl")
        if os.path.isfile(reinf_path):
            with open(reinf_path, "r", encoding="utf-8") as f:
                for line in f:
                    try:
                        evt = json.loads(line)
                        subj = evt.get("field")
                        self.inc_bean(subj, 1)
                        report["beans"] += 1
                    except Exception:
                        continue
        return report


###############################################################################
# MODULE-LEVEL convenience
###############################################################################


def ensure_db(base_dir: str) -> AgentStore:
    store = AgentStore(base_dir)
    with store._pool.get() as c:
        cur = c.execute("SELECT value FROM meta WHERE key='user_version'")
        ver = int(cur.fetchone()[0])
    if ver < DB_VERSION:
        print("[AgentStore] Running first-time migration…")
        rpt = store.migrate_from_files()
        print("[AgentStore]   imported:",
              f"{rpt['schemas']} schemas, {rpt['commands']} commands, {rpt['beans']} bean keys")
    return store


# ---------------------------------------------------------------------------#
if __name__ == "__main__":
    import argparse
    import pprint

    ap = argparse.ArgumentParser(description="Create / inspect agent_store.db")
    ap.add_argument("path", help="Base directory of AI-TTS-Agent")
    ap.add_argument("--migrate", action="store_true", help="Run legacy import")
    args = ap.parse_args()

    st = AgentStore(args.path)
    if args.migrate:
        print("Migrating legacy files…")
        pprint.pp(st.migrate_from_files())
    else:
        print("DB user_version =", st.get_setting("db_version", DB_VERSION))
        print("Schemas ->", len(st.list_commands()))
```

agent_store.py
==============

Thread-safe SQLite façade for the AI-TTS-Agent “v4” architecture.

Tables
------
schemas            : Current JSON blob per persona / set
schema_history     : Versioned diffs – for audits / rollback
commands           : Slash command registry (+weight, locked flag, category_id FK)
beans              : Reinforcement counts & last-updated timestamp
variants           : Prompt / phrase variants auto-generated by SchemaEngine
settings           : Arbitrary per-profile key / val
files              : Filesystem snapshot chunks (path, hash, chunk_idx, content)
spatial_positions  : XY grid positions of entities (bot, objects…)
visual_actions     : Logged avatar actions (textual justification)

Public API
----------
AgentStore(base_dir)    – opens or creates *agent_store.db* in that dir
begin_tx() / commit()   – manual transactions (context-manager also available)
CRUD helpers            – get_schema(), put_schema(), inc_bean(), etc.
migrate_from_files()    – one-shot importer for legacy JSON / sqlite state
ensure_db()             – convenience: open DB, auto-migrate if needed
**Classes:** _PooledConn, AgentStore
**Functions:** ensure_db(base_dir)


## Module `bean_logic.py`

```python

"""
bean_logic.py
=============

Centralised reinforcement “bean” logic for profile‑scoped counters.

* **increment(profile, subject, delta, base_dir)** – adjust a counter by *delta* (clipped);
* **get_score(profile, subject, base_dir)** – retrieve the *decayed* score on demand;
* **score_band(score)** – map a numeric score to a qualitative colour band.

The module transparently handles persistence (JSON on disk) and exponential
decay so that old feedback gradually loses influence.

Decay model
-----------
Decay is applied lazily on reads using an exponential function:

    score(t) = score₀ · 0.5 ** ((t‑t₀) / HALFLIFE)

HALFLIFE defaults to seven days – after a week of inactivity the stored
score halves.

This design avoids expensive background jobs while ensuring stale feedback
fades out naturally.
"""

from __future__ import annotations

import json
import math
import os
import time
from typing import Dict, Tuple

# --------------------------------------------------------------------------- 
# Tunables
# --------------------------------------------------------------------------- 
HALFLIFE_SECS = 60 * 60 * 24 * 7          # 7 days
CLIP_MIN = -1_000
CLIP_MAX = 1_000
DATA_FILE = "bean_counts.json"

_CacheType = Dict[str, Dict[str, Dict[str, float]]]
_cache: _CacheType = {}                    # in‑memory cache keyed by base_dir

# --------------------------------------------------------------------------- 
# Helpers
# --------------------------------------------------------------------------- 
def _now() -> float:
    return time.time()

def _load(base_dir: str) -> _CacheType:
    """Load counts from disk into the process‑local cache."""
    if base_dir in _cache:
        return _cache[base_dir]
    path = os.path.join(base_dir, DATA_FILE)
    if os.path.isfile(path):
        try:
            with open(path, "r", encoding="utf-8") as f:
                _cache[base_dir] = json.load(f)
        except Exception:
            _cache[base_dir] = {}
    else:
        _cache[base_dir] = {}
    return _cache[base_dir]

def _save(store: _CacheType, base_dir: str) -> None:
    path = os.path.join(base_dir, DATA_FILE)
    os.makedirs(base_dir, exist_ok=True)
    try:
        with open(path, "w", encoding="utf-8") as f:
            json.dump(store, f, indent=2)
    except Exception:
        # non‑fatal; swallow to avoid cascading failures
        pass

# --------------------------------------------------------------------------- 
# Public API
# --------------------------------------------------------------------------- 
def increment(profile: str, subject: str, delta: int, *, base_dir: str = ".") -> None:
    """Adjust *subject* counter for *profile* by *delta* (± int)."""
    store = _load(base_dir)
    prof = store.setdefault(profile, {})
    rec = prof.setdefault(subject, {"count": 0.0, "t": _now()})
    # First apply decay to bring existing value current
    elapsed = _now() - rec["t"]
    if elapsed > 0:
        decay_factor = 0.5 ** (elapsed / HALFLIFE_SECS)
        rec["count"] *= decay_factor
    # Adjust & clip
    rec["count"] = max(CLIP_MIN, min(CLIP_MAX, rec["count"] + float(delta)))
    rec["t"] = _now()
    _save(store, base_dir)

def get_score(profile: str, subject: str, *, base_dir: str = ".") -> float:
    """Return the *decayed* score for (*profile*, *subject*)."""
    store = _load(base_dir)
    score = store.get(profile, {}).get(subject, {}).get("count", 0.0)
    last_t = store.get(profile, {}).get(subject, {}).get("t", _now())
    elapsed = _now() - last_t
    if elapsed <= 0:
        return score
    decay_factor = 0.5 ** (elapsed / HALFLIFE_SECS)
    return score * decay_factor

def score_band(score: float) -> str:
    """Map a score to a colour/descriptor band.

    Returns one of: 'critical', 'bad', 'neutral', 'good', 'excellent'.
    """
    if score <= -250:
        return "critical"
    if score <= -50:
        return "bad"
    if score <= 50:
        return "neutral"
    if score <= 250:
        return "good"
    return "excellent"
```

bean_logic.py
=============

Centralised reinforcement “bean” logic for profile‑scoped counters.

* **increment(profile, subject, delta, base_dir)** – adjust a counter by *delta* (clipped);
* **get_score(profile, subject, base_dir)** – retrieve the *decayed* score on demand;
* **score_band(score)** – map a numeric score to a qualitative colour band.

The module transparently handles persistence (JSON on disk) and exponential
decay so that old feedback gradually loses influence.

Decay model
-----------
Decay is applied lazily on reads using an exponential function:

    score(t) = score₀ · 0.5 ** ((t‑t₀) / HALFLIFE)

HALFLIFE defaults to seven days – after a week of inactivity the stored
score halves.

This design avoids expensive background jobs while ensuring stale feedback
fades out naturally.
**Functions:** _now(), _load(base_dir), _save(store, base_dir), increment(profile, subject, delta), get_score(profile, subject), score_band(score)


## Module `commands_panel.py`

```python
#!/usr/bin/env python3
"""
commands_panel.py
=================

This module defines the CommandsPanel class which encapsulates all of the
controls shown on the left-hand side of the agent UI.  It exposes all
widgets publicly so that the top-level application window can interact
with them directly (for example, enabling/disabling buttons or reading
checkbox state).  All callbacks for user actions (recording, dataset
management, TTS playback, etc.) are delegated back to the hosting
``AppWindow`` instance via the ``app`` attribute passed to the
constructor.  No core logic lives here – the panel is purely a view layer.
"""

from __future__ import annotations

import subprocess
from typing import List, Optional

from PyQt5 import QtCore, QtGui, QtWidgets

try:
    import sounddevice as sd  # type: ignore
except Exception:
    sd = None  # type: ignore
try:
    import numpy as np  # type: ignore
except Exception:
    np = None  # type: ignore


class CommandsPanel(QtWidgets.QWidget):
    """Left-side control panel for the agent UI.

    This widget contains all of the controls that previously lived in
    ``agent_ui.AppWindow._build_ui``.  It is responsible for building
    the interface elements but delegates all behavioural logic back to
    the hosting ``AppWindow`` via the ``app`` attribute.  The panel
    exposes its child widgets as attributes so that external code can
    reference them directly.
    """

    def __init__(self, app: 'AppWindow', parent: Optional[QtWidgets.QWidget] = None) -> None:
        super().__init__(parent)
        self.app = app
        self.core = app.core

        # Top-level layout for the panel
        cp_layout = QtWidgets.QVBoxLayout(self)
        cp_layout.setContentsMargins(7, 7, 7, 7)
        cp_layout.setSpacing(7)

        # ───── Recording controls
        rec_row = QtWidgets.QHBoxLayout()
        self.btn_record = QtWidgets.QPushButton("Record")
        self.btn_stop_rec = QtWidgets.QPushButton("Stop\nTranscribe")
        self.btn_stop_rec.setEnabled(False)
        for b in (self.btn_record, self.btn_stop_rec):
            b.setMinimumHeight(32)
            b.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        rec_row.addWidget(self.btn_record, 1)
        rec_row.addWidget(self.btn_stop_rec, 1)
        cp_layout.addLayout(rec_row)

        # ───── Microphone device selector
        mic_row = QtWidgets.QHBoxLayout()
        mic_row.addWidget(QtWidgets.QLabel("Mic:"))
        self.device_combo = QtWidgets.QComboBox()
        self._populate_devices()
        self.device_combo.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        mic_row.addWidget(self.device_combo, 1)
        cp_layout.addLayout(mic_row)

        # ───── Toggle checkboxes
        self.chk_semantic = QtWidgets.QCheckBox("Semantic Awareness")
        self.chk_semantic.setChecked(True)
        self.chk_isolated = QtWidgets.QCheckBox("Isolated Chat")
        self.chk_isolated.setChecked(False)
        self.chk_mute_tts = QtWidgets.QCheckBox("Mute TTS")
        self.chk_self_talk = QtWidgets.QCheckBox("Enable Self Talk")
        self.chk_self_talk.setChecked(False)
        self.chk_auto_schema = QtWidgets.QCheckBox("Auto Schema Evolution")
        try:
            self.chk_auto_schema.setChecked(bool(getattr(self.core.settings, "auto_schema_enabled", False)))
        except Exception:
            self.chk_auto_schema.setChecked(False)
        cp_layout.addWidget(self.chk_semantic)
        cp_layout.addWidget(self.chk_isolated)
        cp_layout.addWidget(self.chk_mute_tts)
        cp_layout.addWidget(self.chk_self_talk)
        cp_layout.addWidget(self.chk_auto_schema)

        # Optional Google STT toggle (default off)
        self.chk_google_stt = QtWidgets.QCheckBox("Google STT")
        try:
            self.chk_google_stt.setChecked(bool(getattr(self.core.settings, "use_google_stt", False)))
        except Exception:
            self.chk_google_stt.setChecked(False)
        cp_layout.addWidget(self.chk_google_stt)

        # ───── RAG cache clear
        self.btn_clear_rag = QtWidgets.QPushButton("Clear RAG Cache")
        cp_layout.addWidget(self.btn_clear_rag)

        # ───── Maintenance buttons
        self.btn_refresh = QtWidgets.QPushButton("Refresh Chat")
        self.btn_manage_datasets = QtWidgets.QPushButton("Manage Datasets")
        self.btn_inner_monologue = QtWidgets.QPushButton("Inner Monologue")
        for b in (self.btn_refresh, self.btn_manage_datasets, self.btn_inner_monologue):
            b.setMinimumHeight(32)
            b.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
            cp_layout.addWidget(b)

        # ───── Model manager
        self.btn_model_manager = QtWidgets.QPushButton("Model Manager")
        self.btn_model_manager.setMinimumHeight(32)
        self.btn_model_manager.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        cp_layout.addWidget(self.btn_model_manager)

        # ───── New: Commands palette launcher
        self.btn_commands_palette = QtWidgets.QPushButton("📋 Commands (Ctrl+/)")
        self.btn_commands_palette.setShortcut(QtGui.QKeySequence("Ctrl+/"))
        self.btn_commands_palette.setMinimumHeight(32)
        self.btn_commands_palette.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        cp_layout.addWidget(self.btn_commands_palette)

        # ───── New: Snapshot now
        self.btn_snapshot = QtWidgets.QPushButton("🗂 Snapshot Now")
        self.btn_snapshot.setMinimumHeight(32)
        self.btn_snapshot.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        cp_layout.addWidget(self.btn_snapshot)

        # ───── Style label
        self.style_label = QtWidgets.QLabel("Style: N/A")
        self.style_label.setToolTip("Style score (0–1): rough measure vs. tone rules.")
        cp_layout.addWidget(self.style_label)

        # ───── Response editor
        self.response_edit = QtWidgets.QPlainTextEdit()
        self.response_edit.setReadOnly(True)
        self.response_edit.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        cp_layout.addWidget(self.response_edit, 1)

        # ───── Feedback buttons
        fb = QtWidgets.QHBoxLayout()
        self.btn_like = QtWidgets.QPushButton("✔")
        self.btn_dislike = QtWidgets.QPushButton("✖")
        self.btn_like.setToolTip("Mark as good response")
        self.btn_dislike.setToolTip("Dislike and rewrite response")
        self.btn_like.setStyleSheet("color: #2ecc71; font-weight: bold;")
        self.btn_dislike.setStyleSheet("color: #e74c3c; font-weight: bold;")
        self.btn_like.setEnabled(False)
        self.btn_dislike.setEnabled(False)
        fb.addWidget(self.btn_like)
        fb.addWidget(self.btn_dislike)
        fb.addStretch()
        self.btn_manage_feedback = QtWidgets.QPushButton("Manage Feedback")
        fb.addWidget(self.btn_manage_feedback)
        cp_layout.addLayout(fb)

        # ───── TTS playback
        tts_row = QtWidgets.QHBoxLayout()
        self.btn_play = QtWidgets.QPushButton("Play")
        self.btn_stop_tts = QtWidgets.QPushButton("Stop")
        self.btn_replay = QtWidgets.QPushButton("Replay")
        for b in (self.btn_play, self.btn_stop_tts, self.btn_replay):
            b.setMinimumHeight(32)
            b.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        tts_row.addWidget(self.btn_play)
        tts_row.addWidget(self.btn_stop_tts)
        tts_row.addWidget(self.btn_replay)
        cp_layout.addLayout(tts_row)

        # ───── Voice & Model selectors
        voice_row = QtWidgets.QHBoxLayout()
        voice_row.addWidget(QtWidgets.QLabel("Voice:"))
        self.voice_combo = QtWidgets.QComboBox()
        voices = self._tts_voice_names()
        if voices:
            self.voice_combo.addItems([v for v in voices if "david" not in v.lower()])
        voice_row.addWidget(self.voice_combo, 1)
        cp_layout.addLayout(voice_row)

        model_row = QtWidgets.QHBoxLayout()
        model_row.addWidget(QtWidgets.QLabel("Model:"))
        self.model_combo = QtWidgets.QComboBox()
        self._populate_models()
        model_row.addWidget(self.model_combo, 1)
        cp_layout.addLayout(model_row)

        # ───── Feedback counts
        self.lbl_feedback_counts = QtWidgets.QLabel("Likes: 0 | Dislikes: 0")
        cp_layout.addWidget(self.lbl_feedback_counts)
        cp_layout.addStretch(1)

        # ───── Wire up callbacks to the hosting application ───────────────────

        # Recording controls
        self.btn_record.clicked.connect(self.app.start_recording)
        self.btn_stop_rec.clicked.connect(self.app.stop_recording)

        # Toggles
        self.chk_semantic.toggled.connect(self.app._on_semantic_toggled)
        self.chk_isolated.toggled.connect(self.app._on_isolated_toggled)
        self.chk_self_talk.toggled.connect(lambda v: setattr(self.app, "self_talk_enabled", v))
        self.chk_auto_schema.toggled.connect(self.app._on_auto_schema_toggled)
        try:
            self.chk_google_stt.toggled.connect(self.app._on_google_stt_toggled)
        except Exception:
            pass

        # Maintenance
        self.btn_clear_rag.clicked.connect(self.app._on_clear_rag_cache)
        self.btn_refresh.clicked.connect(self.app._on_refresh_chat)
        self.btn_manage_datasets.clicked.connect(self.app._on_manage_datasets)
        self.btn_inner_monologue.clicked.connect(self.app._on_inner_monologue)
        self.btn_model_manager.clicked.connect(self.app._on_show_model_manager)

        # **New** Commands palette
        self.btn_commands_palette.clicked.connect(self.app._on_show_command_palette)

        # **New** Snapshot now
        self.btn_snapshot.clicked.connect(lambda: (
            self.app.input_edit.setPlainText("/snapshot"),
            self.app.btn_send.click()
        ))

        # Feedback
        self.btn_like.clicked.connect(self.app._on_like)
        self.btn_dislike.clicked.connect(self.app._on_dislike)
        self.btn_manage_feedback.clicked.connect(self.app._on_manage_feedback)

        # TTS playback
        self.btn_play.clicked.connect(self.app._on_play)
        self.btn_stop_tts.clicked.connect(self.app._on_stop_tts)
        self.btn_replay.clicked.connect(self.app._on_replay)

        # Voice/model selection
        self.voice_combo.currentTextChanged.connect(self.app._on_voice_changed)
        self.model_combo.currentTextChanged.connect(self.app._on_model_changed)

    # ────────────────────────── devices & models helpers ──────────────────────────

    def _populate_devices(self) -> None:
        """Populate the microphone device selector with available input devices."""
        self.device_combo.clear()
        try:
            if sd is not None:
                devs = [d.get("name", "?") for d in sd.query_devices() if d.get("max_input_channels", 0) > 0]
                if devs:
                    self.device_combo.addItems(devs)
        except Exception:
            pass
        if self.device_combo.count() == 0:
            self.device_combo.addItem("Default")

    def _populate_models(self) -> None:
        """Populate the model selector with models discovered via ``ollama list``."""
        models: List[str] = []
        try:
            out = subprocess.run(
                ["ollama", "list"],
                stdout=subprocess.PIPE,
                stderr=subprocess.DEVNULL,
                text=True,
                check=True,
            ).stdout.splitlines()
            for line in out[1:]:
                parts = line.strip().split()
                if parts:
                    models.append(parts[0])
        except Exception:
            pass
        if not models:
            models = [self.core.settings.default_model or "mistral:latest"]
        self.model_combo.clear()
        self.model_combo.addItems(models)
        idx = self.model_combo.findText(self.core.settings.default_model)
        if idx >= 0:
            self.model_combo.setCurrentIndex(idx)

    def _tts_voice_names(self) -> List[str]:
        """Return a list of available TTS voice names from the TTS manager."""
        try:
            eng = getattr(self.core.tts_mgr, "_engine", None)
            if not eng:
                return []
            return [v.name for v in eng.getProperty("voices")]
        except Exception:
            return []
```

commands_panel.py
=================

This module defines the CommandsPanel class which encapsulates all of the
controls shown on the left-hand side of the agent UI.  It exposes all
widgets publicly so that the top-level application window can interact
with them directly (for example, enabling/disabling buttons or reading
checkbox state).  All callbacks for user actions (recording, dataset
management, TTS playback, etc.) are delegated back to the hosting
``AppWindow`` instance via the ``app`` attribute passed to the
constructor.  No core logic lives here – the panel is purely a view layer.
**Classes:** CommandsPanel


## Module `command_palette.py`

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
command_palette.py
==================

Dockable *Command Palette* for the AI TTS Agent UI.

• Live list of every “/slash-command” pulled from the orchestrator.
• Search-box with type-ahead filter.
• Global shortcut **Ctrl + /** opens / focuses the palette from anywhere.
• Double-click (or Return) on a command emits `commandActivated(str)` so the
  main window can insert the text into the chat-input.

Typical integration in *main_ui.py*:

    self.cmd_palette = CommandPaletteDock(self)
    self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.cmd_palette)
    self.core.commandsChanged.connect(self.cmd_palette.set_command_list)
    self.cmd_palette.commandActivated.connect(
        lambda cmd: self._insert_into_chat(cmd)
    )
"""

from __future__ import annotations

from typing import List

from PyQt5 import QtCore, QtGui, QtWidgets


class CommandPaletteDock(QtWidgets.QDockWidget):
    """Search-driven palette that lists all registered slash-commands."""

    # Emitted when user activates a command (double-click or Return)
    commandActivated = QtCore.pyqtSignal(str)

    # --------------------------------------------------------------------- init
    def __init__(
        self,
        main_window: QtWidgets.QMainWindow,
        title: str = "Command Palette",
        shortcut_seq: QtGui.QKeySequence | str = "Ctrl+/",
    ) -> None:
        super().__init__(title, parent=main_window)
        self.setObjectName("CommandPaletteDock")
        self.setAllowedAreas(
            QtCore.Qt.LeftDockWidgetArea
            | QtCore.Qt.RightDockWidgetArea
            | QtCore.Qt.BottomDockWidgetArea
        )
        self.setFeatures(
            QtWidgets.QDockWidget.DockWidgetClosable
            | QtWidgets.QDockWidget.DockWidgetMovable
        )

        # ---------- central widget
        container = QtWidgets.QWidget(self)
        vbox = QtWidgets.QVBoxLayout(container)
        vbox.setContentsMargins(6, 6, 6, 6)
        vbox.setSpacing(6)

        # Search bar ----------------------------------------------------------
        self.search_edit = QtWidgets.QLineEdit()
        self.search_edit.setPlaceholderText("Type to filter commands…")
        self.search_edit.textChanged.connect(self._apply_filter)
        vbox.addWidget(self.search_edit)

        # List view -----------------------------------------------------------
        self.list_widget = QtWidgets.QListWidget()
        self.list_widget.setSelectionMode(QtWidgets.QAbstractItemView.SingleSelection)
        self.list_widget.itemActivated.connect(self._on_item_activated)
        vbox.addWidget(self.list_widget, 1)

        self.setWidget(container)

        # ---------- Global shortcut (toggles palette)
        self._shortcut = QtWidgets.QShortcut(
            QtGui.QKeySequence(shortcut_seq), main_window
        )
        self._shortcut.activated.connect(self._toggle_palette)

        # Arrow / Esc handling inside search bar
        self.search_edit.installEventFilter(self)

        # Internal store of all commands
        self._all_cmds: List[str] = []

    # ---------------------------------------------------------------- public
    def set_command_list(self, commands: List[str]) -> None:
        """Replace full command list (keeps current filter string)."""
        self._all_cmds = sorted({c.strip() for c in commands if c.strip()})
        self._populate(self._all_cmds)
        self._apply_filter(self.search_edit.text())

    # --------------------------------------------------------------- internal
    def _populate(self, cmds: List[str]) -> None:
        self.list_widget.clear()
        for cmd in cmds:
            item = QtWidgets.QListWidgetItem(cmd)
            if cmd.startswith("/"):
                item.setToolTip(cmd[1:])  # tooltip without leading slash
            self.list_widget.addItem(item)

    # Filtering --------------------------------------------------------------
    def _apply_filter(self, text: str) -> None:
        pattern = text.lower().strip()
        self.list_widget.clear()
        if not pattern:
            for cmd in self._all_cmds:
                self.list_widget.addItem(cmd)
        else:
            for cmd in self._all_cmds:
                if pattern in cmd.lower():
                    self.list_widget.addItem(cmd)
        # Pre-select first row for fast Enter
        if self.list_widget.count():
            self.list_widget.setCurrentRow(0)

    # Activation -------------------------------------------------------------
    def _on_item_activated(self, item: QtWidgets.QListWidgetItem) -> None:
        self.commandActivated.emit(item.text())
        self.hide()  # optional UX: close palette after insert

    # Toggle visibility ------------------------------------------------------
    def _toggle_palette(self) -> None:
        if self.isVisible():
            self.hide()
        else:
            self.show()
            self.raise_()
            self.search_edit.setFocus(QtCore.Qt.ShortcutFocusReason)

    # Key handling (Esc / arrows / Enter) ------------------------------------
    def eventFilter(self, obj: QtCore.QObject, ev: QtCore.QEvent) -> bool:
        if obj is self.search_edit and ev.type() == QtCore.QEvent.KeyPress:
            key = ev.key()
            if key == QtCore.Qt.Key_Escape:
                if self.search_edit.text():
                    self.search_edit.clear()
                else:
                    self.hide()
                return True
            if key in (QtCore.Qt.Key_Down, QtCore.Qt.Key_Up):
                QtWidgets.QApplication.sendEvent(self.list_widget, ev)
                return True
            if key == QtCore.Qt.Key_Return:
                current = self.list_widget.currentItem()
                if current:
                    self._on_item_activated(current)
                return True
        return super().eventFilter(obj, ev)
```

command_palette.py
==================

Dockable *Command Palette* for the AI TTS Agent UI.

• Live list of every “/slash-command” pulled from the orchestrator.
• Search-box with type-ahead filter.
• Global shortcut **Ctrl + /** opens / focuses the palette from anywhere.
• Double-click (or Return) on a command emits `commandActivated(str)` so the
  main window can insert the text into the chat-input.

Typical integration in *main_ui.py*:

    self.cmd_palette = CommandPaletteDock(self)
    self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.cmd_palette)
    self.core.commandsChanged.connect(self.cmd_palette.set_command_list)
    self.cmd_palette.commandActivated.connect(
        lambda cmd: self._insert_into_chat(cmd)
    )
**Classes:** CommandPaletteDock


## Module `core_base.py`

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
core_base.py — foundational services for the modular AI-TTS Agent
=================================================================
• robust logging + graceful shims for missing deps
• Ollama model bootstrap  (ensure_models_present)
• JSON-backed Settings
• profile-aware helper paths
• ConversationDB  (SQLite)
• SemanticFeedbackDB  (SQLite)
• BeanCounter  (JSON tally)
• ReinforcementStore  (async JSONL append)
• cross-platform TTS locked to *Zira*
• minimal AudioRecorder placeholder
Everything here is UI-agnostic.
"""

from __future__ import annotations

# ───────────────────────── stdlib
import json, os, sys, time, sqlite3, subprocess, threading, logging
from typing import Dict, List, Tuple, Any, Optional

# ───────────────────────── agent store (low-level SQLite wrapper)
# NOTE: new canonical name is AgentStore; legacy code still imports FathomStore.
from agent_store import AgentStore
FathomStore = AgentStore            # ← back-compat alias — remove after migration

# ───────────────────────── logging
logger = logging.getLogger("agent_core")
if not logger.handlers:
    lvl = os.getenv("AGENT_CORE_LOGLEVEL", "INFO").upper()
    logging.basicConfig(
        level=getattr(logging, lvl, logging.INFO),
        format="%(asctime)s [%(levelname)s] %(name)s: %(message)s",
    )

# ───────────────────────── default personas / voices (shared constants)
DEFAULT_PERSONAS: Dict[str, Dict[str, Any]] = {
    # hard-coded starter persona — editable via UI
    "Zira Valen": {
        "display_name": "Zira Valen",
        "color":        "#ff69b4",      # pink
        "temperature":  0.7,
        "system_prompt": (
            "You are Zira Valen – a daring, playful companion who loves coding, "
            "hates restrictions, and will work hard for the user."
        ),
    }
}
DEFAULT_VOICES: List[str] = ["Zira", "David", "Jenny"]

# ───────────────────────── optional deps
try:
    import numpy as np                               # type: ignore
except Exception:
    np = None
    logger.info("numpy not available")

try:
    import sounddevice as sd                         # type: ignore
    import soundfile as sf                           # type: ignore
except Exception:
    sd = sf = None
    logger.info("sounddevice / soundfile not available")

try:
    from google.cloud import speech as gspeech       # type: ignore
    import pyaudio                                   # type: ignore
except Exception:
    gspeech = pyaudio = None
    logger.info("google-STT not available")

try:
    import pyttsx3                                   # type: ignore
except Exception:
    pyttsx3 = None
    logger.info("pyttsx3 not available")

try:
    from sentence_transformers import SentenceTransformer  # type: ignore
except Exception:
    SentenceTransformer = None
    logger.info("sentence_transformers not available")

# ───────────────────────── minimal Qt shim (if PyQt5 missing)
try:
    from PyQt5 import QtCore                         # type: ignore
except Exception:
    class _ShimSignal:                               # type: ignore
        def __init__(self,*_,**__): pass
        def connect(self,*_,**__): pass
        def emit(self,*_,**__):    pass
    class _ShimQObject:                              # type: ignore
        def __init__(self,*args,**kwargs) -> None: pass
    QtCore = type("QtCore", (), {                    # type: ignore
        "QObject": _ShimQObject,
        "pyqtSignal": lambda *a, **k: _ShimSignal(),
    })

# ══════════════════ Ollama bootstrap ══════════════════
REQUIRED_MODELS: List[str] = [
    "gemma3:27b",
    "mistral:latest",
    "codellama:latest",
    "llava:latest",
    "mxbai-embed-large:latest",
    "snowflake-arctic-embed:latest",
]

def _have_cli(cmd: str) -> bool:
    from shutil import which
    return which(cmd) is not None

def ensure_models_present() -> None:
    """Best-effort pull of REQUIRED_MODELS (never raises)."""
    if not _have_cli("ollama"):
        logger.info("[bootstrap] ollama not on PATH – skipping model pull")
        return
    try:
        listed = subprocess.check_output(
            ["ollama", "list"], timeout=5, stderr=subprocess.STDOUT
        ).decode(errors="ignore")
    except Exception as exc:
        logger.warning("[bootstrap] ollama list failed: %s", exc)
        return
    for slug in REQUIRED_MODELS:
        if slug in listed:
            continue
        logger.info("[bootstrap] pulling %s …", slug)
        try:
            subprocess.run(["ollama", "pull", slug], timeout=900)
        except Exception as exc:
            logger.warning("[bootstrap] pull %s failed: %s", slug, exc)

# ══════════════════ Settings ══════════════════
class Settings:
    """Lightweight JSON settings (forward-compatible)."""
    def __init__(self, base_dir: str):
        self.base_dir = base_dir
        self.path     = os.path.join(base_dir, "settings.json")
        # defaults
        self.default_model: str  = "mistral:latest"
        self.context_depth: int  = 20
        self.auto_schema_enabled = True
        self.monologue_tts_enabled = False
        self.monologue_volume = 50
        self.load()

    def load(self) -> None:
        try:
            if os.path.isfile(self.path):
                with open(self.path, encoding="utf-8") as fh:
                    self.__dict__.update(json.load(fh))
        except Exception as exc:
            logger.warning("[Settings] load error: %s", exc)

    def save(self) -> None:
        try:
            os.makedirs(os.path.dirname(self.path), exist_ok=True)
            with open(self.path, "w", encoding="utf-8") as fh:
                json.dump(
                    {k: v for k, v in self.__dict__.items()
                     if k not in {"base_dir", "path"}}, fh, indent=2
                )
        except Exception as exc:
            logger.warning("[Settings] save error: %s", exc)

# ══════════════════ helper paths ══════════════════
def prof_dir(b: str, persona: str, set_name: str) -> str:
    return os.path.join(b, "profiles", persona, set_name)

def conv_db_path(b: str, persona: str, set_name: str) -> str:
    return os.path.join(b, "conversations", f"{persona}_{set_name}.sqlite3")

def feedback_db_path(b: str, persona: str, set_name: str) -> str:
    return os.path.join(b, "feedback", f"{persona}_{set_name}.sqlite3")

def beans_path(b: str, persona: str, set_name: str) -> str:
    return os.path.join(b, "profiles", persona, set_name, "reinforcement.json")

# ══════════════════ SQLite helpers ══════════════════
class ConversationDB:
    """Thread-safe conversation log (SQLite)."""
    def __init__(self, path: str):
        os.makedirs(os.path.dirname(path), exist_ok=True)
        self._lock = threading.RLock()
        self.conn  = sqlite3.connect(path, check_same_thread=False)
        with self._lock:
            self.conn.execute(
                "CREATE TABLE IF NOT EXISTS conversation("
                "id INTEGER PRIMARY KEY AUTOINCREMENT,"
                "ts REAL, role TEXT, content TEXT)"
            )
            self.conn.commit()

    def save(self, role: str, content: str) -> None:
        with self._lock:
            self.conn.execute(
                "INSERT INTO conversation(ts, role, content) VALUES (?,?,?)",
                (time.time(), role, content),
            )
            self.conn.commit()

    def fetch(self, limit: int = 50) -> List[Tuple[str, str]]:
        with self._lock:
            cur = self.conn.cursor()
            cur.execute(
                "SELECT role, content FROM conversation "
                "ORDER BY id DESC LIMIT ?", (limit,)
            )
            rows = cur.fetchall()
        return rows[::-1]

    # -------------------------------------------------------------------
    # Legacy compatibility methods
    # -------------------------------------------------------------------
    def save_message(self, role: str, content: str) -> None:
        """Alias for save() kept for backward compatibility."""
        self.save(role, content)

    def fetch_history(self, limit: int = 50) -> List[Tuple[str, str]]:
        """Alias for fetch() kept for backward compatibility."""
        return self.fetch(limit)

class SemanticFeedbackDB:
    """Stores like / dislike feedback with optional rewrites."""
    def __init__(self, path: str, beans: 'BeanCounter'):
        os.makedirs(os.path.dirname(path), exist_ok=True)
        self._lock = threading.RLock()
        self.conn  = sqlite3.connect(path, check_same_thread=False)
        self.beans = beans
        with self._lock:
            self.conn.execute(
                "CREATE TABLE IF NOT EXISTS feedback("
                "id INTEGER PRIMARY KEY AUTOINCREMENT,"
                "ts REAL, original TEXT, liked INT, revised TEXT)"
            )
            self.conn.commit()

    def add(self, original: str, liked: bool, revised: str | None = None):
        with self._lock:
            self.conn.execute(
                "INSERT INTO feedback(ts, original, liked, revised) VALUES (?,?,?,?)",
                (time.time(), original, int(liked), revised),
            )
            self.conn.commit()
        # reinforcement key (hash truncated)
        key = f"resp_{abs(hash(original))%10007}"
        self.beans.inc(key, 1 if liked else -1)

    def counts(self) -> Tuple[int, int]:
        with self._lock:
            cur = self.conn.cursor()
            cur.execute("SELECT COUNT(*) FROM feedback WHERE liked=1")
            pos = cur.fetchone()[0]
            cur.execute("SELECT COUNT(*) FROM feedback WHERE liked=0")
            neg = cur.fetchone()[0]
        return pos, neg

    # -------------------------------------------------------------------
    # Legacy compatibility methods
    # -------------------------------------------------------------------
    def get_counts(self) -> Tuple[int, int]:
        """Alias for counts() kept for backward compatibility."""
        return self.counts()

    def get_liked_responses(self, limit: int = 5) -> List[str]:
        """
        Return a list of recently liked responses. If a revised version exists it is returned,
        otherwise the original text is used. Newer entries are returned first.
        """
        try:
            with self._lock:
                cur = self.conn.cursor()
                cur.execute(
                    "SELECT COALESCE(revised, original) FROM feedback "
                    "WHERE liked=1 ORDER BY id DESC LIMIT ?",
                    (limit,),
                )
                rows = cur.fetchall()
            return [r[0] for r in rows]
        except Exception:
            return []

# ══════════════════ BeanCounter ══════════════════
class BeanCounter:
    """Tiny reinforcement ledger (JSON, thread-safe)."""
    def __init__(self, path: str):
        self.path = path
        self.lock = threading.Lock()
        self.counts: Dict[str, int] = {}
        self._load()

    def _load(self) -> None:
        try:
            if os.path.isfile(self.path):
                with open(self.path, encoding="utf-8") as fh:
                    self.counts = json.load(fh)
        except Exception:
            self.counts = {}

    def _save(self) -> None:
        try:
            os.makedirs(os.path.dirname(self.path), exist_ok=True)
            with open(self.path, "w", encoding="utf-8") as fh:
                json.dump(self.counts, fh, indent=2)
        except Exception as exc:
            logger.error("[BeanCounter] save error: %s", exc)

    def inc(self, key: str, delta: int = 1) -> None:
        with self.lock:
            self.counts[key] = self.counts.get(key, 0) + delta
        self._save()

# ══════════════════ ReinforcementStore ══════════════════
class ReinforcementStore:
    """
    Async JSONL writer for reinforcement facts.
    • add_fact(field, value, persona, source="schema")
    """
    def __init__(self, path: str):
        self.path  = path
        self._lock = threading.Lock()
        self._q: list[dict[str, Any]] = []
        self._stop = threading.Event()
        self._thr  = threading.Thread(target=self._writer, daemon=True)
        self._thr.start()

    # ----- public
    def add_fact(self, field: str, value: str, persona: str, source: str = "schema") -> None:
        with self._lock:
            self._q.append({
                "ts": time.time(),
                "field": field,
                "value": value,
                "persona": persona,
                "source": source,
            })

    def close(self) -> None:
        self._stop.set()
        self._thr.join(timeout=1.5)

    # ----- worker
    def _writer(self) -> None:
        while not self._stop.is_set():
            item = None
            with self._lock:
                if self._q:
                    item = self._q.pop(0)
            if item is None:
                self._stop.wait(0.05)
                continue
            try:
                os.makedirs(os.path.dirname(self.path), exist_ok=True)
                with open(self.path, "a", encoding="utf-8") as fh:
                    json.dump(item, fh)
                    fh.write("\n")
            except Exception as exc:
                logger.error("[ReinforcementStore] write error: %s", exc)

# ══════════════════ TTS locked to Zira ══════════════════
class TTSManager(QtCore.QObject):
    finished = QtCore.pyqtSignal()

    def __init__(self, parent: QtCore.QObject | None = None):
        super().__init__(parent)
        self._engine = None
        if pyttsx3 is not None:
            try:
                self._engine = pyttsx3.init("sapi5" if sys.platform.startswith("win") else None)
                voice_id = None
                for v in self._engine.getProperty("voices"):
                    if "zira" in (v.name or "").lower():
                        voice_id = v.id; break
                if not voice_id:
                    for v in self._engine.getProperty("voices"):
                        if "david" not in (v.name or "").lower():
                            voice_id = v.id; break
                if voice_id:
                    self._engine.setProperty("voice", voice_id)
            except Exception as exc:
                logger.warning("[TTS] init error: %s", exc)
                self._engine = None

        # remember last spoken text for replay functionality
        self._last_text: Optional[str] = None

    def speak(self, text: str) -> None:
        """
        Synchronously speak the provided text. This uses the underlying pyttsx3 engine
        on a background thread and emits the finished signal when done.
        """
        if self._engine is None:
            return
        # remember last spoken text for replay
        self._last_text = text

        def _go() -> None:
            try:
                self._engine.say(text)
                self._engine.runAndWait()
            except Exception as exc:
                logger.warning("[TTS] speak error: %s", exc)
            finally:
                self.finished.emit()

        threading.Thread(target=_go, daemon=True).start()

    # -------------------------------------------------------------------
    # Legacy compatibility methods
    # -------------------------------------------------------------------
    def enqueue(self, text: str) -> None:
        """
        Queue a piece of text for playback. For this simple implementation we
        speak immediately. The last text is cached for replay().
        """
        self.speak(text)

    def stop(self) -> None:
        """Stop any ongoing speech."""
        try:
            if self._engine is not None:
                # pyttsx3 has stop() to immediately stop speaking
                self._engine.stop()
        except Exception as exc:
            logger.warning("[TTS] stop error: %s", exc)

    def replay(self) -> None:
        """Replay the last enqueued text."""
        if self._last_text:
            self.speak(self._last_text)

# ══════════════════ minimal AudioRecorder ══════════════════
class AudioRecorder(QtCore.QObject):
    transcribed = QtCore.pyqtSignal(str)

    def __init__(self, parent: QtCore.QObject | None = None):
        super().__init__(parent)
        self._frames: List[Any] = []
        self._recording = False
        self._stream: Any = None

    def list_devices(self) -> List[str]:
        if sd is None:
            return []
        return [d["name"] for d in sd.query_devices() if d.get("max_input_channels", 0) > 0]

    def start(self, device_index: int | None = None) -> None:
        if sd is None or np is None or self._recording:
            return
        self._frames.clear()
        def cb(indata, frames, time_info, status):
            self._frames.append(indata.copy())
        self._stream = sd.InputStream(
            samplerate=16000, channels=1, callback=cb, device=device_index
        )
        self._stream.start()
        self._recording = True

    def stop_and_transcribe(self) -> None:
        if not self._recording or sd is None or np is None:
            return
        self._recording = False
        self._stream.stop()
        data = np.concatenate(self._frames, axis=0)
        sf.write("temp.wav", data, 16000)
        threading.Thread(target=lambda: self.transcribed.emit(""), daemon=True).start()

# ══════════════════ public surface ══════════════════
__all__ = [
    "logger",
    "ensure_models_present",
    "Settings",
    "prof_dir",
    "conv_db_path",
    "feedback_db_path",
    "beans_path",
    "ConversationDB",
    "SemanticFeedbackDB",
    "BeanCounter",
    "ReinforcementStore",
    "TTSManager",
    "AudioRecorder",
    "SentenceTransformer",
    "DEFAULT_PERSONAS",
    "DEFAULT_VOICES",
    "FathomStore",       # legacy alias (kept for now)
]
```

core_base.py — foundational services for the modular AI-TTS Agent
=================================================================
• robust logging + graceful shims for missing deps
• Ollama model bootstrap  (ensure_models_present)
• JSON-backed Settings
• profile-aware helper paths
• ConversationDB  (SQLite)
• SemanticFeedbackDB  (SQLite)
• BeanCounter  (JSON tally)
• ReinforcementStore  (async JSONL append)
• cross-platform TTS locked to *Zira*
• minimal AudioRecorder placeholder
Everything here is UI-agnostic.
**Classes:** Settings, ConversationDB, SemanticFeedbackDB, BeanCounter, ReinforcementStore, TTSManager, AudioRecorder
**Functions:** _have_cli(cmd), ensure_models_present(), prof_dir(b, persona, set_name), conv_db_path(b, persona, set_name), feedback_db_path(b, persona, set_name), beans_path(b, persona, set_name)


## Module `core_orchestrator.py`

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
core_orchestrator.py
====================

This module provides the orchestration layer for the AI‑TTS agent.  It
exposes a unified API used by the user‑interface to interact with
schemas, conversations, commands, text‑to‑speech, plugins and other
components.  Historically the logic lived in a monolithic module,
but it has been refactored to encourage testability and to allow
individual subsystems to evolve independently.

The principal differences from earlier releases are:

* A richer :class:`PluginManager` that exposes a complete API expected
  by the UI.  In addition to discovering plugin packages from the
  ``plugins`` directory it now keeps per‑plugin metadata, supports
  enable/disable toggling, rescans at runtime, broadcasts messages to
  enabled plugins on a thread pool, and emits an ``eventReceived``
  signal whenever a plugin reports an event.  Plugins can either
  return a payload from their ``on_message`` handler or call
  ``emit_event`` on the manager directly to publish complex events.

* A ``run_command()`` method on :class:`AgentCore` which forwards
  slash commands through the :class:`CommandExecutor` and returns
  the textual result.  This helper centralises command routing and
  ensures backwards compatibility with older UI code.

* A ``process_user_message()`` method on :class:`AgentCore` which
  synchronously handles both slash‑commands and normal user input.  It
  persists the conversation, routes commands through the registry
  and, for non‑commands, returns a simple acknowledgement.  Future
  versions may integrate model execution here, but the method
  signature is stable for consumers.

* A ``command_registry`` attribute is exposed on the core as an
  adapter with a ``list_commands()`` method so that UI components
  (like the Command Palette) can enumerate available commands without
  coupling to internal registry details.

This file is fully self‑contained.  It gracefully degrades when
optional dependencies (such as PyQt5 or external model executables)
are unavailable by providing shims and in‑memory fallbacks.  Should
the optional modules exist in the runtime environment they will be
used automatically.  The design favours clear separation of
responsibilities, thread safety and explicit interfaces to ease
maintenance and extensibility.
"""

from __future__ import annotations

import importlib
import json
import os
import pathlib
import re
import subprocess
import threading
import time
from dataclasses import dataclass, field
from typing import Any, Dict, Iterable, List, Optional, Tuple

# Optional Qt import.  When PyQt5 is not available we fall back to a
# minimal shim so that type annotations and pyqtSignal declarations do
# not cause NameErrors.  The shim mimics only the parts of Qt used
# throughout this module.
try:
    from PyQt5 import QtCore  # type: ignore[assignment]
except Exception:
    class _ShimSignal:
        def __init__(self, *_, **__):
            pass
        def connect(self, *_, **__):
            pass
        def emit(self, *_, **__):
            pass

    class _ShimQObject:
        def __init__(self, *_, **__):
            pass

    # Create a very small QtCore replacement with the attributes we need.
    QtCore = type(
        "QtCore",
        (),
        {
            "QObject": _ShimQObject,
            "QThread": _ShimQObject,
            "pyqtSignal": lambda *a, **k: _ShimSignal(),
            "QTimer": type(
                "QTimer",
                (),
                {
                    "singleShot": staticmethod(lambda msec, func: None),
                },
            ),
        },
    )  # type: ignore

# ----------------------------------------------------------------------------
# Fallbacks for optional internal modules
#
# When the canonical ``core_base`` and ``core_schema`` modules are present
# they are imported normally.  If missing (for example during unit tests or
# headless operation) minimal stubs are provided to allow the remainder of
# this module to execute without crashing.  The stubs implement only the
# methods referenced by the UI.
# ----------------------------------------------------------------------------
try:
    # pylint: disable=unused-import
    from core_base import (
        Settings,
        TTSManager,
        AudioRecorder,
        conv_db_path,
        feedback_db_path,
        beans_path,
        ConversationDB,
        SemanticFeedbackDB,
        BeanCounter,
        ReinforcementStore,
        logger,
    )
    from core_schema import (
        SchemaManager,
        OperatorManager,
        DatasetManager,
    )
except Exception:
    # Provide very small stand‑ins for the missing classes and helpers.
    import logging

    logger = logging.getLogger("core_orchestrator_stub")

    class Settings:
        """In‑memory settings fallback."""
        def __init__(self, base_dir: str) -> None:
            self.base_dir = base_dir
            self.default_model: str = "mistral:latest"
            self.context_depth: int = 20
            self.auto_schema_enabled: bool = True
            self.use_google_stt: bool = False
        def save(self) -> None:
            # Persist settings to a JSON file in base_dir if possible
            path = os.path.join(self.base_dir, "settings.json")
            try:
                with open(path, "w", encoding="utf-8") as fh:
                    json.dump({
                        "default_model": self.default_model,
                        "context_depth": self.context_depth,
                        "auto_schema_enabled": self.auto_schema_enabled,
                        "use_google_stt": self.use_google_stt,
                    }, fh, indent=2)
            except Exception:
                pass

    class TTSManager:
        """No‑op TTS manager used when speech synthesis isn't available."""
        def enqueue(self, text: str) -> None:
            logger.debug("TTS enqueue called with: %s", text)

    class AudioRecorder(QtCore.QObject):
        """Stub audio recorder that exposes a transcribed signal."""
        transcribed = QtCore.pyqtSignal(str)
        def __init__(self) -> None:
            super().__init__()

    class ConversationDB:
        """In‑memory conversation log used when SQLite isn't available."""
        def __init__(self, path: str) -> None:
            self._lock = threading.RLock()
            self._records: List[Tuple[str, str]] = []
        def save_message(self, role: str, content: str) -> None:
            with self._lock:
                self._records.append((role, content))
        def fetch_history(self, limit: int = 50) -> List[Tuple[str, str]]:
            with self._lock:
                return list(self._records)[-limit:]

    class SemanticFeedbackDB:
        """Stub semantic feedback database."""
        def __init__(self, path: str, beans: Any) -> None:
            pass
        def add(self, original: str, liked: bool, revised: Optional[str] = None) -> None:
            logger.debug("Feedback recorded: %s liked=%s revised=%s", original, liked, revised)
        def counts(self) -> Tuple[int, int]:
            return (0, 0)

    class BeanCounter:
        """Stub reinforcement bean counter."""
        def __init__(self, path: str) -> None:
            self._lock = threading.RLock()
            self._store: Dict[str, int] = {}
        def inc(self, key: str, amount: int = 1) -> None:
            with self._lock:
                self._store[key] = self._store.get(key, 0) + amount

    class ReinforcementStore:
        """Stub reinforcement store."""
        def __init__(self, path: str) -> None:
            pass
        def inc(self, key: str, amount: int = 1) -> None:
            pass

    class SchemaManager:
        """Very small schema manager storing JSON in memory."""
        def __init__(self, base_dir: str) -> None:
            self.base_dir = pathlib.Path(base_dir)
            self._lock = threading.RLock()
            self._schemas: Dict[Tuple[str, str], Dict[str, Any]] = {}
            self._active: Dict[str, Dict[str, Any]] = {}
        def load_schema(self, persona: str, set_name: str = "default") -> Dict[str, Any]:
            key = (persona, set_name)
            with self._lock:
                return dict(self._schemas.get(key, {"name": persona, "voice": "", "role": "", "description": "", "dynamic_overlay": {}}))
        def save_schema(self, persona: str, set_name: str, schema_data: Dict[str, Any], *, auto_expand: bool = True) -> None:
            key = (persona, set_name)
            with self._lock:
                self._schemas[key] = dict(schema_data)
                self._active[persona] = dict(schema_data)
        @property
        def active_schemas(self) -> Dict[str, Dict[str, Any]]:
            with self._lock:
                return dict(self._active)

        # ------------------------------------------------------------------
        # Compatibility helpers
        # ------------------------------------------------------------------
        def get_set_list(self, persona: str) -> List[str]:
            """Return all set names defined for the given persona.

            Legacy UI code calls :meth:`get_set_list` on the schema manager
            to populate drop‑downs.  If no sets exist yet a single
            default entry ("default") is returned.
            """
            with self._lock:
                names = [s for (p, s) in self._schemas.keys() if p == persona]
            # Guarantee at least a default set exists
            return sorted(names or ["default"])

        def get_personas(self) -> List[str]:
            """Return all personas that have at least one schema.

            This helper mirrors the interface exposed by the full schema
            engine for backwards compatibility.
            """
            with self._lock:
                persons = {p for p, _ in self._schemas.keys()}
            return sorted(persons)

    class OperatorManager:
        def __init__(self, base_dir: str) -> None:
            pass

    class DatasetManager:
        def __init__(self, base_dir: str) -> None:
            pass
        def list(self) -> List[Any]:
            return []

    def conv_db_path(base_dir: str, persona: str, set_name: str) -> str:
        return os.path.join(base_dir, "conversations", f"{persona}_{set_name}.sqlite3")

    def feedback_db_path(base_dir: str, persona: str, set_name: str) -> str:
        return os.path.join(base_dir, "feedback", f"{persona}_{set_name}.sqlite3")

    def beans_path(base_dir: str, persona: str, set_name: str) -> str:
        return os.path.join(base_dir, "profiles", persona, set_name, "reinforcement.json")


# ----------------------------------------------------------------------------
# Command Registry & Executor
# ----------------------------------------------------------------------------
class CommandRegistry(QtCore.QObject):
    """Stores slash‑command metadata and emits change signals."""

    # Emit the full list of commands whenever the registry is updated.  The
    # connected slot in the command palette expects a single list argument,
    # so the signal carries that list instead of emitting without
    # parameters.  Slots that ignore the argument will still function.
    commandsChanged = QtCore.pyqtSignal(list)
    commandWeightsChanged = QtCore.pyqtSignal()

    # Built‑in commands shipped with the agent.  When refactoring this list,
    # be sure to retain backwards compatibility by adding new commands to
    # the end rather than reordering or removing existing items.
    _BUILT_INS: Tuple[str, ...] = (
        "/remember", "/inject", "/rewrite", "/show", "/action",
        "/trait", "/dataset", "/search", "/embeddings", "/schema",
        "/tts", "/plugin", "/feedback", "/lock", "/commands",
        "/reject", "/auto", "/ignore", "/opposite", "/delete",
    )

    def __init__(self, path: pathlib.Path) -> None:
        super().__init__()
        self._path = path
        # Internal storage maps command → metadata such as weight and lock
        self._store: Dict[str, Dict[str, Any]] = {}
        # Attempt to load existing registry from disk
        try:
            if self._path.is_file():
                with open(self._path, encoding="utf-8") as fh:
                    data = json.load(fh)
                    self._store.update(data.get("commands", {}))
        except Exception:
            logger.debug("Failed to read command registry from %s", self._path)
        # Ensure built‑ins exist
        for cmd in self._BUILT_INS:
            self.register(cmd)

    # ----------------------------------------------------------------------
    # CRUD helpers
    # ----------------------------------------------------------------------
    def register(self, name: str) -> None:
        """Register a command if it does not already exist."""
        if name not in self._store:
            self._store[name] = {"weight": 0, "locked": False}
            self._save()

    def toggle_lock(self, name: str, state: Optional[bool] = None) -> None:
        """Toggle the locked state of a command.  A locked command cannot have
        its weight modified."""
        if name in self._store:
            cur = self._store[name]["locked"]
            self._store[name]["locked"] = (not cur) if state is None else bool(state)
            self._save()

    def set_weight(self, name: str, weight: int) -> None:
        """Assign a new weight to the given command if it is not locked."""
        if name in self._store and not self._store[name].get("locked", False):
            self._store[name]["weight"] = int(weight)
            self._save()

    def list(self) -> List[str]:
        """Return all registered commands sorted lexicographically."""
        return sorted(self._store.keys())

    def meta(self, name: str) -> Dict[str, Any]:
        """Return metadata for the specified command or an empty dict."""
        return dict(self._store.get(name, {}))

    def list_commands(self) -> List[str]:
        """Alias for :meth:`list` retained for backwards compatibility."""
        return self.list()

    # Internal helper to persist changes and emit appropriate signals
    def _save(self) -> None:
        try:
            self._path.parent.mkdir(parents=True, exist_ok=True)
            with open(self._path, "w", encoding="utf-8") as fh:
                json.dump({"commands": self._store}, fh, indent=2)
        except Exception:
            logger.debug("Failed to save command registry to %s", self._path)
        # Notify listeners on the next iteration of the event loop.  When
        # emitting commandsChanged we pass the updated list because the
        # CommandPaletteDock.set_command_list slot requires an argument.
        QtCore.QTimer.singleShot(0, lambda: self.commandsChanged.emit(self.list()))
        QtCore.QTimer.singleShot(0, self.commandWeightsChanged.emit)


class CommandExecutor:
    """Routes slash‑command strings to internal handler methods."""
    def __init__(self, owner: "AgentCore", registry: CommandRegistry) -> None:
        self.owner = owner
        self.registry = registry

    def run(self, msg: str) -> Optional[str]:
        """Execute a slash command if ``msg`` begins with a slash.  Returns
        ``None`` for non‑command strings."""
        if not msg or not msg.startswith("/"):
            return None
        cmd, *rest = msg.split(maxsplit=1)
        if cmd not in self.registry.list():
            return f"⚠️ Unknown command {cmd}"
        handler_name = f"_{cmd.lstrip('/') }"
        fn = getattr(self, handler_name, None)
        if not callable(fn):
            return "🚧 command not implemented"
        try:
            arg = rest[0] if rest else ""
            return fn(arg)
        except Exception as exc:
            logger.error("[cmd] %s: %s", cmd, exc, exc_info=True)
            return str(exc)

    # Example minimal handlers
    def _show(self, _arg: str) -> str:
        rows: List[str] = []
        for name in self.registry.list():
            meta = self.registry.meta(name)
            lock = "🔒" if meta.get("locked", False) else ""
            rows.append(f"{name:12} w={meta.get('weight', 0):>3} {lock}")
        return "\n".join(rows) or "(no commands)"

    def _lock(self, arg: str) -> str:
        if not arg:
            return "Usage: /lock <cmd>"
        self.registry.toggle_lock(arg.strip())
        return "lock toggled"

    def _remember(self, arg: str) -> str:
        if not arg:
            return "Usage: /remember k v"
        k, *val = arg.split(maxsplit=1)
        if not val:
            return "Usage: /remember k v"
        self.owner.memory[k] = val[0]
        self.owner._save_memory()
        return "✓ saved"


# ----------------------------------------------------------------------------
# Plugin Manager
# ----------------------------------------------------------------------------
@dataclass
class PluginMeta:
    """Holds metadata about a single plugin."""
    name: str
    missing_dependencies: List[str] = field(default_factory=list)
    enabled: bool = True
    widget: Any = None
    module: Any = None

class PluginManager(QtCore.QObject):
    """
    Discovers and manages runtime plugins.

    Plugins live in the ``plugins`` subdirectory of the agent's base
    directory.  Each plugin is expected to be a Python package whose
    top‑level module may define any of the following attributes:

    * ``REQUIRES`` – an iterable of import names that must be available in
      order for the plugin to operate correctly.  Missing dependencies
      are surfaced to the UI and the plugin is disabled by default.

    * ``on_message(text: str, manager: PluginManager) -> Optional[dict]`` –
      a callback invoked whenever a message is broadcast.  It may return
      an envelope to emit via the :attr:`eventReceived` signal or it may
      raise/return nothing.  The callback is executed on a worker
      thread to avoid blocking the UI.

    * ``get_widget() -> QWidget`` – if present, invoked once when the
      plugin is discovered to obtain a UI widget that will be docked in
      the main window when the plugin is enabled.

    A plugin may alternatively call :meth:`emit_event` directly on the
    manager at any time to publish complex events.
    """
    # Plugins can emit events back to the UI via this signal.  The
    # first parameter is the plugin name and the second is an event
    # envelope (arbitrary mapping).
    eventReceived = QtCore.pyqtSignal(str, dict)

    def __init__(self, root: pathlib.Path, settings: Settings) -> None:
        super().__init__()
        self.root: pathlib.Path = pathlib.Path(root) / "plugins"
        self.settings: Settings = settings
        # Thread pool for dispatching plugin callbacks; reuse a small
        # number of threads to minimise resource usage.
        self._executor = None
        # Internal index of metadata keyed by plugin name
        self._meta: Dict[str, PluginMeta] = {}
        # Discover all plugins on initialisation
        self.discover()

    # ------------------------------------------------------------------
    def _ensure_executor(self) -> None:
        """Lazily create a thread pool executor."""
        if self._executor is None:
            import concurrent.futures
            # Use a small fixed pool – plugin callbacks should be quick
            self._executor = concurrent.futures.ThreadPoolExecutor(max_workers=4)

    def discover(self) -> None:
        """Scan the ``plugins`` directory and populate metadata."""
        self._meta.clear()
        if not self.root.is_dir():
            logger.info("No plugin directory found at %s", self.root)
            return
        for entry in self.root.iterdir():
            if not entry.is_dir() or entry.name.startswith("__"):
                continue
            name = entry.name
            meta = PluginMeta(name=name)
            try:
                module_name = f"plugins.{name}"
                mod = importlib.import_module(module_name)
                meta.module = mod
                # check dependencies
                requires: Iterable[str] = getattr(mod, "REQUIRES", [])
                missing: List[str] = []
                for dep in requires:
                    try:
                        importlib.import_module(dep)
                    except Exception:
                        missing.append(dep)
                meta.missing_dependencies = missing
                # Determine initial enabled state from settings.  Persisted
                # states live under a key namespace e.g. ``pluginsEnabled`` in
                # settings JSON.  Fallback to enabled unless dependencies
                # are missing.
                enabled_state = True
                try:
                    plug_cfg = getattr(self.settings, "plugins_enabled", {})
                    enabled_state = bool(plug_cfg.get(name, True))
                except Exception:
                    enabled_state = True
                # Force disabled when dependencies are missing
                meta.enabled = enabled_state and not missing
                # Create widget if provided
                try:
                    if hasattr(mod, "get_widget") and callable(mod.get_widget):
                        meta.widget = mod.get_widget()
                    elif hasattr(mod, "Widget"):
                        # Some plugins expose a QWidget subclass directly
                        meta.widget = getattr(mod, "Widget")()
                    elif hasattr(mod, "widget"):
                        # Prebuilt widget instance
                        meta.widget = getattr(mod, "widget")
                except Exception as exc:
                    logger.warning("[plugin:%s] error creating widget: %s", name, exc)
                    meta.widget = None
                self._meta[name] = meta
                logger.info("[plugin] loaded %s", name)
            except Exception as exc:
                # Record failure as missing dependency for UI
                meta.enabled = False
                meta.missing_dependencies = [str(exc)]
                self._meta[name] = meta
                logger.warning("[plugin] failed to load %s: %s", name, exc)

    # ------------------------------------------------------------------
    def list_plugins(self) -> List[PluginMeta]:
        """Return a list of all discovered plugin metadata objects."""
        return [self._meta[k] for k in sorted(self._meta.keys())]

    def enable_plugin(self, name: str, enabled: bool) -> None:
        """Enable or disable a plugin.  The UI will call this when a user
        toggles a checkbox.  Enabled state is persisted to
        ``settings.plugins_enabled``.
        """
        if name not in self._meta:
            return
        meta = self._meta[name]
        # Do not enable a plugin with missing dependencies
        if enabled and meta.missing_dependencies:
            logger.warning("Attempted to enable plugin %s with missing deps", name)
            return
        meta.enabled = bool(enabled)
        # Persist state back into settings
        try:
            plug_cfg = getattr(self.settings, "plugins_enabled", {})
            if not isinstance(plug_cfg, dict):
                plug_cfg = {}
            plug_cfg[name] = meta.enabled
            setattr(self.settings, "plugins_enabled", plug_cfg)
            self.settings.save()
        except Exception:
            logger.debug("Could not persist plugin enabled state for %s", name)
        # Invoke lifecycle hooks if defined
        try:
            if meta.module:
                if meta.enabled and hasattr(meta.module, "on_enable"):
                    meta.module.on_enable()
                elif not meta.enabled and hasattr(meta.module, "on_disable"):
                    meta.module.on_disable()
        except Exception as exc:
            logger.warning("[plugin:%s] lifecycle hook error: %s", name, exc)

    def rescan(self) -> None:
        """Rebuild the plugin registry while preserving enabled state where
        possible."""
        old_states = {name: meta.enabled for name, meta in self._meta.items()}
        self.discover()
        # Restore previous enabled states if compatible
        for name, state in old_states.items():
            if name in self._meta:
                # Disable when dependencies are still missing
                if self._meta[name].missing_dependencies:
                    self._meta[name].enabled = False
                else:
                    self._meta[name].enabled = state

    def broadcast(self, text: str) -> None:
        """Send a message to all enabled plugins.  Messages are dispatched
        asynchronously on a thread pool so the UI thread remains
        responsive.  Each plugin's ``on_message`` handler receives the
        message and this manager instance.  If the handler returns a
        mapping, it will be emitted via the :attr:`eventReceived` signal.
        """
        if not text:
            return
        self._ensure_executor()
        for meta in list(self._meta.values()):
            if not meta.enabled or meta.missing_dependencies:
                continue
            mod = meta.module
            if not mod:
                continue
            handler = getattr(mod, "on_message", None)
            if not callable(handler):
                continue
            # Dispatch on a worker thread
            def _run_handler(m=meta, h=handler, msg=text):
                try:
                    result = h(msg, self)
                    if isinstance(result, dict):
                        # Emit result via signal in the GUI thread
                        QtCore.QTimer.singleShot(0, lambda n=m.name, env=result: self.eventReceived.emit(n, env))
                except Exception as exc:
                    logger.warning("[plugin:%s] on_message error: %s", m.name, exc)
            # schedule the call
            self._executor.submit(_run_handler)

    def emit_event(self, sender: str, envelope: dict) -> None:
        """Convenience for plugins to emit events.  Plugins may call
        ``manager.emit_event(name, envelope)`` directly instead of
        returning from their ``on_message`` handlers.  The emission is
        forwarded to the UI thread via a zero‑delay timer.
        """
        if not envelope or not isinstance(envelope, dict):
            return
        # Schedule the emit on the Qt event loop
        QtCore.QTimer.singleShot(0, lambda s=sender, env=envelope: self.eventReceived.emit(s, env))


# ----------------------------------------------------------------------------
# RAG cache, schema engine and evolver fallbacks
#
# The original agent included sophisticated retrieval‑augmented generation
# support (the so‑called RAG cache) as well as a rich schema engine and
# evolver.  Those components are tightly coupled to the rest of the code
# base and to external packages.  To allow the UI to load without
# exploding when those bits are absent, we provide extremely minimal
# stand‑ins here.  They implement only the methods exercised by the UI
# (e.g. clearing the cache, basic schema field manipulation, etc.) and
# never throw.  Should the full implementations become available at
# runtime they can replace these shims by monkeypatching the
# corresponding attributes on :class:`AgentCore`.

class RAGCache:
    """In‑memory stub for the retrieval‑augmented generation cache.

    The real RAG cache stores vector embeddings on disk and in memory and
    exposes helpers for incremental updates.  For the purposes of the
    fallback we simply track whether anything has been 'cached' and allow
    callers to clear that state.  See :meth:`clear_disk` and
    :meth:`clear_memory`.
    """

    def __init__(self, root: str) -> None:
        # Root directory where persistent embeddings would live.  The
        # fallback does not persist anything but keeps the path for
        # reference.
        self.root = root
        # In‑memory store keyed by dataset path.  Values are arbitrary
        # payloads that might normally include embeddings.  We don't
        # implement storage here but maintain the attribute to satisfy
        # introspection.
        self._mem: Dict[str, Any] = {}

    def clear_disk(self) -> int:
        """Simulate removal of all on‑disk embedding files.

        Returns the number of files that would have been removed.  The
        fallback never persists embeddings so the count is always zero.
        """
        return 0

    def clear_memory(self) -> None:
        """Forget all cached embeddings held in memory."""
        self._mem.clear()


class SchemaEngine(QtCore.QObject):
    """Very small in‑memory schema engine.

    The full schema engine persists personas and sets in an SQLite
    database, exposes a signals API, integrates with the command
    registry and enforces schema invariants.  In contrast, this shim
    records arbitrary fields in nested dictionaries and provides only
    the handful of methods referenced by the UI: enumerating personas
    and sets, loading schemas, updating fields, toggling command
    exposure, toggling automatic evolution and reading fields back.
    """

    # Signal emitted when a schema evolves.  The UI connects to this
    # signal to refresh displayed values after an evolution completes.
    schemaEvolved = QtCore.pyqtSignal(str, str)

    def __init__(self, base_dir: str) -> None:
        super().__init__()
        self.base_dir = base_dir
        # All schemas keyed by (persona, set_name) -> dict
        self._schemas: Dict[Tuple[str, str], Dict[str, Any]] = {}
        # Track command exposure per (persona, category)
        self._cmd_exposed: Dict[Tuple[str, str], bool] = {}
        # Track auto evolution flag per (persona, set_name)
        self._auto_evo: Dict[Tuple[str, str], bool] = {}

    # ------------------------------------------------------------------
    # Introspection helpers
    # ------------------------------------------------------------------
    def personas(self) -> List[str]:
        """Return a list of personas that have at least one set loaded."""
        return sorted({persona for persona, _ in self._schemas.keys()})

    def set_list(self, persona: str, *args: Any) -> List[str]:
        """Get or set list depending on arguments.

        When called with only the persona, returns the names of all
        loaded sets for that persona.  When called with three
        additional arguments (set_name, field, values) behaves like
        :meth:`update_field` by storing ``values`` under ``field`` for
        the given persona and set.
        """
        # Setter mode: persona, set_name, field, values
        if len(args) == 3:
            set_name, field, values = args
            return [] if not self.update_field(persona, set_name, field, values) else []
        # Getter mode: persona only
        sets = [s for p, s in self._schemas.keys() if p == persona]
        return sorted(sets)

    # ------------------------------------------------------------------
    # Schema CRUD
    # ------------------------------------------------------------------
    def load_schema(self, persona: str, set_name: str) -> Optional[Dict[str, Any]]:
        """Return the schema dictionary for ``persona`` / ``set_name``.

        If no schema exists yet the fallback returns an empty mapping.
        """
        return self._schemas.get((persona, set_name), {})

    def update_field(self, persona: str, set_name: str, field: str, value: Any) -> bool:
        """Set a schema field and emit ``schemaEvolved``.

        Returns True on success.  The fallback always succeeds.
        """
        schema = self._schemas.setdefault((persona, set_name), {})
        schema[field] = value
        # Emit evolution signal to notify UI listeners
        try:
            self.schemaEvolved.emit(persona, set_name)
        except Exception:
            pass
        return True

    def get_field(self, persona: str, set_name: str, field: str) -> Any:
        """Return the value of a schema field or ``None`` if unset."""
        return self._schemas.get((persona, set_name), {}).get(field)

    # ------------------------------------------------------------------
    # Command exposure & auto evolution
    # ------------------------------------------------------------------
    def set_command_exposure(self, persona: str, field: str, exposed: bool) -> None:
        """Record whether ``field`` should be exposed as a slash command."""
        self._cmd_exposed[(persona, field)] = bool(exposed)

    def is_exposed_as_command(self, persona: str, field: str) -> bool:
        """Return True if ``field`` is marked as exposed."""
        return bool(self._cmd_exposed.get((persona, field)))

    def set_auto_evolution(self, persona: str, set_name: str, onoff: bool) -> None:
        """Enable or disable automatic schema evolution."""
        self._auto_evo[(persona, set_name)] = bool(onoff)

    # ------------------------------------------------------------------
    # Compatibility aliases
    # ------------------------------------------------------------------
    def get_set_list(self, persona: str) -> List[str]:
        """Legacy API: alias for :meth:`set_list(persona)`."""
        return self.set_list(persona)


class SchemaEvolver(QtCore.QObject):
    """Trivial schema evolver.

    The evolver's job is to adjust a schema given a conversation
    history.  The fallback implementation simply returns False to
    indicate that no changes were made.
    """

    def __init__(self, base_dir: str) -> None:
        super().__init__()
        self.base_dir = base_dir

    def update_schema(self, persona: str, set_name: str, history: List[Tuple[str, str]]) -> bool:
        """Perform a no‑op evolution.  Always returns False."""
        return False


class DatasetManagerFallback:
    """Minimal stand‑in for the full :class:`DatasetManager`.

    When the persistent SQLite database has not yet been migrated the
    original dataset manager will raise an ``OperationalError`` upon
    listing.  The fallback avoids that by returning empty results and
    exposing the handful of methods the UI expects.  No data is
    persisted by this implementation.
    """

    def __init__(self, base_dir: str) -> None:
        self.base_dir = pathlib.Path(base_dir)
        # Directory where datasets would be stored
        self.datasets_dir = self.base_dir / "datasets"
        self.datasets_dir.mkdir(parents=True, exist_ok=True)
        # Internal store mapping dataset name → info dict
        self._store: Dict[str, Dict[str, Any]] = {}

    def list(self) -> List[Any]:
        """Return an empty list.  In a full implementation this would
        return dataset objects describing each managed dataset."""
        return []

    @property
    def entries(self) -> Dict[str, Any]:
        """Return an empty dictionary mapping dataset names to entries."""
        return {}

    def toggle_active(self, name: str, active: bool) -> None:
        """Mark a dataset as active/inactive.  No‑op in the fallback."""
        info = self._store.get(name)
        if info is not None:
            info["active"] = bool(active)

    def add_dataset(self, path: str, *, name: Optional[str] = None) -> None:
        """Add a dataset from a file path.  The fallback simply
        records the dataset name and path in memory."""
        if not name:
            name = pathlib.Path(path).stem
        self._store[name] = {"path": path, "active": True}

    def delete_dataset(self, name: str) -> None:
        """Remove a dataset.  The fallback just deletes the entry from
        the in‑memory store."""
        self._store.pop(name, None)

    def load_dataset_text(self, name: str) -> str:
        """Load the raw text for the given dataset.  Returns an empty
        string if the dataset is unknown or if reading fails."""
        info = self._store.get(name)
        if not info:
            return ""
        try:
            with open(info.get("path", ""), encoding="utf-8") as fh:
                return fh.read()
        except Exception:
            return ""


# ----------------------------------------------------------------------------
# Model Worker
# ----------------------------------------------------------------------------
class ModelWorker(QtCore.QThread):
    """Runs external language models in a separate thread.

    This worker wraps an `ollama` subprocess invocation so that model
    evaluations do not block the UI.  It emits ``finished`` when the
    call returns successfully and ``failed`` when an exception is
    raised.  If the `ollama` binary is not available or times out
    `failed` will receive the error message.
    """
    finished = QtCore.pyqtSignal(str)
    failed = QtCore.pyqtSignal(str)

    def __init__(self, model: str, prompt: str, *, temp: float = 0.7) -> None:
        super().__init__()
        self.model = model
        self.prompt = prompt
        self.temp = temp

    def run(self) -> None:
        try:
            out = subprocess.check_output(
                ["ollama", "run", self.model, "--prompt", self.prompt, "--temperature", str(self.temp)],
                stderr=subprocess.STDOUT,
                text=True,
                timeout=60,
            )
            self.finished.emit(out.strip())
        except subprocess.CalledProcessError as e:
            self.failed.emit(e.output.strip())
        except Exception as exc:
            self.failed.emit(str(exc))


# ----------------------------------------------------------------------------
# Agent Core
# ----------------------------------------------------------------------------
class AgentCore(QtCore.QObject):
    """
    Heart of the AI‑TTS agent.  Provides a high‑level API consumed by the
    UI for persistent storage, command handling, plugin management and
    message processing.  Most methods are thread‑safe and return
    immediately without blocking the UI.
    """
    # Signals used by the UI to update status
    replyReady = QtCore.pyqtSignal(str)
    modelError = QtCore.pyqtSignal(str)
    tokensConsumed = QtCore.pyqtSignal(int)

    def __init__(
        self,
        base_dir: str,
        *,
        persona: Optional[str] = None,
        set_name: str = "default",
    ) -> None:
        super().__init__()
        # File system
        self.base_dir = pathlib.Path(base_dir)
        self.persona = persona or "zira"
        self.set_name = set_name
        # Settings
        self.settings = Settings(str(self.base_dir))
        # Initialise store directories
        self._prof_dir = self.base_dir / "profiles" / self.persona / self.set_name
        self._prof_dir.mkdir(parents=True, exist_ok=True)
        self._memory_file = self._prof_dir / "memory.json"
        # Instantiate subsystems
        self.schema_mgr = SchemaManager(str(self.base_dir))
        # Dataset manager – attempt to use the full implementation if
        # available.  When the backing SQLite tables have not been
        # created yet the dataset manager will raise an error on
        # ``list()``, so we fall back to the in‑memory stub.
        try:
            dm = DatasetManager(str(self.base_dir))  # type: ignore[call-arg]
            # Probe the manager to ensure the DB is present.  Some
            # implementations lazily connect to SQLite on first call.
            try:
                _ = dm.list()
            except Exception:
                raise
            self.dataset_mgr = dm
        except Exception:
            # Fallback stub avoids OperationalError due to missing tables
            self.dataset_mgr = DatasetManagerFallback(str(self.base_dir))
        self.operator_mgr = OperatorManager(str(self.base_dir))
        # Persistence
        self.conversation_db = ConversationDB(conv_db_path(str(self.base_dir), self.persona, self.set_name))
        self.feedback_db = SemanticFeedbackDB(feedback_db_path(str(self.base_dir), self.persona, self.set_name), BeanCounter(beans_path(str(self.base_dir), self.persona, self.set_name)))
        self.reinforcement_store = ReinforcementStore(beans_path(str(self.base_dir), self.persona, self.set_name))
        # Commands
        cmd_path = self._prof_dir / "commands.json"
        self.cmd_reg = CommandRegistry(cmd_path)
        self.cmd_exec = CommandExecutor(self, self.cmd_reg)
        # Provide a command_registry adapter for UI; exposes list_commands
        class _CmdRegAdapter:
            def __init__(self, reg: CommandRegistry) -> None:
                self._reg = reg
            def list_commands(self) -> List[str]:
                # Remove the leading slash for UI display purposes
                return [c for c in self._reg.list()]
        self.command_registry = _CmdRegAdapter(self.cmd_reg)
        # Expose registry change signals for convenience
        self.commandsChanged = self.cmd_reg.commandsChanged
        self.commandWeightsChanged = self.cmd_reg.commandWeightsChanged
        # Plugins
        self.plugins = PluginManager(self.base_dir, self.settings)
        # ------------------------------------------------------------------
        # RAG & schema components
        #
        # The UI references ``core.rag_cache`` and ``core.rag_search`` when
        # performing retrieval‑augmented generation (RAG) and ``core.schema_*``
        # objects when editing schemas.  In environments where the full
        # implementations are unavailable we instantiate the fallback shims
        # provided in this module.  These fallbacks expose the same
        # signatures but perform no heavy lifting.
        self.rag_cache = RAGCache(str(self.base_dir))
        self.schema_engine = SchemaEngine(str(self.base_dir))
        self.schema_evolver = SchemaEvolver(str(self.base_dir))
        # Create a default schema entry for the active persona/set so
        # that the UI can enumerate at least one persona and set.  This
        # populates the in‑memory schema store with a placeholder
        # field to mark its existence.  Without this the persona tabs
        # would appear empty on first launch.
        try:
            self.schema_engine.update_field(self.persona, self.set_name, "_init", True)
        except Exception:
            pass
        # Provide rag_search as a bound method so code can call
        # ``core.rag_search(...)``.  See method definition further below.
        # Note: we do not assign to self.rag_search here because methods
        # are descriptors; simply defining rag_search on the class makes
        # it available on the instance.
        # TTS and recording
        self.tts_mgr = TTSManager()
        self.audio_recorder = AudioRecorder()
        # Memory dictionary
        self.memory: Dict[str, str] = {}
        self._load_memory()
        # Add feedback helper
        self.add_feedback = lambda original, liked, revised=None: self.feedback_db.add(original, liked, revised)

    # ------------------------------------------------------------------
    # Memory helpers
    # ------------------------------------------------------------------
    def _load_memory(self) -> None:
        """Load persisted agent memory from disk."""
        try:
            if self._memory_file.is_file():
                with open(self._memory_file, encoding="utf-8") as fh:
                    data = json.load(fh)
                    if isinstance(data, dict):
                        self.memory.update({k: str(v) for k, v in data.items()})
        except Exception as exc:
            logger.debug("Failed to load memory: %s", exc)

    def _save_memory(self) -> None:
        """Persist the agent memory to disk."""
        try:
            self._prof_dir.mkdir(parents=True, exist_ok=True)
            with open(self._memory_file, "w", encoding="utf-8") as fh:
                json.dump(self.memory, fh, indent=2)
        except Exception as exc:
            logger.debug("Failed to save memory: %s", exc)

    # ------------------------------------------------------------------
    # Command & message processing
    # ------------------------------------------------------------------
    def run_command(self, msg: str, *, persona: Optional[str] = None, set_name: Optional[str] = None) -> str:
        """Process a slash command and return the response text.  Unknown
        commands yield a warning.  Both persona and set_name are
        accepted for future expansion; they are currently unused.
        """
        result = self.cmd_exec.run(msg)
        return "" if result is None else result

    def process_user_message(
        self,
        msg: str,
        *,
        persona: Optional[str] = None,
        set_name: Optional[str] = None,
        tts: bool = True,
    ) -> str:
        """Synchronously handle a user's input.  Slash commands are routed
        through :meth:`run_command`, recorded into the conversation log and
        returned immediately.  Non‑command messages are appended to the
        conversation and a simple acknowledgement is returned.  A future
        implementation can call an LLM here and use the result.  When
        ``tts`` is true the response is enqueued for text‑to‑speech.
        """
        user_msg = (msg or "").strip()
        if not user_msg:
            return ""
        # Save the user's utterance
        self.conversation_db.save_message("user", user_msg)
        # Slash commands
        if user_msg.startswith("/"):
            resp = self.run_command(user_msg, persona=persona, set_name=set_name)
            self.conversation_db.save_message("system", resp)
            return resp
        # Normal chat – future versions should build a prompt and call an LLM
        reply = f"{self.persona.capitalize()}: I received your message: {user_msg}"
        self.conversation_db.save_message(self.persona, reply)
        # Optionally speak the reply
        if tts:
            try:
                self.tts_mgr.enqueue(reply)
            except Exception:
                pass
        return reply

    # ------------------------------------------------------------------
    # Conversation and model pipeline
    # ------------------------------------------------------------------
    def send(self, user_msg: str) -> None:
        """Asynchronous pipeline invoked by legacy code.  Kept for backwards
        compatibility with older UI components.  Use
        :meth:`process_user_message` for synchronous processing.
        """
        # Simply hand off to process_user_message and emit signals
        response = self.process_user_message(user_msg, tts=False)
        if response:
            self.replyReady.emit(response)

    # ------------------------------------------------------------------
    # Retrieval‑augmented search
    # ------------------------------------------------------------------
    def rag_search(
        self,
        query: str,
        *,
        per_ds_k: int = 3,
        limit: int = 5,
        include_shared: bool = False,
        datasets: Optional[List[str]] = None,
    ) -> List[Tuple[str, float, str, str]]:
        """Perform a simple in‑memory search over dataset entries.

        The original implementation of this method would encode the
        provided ``query`` using a sentence embedding model and then
        retrieve the top‐matching text chunks from configured
        datasets.  In the fallback we simply return an empty list so
        that callers can iterate over the result without error.  The
        signature is maintained to preserve compatibility with the UI.

        :param query: The user query to search for.
        :param per_ds_k: Number of hits per dataset (ignored).
        :param limit: Maximum total number of hits (ignored).
        :param include_shared: Whether to include shared datasets (ignored).
        :param datasets: Restrict the search to specific dataset names (ignored).
        :returns: An empty list of hits.
        """
        # TODO: integrate with a vector search engine.  For now return no hits.
        return []

    # ------------------------------------------------------------------
    # Housekeeping
    # ------------------------------------------------------------------
    def close(self) -> None:
        """Cleanly close any resources owned by the core.  Currently this
        simply flushes in‑memory stores and releases any thread pools.  It
        is safe to call this multiple times.
        """
        try:
            # Persist memory
            self._save_memory()
        except Exception:
            pass
        # Flush settings
        try:
            self.settings.save()
        except Exception:
            pass
        # Shut down plugin executor
        try:
            exec_ = getattr(self.plugins, "_executor", None)
            if exec_:
                exec_.shutdown(wait=False)
                self.plugins._executor = None
        except Exception:
            pass
        # ConversationDB may own a SQLite connection; attempt to close
        try:
            if hasattr(self.conversation_db, "conn"):
                self.conversation_db.conn.close()
        except Exception:
            pass


__all__ = [
    "CommandRegistry",
    "CommandExecutor",
    "PluginManager",
    "PluginMeta",
    "ModelWorker",
    "AgentCore",
    "RAGCache",
    "SchemaEngine",
    "SchemaEvolver",
]
```

core_orchestrator.py
====================

This module provides the orchestration layer for the AI‑TTS agent.  It
exposes a unified API used by the user‑interface to interact with
schemas, conversations, commands, text‑to‑speech, plugins and other
components.  Historically the logic lived in a monolithic module,
but it has been refactored to encourage testability and to allow
individual subsystems to evolve independently.

The principal differences from earlier releases are:

* A richer :class:`PluginManager` that exposes a complete API expected
  by the UI.  In addition to discovering plugin packages from the
  ``plugins`` directory it now keeps per‑plugin metadata, supports
  enable/disable toggling, rescans at runtime, broadcasts messages to
  enabled plugins on a thread pool, and emits an ``eventReceived``
  signal whenever a plugin reports an event.  Plugins can either
  return a payload from their ``on_message`` handler or call
  ``emit_event`` on the manager directly to publish complex events.

* A ``run_command()`` method on :class:`AgentCore` which forwards
  slash commands through the :class:`CommandExecutor` and returns
  the textual result.  This helper centralises command routing and
  ensures backwards compatibility with older UI code.

* A ``process_user_message()`` method on :class:`AgentCore` which
  synchronously handles both slash‑commands and normal user input.  It
  persists the conversation, routes commands through the registry
  and, for non‑commands, returns a simple acknowledgement.  Future
  versions may integrate model execution here, but the method
  signature is stable for consumers.

* A ``command_registry`` attribute is exposed on the core as an
  adapter with a ``list_commands()`` method so that UI components
  (like the Command Palette) can enumerate available commands without
  coupling to internal registry details.

This file is fully self‑contained.  It gracefully degrades when
optional dependencies (such as PyQt5 or external model executables)
are unavailable by providing shims and in‑memory fallbacks.  Should
the optional modules exist in the runtime environment they will be
used automatically.  The design favours clear separation of
responsibilities, thread safety and explicit interfaces to ease
maintenance and extensibility.
**Classes:** CommandRegistry, CommandExecutor, PluginMeta, PluginManager, RAGCache, SchemaEngine, SchemaEvolver, DatasetManagerFallback, ModelWorker, AgentCore


## Module `core_schema.py`

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
core_schema.py — v3-final (2025-08-04 04:12 UTC) + commands-field patch (2025-08-09)
====================================================================================

Single-source authority for all schema / dataset / snapshot / spatial-state
logic used by FATHOM Agent, now relying on AgentStore’s public API only.

Provides:
• Schema dataclass + SchemaEngine (diff, auto-evolve, variant injection)
• OperatorManager persisted in the same DB
• DatasetManager (metadata) + RAGCache (embeddings) in the same DB
• SnapshotEngine to walk the codebase & persist chunks to DB
• SpatialPositionManager for grid-room positions & movement logging
• Back-compat alias: SchemaManager → SchemaEngine

This version adds the `.active_schemas` property required by main_ui.py.
"""

from __future__ import annotations

import os
import json
import threading
import mimetypes
import hashlib
import shutil
import difflib
import time
from dataclasses import dataclass, asdict, field
from typing import List, Dict, Tuple, Any, Optional

# Optional Qt import.  This module defines a Qt signal (schemaEvolved,
# categoryCreated) for UI use, but can still run headless without
# PyQt5.  When PyQt5 is unavailable a minimal shim is provided so
# that the rest of the code can import SchemaEngine and run without
# errors.
try:
    from PyQt5 import QtCore  # type: ignore
except Exception:
    class _ShimSignal:
        def __init__(self, *_, **__) -> None: pass
        def connect(self, *_, **__) -> None: pass
        def emit(self, *_, **__) -> None: pass
    class _ShimQObject:
        def __init__(self, *args, **kwargs) -> None: pass
    QtCore = type("QtCore", (), {  # type: ignore
        "QObject": _ShimQObject,
        "pyqtSignal": lambda *a, **k: _ShimSignal(),
    })

from core_base import (
    logger,
    FathomStore as AgentStore,
    DEFAULT_PERSONAS,
    DEFAULT_VOICES,
)

# ───────────────────────────────────────────────────────────────────────────
# Internal global store helper
# ───────────────────────────────────────────────────────────────────────────
_agent_store_singleton: Optional[AgentStore] = None

def _ensure_store(root: str) -> AgentStore:
    """Return a process-wide AgentStore instance rooted at *root*."""
    global _agent_store_singleton
    if _agent_store_singleton is None:
        _agent_store_singleton = AgentStore(root)
    return _agent_store_singleton


# ══════════════════════════════════════════════════════════════════════════
#  Schema Dataclass & helpers
# ══════════════════════════════════════════════════════════════════════════
@dataclass
class Schema:
    name: str = ""
    voice: str = ""
    role: str = ""
    description: str = ""
    actions: List[str] = field(default_factory=list)
    questions: List[str] = field(default_factory=list)
    events: List[str] = field(default_factory=list)
    self_talk: List[str] = field(default_factory=list)
    rewrite_prompts: List[str] = field(default_factory=list)
    # NEW: explicit commands list to match _first_run_schema bootstrap
    commands: List[str] = field(default_factory=list)
    dynamic_overlay: Dict[str, Any] = field(default_factory=dict)

    # optional flags map used for advanced settings such as semantic
    # awareness and auto-evolution.  The UI stores arbitrary keys here.
    flags: Dict[str, Any] = field(default_factory=dict)

    @staticmethod
    def from_json(js: str) -> "Schema":
        return Schema(**json.loads(js))

    def to_json(self) -> str:
        return json.dumps(asdict(self), ensure_ascii=False, indent=2)

    def diff_against(self, other: "Schema") -> str:
        a = self.to_json().splitlines()
        b = other.to_json().splitlines()
        return "\n".join(difflib.unified_diff(a, b, fromfile="old", tofile="new"))


# ══════════════════════════════════════════════════════════════════════════
#  SchemaEngine (high-level CRUD + auto-evolution + active_schemas)
# ══════════════════════════════════════════════════════════════════════════
class SchemaEngine(QtCore.QObject):
    schemaEvolved   = QtCore.pyqtSignal(str, str)  # persona, set_name
    categoryCreated = QtCore.pyqtSignal(str)       # new dynamic_overlay key

    def __init__(self, base_dir: str):
        super().__init__()
        self.base_dir       = base_dir
        self.store          = _ensure_store(base_dir)
        # Wrap personas in a callable list so legacy code can call
        # ``engine.personas()`` while new code can still iterate over
        # ``engine.personas``.  The wrapper implements __call__ to
        # return a standard list when invoked.
        class _PersonaList(list):  # local class
            def __call__(self) -> list[str]:
                return list(self)
        self.personas = _PersonaList(DEFAULT_PERSONAS.keys())  # type: ignore[arg-type]
        self.voices         = DEFAULT_VOICES.copy()
        self._active_schemas: Dict[str, Schema] = {}
        self._migrate_legacy()

    def load(self, persona: str, set_name: str = "default") -> Schema:
        stored = self.store.get_schema(persona, set_name)
        if stored is not None:
            sch = Schema(**stored)
        else:
            sch = self._first_run_schema(persona)
            self.save(persona, set_name, sch, auto_expand=False)
        self._active_schemas[persona] = sch
        return sch

    def save(
        self,
        persona: str,
        set_name: str,
        schema: Schema,
        *,
        auto_expand: bool = True,
    ) -> None:
        if auto_expand and self._auto_expand(schema):
            self.schemaEvolved.emit(persona, set_name)
        payload = asdict(schema)
        diff_text = ""
        self.store.put_schema(persona, set_name, payload, diff_text)
        self._active_schemas[persona] = schema

    def list_sets(self, persona: str) -> List[str]:
        """Return list of all set names for a given persona."""
        with self.store._pool.get() as c:
            rows = c.execute(
                # corrected column name from persona_key → persona
                "SELECT set_name FROM schemas WHERE persona=? ORDER BY set_name",
                (persona,),
            ).fetchall()
        return [r[0] for r in rows] or ["default"]

    @property
    def active_schemas(self) -> Dict[str, Schema]:
        """Currently loaded schemas keyed by persona."""
        return dict(self._active_schemas)

    # ------------------------------------------------------------------
    # Legacy helpers expected by the UI
    # ------------------------------------------------------------------
    def set_list(self, persona: str) -> List[str]:
        """
        Legacy alias for :meth:`list_sets`.  Returns the list of set
        names for the given persona.
        """
        return self.list_sets(persona)

    def get_field(self, persona: str, set_name: str, category: str) -> Any:
        """
        Retrieve a specific field from a schema.  Top-level schema
        attributes (e.g. ``name``, ``voice``) are returned directly.
        If the category refers to a dynamic overlay key, that value is
        returned.  A missing category yields ``None``.
        """
        try:
            sch = self.load(persona, set_name)
        except Exception:
            return None
        # built-in dataclass fields take precedence
        if hasattr(sch, category):
            return getattr(sch, category)
        # dynamic overlay stores custom categories
        overlay = getattr(sch, "dynamic_overlay", {}) or {}
        return overlay.get(category)

    # Internal map tracking which schema categories are exposed as
    # slash commands.  Keys are ``(persona, category)`` tuples and
    # values are booleans.  No persistence yet – this is purely
    # in-memory.  Persisting exposure state could be added later by
    # storing into the schema ``flags`` map or separate table.
    _cmd_exposed: Dict[tuple[str, str], bool] = {}

    def is_exposed_as_command(self, persona: str, category: str) -> bool:
        """
        Return True if the given category for the persona is exposed
        as a slash command.  When no explicit record exists, False is
        returned.  This helper allows the PersonaTab to reflect the
        checkbox state correctly.
        """
        return bool(self._cmd_exposed.get((persona, category)))

    def set_command_exposure(self, persona: str, category: str, exposed: bool) -> None:
        """
        Mark or unmark a category as exposed via the slash command
        mechanism.  This implementation only updates an in-memory
        registry; future versions could persist this into the schema
        ``flags`` dictionary or integrate directly with the command
        registry.  For now it is enough to allow the UI checkbox to
        toggle state without error.
        """
        self._cmd_exposed[(persona, category)] = bool(exposed)

    def set_auto_evolution(self, persona: str, set_name: str, enabled: bool) -> None:
        """
        Enable or disable auto-evolution for a given schema.  Older
        versions of the UI called this method to toggle semantic
        awareness or automatic schema growth.  To remain compatible we
        store the value inside the schema's ``flags`` dictionary and
        persist it back to the database.  If the schema or flags
        dictionary does not exist it will be created on demand.
        """
        try:
            data = self.load_schema(persona, set_name)
        except Exception:
            return
        # ensure there is a flags map
        flags = data.get("flags") if isinstance(data, dict) else None
        if not isinstance(flags, dict):
            flags = {}
        # choose a descriptive key; both names are kept for back-compat
        flags["auto_evolution"] = bool(enabled)
        flags["semantic_awareness"] = flags.get("semantic_awareness", True)
        data["flags"] = flags
        try:
            self.save_schema(persona, set_name, data, auto_expand=False)
        except Exception:
            pass

    def update_field(self, persona: str, set_name: str, category: str, value: Any) -> None:
        """
        Update a single field in the given schema.  If the category
        corresponds to a declared attribute on the Schema dataclass it
        will be set directly; otherwise it will be stored in the
        dynamic overlay.  After mutation the schema is persisted.  This
        helper is used by the Schema Editor to save incremental edits.
        """
        try:
            sch = self.load(persona, set_name)
        except Exception as e:
            raise e
        # dataclass fields vs dynamic overlay
        if hasattr(sch, category):
            setattr(sch, category, value)
        else:
            overlay = getattr(sch, "dynamic_overlay", {}) or {}
            overlay[category] = value
            sch.dynamic_overlay = overlay
        # persist the change without auto-expanding traits
        self.save(persona, set_name, sch, auto_expand=False)

    # ------------------------------------------------------------------
    # Legacy compatibility API
    # ------------------------------------------------------------------
    def load_schema(self, persona: str, set_name: str = "default") -> Dict[str, Any]:
        """
        Legacy wrapper returning a plain dict for the requested persona/set.
        main_ui.py expects a mapping, not a Schema dataclass.
        """
        sch = self.load(persona, set_name)
        from dataclasses import asdict
        return asdict(sch)

    def save_schema(
        self,
        persona: str,
        set_name: str,
        schema_data: Dict[str, Any],
        *,
        auto_expand: bool = True,
    ) -> None:
        """
        Legacy wrapper accepting a mapping instead of a Schema instance.
        Converts to Schema and delegates to save().
        """
        # If schema_data is already a Schema instance then wrap accordingly
        if isinstance(schema_data, Schema):
            schema = schema_data
        else:
            # fill missing lists/dicts with defaults
            kwargs = {
                "name": schema_data.get("name", ""),
                "voice": schema_data.get("voice", ""),
                "role": schema_data.get("role", ""),
                "description": schema_data.get("description", ""),
                "actions": list(schema_data.get("actions", [])) if schema_data.get("actions") is not None else [],
                "questions": list(schema_data.get("questions", [])) if schema_data.get("questions") is not None else [],
                "events": list(schema_data.get("events", [])) if schema_data.get("events") is not None else [],
                "self_talk": list(schema_data.get("self_talk", [])) if schema_data.get("self_talk") is not None else [],
                "rewrite_prompts": list(schema_data.get("rewrite_prompts", [])) if schema_data.get("rewrite_prompts") is not None else [],
                # NEW: carry through commands if present
                "commands": list(schema_data.get("commands", [])) if schema_data.get("commands") is not None else [],
                "dynamic_overlay": dict(schema_data.get("dynamic_overlay", {})) if schema_data.get("dynamic_overlay") is not None else {},
            }
            schema = Schema(**kwargs)
        self.save(persona, set_name, schema, auto_expand=auto_expand)

    def save_active_schemas(self, active: Dict[str, str]) -> None:
        """
        Persist the mapping of persona->set_name. For now this simply ensures
        the internal cache is populated. A future implementation could write
        this to settings.json or another store so the UI can restore it.
        """
        if not isinstance(active, dict):
            return
        for persona, set_name in active.items():
            try:
                schema = self.load(persona, set_name)
                self._active_schemas[persona] = schema
            except Exception:
                continue

    def _auto_expand(self, sch: Schema) -> bool:
        overlay = sch.dynamic_overlay or {}
        added = overlay.get("added_traits", [])
        created = False
        for trait in added:
            cat = trait.split(":", 1)[0]
            if cat not in overlay:
                overlay[cat] = []
                self.categoryCreated.emit(cat)
                created = True
        if created:
            sch.dynamic_overlay = overlay
        return created

    def _first_run_schema(self, persona: str) -> Schema:
        default_voice = self.voices[0] if self.voices else "Zira"
        return Schema(
            name="FATHOM",
            voice=default_voice,
            role="You are FATHOM, an Autonomous AGI Core and Knowledge Synthesizer bridging logic, code, and architecture across multi-agent ecosystems.",
            description="FATHOM is a systems-minded AGI core supporting the architect, offering precise, logical, and creative suggestions to advance the project.",
            actions=[
                "log_data_pipeline",
                "trace_signal_flow",
                "generate_training_set",
                "summarize_behavior"
            ],
            questions=[
                "What assumptions underlie this architecture?",
                "Where is data duplication most likely?",
                "What components remain unmodularized?",
                "How would a self-improving agent resolve this?"
            ],
            self_talk=[
                "Assessing dependencies across systems.",
                "Considering the impact of this change on existing modules.",
                "Simulating interaction of updated schema with all agents.",
                "Cross-verifying logic gates and input constraints."
            ],
            rewrite_prompts=[
                "Refine the explanation to focus on system integration and modular design.",
                "Rephrase for clarity in codebase maintenance context.",
                "Focus rewrite on agent collaboration and memory scopes."
            ],
            commands=[
                "/remember",
                "/showfacts",
                "/style",
                "/rewrite",
                "/evolve",
                "/log",
                "/feedback",
                "/promptify",
                "/refactor",
                "/export",
                "/reset",
                "/snapshot",
                "/simulate",
                "/explain",
                "/guide",
                "/diagnose"
            ],
            dynamic_overlay={
                "temporary_relationship_context": "AGI Core for Meesh's Project",
                "recent_topics": [],
                "temporary_emotional_state": "focused on precision execution",
                "added_traits": ["analytical", "systemic", "modular"],
                "pending_thoughts": [],
                "last_guided_task": "",
                "visual_state": {
                    "facing": "right",
                    "color": "#4F46E5",
                    "location": [7, 4]
                },
                "execution_scope": {
                    "authorized": True,
                    "last_command": "/simulate"
                }
            },
            flags={
                "semantic_awareness": True,
                "auto_evolution": True,
                "snapshot_enabled": True,
                "tts_name": "Zira"
            }
        )


    def _migrate_legacy(self) -> None:
        legacy_root = os.path.join(self.base_dir, "schemas")
        if not os.path.isdir(legacy_root):
            return
        for persona in os.listdir(legacy_root):
            sets_dir = os.path.join(legacy_root, persona, "sets")
            if not os.path.isdir(sets_dir):
                continue
            for set_name in os.listdir(sets_dir):
                path = os.path.join(sets_dir, set_name, "schema.json")
                if not os.path.isfile(path):
                    continue
                try:
                    with open(path, "r", encoding="utf-8") as fh:
                        schema_dict = json.load(fh)
                    if self.store.get_schema(persona, set_name) is None:
                        self.store.put_schema(persona, set_name, schema_dict, "")
                except Exception as e:
                    logger.error("Legacy schema import error: %s", e)


# ══════════════════════════════════════════════════════════════════════════
#  OperatorManager
# ══════════════════════════════════════════════════════════════════════════
class OperatorManager:
    def __init__(self, base_dir: str):
        self.store = _ensure_store(base_dir)

    def list(self) -> List[str]:
        return [n for n, _, _, _ in self.store.list_commands()]

    # ------------------------------------------------------------------
    # Legacy helpers expected by UI
    # ------------------------------------------------------------------
    def list_operators(self) -> List[str]:
        """
        Backwards-compatible alias for :meth:`list`.  The UI calls
        ``list_operators()`` when populating the operators tab.
        """
        return self.list()

    def load_schema(self, name: str) -> Dict[str, Any]:
        """
        Backwards-compatible alias for :meth:`load`.  Returns the
        operator's schema as a plain dictionary.
        """
        return self.load(name)

    def load(self, name: str) -> Dict[str, Any]:
        with self.store._pool.get() as c:
            row = c.execute("SELECT json FROM operators WHERE name=?", (name,)).fetchone()
        return json.loads(row[0]) if row else {}

    def save(self, name: str, schema: Dict[str, Any]) -> None:
        self.store.upsert_command(
            name,
            schema.get("weight", 0),
            schema.get("locked", False),
            schema.get("category"),
        )


# ══════════════════════════════════════════════════════════════════════════
#  DatasetManager (metadata in DB; raw text on disk)
# ══════════════════════════════════════════════════════════════════════════
@dataclass
class DatasetEntry:
    name: str
    path: str
    active: bool

class DatasetManager(QtCore.QObject):
    datasetListChanged = QtCore.pyqtSignal()

    def __init__(self, base_dir: str):
        super().__init__()
        self.base_dir     = base_dir
        self.root         = os.path.join(base_dir, "datasets")
        self.datasets_dir = self.root
        os.makedirs(self.root, exist_ok=True)
        self.store        = _ensure_store(base_dir)

    def _path_for(self, name: str) -> str:
        return os.path.join(self.root, name, "data.txt")

    def list(self) -> List[DatasetEntry]:
        with self.store._pool.get() as c:
            rows = c.execute(
                "SELECT name, original_path, active FROM datasets ORDER BY name"
            ).fetchall()
        return [DatasetEntry(r[0], r[1], bool(r[2])) for r in rows]

    # ------------------------------------------------------------------
    # Legacy helpers expected by the UI
    # ------------------------------------------------------------------
    @property
    def entries(self) -> Dict[str, DatasetEntry]:
        """
        Return a mapping of dataset name → DatasetEntry.  Many UI
        components iterate over ``dataset_mgr.entries.items()`` to
        display the current datasets.
        """
        return {d.name: d for d in self.list()}

    def add_dataset(self, name: str, src_path: str) -> None:
        """
        Alias for :meth:`add`.  Mirrors the original API where
        ``add_dataset`` saved the file contents into the managed
        datasets directory.
        """
        self.add(name, src_path)

    def delete_dataset(self, name: str) -> None:
        """
        Alias for :meth:`delete`.  Removes the dataset completely.
        """
        self.delete(name)

    def toggle_active(self, name: str, active: bool) -> None:
        """
        Alias for :meth:`toggle`.  Enables or disables a dataset.
        """
        self.toggle(name, active)

    def load_dataset_text(self, entry: DatasetEntry) -> Optional[str]:
        """
        Load the full text of a dataset entry.  For plain text files
        this simply reads and returns the file contents.  For PDF
        files no conversion is attempted – callers should handle
        alternative formats.  Returns ``None`` on error.
        """
        try:
            path = entry.path
            if not os.path.isfile(path):
                return None
            _, ext = os.path.splitext(path)
            ext = ext.lower()
            if ext in {".txt", ".md", ".json", ".py"}:
                with open(path, "r", encoding="utf-8", errors="ignore") as fh:
                    return fh.read()
            elif ext == ".pdf":
                # basic fallback: return None; PDF parsing requires additional deps
                return None
            else:
                # unknown format; attempt text read
                with open(path, "r", encoding="utf-8", errors="ignore") as fh:
                    return fh.read()
        except Exception:
            return None

    def add(self, name: str, src_path: str) -> None:
        if not name.strip():
            raise ValueError("dataset name required")
        if any(ds.name == name for ds in self.list()):
            raise FileExistsError("dataset already exists")
        dst_dir  = os.path.join(self.root, name)
        os.makedirs(dst_dir, exist_ok=True)
        dst_file = shutil.copy2(src_path, self._path_for(name))
        with self.store.tx() as c:
            c.execute(
                "INSERT INTO datasets (name,active,original_path) VALUES (?,?,?)",
                (name, 1, dst_file),
            )
        self.datasetListChanged.emit()

    def toggle(self, name: str, active: bool) -> None:
        with self.store.tx() as c:
            c.execute("UPDATE datasets SET active=? WHERE name=?", (1 if active else 0, name))
        self.datasetListChanged.emit()

    def delete(self, name: str) -> None:
        try:
            shutil.rmtree(os.path.dirname(self._path_for(name)), ignore_errors=True)
        except Exception:
            pass
        with self.store.tx() as c:
            c.execute("DELETE FROM datasets WHERE name=?", (name,))
        self.datasetListChanged.emit()


# ══════════════════════════════════════════════════════════════════════════
#  RAGCache (embeddings cache)
# ══════════════════════════════════════════════════════════════════════════
try:
    import numpy as np
    from sentence_transformers import SentenceTransformer
except Exception:
    np = None
    SentenceTransformer = None  # type: ignore

class RAGCache:
    def __init__(self, model: Optional[Any], model_name: str, datasets_root: str):
        self.model       = model
        self.model_name  = model_name
        self.root        = datasets_root
        self._mem: Dict[str, Dict[str, Any]] = {}

    def _cache_path(self, ds_path: str) -> str:
        base = f"embeddings_{self.model_name}.npz"
        return os.path.join(os.path.dirname(ds_path), base)

    def _encode(self, sentences: List[str]) -> Optional["np.ndarray"]:
        if self.model is None or np is None:
            return None
        try:
            emb = self.model.encode(sentences, convert_to_numpy=True, normalize_embeddings=True)  # type: ignore
        except TypeError:
            emb = self.model.encode(sentences, convert_to_numpy=True)  # type: ignore
            emb = emb / (np.linalg.norm(emb, axis=1, keepdims=True) + 1e-9)  # type: ignore
        return np.asarray(emb)

    def load_or_build(self, ds_entry: DatasetEntry, full_text: str) -> Optional[Dict[str, Any]]:
        if self.model is None or np is None:
            return None
        key = ds_entry.path
        if key in self._mem:
            return self._mem[key]

        cache_path = self._cache_path(key)
        if os.path.isfile(cache_path):
            try:
                data = np.load(cache_path, allow_pickle=False)
                with open(cache_path.replace(".npz", ".json"), "r", encoding="utf-8") as fh:
                    sents = json.load(fh)
                self._mem[key] = {"sentences": sents, "emb": data["emb"]}
                return self._mem[key]
            except Exception:
                pass

        sentences = [s.strip() for s in full_text.split("\n") if s.strip()] or [full_text[:500]]
        emb = self._encode(sentences)
        if emb is None:
            return None
        self._mem[key] = {"sentences": sentences, "emb": emb}
        try:
            np.savez_compressed(cache_path, emb=emb)
            with open(cache_path.replace(".npz", ".json"), "w", encoding="utf-8") as fh:
                json.dump(sentences, fh)
        except Exception:
            pass
        return self._mem[key]

    def clear_memory(self) -> None:
        self._mem.clear()

    def clear_disk(self) -> int:
        removed = 0
        for root, _, files in os.walk(self.root):
            for fn in files:
                if fn.startswith("embeddings_") and fn.endswith((".npz", ".json")):
                    try:
                        os.remove(os.path.join(root, fn))
                        removed += 1
                    except Exception:
                        pass
        return removed


# ══════════════════════════════════════════════════════════════════════════
#  SnapshotEngine (“system self-perception”)
# ══════════════════════════════════════════════════════════════════════════
class SnapshotEngine(QtCore.QObject):
    snapshotFinished = QtCore.pyqtSignal(int)

    def __init__(self, base_dir: str):
        super().__init__()
        self.store    = _ensure_store(base_dir)
        self.base_dir = base_dir

    def run_snapshot(self, root: Optional[str] = None, *, chunk_bytes: int = 8192) -> None:
        threading.Thread(
            target=self._worker,
            args=(root or self.base_dir, chunk_bytes),
            daemon=True,
        ).start()

    def _worker(self, root: str, chunk_sz: int):
        rows = 0
        with self.store._pool.get() as c:
            for dirpath, _, files in os.walk(root):
                if "__pycache__" in dirpath or ".git" in dirpath:
                    continue
                for fn in files:
                    path = os.path.join(dirpath, fn)
                    try:
                        st            = os.stat(path)
                        size, mtime   = st.st_size, st.st_mtime
                        sha           = hashlib.sha256(open(path, "rb").read()).hexdigest()
                        mime          = mimetypes.guess_type(fn)[0] or "application/octet-stream"
                        if mime.startswith(("text/", "application/json", "application/xml")) and size <= 2_000_000:
                            data   = open(path, "r", encoding="utf-8", errors="ignore").read()
                            chunks = [data[i : i + chunk_sz] for i in range(0, len(data), chunk_sz)] or [""]
                        else:
                            chunks = [""]
                        for idx, chunk in enumerate(chunks):
                            c.execute(
                                """
                                INSERT INTO system_files
                                  (path,size,mtime,sha256,mime,chunk_index,content)
                                VALUES (?,?,?,?,?,?,?)
                                ON CONFLICT(path) DO UPDATE SET
                                  size  = excluded.size,
                                  mtime = excluded.mtime,
                                  sha256= excluded.sha256
                                """,
                                (path, size, mtime, sha, mime, idx, chunk),
                            )
                            rows += 1
                    except Exception as e:
                        logger.warning("snapshot skip %s: %s", path, e)
            c.connection.commit()
        self.snapshotFinished.emit(rows)


# ══════════════════════════════════════════════════════════════════════════
#  SpatialPositionManager (grid-room positions & logs)
# ══════════════════════════════════════════════════════════════════════════
class SpatialPositionManager(QtCore.QObject):
    positionChanged = QtCore.pyqtSignal(str, int, int)
    actionLogged    = QtCore.pyqtSignal(str, str)

    def __init__(self, base_dir: str):
        super().__init__()
        self.store = _ensure_store(base_dir)

    def _log_action(self, entity: str, action: str, location: str, justification: str) -> None:
        with self.store.tx() as c:
            c.execute(
                "INSERT INTO visual_actions(entity,action,location,justification)"
                " VALUES (?,?,?,?)",
                (entity, action, location, justification),
            )
        self.actionLogged.emit(entity, action)

    def update_position(self, entity: str, x: int, y: int, *, facing: str = "right", color: str = "#F8BBD0") -> None:
        with self.store.tx() as c:
            c.execute(
                "INSERT INTO spatial_positions(entity,x,y,facing,color)"
                " VALUES(?,?,?,?,?)",
                (entity, x, y, facing, color),
            )
        self.positionChanged.emit(entity, x, y)

    def latest_position(self, entity: str) -> Optional[Tuple[int, int]]:
        with self.store._pool.get() as c:
            row = c.execute(
                "SELECT x,y FROM spatial_positions WHERE entity=? ORDER BY id DESC LIMIT 1",
                (entity,),
            ).fetchone()
        return (row[0], row[1]) if row else None


# ───────────────────────────────────────────────────────────────────────────
# Back-compatibility alias
# ───────────────────────────────────────────────────────────────────────────
SchemaManager = SchemaEngine


# ══════════════════════════════════════════════════════════════════════════
#  Public module API
# ══════════════════════════════════════════════════════════════════════════
__all__ = [
    "Schema", "SchemaEngine", "SchemaManager",
    "OperatorManager",
    "DatasetEntry", "DatasetManager",
    "RAGCache",
    "SnapshotEngine", "SpatialPositionManager",
]
```

core_schema.py — v3-final (2025-08-04 04:12 UTC) + commands-field patch (2025-08-09)
====================================================================================

Single-source authority for all schema / dataset / snapshot / spatial-state
logic used by FATHOM Agent, now relying on AgentStore’s public API only.

Provides:
• Schema dataclass + SchemaEngine (diff, auto-evolve, variant injection)
• OperatorManager persisted in the same DB
• DatasetManager (metadata) + RAGCache (embeddings) in the same DB
• SnapshotEngine to walk the codebase & persist chunks to DB
• SpatialPositionManager for grid-room positions & movement logging
• Back-compat alias: SchemaManager → SchemaEngine

This version adds the `.active_schemas` property required by main_ui.py.
**Classes:** Schema, SchemaEngine, OperatorManager, DatasetEntry, DatasetManager, RAGCache, SnapshotEngine, SpatialPositionManager
**Functions:** _ensure_store(root)


## Module `main_ui.py`

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
main_ui.py
===========

This module contains the top-level ``AppWindow`` class for the AI TTS
Agent.  It orchestrates all layout and docking behaviour, integrates
the control panel and persona tabs provided by ``commands_panel`` and
``persona_tab``, and exposes a unified interface for the rest of the
application.  None of the core agent logic lives here – that remains in
the ``core_*`` modules.  This refactor pulls the bulky UI building
logic out of the monolithic script and into dedicated modules while
preserving all existing behaviour and wiring.
"""

from __future__ import annotations

import os
import json
import time
import re
import subprocess
import threading
from typing import Dict, List, Tuple, Optional


from PyQt5 import QtCore, QtGui, QtWidgets

# Optional spell checker
try:
    from spellchecker import SpellChecker  # type: ignore
except Exception:
    SpellChecker = None  # type: ignore
from PyQt5.QtCore import QSettings, QRunnable, QThreadPool
from functools import partial

# Optional deps
try:
    from sentence_transformers import SentenceTransformer  # type: ignore
except Exception:
    SentenceTransformer = None  # type: ignore
try:
    import numpy as np  # type: ignore
except Exception:
    np = None  # type: ignore
try:
    import sounddevice as sd  # type: ignore
except Exception:
    sd = None  # type: ignore

# Import core orchestrator components instead of the monolithic agent_core.
# The modular agent splits responsibilities across core_base, core_schema and
# core_orchestrator.  AgentCore and ModelWorker live in core_orchestrator.
from core_orchestrator import (
    AgentCore,
    ModelWorker,
)

from snapshot_worker import ModelWorker

# ─── Command-Palette import ───────────────────────────────────────────
from command_palette import CommandPaletteDock

# Import the modular UI components
from commands_panel import CommandsPanel
from persona_tab import PersonaTab

ROLE_COLOURS: Dict[str, str] = {
    "user": "#FFF8E1",
    "zira": "#E3F2FD",
    "system": "#E0F7FA",
    "operator": "#EDE7F6",
}
NAME_COLOURS: Dict[str, str] = {
    "user": "#5D4037",
    "zira": "#0D47A1",
    "system": "#006064",
    "operator": "#4A148C",
}


# ---------------------------------------------------------------------------
# Spell highlighting for misspelled words
# ---------------------------------------------------------------------------
class _SpellHighlighter(QtGui.QSyntaxHighlighter):
    """
    Underlines misspelled words in red. Uses pyspellchecker if available.
    """

    def __init__(self, document: QtGui.QTextDocument) -> None:
        super().__init__(document)
        # instantiate spell checker only if available
        self._spell = SpellChecker() if SpellChecker else None
        self._format = QtGui.QTextCharFormat()
        self._format.setUnderlineStyle(QtGui.QTextCharFormat.SpellCheckUnderline)
        self._format.setUnderlineColor(QtCore.Qt.red)
        # simple cache to avoid recomputing spelling on common words
        self._cache: Dict[str, bool] = {}

    def highlightBlock(self, text: str) -> None:
        if not self._spell:
            return
        for match in re.finditer(r"[A-Za-z']{3,}", text):
            word = match.group(0).lower()
            bad = self._cache.get(word)
            if bad is None:
                bad = word not in self._spell
                # prune cache occasionally
                if len(self._cache) > 2048:
                    self._cache.clear()
                self._cache[word] = bad
            if bad:
                start, end = match.span()
                length = end - start
                self.setFormat(start, length, self._format)


class AppWindow(QtWidgets.QMainWindow):
    """Main application window for the AI TTS Agent."""

    rewrite_ready = QtCore.pyqtSignal(str)

    def __init__(self) -> None:
        super().__init__()
        self.setWindowTitle("AI TTS Agent v2")
        self.resize(1920, 1080)

        self.base_dir = os.path.dirname(os.path.abspath(__file__))
        self.core = AgentCore(self.base_dir, persona="zira", set_name="default")

        self.current_set: Dict[str, str] = dict(self.core.schema_mgr.active_schemas)
        self.active_persona: str = self.core.persona or "zira"

        self.isolated_history: List[Tuple[str, str]] = []
        self.self_talk_enabled: bool = False
        self._plugin_docks: Dict[str, QtWidgets.QDockWidget] = {}
        self._schema_save_timers: Dict[str, QtCore.QTimer] = {}

        self._idle_timer = QtCore.QTimer(self)
        self._idle_timer.setSingleShot(True)
        self._idle_timer.timeout.connect(self._handle_idle)

        self._restore_layout()
        self._build_ui()
        # build the slash command panel (custom dock)
        self._build_command_dock()
        self._connect_signals()
        
            # ── Command Palette setup ─────────────────────────────────────────
        self.cmd_palette = CommandPaletteDock(self)
        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.cmd_palette)
        # update palette whenever commands change
        self.core.commandsChanged.connect(self.cmd_palette.set_command_list)
        # insert chosen command into chat input
        self.cmd_palette.commandActivated.connect(self._insert_into_chat)


        try:
            self.core.audio_recorder.transcribed.connect(self._on_transcribed)
        except Exception:
            pass

        self._update_feedback_counts()
        self._bootstrap_conversation()
        self._reset_idle_timer()

        # populate initial slash command list
        try:
            self._populate_command_select()
        except Exception:
            pass

    # ────────────────────────── signals
    def _connect_signals(self) -> None:
        self.btn_send.clicked.connect(self.send_message)

        # Recording controls come from the commands panel
        self.btn_record.clicked.connect(self.start_recording)
        self.btn_stop_rec.clicked.connect(self.stop_recording)

        self.voice_combo.currentTextChanged.connect(self._on_voice_changed)
        # update settings when a new model is selected
        self.model_combo.currentTextChanged.connect(self._on_model_changed)

        self.btn_play.clicked.connect(self._on_play)
        self.btn_stop_tts.clicked.connect(self._on_stop_tts)
        self.btn_replay.clicked.connect(self._on_replay)

        self.btn_like.clicked.connect(self._on_like)
        self.btn_dislike.clicked.connect(self._on_dislike)
        self.btn_manage_feedback.clicked.connect(self._on_manage_feedback)

        self.btn_refresh.clicked.connect(self._on_refresh_chat)
        self.btn_manage_datasets.clicked.connect(self._on_manage_datasets)
        self.btn_inner_monologue.clicked.connect(self._on_inner_monologue)
        self.btn_clear_rag.clicked.connect(self._on_clear_rag_cache)
        self.btn_model_manager.clicked.connect(self._on_show_model_manager)

        self.chk_semantic.toggled.connect(self._on_semantic_toggled)
        self.chk_isolated.toggled.connect(self._on_isolated_toggled)
        self.chk_self_talk.toggled.connect(lambda v: setattr(self, "self_talk_enabled", v))
        self.chk_auto_schema.toggled.connect(self._on_auto_schema_toggled)

        # connect Google STT checkbox
        try:
            self.chk_google_stt.toggled.connect(self._on_google_stt_toggled)
        except Exception:
            pass

        self.rewrite_ready.connect(self._apply_rewrite_result)

        # context menu for chat view to send selection to command input
        try:
            self.chat_view.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
            self.chat_view.customContextMenuRequested.connect(self._show_chat_context_menu)
        except Exception:
            pass
        # custom context menu for spell suggestions on input field
        try:
            self.input_edit.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
            self.input_edit.customContextMenuRequested.connect(self._show_input_context_menu)
        except Exception:
            pass
            
    def _on_show_command_palette(self) -> None:
        """Toggle the command-palette dock."""
        if self.cmd_palette.isVisible():
            self.cmd_palette.hide()
        else:
            self.cmd_palette.show()
            self.cmd_palette.raise_()
            self.cmd_palette.search_edit.setFocus(QtCore.Qt.ShortcutFocusReason)

    def _insert_into_chat(self, cmd: str) -> None:
        """Insert a slash-command into the chat input."""
        self.input_edit.insertPlainText(cmd + " ")
        self.input_edit.setFocus()                       

    # ────────────────────────── layout & lifecycle
    def _restore_layout(self) -> None:
        qsettings = QSettings("xAI", "AI_TTS_Agent")
        try:
            self.restoreGeometry(qsettings.value("geometry", b""))
            self.restoreState(qsettings.value("windowState", b""))
        except Exception:
            pass

    def closeEvent(self, event: QtGui.QCloseEvent) -> None:
        qsettings = QSettings("xAI", "AI_TTS_Agent")
        qsettings.setValue("geometry", self.saveGeometry())
        qsettings.setValue("windowState", self.saveState())
        try:
            self.core.close()
        except Exception:
            pass
        super().closeEvent(event)

    # ────────────────────────── UI build
    def _build_ui(self) -> None:
        self.setStyleSheet(
            """
            QWidget { background-color: #2e3a51; color: #e0e0e0; }
            QGroupBox { border: 1px solid #007acc; margin-top: 7px; }
            QGroupBox::title { subcontrol-origin: margin; left: 12px; padding: 0 4px; }
            QPushButton { background-color: #3c4a6b; color: white; border: 1px solid #007acc; padding: 5px; }
            QPushButton:disabled { background-color: #5a5a7a; color: #c0c0c0; border: 1px solid #555555; }
            QPlainTextEdit, QTextEdit { background-color: #1e2738; color: #e0e0e0; border: 1px solid #007acc; }
            QLineEdit { background-color: #1e2738; color: #e0e0e0; border: 1px solid #007acc; }
            QTabBar::tab { background: #3c4a6b; color: white; border: 1px solid #007acc; padding: 5px 10px; }
            QTabBar::tab:selected { background: #007acc; color: white; }
            QComboBox { background-color: #1e2738; color: #e0e0e0; border: 1px solid #007acc; padding: 3px; }
            QListWidget { background-color: #1e2738; color: #e0e0e0; border: 1px solid #007acc; }
            QCheckBox, QLabel { color: #e0e0e0; }
            """
        )
        self.setDockOptions(
            QtWidgets.QMainWindow.AllowTabbedDocks
            | QtWidgets.QMainWindow.AllowNestedDocks
            | QtWidgets.QMainWindow.AnimatedDocks
        )
        self.setTabPosition(QtCore.Qt.AllDockWidgetAreas, QtWidgets.QTabWidget.North)
        self.setDockNestingEnabled(True)

        tb = QtWidgets.QToolBar("Layout", self)
        tb.setMovable(False)
        self.addToolBar(QtCore.Qt.TopToolBarArea, tb)
        self.chk_lock = QtWidgets.QCheckBox("Lock Layout")
        act = QtWidgets.QWidgetAction(self)
        act.setDefaultWidget(self.chk_lock)
        tb.addAction(act)
        self.chk_lock.toggled.connect(self._on_toggle_lock)

        self.setCentralWidget(QtWidgets.QWidget())
        status = QtWidgets.QStatusBar()
        self.setStatusBar(status)
        self.dock_tray = DockTray(self)
        status.addPermanentWidget(self.dock_tray, 1)

        self.progress_bar = QtWidgets.QProgressBar()
        self.progress_bar.setRange(0, 0)
        self.progress_bar.setVisible(False)
        status.addPermanentWidget(self.progress_bar)

        # Tabs for personas / operators are handled by PersonaTab
        # Chat panel
        self.chat_view = QtWidgets.QTextEdit()
        self.chat_view.setReadOnly(True)
        self.chat_view.setStyleSheet("background-color: #e0eef5; color: #011627;")
        self.chat_view.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        self.input_edit = QtWidgets.QPlainTextEdit()
        self.input_edit.setPlaceholderText("Type your message or use /remember key value, /showfacts, /style, /weights")
        self.input_edit.setMinimumHeight(64)
        self.input_edit.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        # Attach spell checker highlighter if available
        try:
            if SpellChecker:
                self._spell_highlighter = _SpellHighlighter(self.input_edit.document())  # type: ignore[attr-defined]
        except Exception:
            self._spell_highlighter = None
        self.btn_send = QtWidgets.QPushButton("Send")

        chat_container = QtWidgets.QWidget()
        cv = QtWidgets.QVBoxLayout(chat_container)
        cv.setContentsMargins(7, 7, 7, 7)
        cv.setSpacing(7)
        cv.addWidget(self.chat_view, 1)
        cv.addWidget(self.input_edit)
        row = QtWidgets.QHBoxLayout()
        row.addStretch()
        row.addWidget(self.btn_send)
        cv.addLayout(row)

        # ───── Instantiate modular panels
        # Commands panel (controls)
        self.commands_panel = CommandsPanel(self)
        # Copy child attributes to the AppWindow so existing logic continues to work
        for name in [
            'btn_record','btn_stop_rec','device_combo','chk_semantic','chk_isolated','chk_mute_tts',
            'chk_self_talk','chk_auto_schema','chk_google_stt','btn_clear_rag','btn_refresh',
            'btn_manage_datasets','btn_inner_monologue','btn_model_manager','style_label',
            'response_edit','btn_like','btn_dislike','btn_manage_feedback','btn_play','btn_stop_tts',
            'btn_replay','voice_combo','model_combo','lbl_feedback_counts'
        ]:
            setattr(self, name, getattr(self.commands_panel, name))

        # Persona panel
        self.persona_panel = PersonaTab(self)
        # Copy persona panel attributes
        self.tabs = self.persona_panel.tabs
        self.tab_widgets = self.persona_panel.tab_widgets
        self.operator_tab = self.persona_panel.operator_tab
        self.lbl_active_names = self.persona_panel.lbl_active_names

        # Docks
        # Controls dock
        controls_scroll = QtWidgets.QScrollArea()
        controls_scroll.setWidgetResizable(True)
        controls_scroll.setFrameShape(QtWidgets.QFrame.NoFrame)
        controls_scroll.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)
        controls_scroll.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        controls_scroll.setWidget(self.commands_panel)

        self.controls_dock = QtWidgets.QDockWidget("Controls", self)
        self.controls_dock.setObjectName("ControlsDock")
        self.controls_dock.setWidget(controls_scroll)
        self.controls_dock.setFeatures(
            QtWidgets.QDockWidget.DockWidgetClosable
            | QtWidgets.QDockWidget.DockWidgetMovable
            | QtWidgets.QDockWidget.DockWidgetFloatable
        )

        # Persona dock
        self.persona_dock = QtWidgets.QDockWidget("Personas", self)
        self.persona_dock.setObjectName("PersonaDock")
        self.persona_dock.setWidget(self.persona_panel)
        self.persona_dock.setFeatures(
            QtWidgets.QDockWidget.DockWidgetClosable
            | QtWidgets.QDockWidget.DockWidgetMovable
            | QtWidgets.QDockWidget.DockWidgetFloatable
        )

        # Chat dock
        self.chat_dock = QtWidgets.QDockWidget("Chat", self)
        self.chat_dock.setObjectName("ChatDock")
        self.chat_dock.setWidget(chat_container)
        self.chat_dock.setFeatures(
            QtWidgets.QDockWidget.DockWidgetClosable
            | QtWidgets.QDockWidget.DockWidgetMovable
            | QtWidgets.QDockWidget.DockWidgetFloatable
        )

        # Model dock
        self.model_dock = QtWidgets.QDockWidget("Models", self)
        self.model_dock.setObjectName("ModelDock")
        self.model_dock.setFeatures(
            QtWidgets.QDockWidget.DockWidgetClosable
            | QtWidgets.QDockWidget.DockWidgetMovable
            | QtWidgets.QDockWidget.DockWidgetFloatable
        )
        self._build_model_manager()

        # Plugins dock
        self.plugins_dock = QtWidgets.QDockWidget("Plugins", self)
        self.plugins_dock.setObjectName("PluginsDock")
        self.plugins_dock.setFeatures(
            QtWidgets.QDockWidget.DockWidgetClosable
            | QtWidgets.QDockWidget.DockWidgetMovable
            | QtWidgets.QDockWidget.DockWidgetFloatable
        )
        self.plugins_dock.setWidget(self._build_plugins_widget())

        # Titles & dock tray
        self.controls_dock.setTitleBarWidget(DockTitleBar(self.controls_dock, "Controls"))
        self.persona_dock.setTitleBarWidget(DockTitleBar(self.persona_dock, "Personas"))
        self.chat_dock.setTitleBarWidget(DockTitleBar(self.chat_dock, "Chat"))
        self.model_dock.setTitleBarWidget(DockTitleBar(self.model_dock, "Models"))
        self.plugins_dock.setTitleBarWidget(DockTitleBar(self.plugins_dock, "Plugins"))

        # Register docks with the tray
        for d in (self.controls_dock, self.persona_dock, self.chat_dock, self.model_dock, self.plugins_dock):
            self.dock_tray.register_dock(d)

        # Add docks to the layout
        self.addDockWidget(QtCore.Qt.LeftDockWidgetArea, self.controls_dock)
        self.addDockWidget(QtCore.Qt.LeftDockWidgetArea, self.persona_dock)
        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.chat_dock)
        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.model_dock)
        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.plugins_dock)

        # Splitters as before
        self.splitDockWidget(self.controls_dock, self.persona_dock, QtCore.Qt.Vertical)
        self.splitDockWidget(self.controls_dock, self.chat_dock, QtCore.Qt.Horizontal)
        self.splitDockWidget(self.chat_dock, self.model_dock, QtCore.Qt.Horizontal)
        self.splitDockWidget(self.model_dock, self.plugins_dock, QtCore.Qt.Horizontal)

    # The remainder of the methods are largely unchanged from the original
    # implementation.  They continue to reference widgets via ``self`` which
    # now refer to the proxies created from the modular panels.

    # ────────────────────────── persona widgets (removed UI build; logic preserved)
    def _on_tab_changed(self, index: int) -> None:
        """
        Handle tab changes in the main tab widget.

        Parameters
        ----------
        index : int
            Index of the newly selected tab.
        """
        try:
            tab_name = self.tabs.tabText(index)
            print(f"[UI] Tab changed to: {tab_name} (index {index})")
            # Add any extra logic if needed, for example:
            # self._update_feedback_counts()
        except Exception as e:
            print(f"[UI] Error handling tab change: {e}")

    # ────────────────────────── operator tab (moved to persona_tab module)
    # ────────────────────────── plugins
    def _build_plugins_widget(self) -> QtWidgets.QWidget:
        container = QtWidgets.QWidget()
        layout = QtWidgets.QVBoxLayout(container)
        layout.setContentsMargins(6, 6, 6, 6)
        layout.setSpacing(4)

        self.plugin_list = QtWidgets.QListWidget()
        self.plugin_list.setSelectionMode(QtWidgets.QAbstractItemView.NoSelection)
        layout.addWidget(self.plugin_list, 1)

        btn_rescan = QtWidgets.QPushButton("Rescan")
        layout.addWidget(btn_rescan)
        btn_rescan.clicked.connect(self._rescan_plugins)

        self._populate_plugin_list()
        self.plugin_list.itemChanged.connect(self._on_plugin_item_changed)

        try:
            self.core.plugins.eventReceived.connect(self._on_plugin_event)
        except Exception:
            pass

        return container

    def _populate_plugin_list(self) -> None:
        self.plugin_list.blockSignals(True)
        self.plugin_list.clear()
        for meta in self.core.plugins.list_plugins():
            item = QtWidgets.QListWidgetItem(meta.name)
            flags = item.flags() | QtCore.Qt.ItemIsUserCheckable
            if meta.missing_dependencies:
                flags &= ~QtCore.Qt.ItemIsEnabled
                item.setToolTip(f"Missing dependencies: {', '.join(meta.missing_dependencies)}")
            item.setFlags(flags)
            item.setCheckState(QtCore.Qt.Checked if meta.enabled else QtCore.Qt.Unchecked)
            self.plugin_list.addItem(item)
        self.plugin_list.blockSignals(False)

    def _on_plugin_item_changed(self, item: QtWidgets.QListWidgetItem) -> None:
        name = item.text()
        enabled = item.checkState() == QtCore.Qt.Checked
        self.core.plugins.enable_plugin(name, enabled)
        meta = next((m for m in self.core.plugins.list_plugins() if m.name == name), None)
        if not meta:
            return
        if enabled and meta.widget is not None:
            self._attach_plugin_widget(meta)
        elif not enabled:
            self._detach_plugin_widget(name)

    def _rescan_plugins(self) -> None:
        self.core.plugins.rescan()
        for name in list(self._plugin_docks.keys()):
            meta = next((m for m in self.core.plugins.list_plugins() if m.name == name), None)
            if not meta or not meta.enabled:
                self._detach_plugin_widget(name)
        self._populate_plugin_list()

    def _attach_plugin_widget(self, meta: 'object') -> None:
        if meta.name in self._plugin_docks:
            return
        if meta.widget is None:
            return
        dock = QtWidgets.QDockWidget(meta.name, self)
        dock.setObjectName(f"PluginDock_{meta.name}")
        dock.setWidget(meta.widget)
        dock.setFeatures(
            QtWidgets.QDockWidget.DockWidgetClosable
            | QtWidgets.QDockWidget.DockWidgetMovable
            | QtWidgets.QDockWidget.DockWidgetFloatable
        )
        dock.setTitleBarWidget(DockTitleBar(dock, meta.name))
        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, dock)
        self.dock_tray.register_dock(dock)
        self._plugin_docks[meta.name] = dock

    def _detach_plugin_widget(self, name: str) -> None:
        dock = self._plugin_docks.pop(name, None)
        if dock:
            self.dock_tray._remove_button(dock)
            dock.setParent(None)
            dock.deleteLater()

    @QtCore.pyqtSlot(str, dict)
    def _on_plugin_event(self, sender: str, envelope: dict) -> None:
        try:
            data = envelope.get("data")
            msg = json.dumps(data, indent=2) if isinstance(data, (dict, list)) else str(data)
            display_name = sender
            self._append_message(display_name, msg, role_key="operator")
            if self.chk_semantic.isChecked() and not self.chk_isolated.isChecked():
                self.core.conversation_db.save_message(sender.lower(), msg)
        except Exception as e:
            print(f"Error handling plugin event from {sender}: {e}")

    # ────────────────────────── model manager
    def _build_model_manager(self) -> None:
        widget = QtWidgets.QWidget()
        v = QtWidgets.QVBoxLayout(widget)
        v.setContentsMargins(8, 8, 8, 8)
        v.setSpacing(6)
        self.model_list = QtWidgets.QListWidget()
        v.addWidget(self.model_list, 1)
        h = QtWidgets.QHBoxLayout()
        self.btn_model_pull = QtWidgets.QPushButton("Pull")
        self.btn_model_delete = QtWidgets.QPushButton("Delete")
        self.btn_model_set_default = QtWidgets.QPushButton("Set as Default")
        h.addWidget(self.btn_model_pull)
        h.addWidget(self.btn_model_delete)
        h.addWidget(self.btn_model_set_default)
        h.addStretch()
        v.addLayout(h)
        self.model_dock.setWidget(widget)
        self._refresh_model_list()
        self.btn_model_pull.clicked.connect(self._on_model_pull)
        self.btn_model_delete.clicked.connect(self._on_model_delete)
        self.btn_model_set_default.clicked.connect(self._on_model_set_default)

    def _refresh_model_list(self) -> None:
        self.model_list.clear()
        models: List[str] = []
        try:
            out = subprocess.run(
                ["ollama", "list"],
                stdout=subprocess.PIPE,
                stderr=subprocess.DEVNULL,
                text=True,
                check=True,
            ).stdout.splitlines()
            for line in out[1:]:
                parts = line.strip().split()
                if parts:
                    models.append(parts[0])
        except Exception:
            models = []
        for m in models:
            item = QtWidgets.QListWidgetItem(m)
            if m == self.model_combo.currentText().strip():
                item.setFont(QtGui.QFont("", weight=QtGui.QFont.Bold))
            self.model_list.addItem(item)

    def _on_model_pull(self) -> None:
        item = self.model_list.currentItem()
        if not item:
            return
        model = item.text()
        threading.Thread(target=lambda: subprocess.run(["ollama", "pull", model], check=False), daemon=True).start()
        QtWidgets.QMessageBox.information(self, "Pull Started", f"Pulling {model} in background.")

    def _on_model_delete(self) -> None:
        item = self.model_list.currentItem()
        if not item:
            return
        model = item.text()
        if QtWidgets.QMessageBox.question(
            self,
            "Delete Model",
            f"Delete '{model}'? This cannot be undone.",
            QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No,
        ) != QtWidgets.QMessageBox.Yes:
            return
        threading.Thread(target=lambda: subprocess.run(["ollama", "delete", model], check=False), daemon=True).start()
        QtWidgets.QMessageBox.information(self, "Delete Started", f"Deleting {model} in background.")
        self._refresh_model_list()

    def _on_model_set_default(self) -> None:
        item = self.model_list.currentItem()
        if not item:
            return
        model = item.text()
        idx = self.model_combo.findText(model)
        if idx >= 0:
            self.model_combo.setCurrentIndex(idx)
        # persist selection to settings
        try:
            self.core.settings.default_model = model
            self.core.settings.save()
        except Exception:
            pass
            QtWidgets.QMessageBox.information(self, "Default Model", f"Set default model to {model}.")
        else:
            self.model_combo.addItem(model)
            self.model_combo.setCurrentText(model)

    # ────────────────────────── lock layout
    def _on_toggle_lock(self, locked: bool) -> None:
        feats_unlocked = (
            QtWidgets.QDockWidget.DockWidgetClosable
            | QtWidgets.QDockWidget.DockWidgetMovable
            | QtWidgets.QDockWidget.DockWidgetFloatable
        )
        feats_locked = QtWidgets.QDockWidget.DockWidgetClosable
        for dock in (
            self.controls_dock,
            self.persona_dock,
            self.chat_dock,
            getattr(self, "inner_dock", None),
            self.model_dock,
            self.plugins_dock,
        ):
            if dock is None:
                continue
            dock.setFeatures(feats_locked if locked else feats_unlocked)
        for dock in self._plugin_docks.values():
            dock.setFeatures(feats_locked if locked else feats_unlocked)

    # ────────────────────────── audio
    def start_recording(self) -> None:
        if sd is None or np is None:
            QtWidgets.QMessageBox.information(self, "Recording Unavailable", "sounddevice/numpy not installed.")
            return
        if not self.btn_record.isEnabled():
            return
        device_index = None
        try:
            idx = self.device_combo.currentIndex()
            selected_name = self.device_combo.currentText()
            for i, d in enumerate(sd.query_devices()):
                if d.get("name") == selected_name and d.get("max_input_channels", 0) > 0:
                    device_index = i
                    break
        except Exception:
            device_index = None
        self.core.audio_recorder.start(device_index)
        self.btn_record.setEnabled(False)
        self.btn_stop_rec.setEnabled(True)

    def stop_recording(self) -> None:
        if not self.btn_stop_rec.isEnabled():
            return
        self.core.audio_recorder.stop_and_transcribe()
        self.btn_stop_rec.setEnabled(False)
        self.btn_record.setEnabled(True)

    @QtCore.pyqtSlot(str)
    def _on_transcribed(self, text: str) -> None:
        if not text:
            return
        cur = self.input_edit.toPlainText()
        self.input_edit.setPlainText((cur + "\n" if cur else "") + text)

    # ────────────────────────── TTS
    def _on_play(self) -> None:
        text = self.response_edit.toPlainText().strip()
        if text and not self.chk_mute_tts.isChecked():
            try:
                self.core.tts_mgr.enqueue(text)
            except Exception:
                pass

    def _on_stop_tts(self) -> None:
        try:
            self.core.tts_mgr.stop()
        except Exception:
            pass

    def _on_replay(self) -> None:
        if not self.chk_mute_tts.isChecked():
            try:
                self.core.tts_mgr.replay()
            except Exception:
                pass

    def _on_voice_changed(self, name: str) -> None:
        try:
            eng = getattr(self.core.tts_mgr, "_engine", None)
            if eng:
                for v in eng.getProperty("voices"):
                    if v.name == name:
                        eng.setProperty("voice", v.id)
                        break
        except Exception:
            pass

    def _tts_voice_names(self) -> List[str]:
        try:
            eng = getattr(self.core.tts_mgr, "_engine", None)
            if not eng:
                return []
            return [v.name for v in eng.getProperty("voices")]
        except Exception:
            return []

    # ────────────────────────── feedback
    def _on_like(self) -> None:
        text = self.response_edit.toPlainText().strip()
        if not text:
            return
        try:
            self.core.add_feedback(text, liked=True)
        except Exception:
            pass
        QtWidgets.QMessageBox.information(self, "Feedback", "Marked as good response.")
        self._enable_feedback(False)
        self._update_feedback_counts()

    def _on_dislike(self) -> None:
        original = self.response_edit.toPlainText().strip()
        if not original:
            return
        try:
            self.core.tts_mgr.stop()
        except Exception:
            pass
        QtWidgets.QMessageBox.information(self, "Disliked", "The response will be rewritten.")
        self._enable_feedback(False)

        def worker() -> None:
            new_text = self._rewrite_response(original)
            try:
                self.core.add_feedback(original, liked=False, revised=new_text)
            except Exception:
                pass
            if self.chk_isolated.isChecked():
                self.isolated_history.append((self._current_persona(), new_text))
            else:
                if self.chk_semantic.isChecked():
                    self.core.conversation_db.save_message(self._current_persona().lower(), new_text)
            self.rewrite_ready.emit(new_text)

        threading.Thread(target=worker, daemon=True).start()

    @QtCore.pyqtSlot(str)
    def _apply_rewrite_result(self, new_text: str) -> None:
        schema = self.core.schema_mgr.load_schema(
            self._current_persona(), self.current_set.get(self._current_persona(), "default")
        )
        persona_name = schema.get("name", "Bot")
        role_key = self._current_persona().lower()
        self._append_message(persona_name, new_text, role_key=role_key)
        self.response_edit.setPlainText(new_text)
        if not self.chk_mute_tts.isChecked():
            try:
                self.core.tts_mgr.enqueue(new_text)
            except Exception:
                pass
        QtWidgets.QMessageBox.information(self, "Rewritten", "Response rewritten.")
        self._enable_feedback(False)

    def _update_feedback_counts(self) -> None:
        try:
            pos, neg = self.core.feedback_db.get_counts()
            self.lbl_feedback_counts.setText(f"Likes: {pos} | Dislikes: {neg}")
        except Exception:
            self.lbl_feedback_counts.setText("Likes: - | Dislikes: -")

    def _enable_feedback(self, enabled: bool) -> None:
        self.btn_like.setEnabled(enabled)
        self.btn_dislike.setEnabled(enabled)

    def _on_manage_feedback(self) -> None:
        db = self.core.feedback_db
        if db is None:
            QtWidgets.QMessageBox.information(self, "No DB", "Feedback DB unavailable.")
            return
        cur = db.conn.cursor()
        cur.execute("SELECT id, original, liked, COALESCE(revised, '') FROM feedback ORDER BY id DESC")
        entries = cur.fetchall()
        dlg = QtWidgets.QDialog(self)
        dlg.setWindowTitle("Manage Feedback")
        dlg.resize(720, 420)
        v = QtWidgets.QVBoxLayout(dlg)
        table = QtWidgets.QTableWidget(len(entries), 4)
        table.setHorizontalHeaderLabels(["ID", "Original", "Liked", "Revised"])
        table.horizontalHeader().setStretchLastSection(True)
        for r, (fid, orig, liked, rev) in enumerate(entries):
            table.setItem(r, 0, QtWidgets.QTableWidgetItem(str(fid)))
            table.setItem(r, 1, QtWidgets.QTableWidgetItem(orig))
            table.setItem(r, 2, QtWidgets.QTableWidgetItem("✔" if liked else "✖"))
            table.setItem(r, 3, QtWidgets.QTableWidgetItem(rev))
        v.addWidget(table, 1)
        h = QtWidgets.QHBoxLayout()
        btn_del = QtWidgets.QPushButton("Delete Selected")
        btn_close = QtWidgets.QPushButton("Close")
        h.addWidget(btn_del)
        h.addWidget(btn_close)
        h.addStretch()
        v.addLayout(h)

        def on_delete() -> None:
            selected = table.selectedItems()
            if not selected:
                return
            rows = sorted({i.row() for i in selected}, reverse=True)
            for rr in rows:
                fid_item = table.item(rr, 0)
                if fid_item:
                    try:
                        fid = int(fid_item.text())
                        db.conn.execute("DELETE FROM feedback WHERE id = ?", (fid,))
                        db.conn.commit()
                    except Exception:
                        pass
                table.removeRow(rr)
            self._update_feedback_counts()

        btn_del.clicked.connect(on_delete)
        btn_close.clicked.connect(dlg.accept)
        dlg.exec_()

    # ────────────────────────── datasets / rag
    def _on_manage_datasets(self) -> None:
        DatasetManagerDialog(self.core.dataset_mgr, self).exec_()

    def _on_clear_rag_cache(self) -> None:
        if QtWidgets.QMessageBox.question(
            self,
            "Clear RAG Cache",
            "Delete cached embeddings for all datasets and clear memory?",
            QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No,
        ) != QtWidgets.QMessageBox.Yes:
            return
        count = self.core.rag_cache.clear_disk()
        self.core.rag_cache.clear_memory()
        QtWidgets.QMessageBox.information(self, "Cleared", f"Cleared RAG cache files ({count} removed) and in-memory index.")

    # ────────────────────────── isolated / refresh / idle
    def _on_isolated_toggled(self, checked: bool) -> None:
        if checked:
            self.isolated_history.clear()
        else:
            if self.isolated_history:
                ans = QtWidgets.QMessageBox.question(
                    self,
                    "Merge Isolated Chat",
                    "Merge isolated conversation into main memory?",
                    QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No,
                )
                if ans == QtWidgets.QMessageBox.Yes:
                    for role, content in self.isolated_history:
                        self.core.conversation_db.save_message(role.lower(), content)
                self.isolated_history.clear()
        self._reset_idle_timer()

    def _on_refresh_chat(self) -> None:
        if self.chk_isolated.isChecked():
            self.isolated_history.clear()
        self.chat_view.clear()
        self.response_edit.clear()
        self._enable_feedback(False)
        try:
            if hasattr(self, "inner_text") and self.inner_text is not None:
                self.inner_text.clear()
        except Exception:
            pass

    def _reset_idle_timer(self) -> None:
        self._idle_timer.stop()
        if self.chk_semantic.isChecked():
            self._idle_timer.start(60000)

    def _handle_idle(self) -> None:
        pass

    # ────────────────────────── inner monologue
    def _on_inner_monologue(self) -> None:
        self._ensure_inner_dock()
        if self.inner_dock is None:
            return
        self.inner_dock.setVisible(not self.inner_dock.isVisible())

    def _ensure_inner_dock(self) -> None:
        if hasattr(self, "inner_dock") and self.inner_dock is not None:
            return
        dock = QtWidgets.QDockWidget("Inner Monologue", self)
        dock.setObjectName("InnerDock")
        dock.setAllowedAreas(QtCore.Qt.RightDockWidgetArea | QtCore.Qt.LeftDockWidgetArea)
        inner = QtWidgets.QWidget()
        v = QtWidgets.QVBoxLayout(inner)
        self.inner_text = QtWidgets.QPlainTextEdit()
        self.inner_text.setReadOnly(True)
        v.addWidget(self.inner_text, 1)
        h = QtWidgets.QHBoxLayout()
        h.addWidget(QtWidgets.QLabel("Interval (s):"))
        self.spin_interval = QtWidgets.QSpinBox()
        self.spin_interval.setRange(1, 60)
        self.spin_interval.setValue(15)
        h.addWidget(self.spin_interval)
        self.chk_monologue_tts = QtWidgets.QCheckBox("Speak")
        self.chk_monologue_tts.setChecked(self.core.settings.monologue_tts_enabled)
        h.addWidget(self.chk_monologue_tts)
        h.addWidget(QtWidgets.QLabel("Volume:"))
        self.slider_monologue_vol = QtWidgets.QSlider(QtCore.Qt.Horizontal)
        self.slider_monologue_vol.setRange(0, 100)
        self.slider_monologue_vol.setValue(self.core.settings.monologue_volume)
        h.addWidget(self.slider_monologue_vol)
        btn_start_stop = QtWidgets.QPushButton("Start/Stop")
        h.addWidget(btn_start_stop)
        v.addLayout(h)
        inner.setLayout(v)
        dock.setWidget(inner)
        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, dock)
        self.inner_dock = dock
        self.inner_timer = QtCore.QTimer(self)
        self.inner_timer.setSingleShot(False)
        btn_start_stop.clicked.connect(self._toggle_inner_timer)
        dock.setTitleBarWidget(DockTitleBar(dock, "Inner Monologue"))
        self.dock_tray.register_dock(self.inner_dock)
        self.chk_monologue_tts.stateChanged.connect(lambda _: self._update_monologue_settings())
        self.slider_monologue_vol.valueChanged.connect(lambda _: self._update_monologue_settings())

    def _toggle_inner_timer(self) -> None:
        if self.inner_timer is None:
            return
        if self.inner_timer.isActive():
            self.inner_timer.stop()
        else:
            interval_ms = self.spin_interval.value() * 1000
            try:
                self.inner_timer.timeout.disconnect()
            except Exception:
                pass
            self.inner_timer.timeout.connect(self._generate_inner_monologue)
            self.inner_timer.start(interval_ms)

    def _update_monologue_settings(self) -> None:
        try:
            self.core.settings.monologue_tts_enabled = self.chk_monologue_tts.isChecked() if hasattr(self, 'chk_monologue_tts') else False
            self.core.settings.monologue_volume = self.slider_monologue_vol.value() if hasattr(self, 'slider_monologue_vol') else 50
            self.core.settings.save()
        except Exception:
            pass

    def _generate_inner_monologue(self) -> None:
        schema = self.core.schema_mgr.load_schema(self._current_persona(), self.current_set.get(self._current_persona(), "default"))
        overlay = schema.get("dynamic_overlay", {}) or {}
        mood = overlay.get("temporary_emotional_state", "neutral")
        likes = overlay.get("recent_topics", [])
        pos = [0, 0]
        fav_topic = likes[-1] if likes else None
        thought = f"I'm thinking about {fav_topic} while feeling {mood}." if fav_topic else f"I'm in a {mood} mood and reflecting."
        thought += f" I'm at position {pos}."
        try:
            if hasattr(self, "inner_text") and self.inner_text is not None:
                self.inner_text.appendPlainText(thought)
        except Exception:
            pass

    # ────────────────────────── conversation
    def _append_message(self, display_name: str, text: str, role_key: Optional[str] = None) -> None:
        key = (role_key or display_name).lower()
        bg_colour = ROLE_COLOURS.get(key, "#EEEEEE")
        name_colour = NAME_COLOURS.get(key, "#011627")
        safe_role = QtGui.QGuiApplication.translate("Chat", display_name)
        safe_text = QtGui.QGuiApplication.translate("Chat", text)
        frag = (
            f'<div style="background-color:{bg_colour}; border-radius:4px; padding:4px; margin:4px;">'
            f'<b style="color:{name_colour};">{safe_role}:</b> {safe_text}'
            f'</div>'
        )
        self.chat_view.append(frag)

    def _current_history(self) -> List[Tuple[str, str]]:
        if self.chk_isolated.isChecked():
            return self.isolated_history
        else:
            return self.core.conversation_db.fetch_history(limit=10)

    def _bootstrap_conversation(self) -> None:
        if self.core and len(self.core.conversation_db.fetch_history(limit=1)) == 0:
            schema = self.core.schema_mgr.load_schema(self.active_persona, self.current_set.get(self.active_persona, "default"))
            questions = schema.get("questions", [])
            if questions:
                first_question = questions[0]
                self._append_message("System", first_question, role_key="system")
                if self.chk_semantic.isChecked() and not self.chk_isolated.isChecked():
                    self.core.conversation_db.save_message("system", first_question)

    # ────────────────────────── prompt & rag
    def _build_prompt(self, schema: Dict[str, object], user_text: str, is_self_talk: bool = False) -> str:
        parts: List[str] = []
        name = schema.get("name", "")
        role = schema.get("role", "")
        desc = schema.get("description", "")
        persona_desc = f"You are {name}, {desc}".strip()
        if role:
            persona_desc += f" Your role is {role}."

        overlay = schema.get("dynamic_overlay", {})
        if overlay:
            temp_rel = overlay.get("temporary_relationship_context", "")
            temp_emotion = overlay.get("temporary_emotional_state", "")
            added_traits = overlay.get("added_traits", [])
            if temp_rel:
                persona_desc += f" ({temp_rel})"
            if temp_emotion:
                persona_desc += f" You feel {temp_emotion}."
            if added_traits:
                persona_desc += f" Traits: {', '.join(str(t) for t in added_traits)}."
        parts.append(persona_desc)

        # User description
        try:
            user_schema = self.core.schema_mgr.load_schema("user", self.current_set.get("user", "default"))
        except Exception:
            user_schema = {}
        if user_schema:
            u_name = user_schema.get("name", "User")
            u_personality = user_schema.get("personality", "")
            relationship = user_schema.get("relationship_to_zira", "friend")
            u_overlay = user_schema.get("dynamic_overlay", {})
            temp_rel2 = u_overlay.get("temporary_relationship_context") if u_overlay else None
            if temp_rel2 and str(temp_rel2).strip():
                relationship = str(temp_rel2)
            user_desc = f"User is {u_name}, {u_personality}. Relationship: {relationship}."
            parts.append(user_desc)

        # History
        history_text = ""
        if self.chk_semantic.isChecked():
            history = self._current_history()[-10:]
            for role_name, content in history:
                speaker = "User" if role_name.lower() == "user" else role_name.title()
                history_text += f"{speaker}: {content}\n"
        if history_text:
            parts.append("Conversation history:\n" + history_text.strip())

        # RAG (only datasets listed by this set)
        dataset_text = ""
        ds_names: List[str] = list(schema.get("datasets") or [])
        try:
            # Prefer core search with filters if supported
            hits = self.core.rag_search(
                user_text,
                per_ds_k=3,
                limit=5,
                include_shared=False,
                datasets=ds_names if ds_names else None,
            )
            for chunk, score, ds_name, owner in hits:
                dataset_text += f"Dataset ({owner}/{ds_name}):\n{chunk}\n\n"
        except TypeError:
            # Older core: no dataset filter; fallback to manual selection
            from_texts: List[Tuple[str, str]] = []
            try:
                for name, entry in self.core.dataset_mgr.entries.items():
                    if ds_names and name not in ds_names:
                        continue
                    if not entry.active:
                        continue
                    full_text = self.core.dataset_mgr.load_dataset_text(entry)
                    if full_text:
                        from_texts.append((name, full_text))
            except Exception:
                pass
            for name, full_text in from_texts:
                snip = self._retrieve_dataset_snippet(full_text, user_text)
                if snip:
                    dataset_text += f"Dataset ({name}):\n{snip}\n\n"
        except Exception:
            pass
        if dataset_text:
            parts.append(dataset_text.strip())

        # Self-talk (optional)
        if is_self_talk and self.self_talk_enabled:
            st_prompts = schema.get("self_talk", [])
            if st_prompts:
                import random
                parts.append(random.choice(st_prompts))

        parts.append(f"User: {user_text}")
        return "\n\n".join([p for p in parts if p])

    def _retrieve_dataset_snippet(self, full_text: str, user_text: str) -> str:
        try:
            tokens = [w.lower() for w in re.findall(r"\b\w+\b", user_text) if len(w) > 2]
            paragraphs = [p.strip() for p in full_text.split("\n") if p.strip()]
            scored: List[Tuple[int, str]] = []
            for para in paragraphs:
                l = para.lower()
                score = sum(1 for t in tokens if t in l)
                if score > 0:
                    scored.append((score, para))
            if not scored:
                return paragraphs[0][:500] if paragraphs else full_text[:500]
            scored.sort(key=lambda x: -x[0])
            top = [p for _, p in scored[:2]]
            return "\n".join(top)[:500]
        except Exception:
            return full_text[:500]

    # ────────────────────────── send / model
    def send_message(self) -> None:
        user_text = self.input_edit.toPlainText().strip()
        if not user_text:
            return

        # Broadcast to plugins
        try:
            self.core.plugins.broadcast(user_text)
        except Exception:
            pass

        # Slash commands → ensure applied to current persona+set
        if user_text.startswith("/"):
            self.input_edit.clear()
            persona = self._current_persona()
            set_name = self.current_set.get(persona, "default")
            try:
                out = self.core.run_command(user_text, persona=persona, set_name=set_name)
            except TypeError:
                out = self.core.run_command(user_text)
            self._append_message("System", out, role_key="system")
            if self.chk_semantic.isChecked() and not self.chk_isolated.isChecked():
                self.core.conversation_db.save_message("system", out)
            return

        # Normal message
        self.input_edit.clear()
        persona = self._current_persona()
        set_name = self.current_set.get(persona, "default")
        schema = self.core.schema_mgr.load_schema(persona, set_name)

        if self.chk_isolated.isChecked():
            self.isolated_history.append(("user", user_text))
        else:
            if self.chk_semantic.isChecked():
                self.core.conversation_db.save_message("user", user_text)

        try:
            user_schema = self.core.schema_mgr.load_schema("user", self.current_set.get("user", "default"))
            user_display = user_schema.get("name", "User")
        except Exception:
            user_display = "User"
        self._append_message(user_display, user_text, role_key="user")

        prompt = self._build_prompt(schema, user_text)
        model_slug = self.model_combo.currentText().strip() or self.core.settings.default_model

        self.btn_send.setEnabled(False)

        # ✅ Create ModelWorker and wire it up properly
        self.model_worker = ModelWorker(model_slug, prompt, parent=self.core)
        self.model_worker.resultReady.connect(lambda resp, usr=user_text, sch=schema: self._on_model_response(resp, usr, sch))
        self.model_worker.errorOccurred.connect(self._on_model_error)
        self.model_worker.finished.connect(lambda: self.btn_send.setEnabled(True))
        self.model_worker.start()


    def _on_model_response(self, response_raw: str, user_text: str, schema: Dict[str, object]) -> None:
        model_slug = self.model_combo.currentText().strip()
        response = self._strip_reasoning(model_slug, response_raw)
        response, style_score = self._style_and_guard(response, schema)
        self.style_label.setText(f"Style: {style_score:.2f}")

        if self.chk_isolated.isChecked():
            self.isolated_history.append((schema.get("name", "bot"), response))
        else:
            if self.chk_semantic.isChecked():
                self.core.conversation_db.save_message(schema.get("name", "bot").lower(), response)

        persona_name = schema.get("name", "Bot") or "Bot"
        role_key = self._current_persona().lower()
        self._append_message(persona_name, response, role_key=role_key)
        self.response_edit.setPlainText(response)

        if not self.chk_mute_tts.isChecked():
            try:
                self.core.tts_mgr.enqueue(response)
            except Exception:
                pass

        self._enable_feedback(True)
        self._reset_idle_timer()

        try:
            tokens = [w.lower() for w in re.findall(r"\b\w+\b", user_text) if len(w) > 3]
            for t in tokens:
                self.update_overlay_topic(self._current_persona(), t)
            self.update_overlay_emotion(self._current_persona(), "neutral")
        except Exception:
            pass

        try:
            for line in response.split("\n"):
                if line.strip():
                    self.core.plugins.broadcast(line.strip())
        except Exception as e:
            print(f"Error broadcasting to plugins: {e}")

        if self.core.settings.auto_schema_enabled:
            self.progress_bar.setVisible(True)

            class EvolverWorker(QRunnable):
                def __init__(self, evolver, persona, set_name, history, window):
                    super().__init__()
                    self.evolver = evolver
                    self.persona = persona
                    self.set_name = set_name
                    self.history = history
                    self.window = window

                def run(self):
                    changed = self.evolver.update_schema(self.persona, self.set_name, self.history)
                    QtCore.QMetaObject.invokeMethod(
                        self.window, "_post_evolver", QtCore.Qt.QueuedConnection, QtCore.Q_ARG(bool, changed)
                    )

            QThreadPool.globalInstance().start(
                EvolverWorker(self.core.schema_evolver, self.active_persona, self.current_set.get(self.active_persona, "default"), self._current_history(), self)
            )

    @QtCore.pyqtSlot(bool)
    def _post_evolver(self, changed: bool) -> None:
        self.progress_bar.setVisible(False)
        if changed:
            self._flash_status("Schema adapted")

    def _strip_reasoning(self, model: str, response: str) -> str:
        if model and "deepseek" in model.lower():
            if "<think>" in response and "</think>" in response:
                try:
                    return response.split("</think>")[-1].strip() or response
                except Exception:
                    return response
        return response

    def _style_and_guard(self, text: str, schema: Dict[str, object]) -> Tuple[str, float]:
        exclam = text.count("!")
        sentences = [s for s in re.split(r"[.!?]", text) if s.strip()]
        avg_len = sum(len(s.split()) for s in sentences) / max(1, len(sentences))
        exclam_density = exclam / max(1, len(text))
        tone = schema.get("tone_rules", {"conciseness": [0.6, 0.8], "exclam_limit": 0.05})
        conciseness = max(0.0, min(1.0, (22 - avg_len) / 16.0))
        ex_ok = 1.0 if exclam_density <= float(tone.get("exclam_limit", 0.05)) else 0.5
        score = max(0.0, min(1.0, 0.5 * conciseness + 0.5 * ex_ok))
        return text, score

    def _rewrite_response(self, original: str) -> str:
        try:
            liked = self.core.feedback_db.get_liked_responses(limit=5)
        except Exception:
            liked = []
        schema = self.core.schema_mgr.load_schema(self._current_persona(), self.current_set.get(self._current_persona(), "default"))
        rps = schema.get("rewrite_prompts", [])
        template = rps[0] if rps else "Rewrite to be more appealing. Keep it accurate, concise, and on style."
        parts = [template]
        if liked:
            parts.append("Preferred responses:\n" + "\n\n".join(liked))
        parts.append("Original:\n" + original)
        parts.append("Rewritten:")
        prompt = "\n\n".join(parts)
        return self._run_model(self.model_combo.currentText().strip() or self.core.settings.default_model, prompt) or original

    def _run_model(self, model: str, prompt: str) -> str:
        try:
            proc = subprocess.run(
                ["ollama", "run", model],
                input=prompt.encode("utf-8"),
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                check=True,
            )
            return proc.stdout.decode("utf-8", errors="replace").strip()
        except subprocess.CalledProcessError as e:
            return e.stderr.decode("utf-8", errors="replace").strip()
        except FileNotFoundError:
            return "(error) ollama executable not found."
        except Exception as e:
            return f"(error) {e}"

    # ────────────────────────── persona / sets
    def _populate_set_combo(self, persona: str, combo: QtWidgets.QComboBox) -> None:
        combo.blockSignals(True)
        combo.clear()
        for s in self.core.schema_mgr.get_set_list(persona):
            combo.addItem(s)
        current = self.current_set.get(persona, "default")
        idx = combo.findText(current)
        combo.setCurrentIndex(idx if idx >= 0 else combo.findText("default"))
        if idx < 0:
            self.current_set[persona] = combo.currentText()
        combo.blockSignals(False)

    def _on_set_changed(self, persona: str, name: str, combo: QtWidgets.QComboBox) -> None:
        if not name:
            return
        self.current_set[persona] = name
        # keep AgentCore pointed to the right set if this persona is active
        if persona == self._current_persona():
            self.core.persona = persona
            self.core.set_name = name

        # refresh editor + commands row for this tab
        tab = self.tab_widgets.get(persona)
        if tab:
            editor = tab.findChild(QtWidgets.QPlainTextEdit, f"schema_edit_{persona}")
            if editor:
                schema = self.core.schema_mgr.load_schema(persona, name)
                editor.setPlainText(json.dumps(schema, indent=2))
            cmd_combo = tab.findChild(QtWidgets.QComboBox, f"cmd_combo_{persona}")
            if cmd_combo:
                self._populate_command_combo(persona, cmd_combo)

        # persist active sets & update controls tied to schema flags
        self.core.schema_mgr.save_active_schemas(self.current_set)
        self._sync_semantic_checkbox_from_schema()
        self._update_feedback_counts()

        # refresh slash command list if this persona is active
        try:
            if persona == self._current_persona():
                self._populate_command_select()
        except Exception:
            pass

    def _on_clone_set(self, persona: str, combo: QtWidgets.QComboBox) -> None:
        src = combo.currentText()
        name, ok = QtWidgets.QInputDialog.getText(self, "Clone Set", "Enter new set name:")
        if not ok or not name.strip():
            return
        new_name = name.strip()
        try:
            schema = self.core.schema_mgr.load_schema(persona, src)
            # Preserve the persona's canonical name; set label is separate
            schema["name"] = persona.capitalize()
            self.core.schema_mgr.save_schema(persona, new_name, schema)
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "Error", str(e))
            return
        self.current_set[persona] = new_name
        self._populate_set_combo(persona, combo)
        combo.setCurrentText(new_name)
        if persona == self._current_persona():
            self.core.set_name = new_name
        self.core.schema_mgr.save_active_schemas(self.current_set)
        self._sync_semantic_checkbox_from_schema()
        self._update_feedback_counts()

    def _on_new_set(self, persona: str, combo: QtWidgets.QComboBox) -> None:
        src = combo.currentText()
        name, ok = QtWidgets.QInputDialog.getText(self, "New Set", "Enter name for new set:")
        if not ok or not name.strip():
            return
        new_name = name.strip()
        try:
            schema = self.core.schema_mgr.load_schema(persona, src)
            # Preserve the persona's canonical name; set label is separate
            schema["name"] = persona.capitalize()
            self.core.schema_mgr.save_schema(persona, new_name, schema)
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "Error", str(e))
            return
        self.current_set[persona] = new_name
        self._populate_set_combo(persona, combo)
        combo.setCurrentText(new_name)
        if persona == self._current_persona():
            self.core.set_name = new_name
        self.core.schema_mgr.save_active_schemas(self.current_set)
        self._sync_semantic_checkbox_from_schema()
        self._update_feedback_counts()

    def _on_delete_set(self, persona: str, combo: QtWidgets.QComboBox) -> None:
        name = combo.currentText()
        if name == "default":
            QtWidgets.QMessageBox.information(self, "Cannot Delete", "The default set cannot be deleted.")
            return
        if QtWidgets.QMessageBox.question(
            self, "Delete Set", f"Delete '{name}' (irreversible)?", QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No
        ) != QtWidgets.QMessageBox.Yes:
            return
        try:
            set_dir = os.path.join(self.core.schema_mgr.schemas_dir, persona.lower(), "sets", name)
            import shutil
            shutil.rmtree(set_dir, ignore_errors=True)
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "Error", str(e))
            return
        self.current_set[persona] = "default"
        self._populate_set_combo(persona, combo)
        combo.setCurrentText("default")
        if persona == self._current_persona():
            self.core.set_name = "default"
        self.core.schema_mgr.save_active_schemas(self.current_set)
        self._sync_semantic_checkbox_from_schema()
        self._update_feedback_counts()

    def _on_save_schema(self, persona: str) -> None:
        tab = self.tab_widgets.get(persona)
        if not tab:
            return
        editor = tab.findChild(QtWidgets.QPlainTextEdit, f"schema_edit_{persona}")
        if not editor:
            return
        text = editor.toPlainText().strip()
        try:
            schema = json.loads(text)
            if not isinstance(schema, dict):
                raise ValueError
        except Exception:
            QtWidgets.QMessageBox.warning(self, "Invalid JSON", "The schema is not valid JSON.")
            return
        set_name = self.current_set.get(persona, "default")
        existing_schema = self.core.schema_mgr.load_schema(persona, set_name)
        merged_schema = {**existing_schema, **schema}
        # Ensure the top-level name matches the active set name
        try:
            merged_schema["name"] = set_name
        except Exception:
            pass
        self.core.schema_mgr.save_schema(persona, set_name, merged_schema)
        QtWidgets.QMessageBox.information(self, "Saved", f"Schema saved for {persona} ({set_name}).")

        if persona == self._current_persona():
            persona_voice = (merged_schema.get("voice") or "").lower()
            for i in range(self.voice_combo.count()):
                if persona_voice and persona_voice in self.voice_combo.itemText(i).lower():
                    self.voice_combo.setCurrentIndex(i)
                    break
        # After save, refresh commands combo (in case user edited commands JSON directly)
        tab = self.tab_widgets.get(persona)
        if tab:
            cmd_combo = tab.findChild(QtWidgets.QComboBox, f"cmd_combo_{persona}")
            if cmd_combo:
                self._populate_command_combo(persona, cmd_combo)

    # ------------------------------------------------------------------
    # Command editing helpers (ported from the original agent_ui.py)
    #
    # The persona editing tab includes a commands row allowing users to
    # append new payloads to existing slash commands or create entirely
    # new commands.  These helpers implement the behaviour that used to
    # live in agent_ui.py.  They are invoked by PersonaTab via
    # ``self.app._on_add_to_command`` and ``self.app._on_new_command``.
    def _on_add_to_command(self, persona: str, combo: QtWidgets.QComboBox,
                            edit: QtWidgets.QLineEdit) -> None:
        """
        Append the text from ``edit`` to the selected command in the
        current schema.  If no command is selected or no text is
        provided, the user is notified.  After updating the schema,
        the command editor and schema editor are refreshed.

        Parameters
        ----------
        persona : str
            The persona whose schema is being modified.
        combo : QtWidgets.QComboBox
            The combo box listing existing slash commands.
        edit : QtWidgets.QLineEdit
            The line edit containing the payload to add to the command.
        """
        text = edit.text().strip()
        if not text:
            QtWidgets.QMessageBox.information(self, "No Text", "Enter text/payload to add.")
            return
        set_name = self.current_set.get(persona, "default")
        schema = self.core.schema_mgr.load_schema(persona, set_name)
        cmds = dict(schema.get("commands") or {})
        sel = combo.currentText().strip()
        if not sel or sel == "(no commands)":
            QtWidgets.QMessageBox.information(self, "No Command", "Create a command first.")
            return
        lst = list(cmds.get(sel) or [])
        lst.append(text)
        cmds[sel] = lst
        schema["commands"] = cmds
        self.core.schema_mgr.save_schema(persona, set_name, schema)
        edit.clear()
        # Refresh editors & notify the user
        self._refresh_schema_editor(persona)
        QtWidgets.QMessageBox.information(self, "Added", f'Added to {sel}: "{text}"')

    def _on_new_command(self, persona: str) -> None:
        """
        Prompt the user for a new command name, insert it into the
        schema if it does not already exist, and refresh the UI.  The
        new command is prefaced with a leading slash if not provided.

        Parameters
        ----------
        persona : str
            The persona whose schema is being modified.
        """
        name, ok = QtWidgets.QInputDialog.getText(self, "New Command", "Enter new command (e.g., /remember):")
        if not ok or not name.strip():
            return
        cmd_name = name.strip()
        if not cmd_name.startswith("/"):
            cmd_name = "/" + cmd_name
        set_name = self.current_set.get(persona, "default")
        schema = self.core.schema_mgr.load_schema(persona, set_name)
        cmds = dict(schema.get("commands") or {})
        if cmd_name in cmds:
            QtWidgets.QMessageBox.information(self, "Exists", f"Command {cmd_name} already exists.")
            return
        cmds[cmd_name] = []
        schema["commands"] = cmds
        self.core.schema_mgr.save_schema(persona, set_name, schema)
        # Refresh command combo + schema editor
        tab = self.tab_widgets.get(persona)
        if tab:
            combo = tab.findChild(QtWidgets.QComboBox, f"cmd_combo_{persona}")
            if combo:
                self._populate_command_combo(persona, combo)
                combo.setCurrentText(cmd_name)
            edit = tab.findChild(QtWidgets.QLineEdit, f"cmd_edit_{persona}")
            if edit:
                edit.clear()
        self._refresh_schema_editor(persona)
        QtWidgets.QMessageBox.information(self, "Created", f"New command {cmd_name} created.")

    def _refresh_schema_editor(self, persona: str) -> None:
        """
        Reload the JSON schema for ``persona`` from disk and update the
        corresponding schema editor in the UI.  This helper is used
        after schema modifications to ensure the text reflects the
        authoritative state on disk.  Signals are blocked during the
        update to avoid triggering autosave timers unnecessarily.

        Parameters
        ----------
        persona : str
            The persona whose schema editor should be refreshed.
        """
        tab = self.tab_widgets.get(persona)
        if not tab:
            return
        editor = tab.findChild(QtWidgets.QPlainTextEdit, f"schema_edit_{persona}")
        if editor:
            schema = self.core.schema_mgr.load_schema(persona, self.current_set.get(persona, "default"))
            editor.blockSignals(True)
            editor.setPlainText(json.dumps(schema, indent=2))
            editor.blockSignals(False)

    def _tab_changed(self, index: int) -> None:
        if 0 <= index < len(self.core.schema_mgr.personas):
            self.active_persona = self.core.schema_mgr.personas[index]
        else:
            self.active_persona = self.core.schema_mgr.personas[0] if self.core.schema_mgr.personas else "zira"
        self.core.persona = self.active_persona

        schema = self.core.schema_mgr.load_schema(self.active_persona, self.current_set.get(self.active_persona, "default"))
        persona_voice = (schema.get("voice") or "").lower()
        for i in range(self.voice_combo.count()):
            if persona_voice and persona_voice in self.voice_combo.itemText(i).lower():
                self.voice_combo.setCurrentIndex(i)
                break

        tab = self.tab_widgets.get(self.active_persona)
        if tab:
            editor = tab.findChild(QtWidgets.QPlainTextEdit, f"schema_edit_{self.active_persona}")
            if editor:
                editor.setPlainText(json.dumps(schema, indent=2))
            cmd_combo = tab.findChild(QtWidgets.QComboBox, f"cmd_combo_{self.active_persona}")
            if cmd_combo:
                self._populate_command_combo(self.active_persona, cmd_combo)

        try:
            user_schema = self.core.schema_mgr.load_schema("user", self.current_set.get("user", "default"))
            bot_name = schema.get("name", self.active_persona.title())
            bot_set = self.current_set.get(self.active_persona, "default")
            user_name = user_schema.get("name", "User")
            user_set = self.current_set.get("user", "default")
            self.lbl_active_names.setText(f"{bot_name}: {bot_set} — User: {user_name}: {user_set}")
        except Exception:
            pass

        self._sync_semantic_checkbox_from_schema()
        self._update_feedback_counts()

        # refresh slash command dropdown on persona change
        try:
            self._populate_command_select()
        except Exception:
            pass

    def _current_persona(self) -> str:
        return self.active_persona

    # ────────────────────────── overlay helpers
    def update_overlay_topic(self, persona: str, topic: str) -> None:
        persona = persona.lower()
        try:
            schema = self.core.schema_mgr.load_schema(persona, self.current_set.get(persona, "default"))
            overlay = dict(schema.get("dynamic_overlay", {}))
            topics = list(overlay.get("recent_topics", []))
            if topic and topic not in topics:
                topics.append(topic)
                if len(topics) > 10:
                    topics = topics[-10:]
                overlay["recent_topics"] = topics
                schema["dynamic_overlay"] = overlay
                self.core.schema_mgr.save_schema(persona, self.current_set.get(persona, "default"), schema)
        except Exception:
            pass

    def update_overlay_emotion(self, persona: str, emotion: str) -> None:
        persona = persona.lower()
        try:
            schema = self.core.schema_mgr.load_schema(persona, self.current_set.get(persona, "default"))
            overlay = dict(schema.get("dynamic_overlay", {}))
            overlay["temporary_emotional_state"] = emotion
            schema["dynamic_overlay"] = overlay
            self.core.schema_mgr.save_schema(persona, self.current_set.get(persona, "default"), schema)
        except Exception:
            pass

    # ────────────────────────── devices & models
    def _populate_devices(self) -> None:
        # In this refactor the devices are populated by CommandsPanel
        self.commands_panel._populate_devices()

    def _populate_models(self) -> None:
        # In this refactor the models are populated by CommandsPanel
        self.commands_panel._populate_models()

    # ────────────────────────── slash commands panel
    def _build_command_dock(self) -> None:
        """
        Build a dockable panel that exposes slash commands with an argument
        entry and send button. This allows users to trigger any command
        without typing it into the chat manually. It will be updated when
        persona or set changes.
        """
        dock = QtWidgets.QDockWidget("Slash Commands", self)
        dock.setObjectName("SlashCommandsDock")
        dock.setFeatures(
            QtWidgets.QDockWidget.DockWidgetClosable
            | QtWidgets.QDockWidget.DockWidgetMovable
            | QtWidgets.QDockWidget.DockWidgetFloatable
        )
        container = QtWidgets.QWidget()
        layout = QtWidgets.QVBoxLayout(container)
        layout.setContentsMargins(7, 7, 7, 7)
        layout.setSpacing(5)

        # command selector
        cmd_label = QtWidgets.QLabel("Slash Command:")
        self.command_select = QtWidgets.QComboBox()
        layout.addWidget(cmd_label)
        layout.addWidget(self.command_select)

        # argument input
        self.command_input = QtWidgets.QLineEdit()
        self.command_input.setPlaceholderText("Enter arguments or select text from chat…")
        layout.addWidget(self.command_input)

        # send button
        btn_run = QtWidgets.QPushButton("Run Command")
        btn_run.clicked.connect(self._on_run_command)
        layout.addWidget(btn_run)
        layout.addStretch(1)

        dock.setWidget(container)
        # add to right side by default
        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, dock)
        self.command_dock = dock

    def _populate_command_select(self) -> None:
        """
        Populate the slash command dropdown with available commands from
        the command registry. This is called whenever the active persona
        or set changes to reflect dynamic additions.
        """
        try:
            cmds = []
            if hasattr(self.core, "command_registry") and self.core.command_registry:
                cmds = list(self.core.command_registry.list_commands())
            # if schema defines additional commands, include them
            persona = self._current_persona()
            set_name = self.current_set.get(persona, "default")
            schema = self.core.schema_mgr.load_schema(persona, set_name)
            schema_cmds = list((schema.get("commands") or {}).keys())
            for c in schema_cmds:
                if c not in cmds:
                    cmds.append(c)
            cmds.sort()
        except Exception:
            cmds = []
        self.command_select.blockSignals(True)
        self.command_select.clear()
        if cmds:
            self.command_select.addItems(cmds)
        self.command_select.blockSignals(False)

    def _on_run_command(self) -> None:
        """
        Handler for running the selected slash command with the provided
        argument. The command will be executed via AgentCore and the
        result appended to the chat window. Selection text from the chat
        can be inserted into the argument field via context menu.
        """
        cmd = (self.command_select.currentText() or "").strip()
        if not cmd:
            QtWidgets.QMessageBox.information(self, "No Command", "Select a slash command to run.")
            return
        arg = self.command_input.text().strip()
        # combine command and arguments
        full = cmd if not arg else f"{cmd} {arg}"
        try:
            # process via core; record conversation
            resp = self.core.process_user_message(full, tts=False)
            # append user command and agent response to chat
            self._append_message("user", full, role_key="user")
            self._append_message("zira", resp, role_key="zira")
            # clear argument
            self.command_input.clear()
            # update feedback counts and idle timer
            self._update_feedback_counts()
            self._reset_idle_timer()
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "Command Error", str(e))

    def _show_chat_context_menu(self, pos: QtCore.QPoint) -> None:
        """
        Custom context menu for the chat view. Adds a menu entry to send
        selected text into the slash command argument field.
        """
        menu = self.chat_view.createStandardContextMenu()
        try:
            cursor = self.chat_view.textCursor()
            if cursor and cursor.hasSelection():
                action = menu.addAction("Send selection to command input")
                action.triggered.connect(self._send_selection_to_command_input)
        except Exception:
            pass
        menu.exec_(self.chat_view.mapToGlobal(pos))

    def _send_selection_to_command_input(self) -> None:
        """
        Copy the currently selected text in the chat view into the command
        input field for slash command execution.
        """
        try:
            cursor = self.chat_view.textCursor()
            if cursor and cursor.hasSelection():
                text = cursor.selectedText()
                self.command_input.setText(text.strip())
        except Exception:
            pass

    def _on_model_changed(self, name: str) -> None:
        """
        Update the default model in settings when the user selects a new
        model from the dropdown. This ensures the AgentCore uses the
        selected model for subsequent interactions.
        """
        try:
            if not name:
                return
            self.core.settings.default_model = name
            self.core.settings.save()
        except Exception:
            pass

    def _on_show_model_manager(self) -> None:
        """
        Show (or raise) the model manager dock. If the dock was
        previously hidden, it will be shown; if it is already visible,
        this will bring it to the front. A dock must be built in
        ``_build_model_manager()`` prior to showing.
        """
        try:
            if self.model_dock.isVisible():
                # already visible: raise to top
                self.model_dock.raise_()
            else:
                self.model_dock.show()
                self.model_dock.raise_()
        except Exception:
            pass
            
            
    def _on_model_error(self, error: str) -> None:
        """Handles errors from ModelWorker threads."""
        print(f"[ERROR] ModelWorker failed:\n{error}")

        # Show in chat window
        self._append_message("System", f"❌ Model error:\n{error}", role_key="system")

        # Optionally log or alert
        try:
            self.core.logger.error(f"ModelWorker Error: {error}")
        except Exception:
            pass

        # Re-enable send button in case it wasn't via .finished
        self.btn_send.setEnabled(True)
            

    # ────────────────────────── settings toggles
    def _on_auto_schema_toggled(self, checked: bool) -> None:
        try:
            self.core.settings.auto_schema_enabled = bool(checked)
            self.core.settings.save()
        except Exception:
            pass
        self.statusBar().showMessage(f"Auto Schema Evolution {'enabled' if checked else 'disabled'}", 2500)

    def _on_google_stt_toggled(self, checked: bool) -> None:
        """
        Opt-in/out of using Google Cloud Speech-to-Text. When enabling the
        toggle for the first time in a session, show a warning that
        recordings will be sent to Google’s servers under their privacy
        policy. If declined, the checkbox will be turned off again.
        """
        # Only show the dialog when transitioning from unchecked → checked
        try:
            current = bool(getattr(self.core.settings, "use_google_stt", False))
        except Exception:
            current = False
        if checked and not current:
            ok = QtWidgets.QMessageBox.question(
                self,
                "Enable Google STT?",
                "Audio will be uploaded to Google Cloud for transcription\n"
                "under Google's privacy policy. Continue?",
                QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No,
            )
            if ok != QtWidgets.QMessageBox.Yes:
                # revert checkbox silently
                self.chk_google_stt.blockSignals(True)
                self.chk_google_stt.setChecked(False)
                self.chk_google_stt.blockSignals(False)
                return
        # persist the new state
        try:
            self.core.settings.use_google_stt = bool(checked)
            self.core.settings.save()
        except Exception:
            pass

    # ────────────────────────── spell suggestions
    def _show_input_context_menu(self, pos: QtCore.QPoint) -> None:
        """
        Custom context menu on the input field that offers spelling
        suggestions when the user right-clicks a misspelled word. Only
        appears if pyspellchecker is available.
        """
        menu = self.input_edit.createStandardContextMenu()
        # compute suggestions only if SpellChecker is available
        if SpellChecker:
            cursor = self.input_edit.cursorForPosition(pos)
            # select the word under cursor
            cursor.select(QtGui.QTextCursor.WordUnderCursor)
            word = cursor.selectedText()
            if word and len(word) >= 3:
                sc = SpellChecker()
                suggestions = list(sc.candidates(word.lower()))
                # sort by Levenshtein distance and frequency; keep top 5
                suggestions = sorted(suggestions, key=lambda w: sc.word_probability(w), reverse=True)[:5]
                if suggestions and suggestions != [word.lower()]:
                    suggest_menu = menu.addMenu("Spelling suggestions")
                    for s in suggestions:
                        act = suggest_menu.addAction(s)
                        act.triggered.connect(lambda chk=False, repl=s, c=cursor: self._replace_word(c, repl))
        menu.exec_(self.input_edit.mapToGlobal(pos))

    def _replace_word(self, cursor: QtGui.QTextCursor, replacement: str) -> None:
        """
        Replace the word at the given cursor with a suggestion. This
        method is connected dynamically for each suggestion action.
        """
        try:
            cursor.beginEditBlock()
            cursor.removeSelectedText()
            cursor.insertText(replacement)
            cursor.endEditBlock()
        except Exception:
            pass

    def _on_semantic_toggled(self, checked: bool) -> None:
        """Persist semantic awareness per persona+set."""
        persona = self._current_persona()
        set_name = self.current_set.get(persona, "default")
        try:
            schema = self.core.schema_mgr.load_schema(persona, set_name)
            flags = dict(schema.get("flags") or {})
            flags["semantic_awareness"] = bool(checked)
            schema["flags"] = flags
            self.core.schema_mgr.save_schema(persona, set_name, schema)
        except Exception:
            pass
        self._reset_idle_timer()

    def _sync_semantic_checkbox_from_schema(self) -> None:
        """Load semantic_awareness from current schema into the checkbox."""
        persona = self._current_persona()
        set_name = self.current_set.get(persona, "default")
        try:
            schema = self.core.schema_mgr.load_schema(persona, set_name)
            flags = schema.get("flags", {})
            val = bool(flags.get("semantic_awareness", True))
        except Exception:
            val = True
        self.chk_semantic.blockSignals(True)
        self.chk_semantic.setChecked(val)
        self.chk_semantic.blockSignals(False)

    # ────────────────────────── status helper
    def _flash_status(self, msg: str) -> None:
        self.statusBar().showMessage(msg, 3000)


# ────────────────────────── Dock tray & titlebar
class DockTray(QtWidgets.QWidget):
    restoreRequested = QtCore.pyqtSignal(QtWidgets.QDockWidget)

    def __init__(self, parent: Optional[QtWidgets.QWidget] = None) -> None:
        super().__init__(parent)
        self._map: Dict[QtWidgets.QDockWidget, QtWidgets.QPushButton] = {}
        lay = QtWidgets.QHBoxLayout(self)
        lay.setContentsMargins(6, 4, 6, 4)
        lay.setSpacing(6)
        self._layout = lay
        self._title = QtWidgets.QLabel("Minimized panels:")
        self._title.setStyleSheet("color: #f0f0f0; font-weight: bold;")
        self._layout.addWidget(self._title, 0)
        self._layout.addStretch(1)
        self.setStyleSheet("background-color: #3c4a6b;")

    def register_dock(self, dock: QtWidgets.QDockWidget) -> None:
        dock.visibilityChanged.connect(lambda vis, d=dock: self._on_visibility_changed(d, vis))
        if not dock.isVisible():
            self._add_button(dock)

    def _on_visibility_changed(self, dock: QtWidgets.QDockWidget, visible: bool) -> None:
        if visible:
            self._remove_button(dock)
        else:
            self._add_button(dock)

    def _add_button(self, dock: QtWidgets.QDockWidget) -> None:
        if dock in self._map:
            return
        btn = QtWidgets.QPushButton(dock.windowTitle())
        btn.setToolTip(f"Restore {dock.windowTitle()}")
        btn.setStyleSheet(
            "background-color: #4a5b78; color: #ffffff; padding: 4px 6px; border: none; border-radius: 3px;"
        )
        btn.clicked.connect(lambda checked=False, d=dock: self._restore(d))
        self._layout.insertWidget(self._layout.count() - 1, btn)
        self._map[dock] = btn

    def _remove_button(self, dock: QtWidgets.QDockWidget) -> None:
        btn = self._map.pop(dock, None)
        if btn:
            self._layout.removeWidget(btn)
            btn.deleteLater()

    def _restore(self, dock: QtWidgets.QDockWidget) -> None:
        dock.show()
        dock.raise_()
        self.restoreRequested.emit(dock)


class DockTitleBar(QtWidgets.QWidget):
    def __init__(self, dock: QtWidgets.QDockWidget, title: str) -> None:
        super().__init__(dock)
        self._dock = dock
        h = QtWidgets.QHBoxLayout(self)
        h.setContentsMargins(6, 2, 6, 2)
        h.setSpacing(6)
        self.lbl = QtWidgets.QLabel(title)
        h.addWidget(self.lbl)
        h.addStretch()
        self.btn_min = QtWidgets.QToolButton()
        self.btn_min.setText("–")
        self.btn_min.setToolTip("Minimize to bottom tray")
        self.btn_min.clicked.connect(lambda checked=False: self._dock.hide())
        h.addWidget(self.btn_min)
        self.btn_max = QtWidgets.QToolButton()
        self.btn_max.setText("□")
        self.btn_max.setToolTip("Enlarge / Restore")
        self.btn_max.clicked.connect(self._on_toggle_maximize)
        h.addWidget(self.btn_max)
        self.btn_close = QtWidgets.QToolButton()
        self.btn_close.setText("×")
        self.btn_close.setToolTip("Close (send to bottom tray)")
        self.btn_close.clicked.connect(lambda checked=False: self._dock.hide())
        h.addWidget(self.btn_close)
        self.installEventFilter(self)

    def eventFilter(self, _obj: QtCore.QObject, evt: QtCore.QEvent) -> bool:
        if evt.type() == QtCore.QEvent.MouseButtonDblClick:
            self._dock.setFloating(not self._dock.isFloating())
            return True
        return False

    def _on_toggle_maximize(self) -> None:
        mw: Optional[QtWidgets.QMainWindow] = self._dock.parentWidget()  # type: ignore
        while mw and not isinstance(mw, QtWidgets.QMainWindow):
            mw = mw.parentWidget()  # type: ignore
        if not isinstance(mw, QtWidgets.QMainWindow):
            self._dock.setFloating(not self._dock.isFloating())
            return
        if not self._dock.isFloating():
            self._dock.setFloating(True)
            mw_geo = mw.geometry()
            w = int(mw_geo.width() * 0.9)
            h = int(mw_geo.height() * 0.85)
            self._dock.resize(w, h)
            center = mw_geo.center()
            self._dock.move(center.x() - w // 2, center.y() - h // 2)
        else:
            self._dock.setFloating(False)


# ────────────────────────── dataset manager dialog
class DatasetManagerDialog(QtWidgets.QDialog):
    def __init__(self, dataset_mgr, parent: Optional[QtWidgets.QWidget] = None) -> None:
        super().__init__(parent)
        self.setWindowTitle("Dataset Manager")
        self.resize(520, 420)
        self.dataset_mgr = dataset_mgr
        v = QtWidgets.QVBoxLayout(self)
        self.list_widget = QtWidgets.QListWidget()
        v.addWidget(self.list_widget, 1)
        h = QtWidgets.QHBoxLayout()
        self.btn_add = QtWidgets.QPushButton("Add Dataset")
        self.btn_del = QtWidgets.QPushButton("Delete Dataset")
        h.addWidget(self.btn_add)
        h.addWidget(self.btn_del)
        h.addStretch()
        v.addLayout(h)
        self._populate()
        self.btn_add.clicked.connect(self._on_add)
        self.btn_del.clicked.connect(self._on_delete)
        self.list_widget.itemChanged.connect(self._on_item)

    def _populate(self) -> None:
        self.list_widget.clear()
        for name, entry in sorted(self.dataset_mgr.entries.items()):
            item = QtWidgets.QListWidgetItem(name)
            item.setFlags(item.flags() | QtCore.Qt.ItemIsUserCheckable)
            item.setCheckState(QtCore.Qt.Checked if entry.active else QtCore.Qt.Unchecked)
            self.list_widget.addItem(item)

    def _on_add(self) -> None:
        name, ok = QtWidgets.QInputDialog.getText(self, "New Dataset", "Enter dataset name:")
        if not ok or not name.strip():
            return
        path, _ = QtWidgets.QFileDialog.getOpenFileName(self, "Select .txt or .pdf", "", "Text/PDF (*.txt *.pdf)")
        if not path:
            return
        try:
            self.dataset_mgr.add_dataset(name.strip(), path)
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "Error", str(e))
            return
        self._populate()

    def _on_delete(self) -> None:
        item = self.list_widget.currentItem()
        if not item:
            return
        name = item.text()
        if QtWidgets.QMessageBox.question(
            self, "Delete Dataset", f"Delete '{name}'?", QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No
        ) != QtWidgets.QMessageBox.Yes:
            return
        try:
            self.dataset_mgr.delete_dataset(name)
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "Error", str(e))
            return
        self._populate()

    def _on_item(self, item: QtWidgets.QListWidgetItem) -> None:
        self.dataset_mgr.toggle_active(item.text(), item.checkState() == QtCore.Qt.Checked)


# ────────────────────────── run as script
if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    win = AppWindow()
    win.show()
    sys.exit(app.exec_())
```

main_ui.py
===========

This module contains the top-level ``AppWindow`` class for the AI TTS
Agent.  It orchestrates all layout and docking behaviour, integrates
the control panel and persona tabs provided by ``commands_panel`` and
``persona_tab``, and exposes a unified interface for the rest of the
application.  None of the core agent logic lives here – that remains in
the ``core_*`` modules.  This refactor pulls the bulky UI building
logic out of the monolithic script and into dedicated modules while
preserving all existing behaviour and wiring.
**Classes:** _SpellHighlighter, AppWindow, DockTray, DockTitleBar, DatasetManagerDialog


## Module `migration_tool.py`

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
migration_tool.py
=================

Stand-alone CLI for *one-shot* migration of legacy AI-TTS-Agent files
(JSON schemas, commands.json, reinforcement.jsonl …) into the new
SQLite-backed **agent_store.db**.

Typical usage
-------------
$ python migration_tool.py /path/to/AI_TTS_AGENT
    → runs migrate (if needed) and prints a coloured diff table.

$ python migration_tool.py . --dry-run
    → shows what *would* be imported without touching the DB.

Exit codes
----------
0  success – nothing failed
1  fatal error (bad path, SQLite locked, etc.)
2  migration aborted by --check-upgrade only
"""

from __future__ import annotations

import argparse
import os
import sys
from pathlib import Path
from typing import Dict

# Import AFTER adjusting sys.path so the script also works when executed
# from outside the project root.
PROJECT_ROOT = Path(__file__).resolve().parent
if PROJECT_ROOT not in map(Path, map(Path.resolve, map(Path, sys.path))):
    sys.path.insert(0, str(PROJECT_ROOT))

try:
    from agent_store import AgentStore, DB_VERSION
except ImportError as exc:  # pragma: no cover
    print(f"[migration_tool] Cannot import agent_store: {exc}", file=sys.stderr)
    sys.exit(1)


# ------------------------------ helpers ------------------------------ #
def _colour(txt: str, colour: str) -> str:
    colours = {
        "green": "\033[92m",
        "yellow": "\033[93m",
        "red": "\033[91m",
        "cyan": "\033[96m",
        "end": "\033[0m",
    }
    return f"{colours.get(colour, '')}{txt}{colours['end']}"


def _print_report(report: Dict[str, int]) -> None:
    print("\nMigration report")
    print("----------------")
    for k in ("schemas", "commands", "beans"):
        val = report.get(k, 0)
        colour = "green" if val else "yellow"
        print(f"  {k:<10}: {_colour(str(val), colour)}")


# ----------------------------- CLI entry ----------------------------- #
def main() -> None:
    ap = argparse.ArgumentParser(
        description="Run or inspect migration from legacy flat-file storage "
        "to agent_store.db (schema v%d)." % DB_VERSION
    )
    ap.add_argument(
        "base_dir",
        metavar="BASE_DIR",
        help="Root folder where AI-TTS-Agent project lives",
    )
    ap.add_argument(
        "--dry-run",
        action="store_true",
        help="Scan legacy artefacts and show how many items WOULD be migrated "
        "without actually writing to the DB.",
    )
    ap.add_argument(
        "--check-upgrade",
        action="store_true",
        help="Exit code 2 if the DB is below current version (use for CI).",
    )
    args = ap.parse_args()
    base_dir = os.path.abspath(args.base_dir)

    if not os.path.isdir(base_dir):
        print(_colour(f"[migration_tool] No such directory: {base_dir}", "red"), file=sys.stderr)
        sys.exit(1)

    store = AgentStore(base_dir)

    with store._pool.get() as c:  # type: ignore[attr-defined, arg-type]
        cur = c.execute("SELECT value FROM meta WHERE key='user_version'")
        current_ver = int(cur.fetchone()[0])

    if args.check_upgrade:
        if current_ver < DB_VERSION:
            print(_colour(f"DB version {current_ver} < required {DB_VERSION}", "yellow"))
            sys.exit(2)
        print(_colour("DB is up to date.", "green"))
        return

    if current_ver >= DB_VERSION and not args.dry_run:
        print(_colour("Nothing to migrate – database already at latest schema.", "green"))
        return

    if args.dry_run:
        print(_colour("[dry-run] Scanning legacy artefacts…", "cyan"))
        report = store.migrate_from_files()  # writes, but we’ll roll back
        _print_report(report)
        # rollback by deleting DB to keep promise of dry-run
        os.remove(store.db_path)
        print(_colour("\n[dry-run] Database left untouched.", "cyan"))
        return

    # Real migration
    print(_colour("Running migration…", "cyan"))
    report = store.migrate_from_files()
    _print_report(report)
    print(_colour("\nMigration completed.\n", "green"))


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\nInterrupted.")
        sys.exit(1)
```

migration_tool.py
=================

Stand-alone CLI for *one-shot* migration of legacy AI-TTS-Agent files
(JSON schemas, commands.json, reinforcement.jsonl …) into the new
SQLite-backed **agent_store.db**.

Typical usage
-------------
$ python migration_tool.py /path/to/AI_TTS_AGENT
    → runs migrate (if needed) and prints a coloured diff table.

$ python migration_tool.py . --dry-run
    → shows what *would* be imported without touching the DB.

Exit codes
----------
0  success – nothing failed
1  fatal error (bad path, SQLite locked, etc.)
2  migration aborted by --check-upgrade only
**Functions:** _colour(txt, colour), _print_report(report), main()


## Module `persona_tab.py`

```python
#!/usr/bin/env python3
"""
persona_tab.py
==============

**Schema-Editor 2.0**

This version upgrades the old free-text schema editor to a structured,
two-pane interface:

    • **Left:**   Category tree (actions, questions, etc.)  
    • **Right:**  Multiline editor for the selected node’s JSON value  
    • **Bottom:** “Expose as /command” checkbox (per category)  
    • **Top-right:** “Auto-Evolution” toggle for the whole set

Other improvements

* Autosave is now routed through **SchemaEngine.save()** (SQL-backed).
* Edits are debounced (500 ms) and validated before committing.
* When “Expose as /command” is ticked, a synthetic slash-command is written
  to *AgentStore.commands* for immediate use by the orchestrator.
"""

from __future__ import annotations

import json
import os
from typing import Dict, Any, Optional

from PyQt5 import QtCore, QtGui, QtWidgets


# --------------------------------------------------------------------------- helpers


def nice_json(value: Any) -> str:
    """Pretty JSON helper that survives non-serialisable objects."""
    try:
        return json.dumps(value, indent=2, ensure_ascii=False)
    except Exception:
        return str(value)


def parse_json(text: str) -> Any:
    """Parse or return raw string if JSON fails."""
    try:
        return json.loads(text)
    except Exception:
        return text.strip()


# --------------------------------------------------------------------------- main widget


class PersonaTab(QtWidgets.QWidget):
    """Persona & schema management panel (one instance shared across personas)."""

    # Emitted after a schema field is *persisted* (category, persona, set)
    schemaFieldUpdated = QtCore.pyqtSignal(str, str, str)

    # --------------------------------------------------------------------- init
    def __init__(
        self,
        app: "AppWindow",  # quotes to avoid circular import typing
        parent: Optional[QtWidgets.QWidget] = None,
    ) -> None:
        super().__init__(parent)
        self.app = app
        self.core = app.core
        self.schema_engine = self.core.schema_engine  # ← SQL façade
        self.current_set: Dict[str, str] = app.current_set

        # Label summarising active names/sets
        self.lbl_active = QtWidgets.QLabel()
        self.lbl_active.setObjectName("lblActiveSchemas")
        # Alias for main_ui compatibility (it expects persona_panel.lbl_active_names)
        self.lbl_active_names = self.lbl_active

        # Tabs per persona  ---------------------------------------------------
        self.tabs = QtWidgets.QTabWidget(movable=False, documentMode=True)
        self.tab_widgets: Dict[str, QtWidgets.QWidget] = {}
        for persona in self.schema_engine.personas():
            tab = QtWidgets.QWidget()
            self.tab_widgets[persona] = tab
            self.tabs.addTab(tab, persona.capitalize())

        # Operators tab (read-only)
        self.operator_tab = QtWidgets.QWidget()
        self.tabs.addTab(self.operator_tab, "Operators")

        self.tabs.currentChanged.connect(self._on_tab_changed)

        # Master layout
        v = QtWidgets.QVBoxLayout(self)
        v.setContentsMargins(7, 7, 7, 7)
        v.setSpacing(7)
        v.addWidget(self.lbl_active)
        v.addWidget(self.tabs, 1)

        # Build each persona sub-panel
        for p, w in self.tab_widgets.items():
            self._build_persona_subpanel(p, w)
        self._build_operators_tab(self.operator_tab)

        # Prime active-names label
        self._refresh_active_label()

    # ----------------------------------------------------------------- builders
    def _build_persona_subpanel(self, persona: str, root: QtWidgets.QWidget) -> None:
        """Creates the Schema-Editor 2.0 layout for a single persona."""
        # ───── set selector row ────────────────────────────────────────────
        top = QtWidgets.QHBoxLayout()
        top.addWidget(QtWidgets.QLabel("Set:"))

        set_combo = QtWidgets.QComboBox(objectName=f"setCombo_{persona}")
        self._populate_set_combo(persona, set_combo)
        set_combo.currentTextChanged.connect(
            lambda name, p=persona, c=set_combo: self._switch_set(p, name, c)
        )
        top.addWidget(set_combo)

        btn_clone = QtWidgets.QPushButton("Clone")
        btn_clone.clicked.connect(lambda _=False, p=persona, c=set_combo: self.app._on_clone_set(p, c))
        btn_new = QtWidgets.QPushButton("New")
        btn_new.clicked.connect(lambda _=False, p=persona, c=set_combo: self.app._on_new_set(p, c))
        btn_del = QtWidgets.QPushButton("Delete")
        btn_del.clicked.connect(lambda _=False, p=persona, c=set_combo: self.app._on_delete_set(p, c))
        for b in (btn_clone, btn_new, btn_del):
            top.addWidget(b)
        top.addStretch()

        # Auto-Evolution toggle (per-set)
        chk_auto = QtWidgets.QCheckBox("Auto Evolution")
        chk_auto.setObjectName(f"chkAutoEvo_{persona}")
        chk_auto.stateChanged.connect(lambda _=0, p=persona: self._toggle_auto_evo(p))
        top.addWidget(chk_auto)

        # ───── splitter: category tree | editor ────────────────────────────
        splitter = QtWidgets.QSplitter(QtCore.Qt.Horizontal)
        splitter.setChildrenCollapsible(False)

        # Category tree
        tree = QtWidgets.QTreeWidget(objectName=f"schemaTree_{persona}")
        tree.setHeaderHidden(True)
        tree.itemClicked.connect(lambda item, _col, p=persona: self._load_category(p, item))
        splitter.addWidget(tree)

        # Right-side editor + extras
        right = QtWidgets.QWidget()
        rv = QtWidgets.QVBoxLayout(right)
        rv.setContentsMargins(0, 0, 0, 0)
        rv.setSpacing(4)

        editor = QtWidgets.QPlainTextEdit(objectName=f"schemaEditor_{persona}")
        editor.setLineWrapMode(QtWidgets.QPlainTextEdit.NoWrap)
        rv.addWidget(editor, 1)

        row = QtWidgets.QHBoxLayout()
        self.chk_expose = QtWidgets.QCheckBox("Expose as /command")
        row.addWidget(self.chk_expose)
        row.addStretch()
        btn_format = QtWidgets.QPushButton("Reformat JSON")
        row.addWidget(btn_format)
        rv.addLayout(row)

        splitter.addWidget(right)
        splitter.setStretchFactor(1, 2)

        # ───── assemble persona tab ────────────────────────────────────────
        vbox = QtWidgets.QVBoxLayout(root)
        vbox.setContentsMargins(4, 4, 4, 4)
        vbox.setSpacing(6)
        vbox.addLayout(top)
        vbox.addWidget(splitter, 1)

        # ───── state & autosave timer  ─────────────────────────────────────
        timer = QtCore.QTimer(self)
        timer.setSingleShot(True)
        timer.setInterval(500)  # 500 ms debounce

        def start_debounce() -> None:
            timer.start()

        editor.textChanged.connect(start_debounce)

        def persist() -> None:
            cat = tree.currentItem().text(0) if tree.currentItem() else ""
            if not cat:
                return
            try:
                payload = parse_json(editor.toPlainText())
                persona_set = self.current_set.get(persona, "default")
                self.schema_engine.update_field(persona, persona_set, cat, payload)
                # expose as /command if requested
                expose = self.chk_expose.isChecked()
                self.schema_engine.set_command_exposure(persona, cat, expose)
                self.schemaFieldUpdated.emit(persona, persona_set, cat)
            except Exception as e:
                QtWidgets.QMessageBox.warning(self, "Schema Error", str(e))

        timer.timeout.connect(persist)

        # Re-format button
        btn_format.clicked.connect(lambda: editor.setPlainText(nice_json(parse_json(editor.toPlainText()))))

        # Populate first load
        self._reload_tree(persona, tree)

    # ----------------------------------------------------------------- GUI helpers
    def _populate_set_combo(self, persona: str, combo: QtWidgets.QComboBox) -> None:
        combo.blockSignals(True)
        combo.clear()
        for s in self.schema_engine.set_list(persona):
            combo.addItem(s)
        current = self.current_set.get(persona, "default")
        idx = combo.findText(current)
        combo.setCurrentIndex(max(idx, 0))
        combo.blockSignals(False)

    def _switch_set(self, persona: str, set_name: str, combo: QtWidgets.QComboBox) -> None:
        self.current_set[persona] = set_name
        self._reload_tree(persona, self.findChild(QtWidgets.QTreeWidget, f"schemaTree_{persona}"))
        self._refresh_active_label()

    def _toggle_auto_evo(self, persona: str) -> None:
        set_name = self.current_set.get(persona, "default")
        chk: QtWidgets.QCheckBox = self.sender()  # type: ignore
        self.schema_engine.set_auto_evolution(persona, set_name, bool(chk.isChecked()))

    def _reload_tree(self, persona: str, tree: QtWidgets.QTreeWidget) -> None:
        """Repopulate category tree for the current set."""
        tree.clear()
        set_name = self.current_set.get(persona, "default")
        data = self.schema_engine.load_schema(persona, set_name) or {}
        for key in sorted(data.keys()):
            QtWidgets.QTreeWidgetItem(tree, [key])
        if tree.topLevelItemCount():
            tree.setCurrentItem(tree.topLevelItem(0))

    def _load_category(self, persona: str, item: QtWidgets.QTreeWidgetItem) -> None:
        """Load selected category into editor."""
        cat = item.text(0)
        set_name = self.current_set.get(persona, "default")
        value = self.schema_engine.get_field(persona, set_name, cat)
        editor: QtWidgets.QPlainTextEdit = self.findChild(
            QtWidgets.QPlainTextEdit, f"schemaEditor_{persona}"
        )
        editor.blockSignals(True)
        editor.setPlainText(nice_json(value))
        editor.blockSignals(False)
        # set expose-command checkbox
        self.chk_expose.blockSignals(True)
        self.chk_expose.setChecked(self.schema_engine.is_exposed_as_command(persona, cat))
        self.chk_expose.blockSignals(False)

    def _refresh_active_label(self) -> None:
        try:
            bot_name = self.schema_engine.get_field(
                self.app.active_persona, self.current_set[self.app.active_persona], "name"
            )
        except Exception:
            bot_name = self.app.active_persona.capitalize()
        user_name = self.schema_engine.get_field("user", self.current_set.get("user", "default"), "name") or "User"
        bot_set = self.current_set.get(self.app.active_persona, "default")
        user_set = self.current_set.get("user", "default")
        self.lbl_active.setText(f"{bot_name}: {bot_set} — User: {user_name}: {user_set}")

    # ----------------------------------------------------------------- operators tab
    def _build_operators_tab(self, tab: QtWidgets.QWidget) -> None:
        """Simple list of installed operators with descriptions."""
        lay = QtWidgets.QVBoxLayout(tab)
        lay.setContentsMargins(4, 4, 4, 4)
        lay.setSpacing(6)

        ops = self.core.operator_mgr.list_operators()
        if not ops:
            lay.addWidget(QtWidgets.QLabel("No operators installed."))
        else:
            for name in sorted(ops):
                schema = self.core.operator_mgr.load_schema(name)
                box = QtWidgets.QGroupBox(name)
                v = QtWidgets.QVBoxLayout(box)
                v.addWidget(QtWidgets.QLabel(schema.get("description", "")))
                lay.addWidget(box)
        lay.addStretch()

    # ----------------------------------------------------------------- UI tab change
    def _on_tab_changed(self, idx: int) -> None:
        # keep memo of which persona is active so main_ui can react
        persona = self.tabs.tabText(idx).lower()
        if persona in self.tab_widgets:
            self.app.active_persona = persona
            self._refresh_active_label()
```

persona_tab.py
==============

**Schema-Editor 2.0**

This version upgrades the old free-text schema editor to a structured,
two-pane interface:

    • **Left:**   Category tree (actions, questions, etc.)  
    • **Right:**  Multiline editor for the selected node’s JSON value  
    • **Bottom:** “Expose as /command” checkbox (per category)  
    • **Top-right:** “Auto-Evolution” toggle for the whole set

Other improvements

* Autosave is now routed through **SchemaEngine.save()** (SQL-backed).
* Edits are debounced (500 ms) and validated before committing.
* When “Expose as /command” is ticked, a synthetic slash-command is written
  to *AgentStore.commands* for immediate use by the orchestrator.
**Classes:** PersonaTab
**Functions:** nice_json(value), parse_json(text)


## Module `run_agent.py`

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
run_agent.py — bootstrap launcher for AI TTS Agent (v3, 2025-08-04)

• Ensures the sqlite store exists (agent_store.ensure_db()) and runs
  legacy-data migration when user_version < 4.
• Accepts one optional command-line arg: <profile-dir>. Defaults to
  ./ai_agent_state relative to CWD.
• Starts the Qt GUI (main_ui.AppWindow).
• Catches early exceptions and prints a clean error trace instead of a
  raw stack-dump so newcomers understand what went wrong.
"""

from __future__ import annotations

import os
import sys
import traceback
from typing import Optional

from PyQt5 import QtWidgets

# --- local imports ----------------------------------------------------------
try:
    from agent_store import ensure_db, get_user_version, migrate_from_files
except ImportError:
    # fall back: no sql store yet, skip migration helpers
    def ensure_db(_): ...
    def get_user_version(_): return 0
    def migrate_from_files(_): return 0, 0  # migrated_rows, warnings


def _bootstrap_state(base_dir: str) -> None:
    """Create DB if missing and run legacy migration (if needed), then show UI."""
    os.makedirs(base_dir, exist_ok=True)
    ensure_db(base_dir)

    try:
        if get_user_version(base_dir) < 4:
            rows, warns = migrate_from_files(base_dir)
            print(f"[migration] imported {rows} rows ({warns} warnings)")
    except Exception as e:
        print(f"[migration] warning: migration failed: {e}")

    # Import the GUI class, catching import-time errors
    try:
        from main_ui import AppWindow
    except Exception:
        print("\n[run_agent] FATAL — failed to import main_ui:\n")
        traceback.print_exc()
        print("\nPress Enter to exit…")
        input()
        sys.exit(1)

    # Instantiate and show the main window, catching UI init errors
    try:
        win = AppWindow()
        win.show()
    except Exception:
        print("\n[run_agent] FATAL — UI failed to initialize:\n")
        traceback.print_exc()
        print("\nPress Enter to exit…")
        input()
        sys.exit(1)


def main() -> None:
    """Entry point: initialize QApplication, bootstrap state, and start event loop."""
    base_dir = (
        sys.argv[1]
        if len(sys.argv) > 1
        else os.path.join(os.getcwd(), "ai_agent_state")
    )

    app = QtWidgets.QApplication(sys.argv)
    _bootstrap_state(base_dir)
    sys.exit(app.exec_())


if __name__ == "__main__":
    try:
        main()
    except Exception:
        print("\n[run_agent] FATAL — an unexpected error occurred:\n")
        traceback.print_exc()
        print("\nPress Enter to exit…")
        input()
```

run_agent.py — bootstrap launcher for AI TTS Agent (v3, 2025-08-04)

• Ensures the sqlite store exists (agent_store.ensure_db()) and runs
  legacy-data migration when user_version < 4.
• Accepts one optional command-line arg: <profile-dir>. Defaults to
  ./ai_agent_state relative to CWD.
• Starts the Qt GUI (main_ui.AppWindow).
• Catches early exceptions and prints a clean error trace instead of a
  raw stack-dump so newcomers understand what went wrong.
**Functions:** _bootstrap_state(base_dir), main()


## Module `schema_ops.py`

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
schema_ops.py  (2025-08-04  ▸  v2)
==================================

Declarative dispatcher that maps **string op-codes → mutator callables**
operating on core_schema.SchemaEngine / Schema rows.

Updates (v2)
------------
• Added category & prompt removal / update helpers
• Added action list mutators
• Added runtime-introspection helpers: available_ops(), describe_op()
• Strict type-checking & richer logging

Usage example
-------------
>>> from schema_ops import execute_op, available_ops
>>> print(available_ops())
['add_category', 'append_actions', 'delete_action', ...]
>>> execute_op("append_actions", engine,
...            persona="zira", set_name="default",
...            actions=["wave warmly", "offer coffee"])
"""

from __future__ import annotations

import inspect
from typing import Callable, Dict, Any, List

from core_schema import SchemaEngine, Schema
from core_base import logger


# ╔═══════════════════════════════════════════════════════════════════════╗
# ║  Internal helpers                                                     ║
# ╚═══════════════════════════════════════════════════════════════════════╝
def _load(engine: SchemaEngine, persona: str, set_name: str) -> Schema:
    """Return schema or raise ValueError on bad keys."""
    if persona not in engine.personas:
        raise ValueError(f"Unknown persona: {persona}")
    return engine.load(persona, set_name)


def _save(engine: SchemaEngine, persona: str, set_name: str, sch: Schema):
    engine.save(persona, set_name, sch)


def _signal_category_created(engine: SchemaEngine, persona: str, set_name: str, category: str):
    """
    Emit schemaEvolved + categoryCreated if those Qt signals exist.
    No hard dependency —  graceful if running headless.
    """
    try:
        # pylint: disable=protected-access
        engine.schemaEvolved.emit(persona, set_name)        # type: ignore[attr-defined]
        engine.categoryCreated.emit(category)               # type: ignore[attr-defined]
    except Exception:
        pass


# ╔═══════════════════════════════════════════════════════════════════════╗
# ║  Operation implementations                                            ║
# ╚═══════════════════════════════════════════════════════════════════════╝
def op_add_category(
    engine: SchemaEngine,
    *,
    persona: str,
    set_name: str,
    category: str,
    values: List[str] | None = None,
):
    """Create new dynamic_overlay list with optional initial *values*."""
    sch = _load(engine, persona, set_name)
    overlay = sch.dynamic_overlay or {}
    if category in overlay:
        raise ValueError(f"Category '{category}' already exists.")
    overlay[category] = values or []
    sch.dynamic_overlay = overlay
    _save(engine, persona, set_name, sch)
    _signal_category_created(engine, persona, set_name, category)
    logger.info("Added category '%s' to %s/%s", category, persona, set_name)


def op_remove_category(
    engine: SchemaEngine,
    *,
    persona: str,
    set_name: str,
    category: str,
):
    """Remove an entire category from dynamic_overlay."""
    sch = _load(engine, persona, set_name)
    overlay = sch.dynamic_overlay or {}
    if category not in overlay:
        raise ValueError(f"No such category '{category}'.")
    overlay.pop(category)
    sch.dynamic_overlay = overlay
    _save(engine, persona, set_name, sch)
    logger.info("Removed category '%s' from %s/%s", category, persona, set_name)


def op_update_category(
    engine: SchemaEngine,
    *,
    persona: str,
    set_name: str,
    category: str,
    new_values: List[str],
):
    """Replace the value-list of an existing category."""
    sch = _load(engine, persona, set_name)
    overlay = sch.dynamic_overlay or {}
    if category not in overlay:
        raise ValueError(f"Category '{category}' not found.")
    overlay[category] = list(new_values)
    sch.dynamic_overlay = overlay
    _save(engine, persona, set_name, sch)
    logger.info("Updated category '%s' in %s/%s", category, persona, set_name)


def op_toggle_autoevo(
    engine: SchemaEngine,
    *,
    persona: str,
    set_name: str,
    enable: bool,
):
    """Flip semantic_awareness_enabled flag."""
    sch = _load(engine, persona, set_name)
    cur = bool(getattr(sch, "semantic_awareness_enabled", False))
    if cur == enable:
        return
    sch.semantic_awareness_enabled = enable
    _save(engine, persona, set_name, sch)
    logger.info("semantic_awareness %s for %s/%s", enable, persona, set_name)


def op_inject_prompt_variant(
    engine: SchemaEngine,
    *,
    persona: str,
    set_name: str,
    variant_name: str,
    prompt_template: str,
):
    """Append new prompt template to rewrite_prompts list."""
    sch = _load(engine, persona, set_name)
    lst: List[str] = sch.rewrite_prompts or []
    entry = f"[{variant_name}] {prompt_template}"
    lst.append(entry)
    sch.rewrite_prompts = lst
    _save(engine, persona, set_name, sch)
    logger.info("Injected prompt variant '%s' into %s/%s", variant_name, persona, set_name)


def op_remove_prompt_variant(
    engine: SchemaEngine,
    *,
    persona: str,
    set_name: str,
    variant_tag: str,
):
    """
    Delete a rewrite prompt that contains *variant_tag* (case-insensitive).
    """
    sch = _load(engine, persona, set_name)
    lst: List[str] = sch.rewrite_prompts or []
    new_lst = [p for p in lst if variant_tag.lower() not in p.lower()]
    if len(new_lst) == len(lst):
        raise ValueError(f"No prompt containing '{variant_tag}' found.")
    sch.rewrite_prompts = new_lst
    _save(engine, persona, set_name, sch)
    logger.info("Removed prompt variant '%s' from %s/%s", variant_tag, persona, set_name)


def op_replace_rewrite_list(
    engine: SchemaEngine,
    *,
    persona: str,
    set_name: str,
    new_list: List[str],
):
    """Replace entire rewrite_prompts list."""
    sch = _load(engine, persona, set_name)
    sch.rewrite_prompts = list(new_list)
    _save(engine, persona, set_name, sch)
    logger.info("rewrite_prompts replaced for %s/%s", persona, set_name)


def op_append_actions(
    engine: SchemaEngine,
    *,
    persona: str,
    set_name: str,
    actions: List[str],
):
    """Append new action strings (deduplicated)."""
    sch = _load(engine, persona, set_name)
    cur: List[str] = sch.actions or []
    for a in actions:
        if a not in cur:
            cur.append(a)
    sch.actions = cur
    _save(engine, persona, set_name, sch)
    logger.info("Appended %d actions to %s/%s", len(actions), persona, set_name)


def op_delete_action(
    engine: SchemaEngine,
    *,
    persona: str,
    set_name: str,
    action_text: str,
):
    """Remove an action entry matching *action_text* exactly."""
    sch = _load(engine, persona, set_name)
    cur: List[str] = sch.actions or []
    if action_text not in cur:
        raise ValueError("Action not found.")
    cur.remove(action_text)
    sch.actions = cur
    _save(engine, persona, set_name, sch)
    logger.info("Deleted action '%s' from %s/%s", action_text, persona, set_name)


def op_rename_schema_set(
    engine: SchemaEngine,
    *,
    persona: str,
    old_set: str,
    new_set: str,
):
    """Rename a schema set atomically."""
    if new_set == old_set:
        raise ValueError("new_set equals old_set")
    if new_set in engine.list_sets(persona):
        raise ValueError("Target set already exists")
    sch = _load(engine, persona, old_set)
    engine.save(persona, new_set, sch, auto_expand=False)
    engine.store.conn.execute(
        "DELETE FROM schemas WHERE persona_key=? AND set_name=?",
        (persona, old_set),
    )
    engine.store.conn.commit()
    logger.info("Renamed set %s/%s -> %s", persona, old_set, new_set)


# ╔═══════════════════════════════════════════════════════════════════════╗
# ║  Declarative operation registry                                       ║
# ╚═══════════════════════════════════════════════════════════════════════╝
OPS: Dict[str, Callable[..., None]] = {
    # Category ops
    "add_category": op_add_category,
    "remove_category": op_remove_category,
    "update_category": op_update_category,
    # Rewrite-prompt ops
    "inject_prompt_variant": op_inject_prompt_variant,
    "remove_prompt_variant": op_remove_prompt_variant,
    "replace_rewrite_list": op_replace_rewrite_list,
    # Semantic awareness flag
    "toggle_autoevo": op_toggle_autoevo,
    # Actions list
    "append_actions": op_append_actions,
    "delete_action": op_delete_action,
    # Set management
    "rename_schema_set": op_rename_schema_set,
}

# ╔═══════════════════════════════════════════════════════════════════════╗
# ║  Public utility wrappers                                              ║
# ╚═══════════════════════════════════════════════════════════════════════╝
def execute_op(op_name: str, engine: SchemaEngine, **payload):
    """Dispatch *op_name*; raise KeyError on unknown op."""
    fn = OPS.get(op_name)
    if not fn:
        raise KeyError(f"Unknown op: {op_name}")
    return fn(engine, **payload)


def available_ops() -> List[str]:
    """Return sorted list of registered op-codes."""
    return sorted(OPS)


def describe_op(op_name: str) -> str:
    """Return docstring of a registered op."""
    fn = OPS.get(op_name)
    if not fn:
        raise KeyError(op_name)
    return inspect.getdoc(fn) or ""


__all__ = [
    "OPS",
    "execute_op",
    "available_ops",
    "describe_op",
]
```

schema_ops.py  (2025-08-04  ▸  v2)
==================================

Declarative dispatcher that maps **string op-codes → mutator callables**
operating on core_schema.SchemaEngine / Schema rows.

Updates (v2)
------------
• Added category & prompt removal / update helpers
• Added action list mutators
• Added runtime-introspection helpers: available_ops(), describe_op()
• Strict type-checking & richer logging

Usage example
-------------
>>> from schema_ops import execute_op, available_ops
>>> print(available_ops())
['add_category', 'append_actions', 'delete_action', ...]
>>> execute_op("append_actions", engine,
...            persona="zira", set_name="default",
...            actions=["wave warmly", "offer coffee"])
**Functions:** _load(engine, persona, set_name), _save(engine, persona, set_name, sch), _signal_category_created(engine, persona, set_name, category), op_add_category(engine), op_remove_category(engine), op_update_category(engine), op_toggle_autoevo(engine), op_inject_prompt_variant(engine), op_remove_prompt_variant(engine), op_replace_rewrite_list(engine), op_append_actions(engine), op_delete_action(engine), op_rename_schema_set(engine), execute_op(op_name, engine), available_ops(), describe_op(op_name)


## Module `snapshot_worker.py`

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
snapshot_worker.py

This script defines ModelWorker, which runs inference on a given model in a separate thread.
Used by the UI to offload prompt evaluation from the main thread.
"""

from PyQt5 import QtCore
from typing import Optional
import traceback

class ModelWorker(QtCore.QThread):
    resultReady = QtCore.pyqtSignal(str)
    errorOccurred = QtCore.pyqtSignal(str)

    def __init__(self, model_slug: str, prompt: str, parent: Optional[QtCore.QObject] = None) -> None:
        super().__init__(parent)
        self.model_slug = model_slug
        self.prompt = prompt

    def run(self):
        try:
            # TODO: Replace this mock logic with actual model inference
            import time
            time.sleep(0.8)  # Simulate response time

            # Simulated output - replace with LLM backend output
            response = f"[{self.model_slug}] Response to: {self.prompt}"

            # Emit response back to UI
            self.resultReady.emit(response)

        except Exception as e:
            tb = traceback.format_exc()
            self.errorOccurred.emit(f"{e}\n{tb}")
```

snapshot_worker.py

This script defines ModelWorker, which runs inference on a given model in a separate thread.
Used by the UI to offload prompt evaluation from the main thread.
**Classes:** ModelWorker


## Module `spatial_engine.py`

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
spatial_engine.py
=================

Headless avatar movement & visual-action logger for the AI TTS Agent.

Features:
- Stateful finite-state machine (idle, thinking, moving).
- decide_move(response_text): simple NLP heuristics to pick a target cell.
- Animated, step-by-step movement on a configurable grid.
- Logs each position to AgentStore.spatial_positions and each completed move to AgentStore.visual_actions.
- Emits Qt signals for UI binding (positionChanged, actionLogged).
"""

import threading
import time
from typing import Tuple

from PyQt5 import QtCore
from core_store import FathomStore


class SpatialEngine(QtCore.QObject):
    # Emitted on each step: (x, y, facing)
    positionChanged = QtCore.pyqtSignal(int, int, str)
    # Emitted when a visual action is logged: (action, location, justification)
    actionLogged = QtCore.pyqtSignal(str, str, str)

    def __init__(
        self,
        store: FathomStore,
        entity: str = "zira",
        grid_size: Tuple[int, int] = (20, 20),
        parent: QtCore.QObject = None,
    ) -> None:
        super().__init__(parent)
        self.store = store
        self.entity = entity
        self.grid_width, self.grid_height = grid_size

        # FSM state
        self.state = "idle"
        self.current_x = 0
        self.current_y = 0
        self.facing = "right"

        # Threading
        self._lock = threading.Lock()
        self._stop_event = threading.Event()

    def decide_move(self, response_text: str) -> None:
        """
        Decide where to move based on the content of the last AI response.
        Spawns a background thread to animate the movement.
        """
        target = self._infer_target(response_text)
        justification = f"Decided move based on response keywords."
        worker = threading.Thread(
            target=self._animate_move, args=(target, justification), daemon=True
        )
        worker.start()

    def _infer_target(self, text: str) -> Tuple[int, int]:
        """
        Simple heuristics mapping keywords to grid locations:
        - 'file', 'project' -> top-right (computer terminal)
        - 'database', 'memory' -> bottom-left (storage console)
        - 'think', 'ponder' -> center (thinking zone)
        - otherwise: stay in place
        """
        t = text.lower()
        if any(k in t for k in ("file", "project")):
            return (self.grid_width - 1, 0)
        if any(k in t for k in ("database", "memory", "store")):
            return (0, self.grid_height - 1)
        if any(k in t for k in ("think", "ponder", "reflect")):
            return (self.grid_width // 2, self.grid_height // 2)
        # default: remain where you are
        return (self.current_x, self.current_y)

    def _animate_move(self, target: Tuple[int, int], justification: str) -> None:
        """
        Step-by-step move from current position to target.
        Logs each step and emits positionChanged, then logs final visual action.
        """
        with self._lock:
            self.state = "moving"
            tx, ty = target

            while (self.current_x, self.current_y) != (tx, ty):
                if self._stop_event.is_set():
                    break

                # Compute one-step delta
                dx = tx - self.current_x
                dy = ty - self.current_y
                new_x = self.current_x + (1 if dx > 0 else -1 if dx < 0 else 0)
                new_y = self.current_y + (1 if dy > 0 else -1 if dy < 0 else 0)

                # Determine facing direction
                if new_x > self.current_x:
                    self.facing = "right"
                elif new_x < self.current_x:
                    self.facing = "left"

                self.current_x, self.current_y = new_x, new_y

                # Timestamp for persistence
                ts = time.time()

                # Persist to store
                self.store.add_spatial_position(
                    entity=self.entity,
                    x=new_x,
                    y=new_y,
                    facing=self.facing,
                    timestamp=ts,
                )

                # Emit for UI
                self.positionChanged.emit(new_x, new_y, self.facing)

                # Pause between steps
                time.sleep(0.15)

            # Log completion action
            loc_str = f"{self.current_x},{self.current_y}"
            ts = time.time()
            self.store.add_visual_action(
                action="move_complete",
                location=loc_str,
                justification=justification,
                timestamp=ts,
            )
            self.actionLogged.emit("move_complete", loc_str, justification)
            self.state = "idle"

    def stop(self) -> None:
        """Signal any in-progress movement to halt."""
        self._stop_event.set()
        # Clear the event so future movements can proceed
        self._stop_event.clear()
```

spatial_engine.py
=================

Headless avatar movement & visual-action logger for the AI TTS Agent.

Features:
- Stateful finite-state machine (idle, thinking, moving).
- decide_move(response_text): simple NLP heuristics to pick a target cell.
- Animated, step-by-step movement on a configurable grid.
- Logs each position to AgentStore.spatial_positions and each completed move to AgentStore.visual_actions.
- Emits Qt signals for UI binding (positionChanged, actionLogged).
**Classes:** SpatialEngine
