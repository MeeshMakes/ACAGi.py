# Project Documentation

## Table of Contents
- [Overview](#overview)
- [Python Modules](#python-modules)
- [Other Files](#other-files)

## Overview
This README was generated automatically by analyzing the project contents. Python modules are parsed for docstrings, classes, and functions. Image files are embedded as previews. Executable files (.exe) are listed by name; their contents are intentionally skipped.

## Python Modules

- `Analyze_folders.py`
- `Rant_PDD.py`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\_burner_scripts\__init__.py`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\_burner_scripts\agent_core.py`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\_burner_scripts\agent_store.py`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\_burner_scripts\agent_ui.py`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\_burner_scripts\bean_logic.py`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\_burner_scripts\command_palette.py`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\_burner_scripts\commands_panel.py`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\_burner_scripts\config_mgr.py`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\_burner_scripts\core_base.py`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\_burner_scripts\core_orchestrator.py`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\_burner_scripts\core_schema.py`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\_burner_scripts\main_ui.py`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\_burner_scripts\migration_tool.py`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\_burner_scripts\persona_tab.py`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\_burner_scripts\run_agent.py`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\_burner_scripts\schema_ops.py`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\_burner_scripts\snapshot_worker.py`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\_burner_scripts\spatial_engine.py`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\AI_TTS_AGENT\agent_store.py`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\AI_TTS_AGENT\AI TTS INFO\config_mgr.py`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\AI_TTS_AGENT\AI TTS INFO\llm_checkpoint_builder\__init__.py`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\AI_TTS_AGENT\AI TTS INFO\Zira Bot\agent_core.py`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\AI_TTS_AGENT\AI TTS INFO\Zira Bot\agent_ui.py`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\AI_TTS_AGENT\bean_logic.py`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\AI_TTS_AGENT\command_palette.py`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\AI_TTS_AGENT\commands_panel.py`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\AI_TTS_AGENT\core_base.py`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\AI_TTS_AGENT\core_orchestrator.py`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\AI_TTS_AGENT\core_schema.py`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\AI_TTS_AGENT\main_ui.py`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\AI_TTS_AGENT\migration_tool.py`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\AI_TTS_AGENT\persona_tab.py`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\AI_TTS_AGENT\run_agent.py`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\AI_TTS_AGENT\schema_ops.py`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\AI_TTS_AGENT\snapshot_worker.py`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\AI_TTS_AGENT\spatial_engine.py`
- `Rant_PDD\Projects\AI_TTS_AGENT\burner_scripts\__init__.py`
- `Rant_PDD\Projects\AI_TTS_AGENT\burner_scripts\agent_core.py`
- `Rant_PDD\Projects\AI_TTS_AGENT\burner_scripts\agent_store.py`
- `Rant_PDD\Projects\AI_TTS_AGENT\burner_scripts\agent_ui.py`
- `Rant_PDD\Projects\AI_TTS_AGENT\burner_scripts\bean_logic.py`
- `Rant_PDD\Projects\AI_TTS_AGENT\burner_scripts\command_palette.py`
- `Rant_PDD\Projects\AI_TTS_AGENT\burner_scripts\commands_panel.py`
- `Rant_PDD\Projects\AI_TTS_AGENT\burner_scripts\config_mgr.py`
- `Rant_PDD\Projects\AI_TTS_AGENT\burner_scripts\core_base.py`
- `Rant_PDD\Projects\AI_TTS_AGENT\burner_scripts\core_orchestrator.py`
- `Rant_PDD\Projects\AI_TTS_AGENT\burner_scripts\core_schema.py`
- `Rant_PDD\Projects\AI_TTS_AGENT\burner_scripts\main_ui.py`
- `Rant_PDD\Projects\AI_TTS_AGENT\burner_scripts\migration_tool.py`
- `Rant_PDD\Projects\AI_TTS_AGENT\burner_scripts\persona_tab.py`
- `Rant_PDD\Projects\AI_TTS_AGENT\burner_scripts\run_agent.py`
- `Rant_PDD\Projects\AI_TTS_AGENT\burner_scripts\schema_ops.py`
- `Rant_PDD\Projects\AI_TTS_AGENT\burner_scripts\snapshot_worker.py`
- `Rant_PDD\Projects\AI_TTS_AGENT\burner_scripts\spatial_engine.py`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\_burner_scripts\__init__.py`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\_burner_scripts\agent_core.py`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\_burner_scripts\agent_store.py`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\_burner_scripts\agent_ui.py`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\_burner_scripts\bean_logic.py`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\_burner_scripts\command_palette.py`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\_burner_scripts\commands_panel.py`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\_burner_scripts\config_mgr.py`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\_burner_scripts\core_base.py`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\_burner_scripts\core_orchestrator.py`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\_burner_scripts\core_schema.py`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\_burner_scripts\main_ui.py`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\_burner_scripts\migration_tool.py`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\_burner_scripts\persona_tab.py`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\_burner_scripts\run_agent.py`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\_burner_scripts\schema_ops.py`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\_burner_scripts\snapshot_worker.py`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\_burner_scripts\spatial_engine.py`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\AI_TTS_AGENT\agent_store.py`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\AI_TTS_AGENT\AI TTS INFO\config_mgr.py`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\AI_TTS_AGENT\AI TTS INFO\llm_checkpoint_builder\__init__.py`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\AI_TTS_AGENT\AI TTS INFO\Zira Bot\agent_core.py`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\AI_TTS_AGENT\AI TTS INFO\Zira Bot\agent_ui.py`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\AI_TTS_AGENT\bean_logic.py`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\AI_TTS_AGENT\command_palette.py`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\AI_TTS_AGENT\commands_panel.py`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\AI_TTS_AGENT\core_base.py`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\AI_TTS_AGENT\core_orchestrator.py`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\AI_TTS_AGENT\core_schema.py`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\AI_TTS_AGENT\main_ui.py`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\AI_TTS_AGENT\migration_tool.py`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\AI_TTS_AGENT\persona_tab.py`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\AI_TTS_AGENT\run_agent.py`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\AI_TTS_AGENT\schema_ops.py`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\AI_TTS_AGENT\snapshot_worker.py`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\AI_TTS_AGENT\spatial_engine.py`

## Other Files

- `analyze.txt`
- `api\api_key.txt`
- `api\other\api_key.txt`
- `Rant_PDD.md`
- `Rant_PDD\config.json`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\.git\config`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\.git\description`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\.git\FETCH_HEAD`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\.git\HEAD`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\.git\hooks\applypatch-msg.sample`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\.git\hooks\commit-msg.sample`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\.git\hooks\fsmonitor-watchman.sample`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\.git\hooks\post-update.sample`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\.git\hooks\pre-applypatch.sample`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\.git\hooks\pre-commit.sample`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\.git\hooks\pre-merge-commit.sample`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\.git\hooks\pre-push.sample`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\.git\hooks\pre-rebase.sample`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\.git\hooks\pre-receive.sample`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\.git\hooks\prepare-commit-msg.sample`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\.git\hooks\push-to-checkout.sample`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\.git\hooks\sendemail-validate.sample`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\.git\hooks\update.sample`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\.git\index`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\.git\info\exclude`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\.git\logs\HEAD`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\.git\logs\refs\heads\main`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\.git\logs\refs\remotes\origin\HEAD`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\.git\logs\refs\remotes\origin\main`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\.git\objects\05\4373664b0a5bae9f13cc8bde59db5773fc631e`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\.git\objects\06\2af2a8bce22d4c134db7fdace465fb83b3c086`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\.git\objects\cb\b02569930ee6e8b7a724ded0144e9446d6bc7e`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\.git\objects\cf\0d7139cbd51e2d01b767404225670870ad3d28`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\.git\objects\pack\pack-07fda421a0e18f3b2efaf50f44b30abc4f918f76.idx`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\.git\objects\pack\pack-07fda421a0e18f3b2efaf50f44b30abc4f918f76.pack`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\.git\objects\pack\pack-07fda421a0e18f3b2efaf50f44b30abc4f918f76.rev`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\.git\packed-refs`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\.git\refs\heads\main`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\.git\refs\remotes\origin\HEAD`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\.git\refs\remotes\origin\main`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\_design_docs\__init__\pdd.txt`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\_design_docs\agent_core\pdd.txt`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\_design_docs\agent_store\pdd.txt`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\_design_docs\agent_ui\pdd.txt`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\_design_docs\bean_logic\pdd.txt`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\_design_docs\command_palette\pdd.txt`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\_design_docs\commands_panel\pdd.txt`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\_design_docs\config_mgr\pdd.txt`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\_design_docs\core_base\pdd.txt`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\_design_docs\core_orchestrator\pdd.txt`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\_design_docs\core_schema\pdd.txt`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\_design_docs\main_ui\pdd.txt`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\_design_docs\migration_tool\pdd.txt`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\_design_docs\persona_tab\pdd.txt`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\_design_docs\run_agent\pdd.txt`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\_design_docs\schema_ops\pdd.txt`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\_design_docs\snapshot_worker\pdd.txt`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\_design_docs\spatial_engine\pdd.txt`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\_info\runtime_assets.json`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\AI_TTS_AGENT\__pycache__\agent_store.cpython-313.pyc`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\AI_TTS_AGENT\__pycache__\command_palette.cpython-313.pyc`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\AI_TTS_AGENT\__pycache__\commands_panel.cpython-313.pyc`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\AI_TTS_AGENT\__pycache__\core_base.cpython-313.pyc`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\AI_TTS_AGENT\__pycache__\core_orchestrator.cpython-313.pyc`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\AI_TTS_AGENT\__pycache__\core_schema.cpython-313.pyc`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\AI_TTS_AGENT\__pycache__\main_ui.cpython-313.pyc`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\AI_TTS_AGENT\__pycache__\persona_tab.cpython-313.pyc`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\AI_TTS_AGENT\__pycache__\snapshot_worker.cpython-313.pyc`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\AI_TTS_AGENT\agent_store.db`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\AI_TTS_AGENT\agent_store.db-shm`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\AI_TTS_AGENT\agent_store.db-wal`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\AI_TTS_AGENT\AI TTS INFO\awareness logic.txt`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\AI_TTS_AGENT\AI TTS INFO\info 0.txt`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\AI_TTS_AGENT\AI TTS INFO\info 1.txt`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\AI_TTS_AGENT\AI TTS INFO\info 2.txt`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\AI_TTS_AGENT\AI TTS INFO\info 3.txt`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\AI_TTS_AGENT\AI TTS INFO\info 4.txt`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\AI_TTS_AGENT\AI TTS INFO\info 5.txt`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\AI_TTS_AGENT\AI TTS INFO\llm_checkpoint_builder\__pycache__\__init__.cpython-313.pyc`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\AI_TTS_AGENT\AI TTS INFO\llm_checkpoint_builder\manifest.json`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\AI_TTS_AGENT\AI TTS INFO\new logic.txt`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\AI_TTS_AGENT\AI TTS INFO\new\icecream logic.txt`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\AI_TTS_AGENT\AI TTS INFO\new\info.txt`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\AI_TTS_AGENT\AI TTS INFO\new\info2.txt`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\AI_TTS_AGENT\AI TTS INFO\new\info3.txt`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\AI_TTS_AGENT\AI TTS INFO\new\info4.txt`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\AI_TTS_AGENT\AI TTS INFO\older info.txt`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\AI_TTS_AGENT\AI TTS INFO\the final convert.txt`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\AI_TTS_AGENT\AI TTS INFO\Zira Bot\__pycache__\agent_core.cpython-313.pyc`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\AI_TTS_AGENT\AI TTS INFO\Zira Bot\conversations\zira_default.sqlite3`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\AI_TTS_AGENT\AI TTS INFO\Zira Bot\feedback\zira_default.sqlite3`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\AI_TTS_AGENT\AI TTS INFO\Zira Bot\operators\InnerMonologue\schema.json`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\AI_TTS_AGENT\AI TTS INFO\Zira Bot\operators\Retriever\schema.json`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\AI_TTS_AGENT\AI TTS INFO\Zira Bot\operators\Rewriter\schema.json`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\AI_TTS_AGENT\AI TTS INFO\Zira Bot\profiles\zira\default\commands.json`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\AI_TTS_AGENT\AI TTS INFO\Zira Bot\Readme.md`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\AI_TTS_AGENT\AI TTS INFO\Zira Bot\schemas\chatbot\sets\default\schema.json`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\AI_TTS_AGENT\AI TTS INFO\Zira Bot\schemas\user\sets\default\schema.json`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\AI_TTS_AGENT\AI TTS INFO\Zira Bot\schemas\zira\sets\default\schema.json`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\AI_TTS_AGENT\conversations\zira_default.sqlite3`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\AI_TTS_AGENT\feedback\zira_default.sqlite3`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\AI_TTS_AGENT\profiles\zira\default\commands.json`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\AI_TTS_AGENT\profiles\zira\default\memory.json`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\AI_TTS_AGENT\Readme.md`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\AI_TTS_AGENT\settings.json`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\AI_TTS_AGENT\temp.wav`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\README.md`
- `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\requirements.txt`
- `Rant_PDD\Projects\AI_TTS_AGENT\burner_lists\__init___burner_list.txt`
- `Rant_PDD\Projects\AI_TTS_AGENT\burner_lists\agent_core_burner_list.txt`
- `Rant_PDD\Projects\AI_TTS_AGENT\burner_lists\agent_store_burner_list.txt`
- `Rant_PDD\Projects\AI_TTS_AGENT\burner_lists\agent_ui_burner_list.txt`
- `Rant_PDD\Projects\AI_TTS_AGENT\burner_lists\bean_logic_burner_list.txt`
- `Rant_PDD\Projects\AI_TTS_AGENT\burner_lists\command_palette_burner_list.txt`
- `Rant_PDD\Projects\AI_TTS_AGENT\burner_lists\commands_panel_burner_list.txt`
- `Rant_PDD\Projects\AI_TTS_AGENT\burner_lists\config_mgr_burner_list.txt`
- `Rant_PDD\Projects\AI_TTS_AGENT\burner_lists\core_base_burner_list.txt`
- `Rant_PDD\Projects\AI_TTS_AGENT\burner_lists\core_orchestrator_burner_list.txt`
- `Rant_PDD\Projects\AI_TTS_AGENT\burner_lists\core_schema_burner_list.txt`
- `Rant_PDD\Projects\AI_TTS_AGENT\burner_lists\main_ui_burner_list.txt`
- `Rant_PDD\Projects\AI_TTS_AGENT\burner_lists\migration_tool_burner_list.txt`
- `Rant_PDD\Projects\AI_TTS_AGENT\burner_lists\persona_tab_burner_list.txt`
- `Rant_PDD\Projects\AI_TTS_AGENT\burner_lists\run_agent_burner_list.txt`
- `Rant_PDD\Projects\AI_TTS_AGENT\burner_lists\schema_ops_burner_list.txt`
- `Rant_PDD\Projects\AI_TTS_AGENT\burner_lists\snapshot_worker_burner_list.txt`
- `Rant_PDD\Projects\AI_TTS_AGENT\burner_lists\spatial_engine_burner_list.txt`
- `Rant_PDD\Projects\AI_TTS_AGENT\conversation.db`
- `Rant_PDD\Projects\AI_TTS_AGENT\Design_Documents\__init__\pdd.txt`
- `Rant_PDD\Projects\AI_TTS_AGENT\Design_Documents\agent_core\pdd.txt`
- `Rant_PDD\Projects\AI_TTS_AGENT\Design_Documents\agent_store\pdd.txt`
- `Rant_PDD\Projects\AI_TTS_AGENT\Design_Documents\agent_ui\pdd.txt`
- `Rant_PDD\Projects\AI_TTS_AGENT\Design_Documents\bean_logic\pdd.txt`
- `Rant_PDD\Projects\AI_TTS_AGENT\Design_Documents\command_palette\pdd.txt`
- `Rant_PDD\Projects\AI_TTS_AGENT\Design_Documents\commands_panel\pdd.txt`
- `Rant_PDD\Projects\AI_TTS_AGENT\Design_Documents\config_mgr\pdd.txt`
- `Rant_PDD\Projects\AI_TTS_AGENT\Design_Documents\core_base\pdd.txt`
- `Rant_PDD\Projects\AI_TTS_AGENT\Design_Documents\core_orchestrator\pdd.txt`
- `Rant_PDD\Projects\AI_TTS_AGENT\Design_Documents\core_schema\pdd.txt`
- `Rant_PDD\Projects\AI_TTS_AGENT\Design_Documents\main_ui\pdd.txt`
- `Rant_PDD\Projects\AI_TTS_AGENT\Design_Documents\migration_tool\pdd.txt`
- `Rant_PDD\Projects\AI_TTS_AGENT\Design_Documents\persona_tab\pdd.txt`
- `Rant_PDD\Projects\AI_TTS_AGENT\Design_Documents\run_agent\pdd.txt`
- `Rant_PDD\Projects\AI_TTS_AGENT\Design_Documents\schema_ops\pdd.txt`
- `Rant_PDD\Projects\AI_TTS_AGENT\Design_Documents\snapshot_worker\pdd.txt`
- `Rant_PDD\Projects\AI_TTS_AGENT\Design_Documents\spatial_engine\pdd.txt`
- `Rant_PDD\Projects\AI_TTS_AGENT\index.json`
- `Rant_PDD\Projects\AI_TTS_AGENT\pdd.txt`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\.git\COMMIT_EDITMSG`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\.git\config`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\.git\description`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\.git\FETCH_HEAD`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\.git\HEAD`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\.git\hooks\applypatch-msg.sample`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\.git\hooks\commit-msg.sample`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\.git\hooks\fsmonitor-watchman.sample`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\.git\hooks\post-update.sample`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\.git\hooks\pre-applypatch.sample`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\.git\hooks\pre-commit.sample`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\.git\hooks\pre-merge-commit.sample`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\.git\hooks\pre-push.sample`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\.git\hooks\pre-rebase.sample`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\.git\hooks\pre-receive.sample`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\.git\hooks\prepare-commit-msg.sample`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\.git\hooks\push-to-checkout.sample`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\.git\hooks\update.sample`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\.git\index`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\.git\info\exclude`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\.git\logs\HEAD`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\.git\logs\refs\heads\main`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\.git\logs\refs\remotes\origin\HEAD`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\.git\logs\refs\remotes\origin\main`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\.git\objects\07\16a2e0ab56364c1132ff51fd202ca9fe0dae9a`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\.git\objects\0c\fe7a099272b19cb7d07cdbe04547886e2aafb0`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\.git\objects\0f\5bc1ec95b261328af3bd6fb806c861f0ba9d9c`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\.git\objects\14\8b47a845a9fb5fcda1770fda9bf15ffdcef66b`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\.git\objects\19\11f113473d828bfb97250801ef10f9d7ea6489`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\.git\objects\20\860500b7a6b53c6258a7e5a04e396107d14ca2`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\.git\objects\28\13ed5084bf40e67af7c0b94ca95dda4ae8946e`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\.git\objects\2a\283509abe48193468305c93f15f6209b5bff36`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\.git\objects\2e\872d0605565ff85155bb69921f8baa9abc2db8`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\.git\objects\2f\78f483de8ef62010065fc4f2752816781766bb`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\.git\objects\34\3090e0efce22deb7d369bddd8497e8b1c2db9f`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\.git\objects\36\265dcf9963af76f9fadce921a78746a1ceaade`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\.git\objects\3d\eeef04bc4fe57541acd385c9dd2432d1578b9a`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\.git\objects\52\b12860a614e89d457ae49c519ae927d72b77e6`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\.git\objects\53\392090ac3aa4320e68b39b52fc8a4ce07818fe`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\.git\objects\57\cb9f9e0c121ac95618ae17082803a86b88bd69`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\.git\objects\5d\342569139e558314c7c2ad5b528d445c9dc2db`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\.git\objects\69\1a0a6d9462b5de1b8e60a2ae3d5987f111e62b`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\.git\objects\7f\098f69bbe83f7ec3f2a01b531744cbaf39afa6`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\.git\objects\8e\1813de2eb35625425237c58b17d5d30e0831e5`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\.git\objects\90\1778617bcd9864f4b88ebe35d43820c106fbae`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\.git\objects\92\28ce3d0f9b9e264961f9a2dbc4f580fdd2613a`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\.git\objects\99\005b58ffd94866929456ae7cdb5ca6e51f69b0`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\.git\objects\9c\42195f93609bbf70fd01de0355ee5231391806`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\.git\objects\9d\8650a5ca14b4fec01b3d70b38298c3f9769892`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\.git\objects\a1\83089ee756641d4144a663f441ed2abb77139d`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\.git\objects\a8\bc920e4534bca1514c9ad202f872aca7563772`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\.git\objects\ae\5a9aacc1a0f1dd434e1df3c2d2da331f4cfb88`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\.git\objects\ae\5d925aec5144d0d9b9400c9bef88b5e5c0bd76`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\.git\objects\b0\6aff75e73040881922875f3e0f09056a0b0fb6`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\.git\objects\b1\c7046fc7a75e590b2c9828d58ffdb5c3af46c1`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\.git\objects\b5\3b3fd9b7c1fdfbb087ea635af6b892f8f2cac5`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\.git\objects\bc\1f6324ca8cc09b6f9f631adb82c04bdd212d7c`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\.git\objects\c2\7c2b0dcda447be3d02f6c7f4ac0d8cacd494c8`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\.git\objects\c5\24fb0189548f7dd8cc455c79f2788b3a3235cf`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\.git\objects\cc\7b42b403c0647f8732ade4a66c275677291671`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\.git\objects\d1\bad693957578b72b5ffd04a4954cf9b8481b27`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\.git\objects\d2\46f313b337e2fc37c447b989fb297985eb0939`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\.git\objects\e6\9de29bb2d1d6434b8b29ae775ad8c2e48c5391`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\.git\objects\e8\21a7a53c7745ca770303a506370e92c3fbb2d0`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\.git\objects\e9\6694a81a15dd177bdb4ce8b57b1d72133b0555`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\.git\objects\pack\pack-b8b09fe1201ef038817ddaa0465d7c857acb1c0d.idx`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\.git\objects\pack\pack-b8b09fe1201ef038817ddaa0465d7c857acb1c0d.pack`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\.git\ORIG_HEAD`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\.git\packed-refs`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\.git\refs\heads\main`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\.git\refs\remotes\origin\HEAD`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\.git\refs\remotes\origin\main`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\_design_docs\__init__\pdd.txt`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\_design_docs\agent_core\pdd.txt`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\_design_docs\agent_store\pdd.txt`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\_design_docs\agent_ui\pdd.txt`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\_design_docs\bean_logic\pdd.txt`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\_design_docs\command_palette\pdd.txt`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\_design_docs\commands_panel\pdd.txt`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\_design_docs\config_mgr\pdd.txt`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\_design_docs\core_base\pdd.txt`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\_design_docs\core_orchestrator\pdd.txt`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\_design_docs\core_schema\pdd.txt`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\_design_docs\main_ui\pdd.txt`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\_design_docs\migration_tool\pdd.txt`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\_design_docs\persona_tab\pdd.txt`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\_design_docs\run_agent\pdd.txt`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\_design_docs\schema_ops\pdd.txt`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\_design_docs\snapshot_worker\pdd.txt`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\_design_docs\spatial_engine\pdd.txt`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\_info\runtime_assets.json`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\AI_TTS_AGENT\__pycache__\agent_store.cpython-313.pyc`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\AI_TTS_AGENT\__pycache__\command_palette.cpython-313.pyc`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\AI_TTS_AGENT\__pycache__\commands_panel.cpython-313.pyc`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\AI_TTS_AGENT\__pycache__\core_base.cpython-313.pyc`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\AI_TTS_AGENT\__pycache__\core_orchestrator.cpython-313.pyc`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\AI_TTS_AGENT\__pycache__\core_schema.cpython-313.pyc`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\AI_TTS_AGENT\__pycache__\main_ui.cpython-313.pyc`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\AI_TTS_AGENT\__pycache__\persona_tab.cpython-313.pyc`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\AI_TTS_AGENT\__pycache__\snapshot_worker.cpython-313.pyc`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\AI_TTS_AGENT\agent_store.db`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\AI_TTS_AGENT\agent_store.db-shm`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\AI_TTS_AGENT\agent_store.db-wal`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\AI_TTS_AGENT\AI TTS INFO\awareness logic.txt`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\AI_TTS_AGENT\AI TTS INFO\info 0.txt`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\AI_TTS_AGENT\AI TTS INFO\info 1.txt`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\AI_TTS_AGENT\AI TTS INFO\info 2.txt`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\AI_TTS_AGENT\AI TTS INFO\info 3.txt`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\AI_TTS_AGENT\AI TTS INFO\info 4.txt`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\AI_TTS_AGENT\AI TTS INFO\info 5.txt`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\AI_TTS_AGENT\AI TTS INFO\llm_checkpoint_builder\__pycache__\__init__.cpython-313.pyc`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\AI_TTS_AGENT\AI TTS INFO\llm_checkpoint_builder\manifest.json`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\AI_TTS_AGENT\AI TTS INFO\new logic.txt`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\AI_TTS_AGENT\AI TTS INFO\new\icecream logic.txt`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\AI_TTS_AGENT\AI TTS INFO\new\info.txt`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\AI_TTS_AGENT\AI TTS INFO\new\info2.txt`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\AI_TTS_AGENT\AI TTS INFO\new\info3.txt`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\AI_TTS_AGENT\AI TTS INFO\new\info4.txt`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\AI_TTS_AGENT\AI TTS INFO\older info.txt`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\AI_TTS_AGENT\AI TTS INFO\the final convert.txt`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\AI_TTS_AGENT\AI TTS INFO\Zira Bot\__pycache__\agent_core.cpython-313.pyc`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\AI_TTS_AGENT\AI TTS INFO\Zira Bot\conversations\zira_default.sqlite3`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\AI_TTS_AGENT\AI TTS INFO\Zira Bot\feedback\zira_default.sqlite3`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\AI_TTS_AGENT\AI TTS INFO\Zira Bot\operators\InnerMonologue\schema.json`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\AI_TTS_AGENT\AI TTS INFO\Zira Bot\operators\Retriever\schema.json`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\AI_TTS_AGENT\AI TTS INFO\Zira Bot\operators\Rewriter\schema.json`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\AI_TTS_AGENT\AI TTS INFO\Zira Bot\profiles\zira\default\commands.json`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\AI_TTS_AGENT\AI TTS INFO\Zira Bot\Readme.md`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\AI_TTS_AGENT\AI TTS INFO\Zira Bot\schemas\chatbot\sets\default\schema.json`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\AI_TTS_AGENT\AI TTS INFO\Zira Bot\schemas\user\sets\default\schema.json`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\AI_TTS_AGENT\AI TTS INFO\Zira Bot\schemas\zira\sets\default\schema.json`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\AI_TTS_AGENT\conversations\zira_default.sqlite3`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\AI_TTS_AGENT\feedback\zira_default.sqlite3`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\AI_TTS_AGENT\profiles\zira\default\commands.json`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\AI_TTS_AGENT\profiles\zira\default\memory.json`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\AI_TTS_AGENT\Readme.md`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\AI_TTS_AGENT\settings.json`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\AI_TTS_AGENT\temp.wav`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\README.md`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\requirements.txt`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_info\runtime_assets.json`
- `Rant_PDD\Projects\AI_TTS_AGENT\project_summary.txt`
- `Rant_PDD\Projects\AI_TTS_AGENT\prompts_config.json`
- `Rant_PDD\Projects\FATHOM\conversation.db`
- `Rant_PDD\Projects\FATHOM\index.json`
- `Rant_PDD\Projects\FATHOM\pdd.txt`
- `Rant_PDD\Projects\FATHOM\project_info\runtime_assets.json`
- `Rant_PDD\Projects\FATHOM\prompts_config.json`
- `Rant_PDD\rant_pdd.log`


## Detailed Module Analyses


## Module `Analyze_folders.py`

```python
import os

def analyze_folders(start_path):
    script_name = os.path.basename(__file__)  # Get script file name
    analyze_file = os.path.join(start_path, "analyze.txt")  # Output file path

    with open(analyze_file, "w", encoding="utf-8") as file:
        file.write(f"Folder Analysis Report\n")
        file.write(f"{'='*50}\n\n")
        file.write(f"Root Directory: {start_path}\n\n")
        
        for root, dirs, files in os.walk(start_path):
            # Skip directories named 'venv'
            if "venv" in root.split(os.sep):
                continue

            level = root.replace(start_path, "").count(os.sep)
            indent = "|   " * level  # Tree structure formatting
            file.write(f"{indent}|-- {os.path.basename(root)}/\n")

            # Filter out the script and output file from the list of files
            filtered_files = [f for f in files if f not in {script_name, "analyze.txt"}]

            # List files in the directory
            for f in filtered_files:
                file_indent = "|   " * (level + 1)
                file.write(f"{file_indent}|-- {f}\n")
    
    print(f"Analysis complete. Results saved in {analyze_file}")

if __name__ == "__main__":
    script_directory = os.path.dirname(os.path.abspath(__file__))
    analyze_folders(script_directory)
```

**Functions:** analyze_folders(start_path)


## Module `Rant_PDD.py`

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Rant_PDD.py — 2025 UI refresh with full workflow, Explorer, Dataset controls, safe resets, Sync & Summary features, versioned repository sync, and Package for GitHub.
🦈 SHARK_SENTINEL DeepSeek Progressive Script Integration + GitHub Enhancements
----------------------------------------------------------------
• Concept shift: Burner Script → Progressive Script (permanent, versioned)
• Progressive Scripts Archive under Design_Documents/<module>/progressive_scripts
• Headers include PDD hash, model used, timestamp
• UI updates:
  - NEW purple buttons: Pull Repo, Update Repo (single-branch mode + GitHub Desktop option)
  - “Progressive Script” tab (renamed) with: ▸ Promote to Repo (archive/inject) ▸ Archive Current Version
  - NEW checkbox: Use GitHub Desktop — routes Pull/Update to also open the repo in GitHub Desktop for verification. Stores per-project repo URL/branch; pulls one branch only. Accepts Git URL or x-github-client:// link.
  - NEW checkbox: Single-branch only — enforces tracking only the selected branch.
  - NEW Update Repo dialog with CHECKBOXES: ▸ Include Progressive Scripts ▸ Include Design_Documents ▸ Include Info (project_info excluding repository) These choices are remembered per project across sessions.
• GitHub flows:
  - Pull Repo remembers URL + branch; single-branch clone/pull only.
  - Update Repo wipes target subfolders first (no residuals), copies selected items, commits, pushes, and optionally opens GitHub Desktop.
• Robust deletion:
  - Delete Repository now wipes ALL nested content including hidden .git on Windows.
  - Reset Project wipes everything and recreates minimal structure.
• Dual export packaging for GitHub (Design_Documents + generated scripts)
  - export_generated_scripts_* is fully wiped on each run, then ALL Progressive Scripts from every module are copied (all *.py versions), no residuals.
• Full backward compatibility with existing Codex-based workflow
• Auto-refresh Explorer after file ops + F5 refresh key
• System Console panel for live logs with colored syntax (STEP/PROGRESS/WARN/ERROR/SUCCESS)
Fixes and Notables (2025-08-06):
• **Streaming System Console**: Sync Repo now runs in a background thread with frequent progress ticks. You immediately see “Starting repository sync …” and periodic updates.
• **Ollama not running resilience**:
  - Centralized retry logic (bounded) for /api/chat and /api/embeddings with exponential backoff.
  - Early WARN/ERROR lines in the console if the local server is down; operations won’t hang the UI.
  - Embeddings gracefully skip; summaries log an error and continue the sync pipeline.
• **Update Repo dialog** revamped with checkboxes and per-project persistence.
• **Wipe/Save semantics (no residuals)** for Update Repo and Package for GitHub.
• **Task Type wiring** influences default options in Update Repo (Coding → include scripts; PDD → include design).
New Features (2025-08-06 Implementation):
• Human-like summaries with conversational prompts.
• Global Update Mode checkbox; repo-wide updates with diff extraction and per-script tasks.
• Launchable exports: UI selector for launch script, Launch button, error capture to versioned logs.
• Packaging checkboxes (Design Docs, Burner Lists, Burner Scripts); persisted; clean wipe; versioned branch naming.
• Codex directive file: generated if missing, persistent, included in exports.
• Integration: Global chat ties with Codex suggestions, PDD updates, summaries in human tone.
• Runtime testing: Capture stdout/stderr/exceptions, asset discovery after launch.
• Embedded humanistic prompts in prompts_config.json.
"""
import os
import sys
import json
import time
import sqlite3
import hashlib
import threading
import subprocess
import platform
import ctypes
import logging
import shutil
import stat
import re
import difflib
from logging.handlers import RotatingFileHandler
from pathlib import Path
from typing import List, Dict, Any, Optional, Tuple, Callable
import tkinter as tk
import tkinter.font as tkfont
import tkinter.simpledialog as simpledialog
from tkinter import messagebox
from tkinter import ttk
from tkinter.filedialog import askdirectory, askopenfilename
import speech_recognition as sr
import pyttsx3
import requests
import numpy as np
from scipy.spatial.distance import cosine

# -------------------- Paths / Config --------------------
ROOT_DIR = r"C:\Users\Art PC\Desktop\Rant_PDD"
BASE_DIR = os.path.join(ROOT_DIR, "Rant_PDD")
PROJECTS_DIR = os.path.join(BASE_DIR, "Projects")
os.makedirs(PROJECTS_DIR, exist_ok=True)
CONFIG_FILE = os.path.join(BASE_DIR, "config.json")
LOG_FILE = os.path.join(BASE_DIR, "rant_pdd.log")
UPDATE_WS_NAME = "project_info"
REPO_FOLDER = "repository"
THINK_DIR_NAME = "Logic_Thoughts"  # where <think> extractions go
DEFAULT_CONFIG = {
    "last_project": "",
    "tts_speed": 150,
    "tts_rate_factor": 1.0,
    "mic_device": 0,
    "context_depth": 20,
    "ollama_model_coding": "deepseek-coder-v2:16b",
    "ollama_model_text": "phi4:latest",  # Prefer embed2 if present; auto-detect in code when missing
    "embedding_model": "snowflake-arctic-embed2:latest",
    # Global defaults; project-specific settings are under "projects"
    "use_github_desktop_default": False,
    "single_branch_only_default": True,
    "projects": {  # "<project_name>": {
        # "use_github_desktop": bool,
        # "repo_url": "https://github.com/owner/repo.git" or "git@github.com:owner/repo.git"
        # or "x-github-client://openRepo/...",
        # "repo_branch": "main",
        # "single_branch_only": True,
        # "desktop_link": "x-github-client://openRepo/...",
        # "update_repo_options": {
        #     "include_scripts": True,
        #     "include_design": True,
        #     "include_info": False,
        #     "commit_direct": True,
        #     "commit_message": "Auto-injected progressive scripts from DeepSeek PDD update"
        # }
        # }
    },
    "global_update_mode": False,
    "launch_script": "main.py"
}
DEFAULT_PROMPTS = {
    "summary": (
        "Explain this script as if you’re handing it off to a new developer. Include why it exists, what its main functions do, how it connects to other parts of the project, and what someone maintaining it needs to know. Use a conversational but professional tone."
    ),
    "consistency": (
        "Scan the entire PDD for conflicts with the new update. "
        "Output only lines like: Section:<id>|Reason:<reason>\n\n"
        "New update:\n{summary}\n\nPDD:\n{full_pdd}"
    ),
    "rewrite": (
        "Rewrite ONLY this section to resolve the inconsistency and align with the new update.\n\n"
        "Section:\n{section_text}\n\nNew update:\n{summary}\n\nReason:\n{reason}"
    ),
    "pseudo": (
        "Pseudo-Code Bot: walk each new PDD section and inject light pseudocode hints "
        "wherever UI elements or code snippets were requested. "
        "Enclose each hint in /* … */ so we can strip or style them later.\n\nPDD:\n{full_pdd}"
    ),
    "burner_script": (
        "Draft a first pass Python script that implements the key behaviors described in this PDD. "
        "Be pragmatic; use TODOs where necessary.\n\nPDD:\n{pdd}"
    ),
    "prep_rewrite": (
        "Rewrite this text more clearly and concisely, preserving meaning:\n\n{text}"
    ),
    "project_sync": (
        "You are a project analyst. Summarize the entire project folder, including all code snippets, "
        "markdown, JSON, and existing PDD, into a single comprehensive PDD instantiation. "
        "Be detailed, structured, and ready for code implementation."
    ),
    "project_overview": (
        "Provide a static overview summary of this project: include high-level goals, "
        "folder structure, key modules, and the current PDD. Do not modify the PDD—just summarize."
    ),
    "global_diff_extraction": (
        "Take the user’s repository-wide instructions and, for each script, identify what changes need to be made and why. Generate a per-script task list that describes these changes in natural, human-readable language but is still actionable by an AI update pipeline. Output these tasks as structured JSON."
    ),
    "human_pdd_update": (
        "Update the PDD for this script to reflect new global architecture changes requested by the user and informed by Codex improvement suggestions. Include:\n1. Why this change was necessary.\n2. How it affects the script’s role in the system.\n3. What functions or components were modified or added.\n4. How it integrates with related scripts.\nUse a conversational but technical tone, like an experienced engineer documenting design changes for their team."
    ),
    "human_summary_update": (
        "Summarize the latest changes to this script after a global update. Focus on what was added or changed and why, and explain how it affects the overall workflow. Write as if to a teammate picking up this code tomorrow."
    ),
    "runtime_documentation": (
        "When launching this repo version, capture all runtime errors and warnings. Present them in a human-readable list explaining what each error means, where it likely originates, and what it impacts. Include file names, line numbers, and probable causes."
    ),
    "packaging": (
        "Package the repository as a new version branch. Include all active Python scripts, dependencies, and metadata (README, requirements.txt). Ensure folder structure matches a real repo root. Create a new GitHub branch using this folder as the base."
    ),
    "improvement_file": (
        "Create a directives file in the repo root instructing Codex to analyze the repository for structural and logic improvements. Ensure it contains explicit do-not-delete instructions and blank space for Codex to fill in improvement notes."
    ),
    "global_chat_execution": (
        "User has requested a repository-wide change. Determine which scripts are affected, generate per-script task plans, integrate Codex improvement suggestions, and update each script’s PDD, summary, pseudocode, and burner script. Stream all actions to the console and update Codex improvement directives for future review."
    ),
    "runtime_testing": (
        "Run the exported branch version using the selected launch script. Capture all console output, Python exceptions, and dynamically created files. Save logs and asset lists in project_info for future analysis."
    ),
    "pdd_generation": (
        "Generate a full Program Design Document for this script. Explain it like an experienced engineer onboarding a new team member. Cover purpose, design choices, dependencies, and potential evolution. Use clear, conversational language while staying technically precise."
    ),
    "summary_generation": (
        "Summarize this script for quick understanding. Explain why it exists, what it does, and how it connects to other parts of the system. Use a conversational but professional tone as if handing off to another developer."
    ),
    "codex_suggestion": (
        "Analyze the entire repository and propose changes to improve structure, performance, or clarity. Include missing features, refactor opportunities, and integration gaps. Write in human-readable actionable steps."
    ),
}

# -------------------- Logging --------------------
logging.basicConfig(level=logging.INFO, format="[%(asctime)s] %(levelname)s: %(message)s")
logger = logging.getLogger("RantPDD")
try:
    logger.addHandler(RotatingFileHandler(LOG_FILE, maxBytes=10**6, backupCount=5))
except Exception:
    pass

# -------------------- DPI / Scaling --------------------
def _set_process_dpi_awareness() -> None:
    if platform.system() == "Windows":
        try:
            ctypes.windll.shcore.SetProcessDpiAwareness(2)
        except Exception:
            try:
                ctypes.windll.user32.SetProcessDPIAware()
            except Exception:
                pass

def _apply_tk_scaling(root: tk.Tk, base_px: int = 96) -> None:
    scale = 1.0
    if platform.system() == "Windows":
        try:
            hwnd = ctypes.windll.user32.GetForegroundWindow()
            dpi = ctypes.windll.user32.GetDpiForWindow(hwnd)
            scale = max(0.8, dpi / base_px)
        except Exception:
            pass
    try:
        root.call("tk", "scaling", scale)
    except Exception:
        pass

# -------------------- Theme & Contrast --------------------
def get_contrast_color(bg_hex: str) -> str:
    r, g, b = (int(bg_hex[i:i+2], 16) for i in (1, 3, 5))
    brightness = (r*299 + g*587 + b*114) / 1000
    return "#000000" if brightness > 125 else "#FFFFFF"

# Module-level theme constants so widgets can reference them safely
THEME_BG = "#0F1115"
THEME_SUR = "#151922"
THEME_ELEV = "#1B2130"
THEME_TEXT = get_contrast_color(THEME_BG)
THEME_ACC = "#60A5FA"
THEME_ACC2 = "#93C5FD"

# Console color palette
CLR_INFO = "#93C5FD"  # soft blue
CLR_WARN = "#FACC15"  # yellow
CLR_ERROR = "#F87171"  # red
CLR_STEP = "#22D3EE"  # cyan
CLR_SUCCESS = "#34D399"  # green
CLR_PROGRESS = "#C084FC"  # violet
CLR_MUTED = "#9CA3AF"  # gray

def apply_modern_theme(style: ttk.Style) -> None:
    style.theme_use("clam")
    for name in ("TFrame", "TLabelframe"):
        style.configure(name, background=THEME_BG)
    style.configure("TLabelframe.Label", background=THEME_BG, foreground=THEME_TEXT)
    style.configure("TLabel", background=THEME_BG, foreground=THEME_TEXT)
    style.configure("TButton", background=THEME_ACC, foreground=get_contrast_color(THEME_ACC), padding=(10, 6), borderwidth=0)
    style.map("TButton", background=[("active", THEME_ACC2)])
    style.configure("Secondary.TButton", background=THEME_SUR, foreground=get_contrast_color(THEME_SUR), padding=(10, 6))
    style.map("Secondary.TButton", background=[("active", THEME_ELEV)])
    style.configure("Purple.TButton", background="#9b59b6", foreground="white", padding=(10, 6))
    style.map("Purple.TButton", background=[("active", "#8e44ad")])
    style.configure("TEntry", fieldbackground=THEME_ELEV, background=THEME_ELEV, foreground=get_contrast_color(THEME_ELEV))
    style.configure("TCombobox", fieldbackground=THEME_ELEV, background=THEME_ELEV, foreground=get_contrast_color(THEME_ELEV))
    style.configure("Treeview", background=THEME_ELEV, fieldbackground=THEME_ELEV, foreground=get_contrast_color(THEME_ELEV), rowheight=24)
    style.map("Treeview", background=[("selected", "#2b5797")])
    base = ("Segoe UI Variable", 10) if platform.system() == "Windows" else ("Helvetica", 11)
    mono = ("Cascadia Mono", 10) if platform.system() == "Windows" else ("Menlo", 11)
    try:
        tkfont.nametofont("TkDefaultFont").configure(family=base[0], size=base[1])
        tkfont.nametofont("TkTextFont").configure(family=base[0], size=base[1])
        tkfont.nametofont("TkFixedFont").configure(family=mono[0], size=mono[1])
    except Exception:
        pass

# -------------------- Retry helpers for Ollama --------------------
def _retry(fn: Callable[[], Any], *, attempts: int = 3, base_delay: float = 0.6, what: str = "request") -> Any:
    """ Simple bounded retry with exponential backoff. Logs WARN on failures. Returns the function result or raises the last exception. """
    last_exc = None
    for i in range(attempts):
        try:
            return fn()
        except Exception as e:
            last_exc = e
            wait = base_delay * (2 ** i)
            logger.warning(f"{what} attempt {i+1}/{attempts} failed: {e}; retrying in {wait:.1f}s")
            time.sleep(wait)
    raise last_exc if last_exc else RuntimeError(f"{what} failed without exception")

# -------------------- Ollama helpers --------------------
def discover_ollama_models() -> List[str]:
    models = []
    try:
        out = subprocess.check_output(["ollama", "list"], text=True, timeout=4)
        for line in out.splitlines()[1:]:
            parts = line.split()
            if parts:
                models.append(parts[0])
    except Exception as e:
        logger.info("ollama list failed: %s", e)
    # Sensible defaults if detection fails
    models.extend([
        "deepseek-coder-v2:16b",
        "phi4:latest",
        "snowflake-arctic-embed2:latest",
        "snowflake-arctic-embed:latest"
    ])
    return sorted(set(models))

def _choose_embedding_model(configured: str) -> str:
    """Prefer configured; if not present in 'ollama list', try to pick an installed embed model."""
    try:
        out = subprocess.check_output(["ollama", "list"], text=True, timeout=4)
        names = [ln.split()[0] for ln in out.splitlines()[1:] if ln.strip()]
        if configured in names:
            return configured
        for cand in names:
            if "embed" in cand:
                return cand
        for cand in ["snowflake-arctic-embed2:latest", "snowflake-arctic-embed:latest"]:
            if cand in names:
                return cand
    except Exception:
        pass
    return configured  # try as-is

def _ollama_post(host: str, endpoint: str, payload: dict, timeout: int):
    return requests.post(f"{host}{endpoint}", json=payload, timeout=timeout)

def call_ollama_chat(model: str, prompt: str, timeout: int = 60) -> str:
    """ Chat wrapper with retries and fallbacks. Non-blocking UI (caller should be on worker thread). """
    hosts = ("http://localhost:11434", "http://127.0.0.1:11434")
    last_err = ""
    def _try_chat_once():
        nonlocal last_err
        for host in hosts:
            try:
                resp = _ollama_post(host, "/api/chat", {"model": model, "messages": [{"role": "user", "content": prompt}], "stream": False}, timeout)
                if resp.status_code == 404:  # Older server may support /api/generate
                    resp = _ollama_post(host, "/api/generate", {"model": model, "prompt": prompt, "stream": False}, timeout)
                resp.raise_for_status()
                j = resp.json()
                if isinstance(j, dict):
                    if "message" in j and isinstance(j["message"], dict):
                        return j["message"].get("content", "")
                    if "response" in j:
                        return j["response"]
                return ""
            except Exception as e:
                last_err = str(e)
                continue
        raise RuntimeError(last_err or "Ollama chat unreachable")
    try:
        return _retry(_try_chat_once, attempts=3, base_delay=0.7, what="ollama chat")
    except Exception as e:
        logger.error("Ollama chat error: %s", e)
        return f"Error: {e}"

def embed(text: str, model: str) -> Optional[List[float]]:
    """ Robust embeddings:
    • Uses /api/embeddings with {"input": "..."} (current spec).
    • Auto-picks an installed embedding model if the configured one is missing.
    • Bounded retries; returns None on failure (UI remains responsive).
    """
    chosen = _choose_embedding_model(model)
    payload_primary = {"model": chosen, "input": text}
    payload_legacy = {"model": chosen, "prompt": text}  # some older builds used 'prompt'
    hosts = ("http://localhost:11434", "http://127.0.0.1:11434")
    def _try_embed_once():
        last_exc = None
        for host in hosts:
            try:
                r = _ollama_post(host, "/api/embeddings", payload_primary, 18)
                if r.status_code == 404:
                    r = _ollama_post(host, "/api/embeddings", payload_legacy, 18)
                r.raise_for_status()
                j = r.json()
                if isinstance(j, dict):
                    if "embedding" in j:
                        return j.get("embedding")
                    if "data" in j and isinstance(j["data"], list) and j["data"]:
                        return j["data"][0].get("embedding")
                return None
            except Exception as e:
                last_exc = e
                continue
        if last_exc:
            raise last_exc
        return None
    try:
        return _retry(_try_embed_once, attempts=2, base_delay=0.5, what="ollama embeddings")
    except Exception as e:
        logger.warning("Embedding error (skipping): %s", e)
        return None

def cos(a, b) -> float:
    if a is None or b is None:
        return 0.0
    return 1 - cosine(np.array(a), np.array(b))

# -------------------- Git helpers --------------------
def run_git(args: List[str], cwd: str) -> Tuple[int, str, str]:
    try:
        cp = subprocess.run(
            ["git"] + args,
            cwd=cwd,
            text=True,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE
        )
        return cp.returncode, cp.stdout, cp.stderr
    except Exception as e:
        return 1, "", str(e)

def git_is_repo(path: str) -> bool:
    code, out, _ = run_git(["rev-parse", "--is-inside-work-tree"], cwd=path)
    return code == 0 and out.strip() == "true"

# -------------------- Consistency parsing --------------------
def parse_tasks(text: str) -> List[Dict[str, str]]:
    tasks = []
    for line in text.splitlines():
        if line.strip().startswith("Section:"):
            parts = [p.strip() for p in line.split("|")]
            try:
                sid = parts[0].split(":", 1)[1].strip()
                reason = parts[1].split(":", 1)[1].strip()
                tasks.append({"section_id": sid, "reason": reason})
            except Exception:
                pass
    return tasks

# -------------------- Robust deletion helpers --------------------
def _on_rm_error(func, path, exc_info):
    # Clear read-only and retry
    try:
        os.chmod(path, stat.S_IWRITE)
        func(path)
    except Exception:
        pass

def wipe_directory_contents(folder: Path):
    """Delete EVERYTHING inside a folder (including hidden .git trees) cross-platform."""
    if not folder.exists():
        return
    for entry in folder.iterdir():
        try:
            if entry.is_dir():
                shutil.rmtree(entry, onerror=_on_rm_error)
            else:
                try:
                    os.chmod(entry, stat.S_IWRITE)
                except Exception:
                    pass
                entry.unlink(missing_ok=True)
        except Exception:
            # Last resort: attempt with OS shell on Windows for stubborn files
            if platform.system() == "Windows":
                try:
                    subprocess.run(["cmd", "/c", "rmdir", "/s", "/q", str(entry)], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
                    subprocess.run(["cmd", "/c", "del", "/f", "/q", str(entry)], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
                except Exception:
                    pass

# -------------------- Update Repo dialog (with checkboxes, persisted) --------------------
class UpdateRepoDialog(tk.Toplevel):
    def __init__(self, parent, default_branch: str, defaults: Dict[str, Any]):
        """ defaults keys: include_scripts (bool), include_design (bool), include_info (bool), commit_direct (bool), commit_message (str) """
        super().__init__(parent)
        self.title("Update Repository")
        self.configure(bg=THEME_BG)
        self.resizable(False, False)
        self.include_scripts = tk.BooleanVar(value=bool(defaults.get("include_scripts", True)))
        self.include_design = tk.BooleanVar(value=bool(defaults.get("include_design", True)))
        self.include_info = tk.BooleanVar(value=bool(defaults.get("include_info", False)))
        self.include_burner_lists = tk.BooleanVar(value=bool(defaults.get("include_burner_lists", False)))
        self.include_burner_scripts = tk.BooleanVar(value=bool(defaults.get("include_burner_scripts", False)))
        self.commit_direct = tk.BooleanVar(value=bool(defaults.get("commit_direct", True)))
        self.commit_message = tk.StringVar(value=defaults.get("commit_message", "Auto-injected progressive scripts from DeepSeek PDD update"))
        ttk.Label(self, text="What do you want to send? (remembered per project)", background=THEME_BG, foreground=THEME_TEXT).pack(anchor="w", padx=10, pady=(10, 6))
        ttk.Checkbutton(self, text="Include Progressive Scripts (ALL archived *.py)", variable=self.include_scripts).pack(anchor="w", padx=18)
        ttk.Checkbutton(self, text="Include Design_Documents", variable=self.include_design).pack(anchor="w", padx=18)
        ttk.Checkbutton(self, text=f"Include Info (/{UPDATE_WS_NAME} excluding /{UPDATE_WS_NAME}/{REPO_FOLDER})", variable=self.include_info).pack(anchor="w", padx=18)
        ttk.Checkbutton(self, text="Include Burner Lists", variable=self.include_burner_lists).pack(anchor="w", padx=18)
        ttk.Checkbutton(self, text="Include Burner Scripts", variable=self.include_burner_scripts).pack(anchor="w", padx=18)
        ttk.Label(self, text="Commit message:", background=THEME_BG, foreground=THEME_TEXT).pack(anchor="w", padx=10, pady=(10, 2))
        e = ttk.Entry(self, textvariable=self.commit_message, width=64)
        e.pack(fill="x", padx=10)
        ttk.Checkbutton(self, text=f"Commit directly to '{default_branch}' (single-branch mode)", variable=self.commit_direct).pack(anchor="w", padx=10, pady=(10, 2))
        btns = ttk.Frame(self)
        btns.pack(fill="x", padx=10, pady=(10, 10))
        ttk.Button(btns, text="Cancel", command=self.destroy, style="Secondary.TButton").pack(side="right")
        ttk.Button(btns, text="Update", command=self._do_ok).pack(side="right", padx=6)
        self.ok = False
        self.grab_set()
        self.protocol("WM_DELETE_WINDOW", self.destroy)

    def _do_ok(self):
        self.ok = True
        self.destroy()

# -------------------- Package Dialog --------------------
class PackageDialog(tk.Toplevel):
    def __init__(self, parent, defaults: Dict[str, Any]):
        super().__init__(parent)
        self.title("Package for GitHub")
        self.configure(bg=THEME_BG)
        self.resizable(False, False)
        self.include_design = tk.BooleanVar(value=bool(defaults.get("include_design", True)))
        self.include_burner_lists = tk.BooleanVar(value=bool(defaults.get("include_burner_lists", False)))
        self.include_burner_scripts = tk.BooleanVar(value=bool(defaults.get("include_burner_scripts", False)))
        ttk.Label(self, text="What do you want to include? (remembered per project)", background=THEME_BG, foreground=THEME_TEXT).pack(anchor="w", padx=10, pady=(10, 6))
        ttk.Checkbutton(self, text="Include Design Documents", variable=self.include_design).pack(anchor="w", padx=18)
        ttk.Checkbutton(self, text="Include Burner Lists", variable=self.include_burner_lists).pack(anchor="w", padx=18)
        ttk.Checkbutton(self, text="Include Burner Scripts", variable=self.include_burner_scripts).pack(anchor="w", padx=18)
        btns = ttk.Frame(self)
        btns.pack(fill="x", padx=10, pady=(10, 10))
        ttk.Button(btns, text="Cancel", command=self.destroy, style="Secondary.TButton").pack(side="right")
        ttk.Button(btns, text="Package", command=self._do_ok).pack(side="right", padx=6)
        self.ok = False
        self.grab_set()
        self.protocol("WM_DELETE_WINDOW", self.destroy)

    def _do_ok(self):
        self.ok = True
        self.destroy()

# -------------------- Main App --------------------
class RantPDD:
    def __init__(self, root: tk.Tk):
        self.root = root
        sw, sh = root.winfo_screenwidth(), root.winfo_screenheight()
        root.geometry(f"{min(1920, sw)}x{min(1080, sh)}")
        self.db_lock = threading.RLock()
        self.config = self._load_config()
        self.prompts = DEFAULT_PROMPTS.copy()
        self.current_project: Optional[str] = None
        self.current_db: Optional[sqlite3.Connection] = None
        self.sections: List[Dict[str, Any]] = []
        self.pdd_lines: List[str] = []
        self.tts = None
        self.tts_muted = False
        self.recognizer = None
        self.mic = None
        self.listening = False
        self.stt_thread: Optional[threading.Thread] = None
        self.task_type = tk.StringVar(value="PDD")  # Default task type
        self.global_mode = tk.BooleanVar(value=False)
        style = ttk.Style()
        apply_modern_theme(style)
        self._build_ui()
        self._init_audio()
        # Hook F5 to refresh
        self.root.bind("<F5>", lambda e: self._refresh_all_views())
        # Attach live console handler with color-aware emit
        class TkConsoleHandler(logging.Handler):
            def __init__(self, app):
                super().__init__()
                self.app = app
            def emit(self, record):
                msg = self.format(record)
                level = record.levelname.upper()
                # Marshal to UI thread with tag based on level
                self.app.root.after(0, self.app._console_write, msg, level)
        h = TkConsoleHandler(self)
        h.setLevel(logging.INFO)
        logger.addHandler(h)
        self._refresh_projects()
        if self.config["last_project"]:
            self._switch_project(self.config["last_project"])

    # ---------- config ----------
    def _load_config(self) -> Dict[str, Any]:
        d = DEFAULT_CONFIG.copy()
        try:
            if os.path.exists(CONFIG_FILE):
                loaded = json.loads(Path(CONFIG_FILE).read_text())
                # Deep-merge for "projects"
                d.update({k: v for k, v in loaded.items() if k != "projects"})
                pj = d.get("projects", {}).copy()
                pj.update(loaded.get("projects", {}))
                d["projects"] = pj
        except Exception:
            pass
        return d

    def _save_config(self):
        # Persist global toggles
        self.config["context_depth"] = int(self.sld_context.get())
        self.config["tts_rate_factor"] = float(self.sld_tts_speed.get())
        # Persist per-project repo settings
        if self.current_project:
            name = os.path.basename(self.current_project)
            proj_cfg = self.config["projects"].setdefault(name, {})
            proj_cfg["use_github_desktop"] = bool(self.use_desktop.get())
            proj_cfg["single_branch_only"] = bool(self.single_branch_only.get())
            proj_cfg["global_update_mode"] = bool(self.global_mode.get())
            proj_cfg["launch_script"] = self.cmb_launch_script.get()
        try:
            Path(CONFIG_FILE).write_text(json.dumps(self.config, indent=2))
        except Exception:
            pass

    # Helpers for per-project repo settings
    def _proj_cfg(self) -> Dict[str, Any]:
        name = os.path.basename(self.current_project) if self.current_project else ""
        cfg = self.config["projects"].setdefault(name, {})
        # Apply defaults if missing
        cfg.setdefault("use_github_desktop", self.config.get("use_github_desktop_default", False))
        cfg.setdefault("single_branch_only", self.config.get("single_branch_only_default", True))
        cfg.setdefault("repo_url", "")
        cfg.setdefault("repo_branch", "main")
        cfg.setdefault("desktop_link", "")  # optional x-github-client link
        cfg.setdefault("update_repo_options", {
            "include_scripts": True,
            "include_design": True,
            "include_info": False,
            "include_burner_lists": False,
            "include_burner_scripts": False,
            "commit_direct": True,
            "commit_message": "Auto-injected progressive scripts from DeepSeek PDD update",
        })
        cfg.setdefault("package_options", {
            "include_design": True,
            "include_burner_lists": False,
            "include_burner_scripts": False,
        })
        cfg.setdefault("global_update_mode", False)
        cfg.setdefault("launch_script", "main.py")
        return cfg

    # ---------- audio ----------
    def _init_audio(self):
        try:
            self.tts = pyttsx3.init()
            base_rate = DEFAULT_CONFIG["tts_speed"]
            factor = self.config.get("tts_rate_factor", 1.0)
            self.tts.setProperty("rate", int(base_rate * factor))
            # Force Zira if present
            for v in self.tts.getProperty("voices"):
                if "zira" in (v.name or "").lower():
                    self.tts.setProperty("voice", v.id)
                    break
        except Exception as e:
            logger.warning("TTS init error: %s", e)
            self.tts = None
        try:
            self.recognizer = sr.Recognizer()
            self.mic = sr.Microphone(device_index=self.config["mic_device"])
        except Exception as e:
            logger.warning("STT init error: %s", e)
            self.recognizer = None
            self.mic = None

    # ---------- UI construction ----------
    def _build_ui(self):
        _apply_tk_scaling(self.root)
        # Toolbar
        tb = ttk.Frame(self.root, padding=8)
        tb.pack(side="top", fill="x")
        ttk.Label(tb, text="Project:").pack(side="left")
        self.cmb_project = ttk.Combobox(tb, state="readonly", width=28)
        self.cmb_project.pack(side="left", padx=6)
        self.cmb_project.bind("<<ComboboxSelected>>", lambda e: self._switch_project(self.cmb_project.get()))
        ttk.Button(tb, text="New Project", command=self._create_project).pack(side="left", padx=6)
        ttk.Button(tb, text="Add Local Repo", command=self._add_local_repo, style="Secondary.TButton").pack(side="left", padx=6)
        # Backward-compatible Clone; new Pull (Purple) preferred
        ttk.Button(tb, text="Clone Repo", command=self._clone_repo, style="Secondary.TButton").pack(side="left", padx=6)
        ttk.Button(tb, text="Pull Repo", command=self._pull_repo, style="Purple.TButton").pack(side="left", padx=6)
        ttk.Button(tb, text="Update Repo", command=self._update_repo_with_progressive, style="Purple.TButton").pack(side="left", padx=6)
        ttk.Button(tb, text="Delete Repository", command=self._delete_repository, style="Secondary.TButton").pack(side="left", padx=6)
        ttk.Button(tb, text="Reset Data Set", command=self._reset_data_set, style="Secondary.TButton").pack(side="left", padx=6)
        ttk.Button(tb, text="Reset Project", command=self._reset_project_folder, style="Secondary.TButton").pack(side="left", padx=6)
        ttk.Button(tb, text="Open in Explorer", command=self._open_in_explorer, style="Secondary.TButton").pack(side="left", padx=6)
        ttk.Button(tb, text="Refresh (F5)", command=self._refresh_all_views, style="Secondary.TButton").pack(side="left", padx=6)
        ttk.Label(tb, text="Task Type:").pack(side="left", padx=(18, 0))
        self.cmb_task = ttk.Combobox(tb, state="readonly", values=["PDD", "Coding"], width=10, textvariable=self.task_type)
        self.cmb_task.pack(side="left", padx=6)
        self.cmb_task.set("PDD")
        self.cmb_task.bind("<<ComboboxSelected>>", lambda e: self._update_task_type())
        ttk.Label(tb, text="Context:").pack(side="left", padx=(18, 0))
        self.sld_context = ttk.Scale(tb, from_=1, to=60, value=self.config.get("context_depth", 20), orient="horizontal", length=160)
        self.sld_context.pack(side="left", padx=6)
        self.sld_context.bind("<ButtonRelease-1>", lambda e: self._save_config())
        ttk.Button(
            tb, text="Prompt/LLM Control", command=lambda: PromptControlDialog(self.root, self.prompts, app_ref=self), style="Secondary.TButton"
        ).pack(side="left", padx=10)
        # NOTE: Sync Repository now runs async (threaded) to keep UI/console alive
        ttk.Button(tb, text="Sync Repository", command=self._sync_repository, style="Secondary.TButton").pack(side="left", padx=6)
        ttk.Button(tb, text="Package for GitHub", command=self._package_for_github, style="Secondary.TButton").pack(side="left", padx=6)
        # Versions controls
        ttk.Label(tb, text="Version:").pack(side="left", padx=(18, 0))
        self.cmb_version = ttk.Combobox(tb, state="readonly", width=22)
        self.cmb_version.pack(side="left", padx=6)
        self.cmb_version.bind("<<ComboboxSelected>>", lambda e: self._load_version(self.cmb_version.get()))
        ttk.Button(tb, text="Save Version", command=self._save_version, style="Secondary.TButton").pack(side="left", padx=6)
        # Git Ops toggles
        ttk.Label(tb, text="Git Ops:").pack(side="left", padx=(18, 2))
        self.use_desktop = tk.BooleanVar(value=self.config.get("use_github_desktop_default", False))
        self.single_branch_only = tk.BooleanVar(value=self.config.get("single_branch_only_default", True))
        ttk.Checkbutton(tb, text="Use GitHub Desktop", variable=self.use_desktop, command=self._save_config).pack(side="left", padx=(2, 12))
        ttk.Checkbutton(tb, text="Single-branch only", variable=self.single_branch_only, command=self._save_config).pack(side="left", padx=(0, 6))
        # Global Mode
        ttk.Checkbutton(tb, text="Global Update Mode", variable=self.global_mode, command=self._save_config).pack(side="left", padx=(0, 6))
        # Launch Controls
        ttk.Label(tb, text="Launch Script:").pack(side="left", padx=(18, 0))
        self.cmb_launch_script = ttk.Combobox(tb, state="readonly", width=20)
        self.cmb_launch_script.pack(side="left", padx=6)
        ttk.Button(tb, text="Set Launch", command=self._set_launch_script, style="Secondary.TButton").pack(side="left", padx=6)
        ttk.Button(tb, text="Test Launch", command=self._test_launch, style="Secondary.TButton").pack(side="left", padx=6)
        ttk.Button(tb, text="Mark Stable", command=self._mark_stable, style="Secondary.TButton").pack(side="left", padx=6)
        ttk.Button(tb, text="Launch Script", command=self._launch_script, style="Secondary.TButton").pack(side="left", padx=6)
        # Main Paned: Explorer | Center
        outer = ttk.PanedWindow(self.root, orient="horizontal")
        outer.pack(fill="both", expand=True)
        # LEFT — Explorer + Viewer + Program Design Manager + Console
        left = ttk.PanedWindow(outer, orient="vertical")
        outer.add(left, weight=1)
        # Explorer
        lf1 = ttk.Labelframe(left, text="Explorer", padding=6)
        left.add(lf1, weight=2)
        self.tree = ttk.Treeview(lf1, show="tree")
        self.tree.pack(side="left", fill="both", expand=True)
        ysb = ttk.Scrollbar(lf1, orient="vertical", command=self.tree.yview)
        self.tree.configure(yscrollcommand=ysb.set)
        ysb.pack(side="right", fill="y")
        self.tree.bind("<<TreeviewSelect>>", lambda e: self._on_tree_select())
        # Viewer
        lf2 = ttk.Labelframe(left, text="Viewer", padding=6)
        left.add(lf2, weight=2)
        mono = tkfont.nametofont("TkFixedFont")
        self.file_view = tk.Text(lf2, bg=THEME_BG, fg=THEME_TEXT, insertbackground=THEME_TEXT, wrap="none", font=mono)
        self.file_view.pack(side="left", fill="both", expand=True)
        ysv = ttk.Scrollbar(lf2, orient="vertical", command=self.file_view.yview)
        self.file_view.configure(yscrollcommand=ysv.set)
        ysv.pack(side="right", fill="y")
        ttk.Button(lf2, text="Delete Selected", command=self._delete_selected, style="Secondary.TButton").pack(side="bottom", pady=4)
        # Program Design Manager
        pdm = ttk.Labelframe(left, text="Program Design Manager", padding=6)
        left.add(pdm, weight=1)
        self.pdd_list = tk.Listbox(pdm, bg=THEME_ELEV, fg=THEME_TEXT, selectbackground="#2b5797")
        self.pdd_list.pack(side="left", fill="both", expand=True)
        self.pdd_list.bind("<<ListboxSelect>>", lambda e: self._on_pdd_list_select())
        pdm_buttons = ttk.Frame(pdm)
        pdm_buttons.pack(side="right", fill="y")
        ttk.Button(pdm_buttons, text="New Subfolder", command=self._new_pdd_subfolder, style="Secondary.TButton").pack(pady=4)
        ttk.Button(pdm_buttons, text="Delete Subfolder", command=self._delete_pdd_subfolder, style="Secondary.TButton").pack(pady=4)
        ttk.Button(pdm_buttons, text="Rename Subfolder", command=self._rename_pdd_subfolder, style="Secondary.TButton").pack(pady=4)
        ttk.Button(pdm_buttons, text="Add Burner Script", command=self._add_burner_script_to_selected, style="Secondary.TButton").pack(pady=4)
        # System Console
        con = ttk.Labelframe(left, text="System Console", padding=6)
        left.add(con, weight=1)
        self.console = tk.Text(con, height=10, bg=THEME_ELEV, fg=THEME_TEXT, insertbackground=THEME_TEXT, wrap="word", font=mono, padx=8, pady=6, state="disabled")
        self.console.pack(side="left", fill="both", expand=True)
        # Tag colors for syntax highlighting
        for tag, fg in [("INFO", CLR_INFO), ("WARN", CLR_WARN), ("ERROR", CLR_ERROR), ("STEP", CLR_STEP), ("SUCCESS", CLR_SUCCESS), ("PROGRESS", CLR_PROGRESS), ("MUTED", CLR_MUTED)]:
            self.console.tag_config(tag, foreground=fg)
        con_scroll = ttk.Scrollbar(con, orient="vertical", command=self.console.yview)
        self.console.configure(yscrollcommand=con_scroll.set)
        con_scroll.pack(side="right", fill="y")
        btns = ttk.Frame(con)
        btns.pack(side="bottom", fill="x", pady=4)
        ttk.Button(btns, text="Clear Console", command=self._clear_console, style="Secondary.TButton").pack(side="right")
        # CENTER — Prep + Input + Workflow
        center = ttk.Labelframe(outer, text="Chat / Workflow", padding=6)
        outer.add(center, weight=2)
        # PREP
        prep_frame = ttk.Labelframe(center, text="Prep (curated to send)", padding=6)
        prep_frame.pack(fill="both", expand=False)
        self.txt_prep = tk.Text(prep_frame, height=10, bg=THEME_ELEV, fg=THEME_TEXT, insertbackground=THEME_TEXT, wrap="word", font=mono, padx=8, pady=6)
        self.txt_prep.pack(side="left", fill="both", expand=True)
        prep_scroll = ttk.Scrollbar(prep_frame, orient="vertical", command=self.txt_prep.yview)
        self.txt_prep.configure(yscrollcommand=prep_scroll.set)
        prep_scroll.pack(side="right", fill="y")
        ttk.Button(prep_frame, text="Rewrite Prep", command=self._rewrite_prep, style="Secondary.TButton").pack(side="bottom", pady=4)
        # INPUT
        in_frame = ttk.Labelframe(center, text="Input (typing + speech-to-text)", padding=6)
        in_frame.pack(fill="both", expand=False, pady=(6, 0))
        self.txt_input = tk.Text(in_frame, height=6, bg=THEME_ELEV, fg=THEME_TEXT, insertbackground=THEME_TEXT, wrap="word", font=mono, padx=8, pady=6)
        self.txt_input.pack(side="left", fill="both", expand=True)
        in_scroll = ttk.Scrollbar(in_frame, orient="vertical", command=self.txt_input.yview)
        self.txt_input.configure(yscrollcommand=in_scroll.set)
        in_scroll.pack(side="right", fill="y")
        self.txt_input.bind("<Return>", self._send_on_enter)
        self.txt_input.bind("<KP_Enter>", self._send_on_enter)
        # INPUT ACTIONS
        in_actions = ttk.Frame(center)
        in_actions.pack(fill="x", pady=(4, 2))
        self.btn_sync = ttk.Button(in_actions, text="Sync Project", command=self._sync_to_project, style="Secondary.TButton")
        self.btn_sync.pack(side="left", padx=(0, 4))
        ttk.Button(in_actions, text="Send to Prep", command=self._send_to_prep).pack(side="left")
        ttk.Button(in_actions, text="Clear Prep", command=lambda: self.txt_prep.delete("1.0", "end"), style="Secondary.TButton").pack(side="left", padx=6)
        ttk.Button(in_actions, text="Add to PDD", command=self._send_prep_to_llm).pack(side="left", padx=6)
        ttk.Button(in_actions, text="Append Prep → PDD", command=self._append_prep_to_pdd, style="Secondary.TButton").pack(side="left", padx=6)
        ttk.Button(in_actions, text="Start Mic", command=self._start_mic, style="Secondary.TButton").pack(side="left", padx=6)
        ttk.Button(in_actions, text="Stop Mic", command=self._stop_mic, style="Secondary.TButton").pack(side="left", padx=6)
        ttk.Button(in_actions, text="Stop TTS", command=self._stop_tts_immediate, style="Secondary.TButton").pack(side="left", padx=6)
        ttk.Label(in_actions, text="TTS Speed:").pack(side="left", padx=(12, 0))
        self.sld_tts_speed = ttk.Scale(in_actions, from_=0.5, to=2.0, value=self.config.get("tts_rate_factor", 1.0), orient="horizontal", length=100)
        self.sld_tts_speed.pack(side="left", padx=4)
        self.sld_tts_speed.bind("<ButtonRelease-1>", lambda e: self._update_tts_speed())
        ttk.Button(in_actions, text="Burner Script", command=self._burner_script, style="Secondary.TButton").pack(side="left", padx=6)
        ttk.Button(in_actions, text="Summarize Project", command=self._summarize_project, style="Secondary.TButton").pack(side="left", padx=6)
        # WORKFLOW OUTPUT — Notebook of PDD, Progressive & Overview
        wf_frame = ttk.Labelframe(center, text="Workflow Output", padding=6)
        wf_frame.pack(fill="both", expand=True, pady=(6, 0))
        self.nb = ttk.Notebook(wf_frame)
        self.nb.pack(fill="both", expand=True)
        # PDD tab
        tab1 = ttk.Frame(self.nb)
        self.nb.add(tab1, text="PDD")
        self.txt_pdd = tk.Text(tab1, bg=THEME_ELEV, fg=THEME_TEXT, insertbackground=THEME_TEXT, wrap="word", font=mono, padx=8, pady=6)
        self.txt_pdd.pack(fill="both", expand=True)
        self.txt_pdd.bind("<Control-s>", lambda e: self._save_pdd() or "break")
        self.txt_pdd.bind("<KeyRelease>", lambda e: (self._on_pdd_edit(), self._update_sync_state()))
        pdd_scroll = ttk.Scrollbar(tab1, orient="vertical", command=self.txt_pdd.yview)
        self.txt_pdd.configure(yscrollcommand=pdd_scroll.set)
        pdd_scroll.pack(side="right", fill="y")
        # Progressive Script tab (renamed from Burner Script)
        tab2 = ttk.Frame(self.nb)
        self.nb.add(tab2, text="Progressive Script")
        self.txt_progressive = tk.Text(tab2, bg=THEME_ELEV, fg=THEME_TEXT, insertbackground=THEME_TEXT, wrap="none", font=mono, padx=8, pady=6, height=20)
        self.txt_progressive.pack(fill="both", expand=True)
        psv_scroll = ttk.Scrollbar(tab2, orient="vertical", command=self.txt_progressive.yview)
        self.txt_progressive.configure(yscrollcommand=psv_scroll.set)
        psv_scroll.pack(side="right", fill="y")
        prog_btns = ttk.Frame(tab2)
        prog_btns.pack(fill="x", pady=4)
        ttk.Button(prog_btns, text="Promote to Repo", command=self._inject_progressive_scripts, style="Purple.TButton").pack(side="left", padx=4)
        ttk.Button(prog_btns, text="Archive Current Version", command=self._archive_current_progressive, style="Secondary.TButton").pack(side="left", padx=4)
        # Project Summary tab
        tab3 = ttk.Frame(self.nb)
        self.nb.add(tab3, text="Project Summary")
        self.txt_overview = tk.Text(tab3, bg=THEME_ELEV, fg=THEME_TEXT, insertbackground=THEME_TEXT, wrap="word", font=mono, padx=8, pady=6)
        self.txt_overview.pack(fill="both", expand=True)
        ov_scroll = ttk.Scrollbar(tab3, orient="vertical", command=self.txt_overview.yview)
        self.txt_overview.configure(yscrollcommand=ov_scroll.set)
        ov_scroll.pack(side="right", fill="y")
        # Diff tools
        diff = ttk.Labelframe(center, text="Diff Tools", padding=6)
        diff.pack(fill="x", pady=(6, 2))
        self.include_diff = tk.BooleanVar(value=False)
        ttk.Checkbutton(diff, text="Include Diff", variable=self.include_diff).pack(side="left", padx=(0, 8))
        ttk.Button(diff, text="Paste from Clipboard", command=self._paste_diff_clip, style="Secondary.TButton").pack(side="left", padx=4)
        ttk.Button(diff, text="Fetch Git diff (local)", command=self._fetch_local_diff, style="Secondary.TButton").pack(side="left", padx=4)
        ttk.Button(diff, text="Init Git Repo", command=self._init_git_repo, style="Secondary.TButton").pack(side="left", padx=4)
        ttk.Button(diff, text="Fetch GitHub Compare", command=self._fetch_github_compare, style="Secondary.TButton").pack(side="left", padx=4)
        ttk.Button(diff, text="Ingest Repo to Dataset", command=self._ingest_repo, style="Secondary.TButton").pack(side="left", padx=4)
        self.txt_diff = tk.Text(center, height=6, bg=THEME_ELEV, fg=THEME_TEXT, insertbackground=THEME_TEXT, font=mono, wrap="none", padx=8, pady=6)
        self.txt_diff.pack(fill="x")
        # Status
        self.status = tk.StringVar(value="Ready")
        ttk.Label(self.root, textvariable=self.status).pack(side="bottom", fill="x", padx=6, pady=3)
        # Initialize Sync button state
        self._update_sync_state()
        self._populate_launch_scripts()

    def _populate_launch_scripts(self):
        if not self.current_project:
            return
        scripts = []
        for cur, dirs, files in os.walk(self.current_project):
            for f in files:
                if f.endswith(".py"):
                    scripts.append(f)
        self.cmb_launch_script["values"] = sorted(scripts)
        cfg = self._proj_cfg()
        self.cmb_launch_script.set(cfg.get("launch_script", "main.py"))

    def _set_launch_script(self):
        if not self.current_project:
            return
        f = askopenfilename(initialdir=self.current_project, filetypes=[("Python", "*.py")])
        if f:
            self.cmb_launch_script.set(os.path.basename(f))
            cfg = self._proj_cfg()
            cfg["launch_script"] = os.path.basename(f)
            self._save_config()

    def _test_launch(self):
        if not self.current_project:
            return
        script = self.cmb_launch_script.get()
        if not script:
            return
        version_id = time.strftime("%Y%m%d_%H%M%S")
        self._log_step(f"Test launching {script}...")
        error_dir = Path(self.current_project) / UPDATE_WS_NAME / "errors"
        error_dir.mkdir(parents=True, exist_ok=True)
        error_path = error_dir / f"errors_v{version_id}.txt"
        try:
            with open(error_path, "w", encoding="utf-8") as err_f:
                proc = subprocess.Popen(["python", script], cwd=self.current_project, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
                for line in iter(proc.stdout.readline, ''):
                    err_f.write(line)
                    if "error" in line.lower() or "exception" in line.lower():
                        self._log_error(line.strip())
                        self._store_error("runtime", line.strip(), "", script, None, "new", version_id)
                proc.wait()
            if proc.returncode != 0:
                self._log_error(f"Script crashed with code {proc.returncode}")
                self._store_error("crash", f"Return code {proc.returncode}", "", script, None, "new", version_id)
            else:
                self._log_success("Script launched without crash.")
            # Parse log for more errors
            with open(error_path, "r", encoding="utf-8") as f:
                log = f.read()
            for match in re.finditer(r"(Error|Exception): (.*)", log, re.I | re.M):
                self._store_error(match.group(1), match.group(2), "", script, None, "new", version_id)
        except Exception as e:
            self._log_error(f"Launch failed: {e}")
            self._store_error("launch", str(e), "", script, None, "new", version_id)

    def _mark_stable(self):
        if not self.current_db:
            return
        with self.db_lock:
            c = self.current_db.cursor()
            c.execute("UPDATE errors SET status = 'stable' WHERE status = 'new'")
            self.current_db.commit()
        self._log_success("Marked as stable.")

    def _store_error(self, type: str, msg: str, tb: str, path: str, line: Optional[int] = None, status: str = "new", version: str = ""):
        if not self.current_db:
            return
        with self.db_lock:
            c = self.current_db.cursor()
            c.execute(
                "INSERT INTO errors (session_id, script, timestamp, type, message, traceback, path, line, status, version_tag) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)",
                (version, path, time.time(), type, msg, tb, path, line, status, version)
            )
            self.current_db.commit()

    def _get_current_errors(self):
        if not self.current_db:
            return ""
        with self.db_lock:
            c = self.current_db.cursor()
            c.execute("SELECT * FROM errors WHERE status = 'new' ORDER BY timestamp DESC LIMIT 10")
            errs = []
            for row in c.fetchall():
                errs.append(f"Error: {row[4]} - {row[5]} at {row[7]}:{row[8]}")  # type, message, path, line
        return "\n".join(errs)

    def _get_errors(self, include_archived: bool = False):
        if not self.current_db:
            return ""
        with self.db_lock:
            c = self.current_db.cursor()
            if include_archived:
                c.execute("SELECT * FROM errors ORDER BY timestamp DESC LIMIT 20")
            else:
                c.execute("SELECT * FROM errors WHERE status = 'new' ORDER BY timestamp DESC LIMIT 10")
            errs = []
            for row in c.fetchall():
                prefix = "Past error: " if row[9] != "new" else ""
                errs.append(f"{prefix}Error: {row[4]} - {row[5]} at {row[7]}:{row[8]}")
        return "\n".join(errs)

    # ---------- Streaming console helpers ----------
    def _console_write(self, msg: str, level: str = "INFO"):
        """Insert a console line with color tag based on level."""
        try:
            self.console.configure(state="normal")
            # Try to detect level from message like "[HH:MM:SS] LEVEL: ..."
            m = re.search(r"\]\s+([A-Z]+):\s", msg)
            tag = level.upper() if not m else m.group(1)
            if tag not in {"INFO", "WARN", "ERROR", "DEBUG"}:
                tag = level.upper()
            if tag == "DEBUG":
                tag = "MUTED"
            ts = time.strftime("%H:%M:%S")
            self.console.insert("end", f"[{ts}] ", ("MUTED",))
            self.console.insert("end", msg.split("] ", 1)[-1] + "\n", (tag,))
            self.console.see("end")
        finally:
            self.console.configure(state="disabled")

    def _console_line(self, text: str, tag: str):
        """Directly write a line with a specific tag (STEP/PROGRESS/SUCCESS/WARN/ERROR/INFO)."""
        try:
            self.console.configure(state="normal")
            ts = time.strftime("%H:%M:%S")
            self.console.insert("end", f"[{ts}] ", ("MUTED",))
            self.console.insert("end", text + "\n", (tag,))
            self.console.see("end")
        finally:
            self.console.configure(state="disabled")

    def _log_step(self, text: str):
        self._console_line(f"STEP: {text}", "STEP")

    def _log_progress(self, text: str):
        self._console_line(f"PROGRESS: {text}", "PROGRESS")

    def _log_success(self, text: str):
        self._console_line(f"SUCCESS: {text}", "SUCCESS")

    def _log_warn(self, text: str):
        self._console_line(f"WARN: {text}", "WARN")

    def _log_error(self, text: str):
        self._console_line(f"ERROR: {text}", "ERROR")

    def _clear_console(self):
        self.console.configure(state="normal")
        self.console.delete("1.0", "end")
        self.console.configure(state="disabled")

    # ---------- Refresh helpers ----------
    def _refresh_all_views(self):
        """Refresh Explorer, PDD list, and force UI to repaint."""
        self._populate_explorer()
        self._populate_pdd_list()
        try:
            self._on_tree_select()
        except Exception:
            pass
        self.root.update_idletasks()
        self._status("Views refreshed")

    # ---------- Sync & Summary features ----------
    def _update_sync_state(self):
        content = self.txt_pdd.get("1.0", "end").strip()
        state = "normal" if not content else "disabled"
        self.btn_sync.configure(state=state)

    def _sync_to_project(self):
        """Generate initial PDD from entire project data."""
        if not self.current_project:
            return
        self._status("Syncing project to PDD…")
        self._log_step("Scanning project files for initial PDD generation…")
        info_dir = Path(self.current_project) / UPDATE_WS_NAME
        texts = []
        if info_dir.exists():
            files = list(info_dir.rglob("*.*"))
            total = len(files)
            self._log_progress(f"Found {total} files in {UPDATE_WS_NAME} for context.")
            for i, p in enumerate(files, 1):
                try:
                    txt = p.read_text(encoding="utf-8", errors="ignore")
                    texts.append(f"[FILE:{p.relative_to(self.current_project)}]\n{txt}")
                except Exception:
                    pass
                if i % 25 == 0:
                    self._log_progress(f"Ingested {i}/{total} metadata files…")
        walked = []
        for cur, dirs, files in os.walk(self.current_project):
            for skip in (".git", "venv", UPDATE_WS_NAME):
                if skip in dirs:
                    dirs.remove(skip)
            for f in files:
                if f in ("pdd.txt", "index.json", "conversation.db"):
                    continue
                try:
                    p = Path(cur) / f
                    txt = p.read_text(encoding="utf-8", errors="ignore")
                    texts.append(f"[FILE:{p.relative_to(self.current_project)}]\n{txt}")
                    walked.append(p)
                except Exception:
                    pass
        self._log_progress(f"Collected {len(walked)} additional project files.")
        prompt = self.prompts["project_sync"]
        merged = "\n\n".join(texts[-10:])
        errors = self._get_current_errors()
        self._log_step("Invoking text model for PDD synthesis…")
        out = call_ollama_chat(self.config["ollama_model_text"], f"{prompt}\nErrors:\n{errors}\n\nDATA:\n{merged}", timeout=120)
        if out.startswith("Error:"):
            self._log_error("Text model unavailable; initial PDD sync aborted. Start Ollama and retry.")
            return
        self.txt_pdd.delete("1.0", "end")
        self.txt_pdd.insert("end", out)
        self._on_pdd_edit()
        self._save_pdd()
        self._status("Project synced to PDD")
        self._add_msg(f"[SYNC_PDD]\n{out}")
        self._log_success("PDD updated from project snapshot.")
        self._update_sync_state()
        self._refresh_all_views()

    def _summarize_project(self):
        """Generate static overview summary in the Summary tab."""
        if not self.current_project:
            return
        self._status("Generating project overview…")
        self._log_step("Composing project overview from current PDD and design docs…")
        prompt = self.prompts["project_overview"]
        pdd = self.txt_pdd.get("1.0", "end").strip()
        data = f"PDD:\n{pdd}\n\n"
        info_dir = Path(self.current_project) / UPDATE_WS_NAME
        snippets = []
        if info_dir.exists():
            files = list(info_dir.rglob("*.*"))
            for p in files[-50:]:
                try:
                    txt = p.read_text(encoding="utf-8", errors="ignore")[:2000]
                    snippets.append(f"[FILE:{p.relative_to(self.current_project)}]\n{txt}")
                except Exception:
                    pass
        data += "\n\n".join(snippets[-5:])
        errors = self._get_current_errors()
        out = call_ollama_chat(self.config["ollama_model_text"], f"{prompt}\nErrors:\n{errors}\n\nDATA:\n{data}", timeout=90)
        if out.startswith("Error:"):
            self._log_error("Text model unavailable; project overview aborted. Start Ollama and retry.")
            return
        self.txt_overview.delete("1.0", "end")
        self.txt_overview.insert("end", out)
        self._add_msg(f"[OVERVIEW]\n{out}")
        self._status("Project overview ready")
        self._log_success("Project overview generated.")
        self.nb.select(self.txt_overview.master)

    # ---------- Repository methods ----------
    def _delete_repository(self):
        """Clears the entire contents of the linked repository folder (including nested hidden .git)."""
        if not self.current_project:
            return
        repo = Path(self.current_project) / UPDATE_WS_NAME / REPO_FOLDER
        if not repo.exists():
            messagebox.showinfo("Delete Repository", "No repository linked.")
            return
        if not messagebox.askyesno("Delete Repository", f"Clear ALL contents under:\n{repo}\n\nThis removes nested .git folders too. Continue?"):
            return
        self._log_step(f"Wiping repository contents at {repo} …")
        wipe_directory_contents(repo)
        self._status("Repository contents cleared")
        self._log_success("Repository folder emptied (including hidden .git).")
        self._refresh_all_views()

    def _prompt_repo_settings_if_needed(self) -> Optional[Dict[str, str]]:
        """Ask for repo URL/branch if not set; persist."""
        cfg = self._proj_cfg()
        changed = False
        if not cfg.get("repo_url") and not cfg.get("desktop_link"):
            url = simpledialog.askstring("Repository URL", "Paste Git URL or 'Open in Desktop' link:\n(e.g. https://github.com/owner/repo.git or x-github-client://openRepo/...)")
            if not url:
                return None
            if url.startswith("x-github-client://"):
                cfg["desktop_link"] = url
                m = re.search(r"x-github-client://openRepo/(.+)$", url)
                if m:
                    cfg["repo_url"] = m.group(1)
            else:
                cfg["repo_url"] = url
            changed = True
        if not cfg.get("repo_branch"):
            br = simpledialog.askstring("Branch", "Branch name to pull (single-branch):", initialvalue="main")
            if not br:
                return None
            cfg["repo_branch"] = br
            changed = True
        if changed:
            self._save_config()
        return {"url": cfg.get("repo_url", ""), "branch": cfg["repo_branch"], "desktop_link": cfg.get("desktop_link", "")}

    def _open_in_github_desktop(self, repo_path: Path, desktop_link: str = ""):
        """Open GitHub Desktop for the repo (best-effort)."""
        self._log_step("Opening repository in GitHub Desktop…")
        try:
            subprocess.Popen(["github", str(repo_path)], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            return
        except Exception:
            pass
        try:
            if platform.system() == "Windows":
                exe = Path(os.getenv("LOCALAPPDATA", "")) / "GitHubDesktop" / "GitHubDesktop.exe"
                if exe.exists():
                    subprocess.Popen([str(exe), f"--open-repository={repo_path}"], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                    return
        except Exception:
            pass
        try:
            if desktop_link:
                if platform.system() == "Windows":
                    os.startfile(desktop_link)
                elif platform.system() == "Darwin":
                    subprocess.Popen(["open", desktop_link])
                else:
                    subprocess.Popen(["xdg-open", desktop_link])
        except Exception:
            pass

    def _ensure_cloned_here(self, settings: Dict[str, str]) -> Optional[Path]:
        """Ensure the repo is cloned under UPDATE_WS_NAME/repository/<name> (single-branch)."""
        repo_root = Path(self.current_project) / UPDATE_WS_NAME / REPO_FOLDER
        repo_root.mkdir(parents=True, exist_ok=True)
        inner = self._resolve_inner_repo(repo_root)
        if git_is_repo(str(inner)):
            return inner
        default_name = "repo"
        url = settings["url"]
        if url and "/" in url:
            default_name = re.sub(r"\.git$", "", url.rstrip("/").split("/")[-1])
        name = simpledialog.askstring("Folder name", "Folder name for local clone:", initialvalue=default_name)
        if not name:
            return None
        target = repo_root / name
        target.mkdir(parents=True, exist_ok=True)
        branch = settings["branch"]
        self._log_step(f"Cloning {url} (branch {branch})…")
        code, out, err = run_git(["clone", "--single-branch", "--branch", branch, url, "."], cwd=str(target))
        if code != 0:
            messagebox.showerror("Clone failed", err or out or "Unknown error")
            self._log_error(f"Clone failed: {err or out or 'Unknown error'}")
            return None
        self._enforce_single_branch(target, branch)
        self._status(f"Cloned repo into {target.name}")
        self._log_success(f"Cloned into {target}.")
        return target

    def _pull_repo(self):
        """Pull latest from configured single branch; open GitHub Desktop if enabled."""
        if not self.current_project:
            return
        settings = self._prompt_repo_settings_if_needed()
        if not settings:
            return
        repo_root = Path(self.current_project) / UPDATE_WS_NAME / REPO_FOLDER
        target = self._resolve_inner_repo(repo_root)
        if not git_is_repo(str(target)):
            self._log_warn("No repo found—launching controlled clone flow.")
            target = self._ensure_cloned_here(settings)
            if not target:
                return
        self._log_step(f"Configuring single-branch tracking for '{settings['branch']}' …")
        self._enforce_single_branch(target, settings["branch"])
        self._log_step("Pulling from remote (ff-only)…")
        code, out, err = run_git(["pull", "--ff-only"], cwd=str(target))
        if code != 0:
            messagebox.showerror("Pull Repo", err or out or "Unknown error")
            self._log_error(f"Pull failed: {err or out or 'Unknown error'}")
        else:
            self._status(f"Repository updated from remote (branch {settings['branch']}).")
            self._log_success(f"Pulled latest on '{settings['branch']}'.")
        if self.use_desktop.get():
            self._open_in_github_desktop(target, settings.get("desktop_link", ""))
        # Get commit hash for version
        code, commit, _ = run_git(["rev-parse", "HEAD"], cwd=str(target))
        if code == 0:
            cfg = self._proj_cfg()
            cfg["repo_commit"] = commit.strip()
            self._save_config()
        self._refresh_all_views()

    def _enforce_single_branch(self, repo_path: Path, branch: str):
        """Configure repo to track ONLY the given branch and prune others locally."""
        run_git(["config", "--unset-all", "remote.origin.fetch"], cwd=str(repo_path))
        run_git(["config", "remote.origin.fetch", f"+refs/heads/{branch}:refs/remotes/origin/{branch}"], cwd=str(repo_path))
        run_git(["fetch", "--prune", "origin"], cwd=str(repo_path))
        run_git(["checkout", "-B", branch, f"origin/{branch}"], cwd=str(repo_path))
        code, out, _ = run_git(["for-each-ref", "--format=%(refname:short)", "refs/heads"], cwd=str(repo_path))
        if code == 0:
            for br in out.splitlines():
                br = br.strip()
                if br and br != branch:
                    run_git(["branch", "-D", br], cwd=str(repo_path))

    def _update_repo_with_progressive(self):
        """Ask (checkboxes) what to send; commit and push to configured branch. Wipes targets first."""
        if not self.current_project:
            return
        settings = self._prompt_repo_settings_if_needed()
        if not settings:
            return
        repo_root = Path(self.current_project) / UPDATE_WS_NAME / REPO_FOLDER
        target = self._resolve_inner_repo(repo_root)
        if not git_is_repo(str(target)):
            messagebox.showerror("Update Repo", "No valid Git repository in project. Use Pull Repo to clone first.")
            self._log_error("Update aborted: no valid git repository found.")
            return
        # Load per-project defaults and tailor by Task Type for initial UX
        cfg = self._proj_cfg()
        defaults = cfg.get("update_repo_options", {}).copy()
        if self.task_type.get() == "Coding":
            defaults.setdefault("include_scripts", True)
            defaults.setdefault("include_design", False)
            defaults.setdefault("include_info", False)
            defaults.setdefault("include_burner_lists", False)
            defaults.setdefault("include_burner_scripts", True)
        else:
            defaults.setdefault("include_scripts", True)
            defaults.setdefault("include_design", True)
            defaults.setdefault("include_info", False)
            defaults.setdefault("include_burner_lists", False)
            defaults.setdefault("include_burner_scripts", False)
        dlg = UpdateRepoDialog(self.root, settings["branch"], defaults)
        self.root.wait_window(dlg)
        if not dlg.ok:
            self._log_warn("Update cancelled by user.")
            return
        # Persist dialog choices per project
        cfg["update_repo_options"] = {
            "include_scripts": bool(dlg.include_scripts.get()),
            "include_design": bool(dlg.include_design.get()),
            "include_info": bool(dlg.include_info.get()),
            "include_burner_lists": bool(dlg.include_burner_lists.get()),
            "include_burner_scripts": bool(dlg.include_burner_scripts.get()),
            "commit_direct": bool(dlg.commit_direct.get()),
            "commit_message": dlg.commit_message.get().strip() or "Update from Rant_PDD",
        }
        self._save_config()
        self._log_step("Preparing files to stage (wipe/save mode)…")
        copied_count = 0
        if cfg["update_repo_options"]["include_scripts"]:
            c = self._copy_progressive_archives_into_repo(target)
            self._log_progress(f"Progressive scripts copied: {c}")
            copied_count += c
        if cfg["update_repo_options"]["include_design"]:
            c = self._copy_design_documents_into_repo(target)
            self._log_progress(f"Design_Documents copied: {c}")
            copied_count += c
        if cfg["update_repo_options"]["include_info"]:
            c = self._copy_project_info_into_repo(target)
            self._log_progress(f"Info package copied: {c}")
            copied_count += c
        if cfg["update_repo_options"]["include_burner_lists"]:
            c = self._copy_burner_lists_into_repo(target)
            self._log_progress(f"Burner lists copied: {c}")
            copied_count += c
        if cfg["update_repo_options"]["include_burner_scripts"]:
            c = self._copy_burner_scripts_into_repo(target)
            self._log_progress(f"Burner scripts copied: {c}")
            copied_count += c
        run_git(["add", "-A"], cwd=str(target))
        commit_msg = cfg["update_repo_options"]["commit_message"]
        branch = settings["branch"]
        if self.single_branch_only.get() and cfg["update_repo_options"]["commit_direct"]:
            self._log_step(f"Committing directly to '{branch}' (single-branch mode)…")
            self._enforce_single_branch(target, branch)
        else:
            branch = f"update_{time.strftime('%Y-%m-%d_%H%M')}"
            self._log_warn(f"Creating safety branch '{branch}' for update…")
            run_git(["checkout", "-b", branch], cwd=str(target))
        code, out, err = run_git(["commit", "-m", commit_msg], cwd=str(target))
        if code != 0 and "nothing to commit" in (out + err).lower():
            self._status("No changes to commit.")
            self._log_warn("No changes to commit.")
        elif code != 0:
            messagebox.showerror("Commit failed", err or out or "Unknown")
            self._log_error(f"Commit failed: {err or out or 'Unknown'}")
            return
        else:
            self._log_success("Local commit created.")
        self._log_step(f"Pushing branch '{branch}' to origin…")
        run_git(["push", "-u", "origin", branch], cwd=str(target))
        self._status(f"Updated repository ({copied_count} files) on branch '{branch}'.")
        self._log_success(f"Pushed updates to remote on '{branch}'.")
        if self.use_desktop.get():
            self._open_in_github_desktop(target, settings.get("desktop_link", ""))
        self._refresh_all_views()

    def _resolve_inner_repo(self, repo_root: Path) -> Path:
        """Return the actual git working dir beneath UPDATE_WS_NAME/repository."""
        if (repo_root / ".git").exists():
            return repo_root
        for child in repo_root.iterdir():
            if child.is_dir() and (child / ".git").exists():
                return child
        return repo_root

    # === Wipe/Save copy helpers ===
    def _copy_progressive_archives_into_repo(self, repo_dir: Path) -> int:
        """ Wipe repo/_progressive then copy ALL progressive *.py files from every module's Design_Documents/<module>/progressive_scripts/ into matching subfolders. """
        dest_root = repo_dir / "_progressive"
        if dest_root.exists():
            shutil.rmtree(dest_root, onerror=_on_rm_error)
        dest_root.mkdir(parents=True, exist_ok=True)
        copied = 0
        dd_root = Path(self.current_project) / "Design_Documents"
        if not dd_root.exists():
            return copied
        for module_dir in sorted([d for d in dd_root.iterdir() if d.is_dir()]):
            psv_dir = module_dir / "progressive_scripts"
            if not psv_dir.exists():
                continue
            dst_mod = dest_root / module_dir.name
            dst_mod.mkdir(parents=True, exist_ok=True)
            for py in sorted(psv_dir.glob("*.py")):
                shutil.copy(py, dst_mod / py.name)
                copied += 1
        return copied

    def _copy_design_documents_into_repo(self, repo_dir: Path) -> int:
        """Wipe repo/_design_docs then copy Design_Documents (files only, preserving structure)."""
        src = Path(self.current_project) / "Design_Documents"
        dst = repo_dir / "_design_docs"
        if dst.exists():
            shutil.rmtree(dst, onerror=_on_rm_error)
        copied = 0
        if src.exists():
            for p in src.rglob("*"):
                if p.is_dir():
                    continue
                rel = p.relative_to(src)
                outp = dst / rel
                outp.parent.mkdir(parents=True, exist_ok=True)
                shutil.copy(p, outp)
                copied += 1
        return copied

    def _copy_project_info_into_repo(self, repo_dir: Path) -> int:
        """ Wipe repo/_info then copy project_info except the 'repository' subfolder to avoid recursion. """
        src = Path(self.current_project) / UPDATE_WS_NAME
        dst = repo_dir / "_info"
        if dst.exists():
            shutil.rmtree(dst, onerror=_on_rm_error)
        copied = 0
        if src.exists():
            for p in src.rglob("*"):
                if REPO_FOLDER in p.parts:
                    continue
                if p.is_dir():
                    continue
                rel = p.relative_to(src)
                outp = dst / rel
                outp.parent.mkdir(parents=True, exist_ok=True)
                shutil.copy(p, outp)
                copied += 1
        return copied

    def _copy_burner_lists_into_repo(self, repo_dir: Path) -> int:
        dst = repo_dir / "_burner_lists"
        if dst.exists():
            shutil.rmtree(dst, onerror=_on_rm_error)
        copied = 0
        src = Path(self.current_project) / "burner_lists"
        if src.exists():
            dst.mkdir(parents=True, exist_ok=True)
            for f in src.glob("*"):
                if f.is_file():
                    shutil.copy(f, dst / f.name)
                    copied += 1
        return copied

    def _copy_burner_scripts_into_repo(self, repo_dir: Path) -> int:
        dst = repo_dir / "_burner_scripts"
        if dst.exists():
            shutil.rmtree(dst, onerror=_on_rm_error)
        copied = 0
        src = Path(self.current_project) / "burner_scripts"
        if src.exists():
            dst.mkdir(parents=True, exist_ok=True)
            for f in src.glob("*.txt"):
                shutil.copy(f, dst / f.name)
                copied += 1
        return copied

    # ---------- Repo sync to dataset / PDD ----------
    def _sync_repository(self):
        """ Public entrypoint — run sync in a worker thread so the UI stays responsive and the System Console streams progress lines even if Ollama is down. """
        if not self.current_project:
            return
        self._log_step("Starting repository sync (threaded)…")
        threading.Thread(target=self._sync_repository_worker, daemon=True).start()

    def _sync_repository_worker(self):
        version_id = time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime())
        try:
            self._status(f"Syncing repository (version {version_id})…")
            self._log_step(f"Scanning repository @ {version_id} …")
            repo_dir = Path(self.current_project) / UPDATE_WS_NAME / REPO_FOLDER
            actual_repo = self._resolve_inner_repo(repo_dir)
            if not actual_repo.exists():
                messagebox.showinfo("Sync Repository", "No repository linked yet.")
                self._log_warn("Sync aborted: no repository linked.")
                return
            files = [p for p in actual_repo.rglob("*.*") if ".git" not in p.parts]
            self._log_progress(f"Found {len(files)} files to ingest…")
            started = time.time()
            last_tick = started
            for i, file in enumerate(files, 1):
                try:
                    content = file.read_text(encoding="utf-8", errors="ignore")
                except Exception:
                    continue
                em = embed(content, self.config["embedding_model"])
                if self.current_db:
                    with self.db_lock:
                        c = self.current_db.cursor()
                        c.execute(
                            "INSERT INTO messages (text, embedding, timestamp) VALUES (?,?,?)",
                            (f"[REPO:{file.relative_to(self.current_project)}|ver:{version_id}]\n{content[:5000]}", json.dumps(em) if em else None, time.time())
                        )
                        self.current_db.commit()
                now = time.time()
                if now - last_tick > 0.35:
                    self._log_progress(f"Ingested {i}/{len(files)} files…")
                    last_tick = now
            # Generate/update PDD + Burner List per .py file
            py_files = [p for p in actual_repo.rglob("*.py") if ".git" not in p.parts]
            self._log_step(f"Generating module PDDs from {len(py_files)} Python files…")
            errors = self._get_errors(include_archived=True)
            for j, py in enumerate(py_files, 1):
                try:
                    code = py.read_text(encoding="utf-8", errors="ignore")
                except Exception:
                    continue
                name = py.stem
                pdd_folder = Path(self.current_project) / "Design_Documents" / name
                pdd_folder.mkdir(parents=True, exist_ok=True)
                self._log_progress(f"[{j}/{len(py_files)}] Summarizing {py.name} → {name}/pdd.txt …")
                summary = call_ollama_chat(
                    self.config["ollama_model_text"],
                    f"# Repository Version: {version_id}\n\n"
                    f"{self.prompts['project_sync']}\nErrors:\n{errors}\n\nDATA:\n{code[:2000]}",
                    timeout=120
                )
                if summary.startswith("Error:"):
                    self._log_error("Text model unavailable; skipping module summaries. Start Ollama and re-run sync.")
                    break
                versioned_pdd = (
                    f"# Repository Version: {version_id}\n\n"
                    f"{summary}\n\n"
                    "NOTE: All prior summaries are from earlier repository versions."
                )
                (pdd_folder / "pdd.txt").write_text(versioned_pdd, encoding="utf-8")
                # Maintain Burner List (legacy / backward compatibility)
                bl = Path(self.current_project) / "burner_lists" / f"{name}_burner_list.txt"
                if not bl.exists():
                    self._initialize_burner_list(bl, code, version_id, name)
                else:
                    self._append_burner_version(bl, code, version_id, name)
            self._generate_project_summary(version_id)
            self._status(f"Repository synced to version {version_id}")
            self._log_success("Repository sync complete.")
            self._refresh_all_views()
        except Exception as e:
            logger.error("Sync repository error: %s", e)
            self._status(f"Sync error: {e}")
            self._log_error(f"Sync error: {e}")

    # ---------- Burner List helpers (legacy) ----------
    def _initialize_burner_list(self, path: Path, code: str, version_id: str, module_name: str):
        header = (
            f"# BURNER LIST: {module_name}\n"
            f"# Linked PDD: Design_Documents/{module_name}/pdd.txt\n"
            f"# Created: {time.strftime('%Y-%m-%d')}\n"
            f"# Repository Version: {version_id}\n"
            f"# Total Versions: 1\n\n"
        )
        block = f"--- VERSION 1 START ---\n{code}\n--- VERSION 1 END ---\n"
        path.write_text(header + block, encoding="utf-8")
        burner_txt = Path(self.current_project) / "burner_scripts" / f"{module_name}.txt"
        burner_txt.write_text(code, encoding="utf-8")

    def _append_burner_version(self, path: Path, new_code: str, version_id: str, module_name: str):
        text = path.read_text(encoding="utf-8")
        try:
            last_start = text.rfind("--- VERSION ")
            last_block = text[last_start:]
            old_code = last_block.split("START ---\n", 1)[1].split("\n--- VERSION", 1)[0]
        except Exception:
            old_code = ""
        diff_txt = "\n".join(
            difflib.unified_diff(
                old_code.splitlines(),
                new_code.splitlines(),
                fromfile="prev.py",
                tofile="curr.py",
                lineterm=""
            )
        )
        try:
            header, body = text.split("\n\n", 1)
            total_line_idx = [i for i, ln in enumerate(header.splitlines()) if ln.startswith("# Total Versions:")][0]
            header_lines = header.splitlines()
            total = int(header_lines[total_line_idx].split(":")[1].strip())
            header_lines[total_line_idx] = f"# Total Versions: {total + 1}"
            for i, ln in enumerate(header_lines):
                if ln.startswith("# Repository Version:"):
                    header_lines[i] = f"# Repository Version: {version_id}"
            header = "\n".join(header_lines)
        except Exception:
            header, body = text, ""
            total = 1
        v_next = (total + 1)
        block = (
            f"\n--- VERSION {v_next} START ---\n{new_code}\n"
            f"--- DIFF FROM VERSION {v_next-1} ---\n{diff_txt}\n"
            f"--- VERSION {v_next} END ---\n"
        )
        path.write_text(header + "\n\n" + body + block, encoding="utf-8")
        burner_txt = Path(self.current_project) / "burner_scripts" / f"{module_name}.txt"
        burner_txt.write_text(new_code, encoding="utf-8")

    # ---------- Progressive Script helpers ----------
    def _current_selected_module(self) -> str:
        sel = self.pdd_list.curselection()
        if sel:
            return self.pdd_list.get(sel[0])
        return "General"

    def _pdd_hash(self) -> str:
        pdd_text = self.txt_pdd.get("1.0", "end")
        return hashlib.sha256(pdd_text.encode("utf-8")).hexdigest()[:12]

    def _make_progressive_header(self, model_used: str) -> str:
        return (
            f"# Progressive Script Archive\n"
            f"# Project: {os.path.basename(self.current_project or '')}\n"
            f"# Module: {self._current_selected_module()}\n"
            f"# Version Timestamp: {time.strftime('%Y-%m-%d %H:%M:%S')}\n"
            f"# PDD Hash: {self._pdd_hash()}\n"
            f"# Model: {model_used}\n"
            f"# Note: Generated by DeepSeek Progressive flow. Review before merge.\n\n"
        )

    def _archive_current_progressive(self):
        """Archive current Progressive Script text into module archive folder with metadata."""
        if not self.current_project:
            return
        ps_text = self.txt_progressive.get("1.0", "end").strip()
        if not ps_text:
            self._status("No Progressive Script content to archive")
            self._log_warn("Archive skipped: Progressive Script editor is empty.")
            return
        timestamp = time.strftime('%Y%m%d_%H%M%S')
        mod_name = self._current_selected_module()
        out_dir = Path(self.current_project) / "Design_Documents" / mod_name / "progressive_scripts"
        out_dir.mkdir(parents=True, exist_ok=True)
        model_used = self.config.get("ollama_model_coding", "deepseek-coder-v2:16b")
        header = self._make_progressive_header(model_used)
        out_file = out_dir / f"version_{timestamp}.py"
        out_file.write_text(header + ps_text + "\n", encoding="utf-8")
        latest_prev = self._latest_progressive_file(out_dir, before=timestamp)
        if latest_prev:
            try:
                prev_txt = Path(latest_prev).read_text(encoding="utf-8").splitlines()
                curr_txt = (header + ps_text + "\n").splitlines()
                diff_txt = "\n".join(difflib.unified_diff(prev_txt, curr_txt, fromfile=Path(latest_prev).name, tofile=out_file.name, lineterm=""))
                (out_dir / f"diff_{timestamp}.txt").write_text(diff_txt, encoding="utf-8")
            except Exception:
                pass
        self._status(f"Progressive script archived: {out_file.name}")
        self._log_success(f"Archived Progressive Script → {out_file}")
        self._refresh_all_views()

    def _latest_progressive_file(self, psv_dir: Path, before: Optional[str] = None) -> Optional[Path]:
        """Return the latest version_*.py under psv_dir; optionally only those < before timestamp."""
        if not psv_dir.exists():
            return None
        files = sorted([p for p in psv_dir.glob("version_*.py") if p.is_file()])
        if before:
            files = [p for p in files if p.stem.split("_", 1)[1] < before]
        return files[-1] if files else None

    def _inject_progressive_scripts(self):
        """Archive current Progressive Script and copy ALL progressive scripts into repo/_progressive; does not commit."""
        if not self.current_project:
            return
        self._log_step("Archiving current Progressive Script…")
        self._archive_current_progressive()
        self._log_step("Copying ALL Progressive Scripts into repo working directory (wipe/save)…")
        repo_root = Path(self.current_project) / UPDATE_WS_NAME / REPO_FOLDER
        target = self._resolve_inner_repo(repo_root)
        if not target.exists():
            self._status("No repository linked—archived only. Use Pull Repo to link a repo.")
            self._log_warn("Promotion skipped: no repository linked.")
            return
        copied = self._copy_progressive_archives_into_repo(target)
        self._status(f"Promoted Progressive Scripts → repo/_progressive ({copied} files). Use 'Update Repo' to commit.")
        self._log_success(f"Promotion complete: {copied} file(s) staged in _progressive/")
        self._refresh_all_views()

    # ---------- Project Summary helpers ----------
    def _generate_project_summary(self, version_id: str):
        self._log_step("Composing project summary across modules…")
        prompt = self.prompts["project_overview"]
        pdds = []
        dd_root = Path(self.current_project) / "Design_Documents"
        if dd_root.exists():
            for d in dd_root.iterdir():
                if d.is_dir() and (d / "pdd.txt").exists():
                    pdds.append(f"### {d.name}\n\n" + (d / "pdd.txt").read_text(encoding="utf-8"))
        merged = "\n\n".join(pdds[-10:])
        errors = self._get_errors(include_archived=True)
        overview = call_ollama_chat(
            self.config["ollama_model_text"],
            f"# Project Summary – Version {version_id}\n\n{prompt}\nErrors:\n{errors}\n\nDATA:\n{merged}",
            timeout=90
        )
        if overview.startswith("Error:"):
            self._log_error("Text model unavailable; project summary skipped.")
            return
        versioned = (
            f"# Project Summary – Version {version_id}\n\n"
            f"{overview}\n\n"
            "NOTE: All prior summaries are from earlier repository versions."
        )
        Path(self.current_project, "project_summary.txt").write_text(versioned, encoding="utf-8")
        self._log_success("Project summary written to project_summary.txt")

    # ---------- Package for GitHub ----------
    def _package_for_github(self):
        """ Create two packages:
        • export_for_github_[ts]/Design_Documents (full tree)
        • export_generated_scripts_[ts]/<module>/*.py (ALL progressive script versions)
        Wipe both target folders before writing to avoid residuals.
        """
        if not self.current_project:
            return
        version_id = time.strftime("%Y%m%d_%H%M%S")
        repo_name = os.path.basename(self.current_project)
        out = Path(self.current_project) / f"{repo_name}_V{version_id}"
        out_gen = Path(self.current_project) / f"{repo_name}_V{version_id}_scripts"
        out.mkdir(parents=True, exist_ok=True)
        out_gen.mkdir(parents=True, exist_ok=True)
        self._log_step(f"Preparing export packages {out.name} and {out_gen.name} (wipe/save) …")
        wipe_directory_contents(out)
        wipe_directory_contents(out_gen)
        cfg = self._proj_cfg()
        defaults = cfg.get("package_options", {"include_design": True, "include_burner_lists": False, "include_burner_scripts": False})
        dlg = PackageDialog(self.root, defaults)
        self.root.wait_window(dlg)
        if not dlg.ok:
            self._log_warn("Packaging cancelled by user.")
            return
        package_options = {
            "include_design": bool(dlg.include_design.get()),
            "include_burner_lists": bool(dlg.include_burner_lists.get()),
            "include_burner_scripts": bool(dlg.include_burner_scripts.get()),
        }
        cfg["package_options"] = package_options
        self._save_config()
        dd_src = Path(self.current_project) / "Design_Documents"
        if package_options["include_design"] and dd_src.exists():
            shutil.copytree(dd_src, out / "Design_Documents", dirs_exist_ok=True)
        bl_src = Path(self.current_project) / "burner_lists"
        if package_options["include_burner_lists"] and bl_src.exists():
            shutil.copytree(bl_src, out / "burner_lists", dirs_exist_ok=True)
        bs_src = Path(self.current_project) / "burner_scripts"
        if package_options["include_burner_scripts"] and bs_src.exists():
            shutil.copytree(bs_src, out / "burner_scripts", dirs_exist_ok=True)
        # Always copy progressive scripts
        if dd_src.exists():
            for module_dir in sorted([d for d in dd_src.iterdir() if d.is_dir()]):
                psv = module_dir / "progressive_scripts"
                if not psv.exists():
                    continue
                dest_mod = out_gen / module_dir.name
                dest_mod.mkdir(parents=True, exist_ok=True)
                for py in sorted(psv.glob("*.py")):
                    shutil.copy(py, dest_mod / py.name)
        # Codex README
        readme = out / "README.md"
        readme.write_text("Repository export for Codex review.", encoding="utf-8")
        (out / "requirements.txt").touch(exist_ok=True)
        # Directive file
        self._ensure_codex_directive(out)
        # Version metadata
        metadata = out / "version_metadata.txt"
        metadata.write_text(
            f"# VERSION METADATA\nVersion: {version_id}\nBranch: {repo_name}_V{version_id}\nPackaged: {time.strftime('%Y-%m-%d %H:%M')}\nChanges:\n- Design docs included: {package_options['include_design']}\n- Burner lists included: {package_options['include_burner_lists']}\n- Burner scripts included: {package_options['include_burner_scripts']}",
            encoding="utf-8"
        )
        # Instructions for Codex + reference to generated scripts
        inst = out / "README_FOR_CODEX.txt"
        inst.write_text(
            f"Hello Codex,\n\n"
            f"You are Codex. Use ALL files in this folder and its subfolders to update the linked repository.\n\n"
            f"This package reflects repository version {version_id}.\n\n"
            "- Implement missing features\n"
            "- Apply PDD logic\n"
            "- Respect backward compatibility\n\n"
            f"Also see: ../{out_gen.name}/ for ALL Progressive Script versions (*.py) per module.\n"
            "All content is structured for implementation. Use every file.\n",
            encoding="utf-8"
        )
        # Add bot guard workflow
        workflow_dir = out / ".github" / "workflows"
        workflow_dir.mkdir(parents=True, exist_ok=True)
        bot_guard = workflow_dir / "bot-guard.yml"
        bot_guard_yaml = """name: Bot Guard
on:
  pull_request:
jobs:
  guard:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with: { fetch-depth: 0 }
      - uses: mikefarah/yq@v4
      - run: bash scripts/guard-gpt-changes.sh .gpt-guard.yaml "${{ github.event.pull_request.base.sha }}" "${{ github.event.pull_request.head.sha }}" """
        bot_guard.write_text(bot_guard_yaml, encoding="utf-8")
        self._status(f"Packaged for GitHub: {out.name} (+ {out_gen.name})")
        self._log_success("Packaging complete.")
        self._refresh_all_views()

    def _ensure_codex_directive(self, root: Path):
        file = root / "suggested_improvements_to_be_filled_out_by_codex.txt"
        if not file.exists():
            content = (
                "# DO NOT ERASE ME\n"
                "# I AM DIRECTIVES\n"
                "# Purpose:\n"
                "# This file is intended for Codex or any automated reasoning system reviewing this repository.\n"
                "# Use these directives to propose improvements.\n"
                "# Instructions:\n"
                "# 1. Analyze the entire repository, including:\n"
                "# - Source code scripts\n"
                "# - Generated burner scripts\n"
                "# - Design documents (PDDs)\n"
                "# - Version metadata\n"
                "# - Automation workflows\n"
                "# 2. Identify:\n"
                "# - Gaps or missing features\n"
                "# - Inefficiencies\n"
                "# - Logical inconsistencies\n"
                "# - Architecture issues\n"
                "# - Opportunities for automation or modernization\n"
                "# 3. Suggest improvements:\n"
                "# - What should be added, removed, or changed?\n"
                "# - How can the repository better align with its intended design?\n"
                "# - Which scripts or workflows need updates to support overall goals?\n"
                "# 4. Write your findings below in plain English, focusing on actionable changes.\n"
                "# Fill below:\n"
            )
            file.write_text(content, encoding="utf-8")

    # ---------- Explorer helpers ----------
    def _populate_explorer(self):
        self.tree.delete(*self.tree.get_children())
        if not self.current_project:
            return
        root_id = self.tree.insert("", "end", text=f"📁 {os.path.basename(self.current_project)}", open=True, values=[self.current_project])
        self._add_nodes(root_id, self.current_project, depth=0)

    def _add_nodes(self, parent, path, depth):
        try:
            for name in sorted(os.listdir(path)):
                if name.lower() in {".git", "venv"}:
                    continue
                full = os.path.join(path, name)
                icon = "📁" if os.path.isdir(full) else "📄"
                node = self.tree.insert(parent, "end", text=f"{icon} {name}", values=[full], open=(depth < 1))
                if os.path.isdir(full):
                    self._add_nodes(node, full, depth + 1)
        except Exception:
            pass

    def _on_tree_select(self):
        sel = self.tree.selection()
        if not sel:
            return
        path = self.tree.item(sel[0], "values")[0]
        self.file_view.delete("1.0", "end")
        if os.path.isdir(path):
            self.file_view.insert("end", f"[Folder] {path}")
        else:
            try:
                text = Path(path).read_text(encoding="utf-8", errors="ignore")
                self.file_view.insert("end", text)
            except Exception as e:
                self.file_view.insert("end", f"Error: {e}")

    def _delete_selected(self):
        sel = self.tree.selection()
        if not sel:
            return
        path = self.tree.item(sel[0], "values")[0]
        if not messagebox.askyesno("Delete", f"Delete '{path}'? This cannot be undone."):
            return
        try:
            if os.path.isdir(path):
                shutil.rmtree(path, onerror=_on_rm_error)
            else:
                try:
                    os.chmod(path, stat.S_IWRITE)
                except Exception:
                    pass
                Path(path).unlink(missing_ok=True)
            self._status(f"Deleted {path}")
            self._log_success(f"Deleted {path}")
        except Exception as e:
            messagebox.showerror("Delete failed", str(e))
            self._log_error(f"Delete failed: {e}")
        finally:
            self._refresh_all_views()

    # ---------- Program Design Manager helpers ----------
    def _populate_pdd_list(self):
        self.pdd_list.delete(0, tk.END)
        if not self.current_project:
            return
        dd_dir = Path(self.current_project) / "Design_Documents"
        if dd_dir.exists():
            for sub in sorted(dd_dir.iterdir()):
                if sub.is_dir():
                    self.pdd_list.insert(tk.END, sub.name)

    def _on_pdd_list_select(self):
        sel = self.pdd_list.curselection()
        if not sel:
            return
        name = self.pdd_list.get(sel[0])
        pdd_folder = Path(self.current_project) / "Design_Documents" / name
        pdd_file = pdd_folder / "pdd.txt"
        if pdd_file.exists():
            txt = pdd_file.read_text(encoding="utf-8")
            self.txt_pdd.delete("1.0", "end")
            self.txt_pdd.insert("end", txt)
            self._on_pdd_edit()
            self._status(f"Loaded PDD: {name}")
            self.nb.select(self.txt_pdd.master)
        psv_dir = pdd_folder / "progressive_scripts"
        latest = self._latest_progressive_file(psv_dir)
        if latest:
            try:
                prog_txt = Path(latest).read_text(encoding="utf-8")
                parts = re.split(r"\n\s*\n", prog_txt, maxsplit=1)
                body = parts[-1] if len(parts) > 1 else prog_txt
                self.txt_progressive.delete("1.0", "end")
                self.txt_progressive.insert("end", body)
            except Exception:
                pass
        burner_txt = Path(self.current_project) / "burner_scripts" / f"{name}.txt"
        if burner_txt.exists():
            code = burner_txt.read_text(encoding="utf-8")
            self.txt_progressive.delete("1.0", "end")
            self.txt_progressive.insert("end", code)

    def _new_pdd_subfolder(self):
        name = simpledialog.askstring("New Subfolder", "PDD Subfolder name:")
        if not name:
            return
        dd_dir = Path(self.current_project) / "Design_Documents" / name
        dd_dir.mkdir(parents=True, exist_ok=True)
        self._status(f"Created PDD subfolder: {name}")
        self._log_success(f"Created subfolder Design_Documents/{name}")
        self._refresh_all_views()

    def _delete_pdd_subfolder(self):
        sel = self.pdd_list.curselection()
        if not sel:
            return
        name = self.pdd_list.get(sel[0])
        if not messagebox.askyesno("Delete", f"Delete PDD subfolder '{name}'?"):
            return
        dd_dir = Path(self.current_project) / "Design_Documents" / name
        shutil.rmtree(dd_dir, onerror=_on_rm_error)
        self._status(f"Deleted PDD subfolder: {name}")
        self._log_success(f"Deleted subfolder Design_Documents/{name}")
        self._refresh_all_views()

    def _rename_pdd_subfolder(self):
        sel = self.pdd_list.curselection()
        if not sel:
            return
        old_name = self.pdd_list.get(sel[0])
        new_name = simpledialog.askstring("Rename", "New name:", initialvalue=old_name)
        if not new_name or new_name == old_name:
            return
        old_dir = Path(self.current_project) / "Design_Documents" / old_name
        new_dir = Path(self.current_project) / "Design_Documents" / new_name
        try:
            old_dir.rename(new_dir)
            self._status(f"Renamed PDD subfolder: {old_name} → {new_name}")
            self._log_success(f"Renamed Design_Documents/{old_name} → {new_name}")
        except Exception as e:
            messagebox.showerror("Rename failed", str(e))
            self._log_error(f"Rename failed: {e}")
            return
        self._refresh_all_views()

    def _add_burner_script_to_selected(self):
        """Legacy flow: generate code into Burner List; also populate Progressive editor."""
        sel = self.pdd_list.curselection()
        if not sel:
            return
        name = self.pdd_list.get(sel[0])
        pdd_folder = Path(self.current_project) / "Design_Documents" / name
        pdd_text = (pdd_folder / "pdd.txt").read_text(encoding="utf-8") if (pdd_folder / "pdd.txt").exists() else ""
        self._log_step(f"Generating burner script for module {name} …")
        code = call_ollama_chat(self.config["ollama_model_coding"], self.prompts["burner_script"].format(pdd=pdd_text), timeout=90)
        if code.startswith("Error:"):
            self._log_error("Coding model unavailable; cannot generate burner script right now.")
            return
        code = self._handle_think_blocks(code, origin="BurnerScript")
        bl = Path(self.current_project) / "burner_lists" / f"{name}_burner_list.txt"
        version_id = time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime())
        if not bl.exists():
            self._initialize_burner_list(bl, code, version_id, name)
        else:
            self._append_burner_version(bl, code, version_id, name)
        self.txt_progressive.delete("1.0", "end")
        self.txt_progressive.insert("end", code)
        self._status(f"Added burner script to {name} (and loaded into Progressive editor)")
        self._log_success(f"Burner script updated under burner_lists/{name}_burner_list.txt")
        self._refresh_all_views()

    # ---------- Add/Clone/Pull Repo ----------
    def _add_local_repo(self):
        if not self.current_project:
            messagebox.showwarning("Add Local Repo", "Select or create a project first.")
            return
        d = askdirectory(title="Select local repo folder", mustexist=True)
        if not d:
            return
        repo_dir = Path(self.current_project) / UPDATE_WS_NAME / REPO_FOLDER
        repo_dir.mkdir(parents=True, exist_ok=True)
        if any(repo_dir.iterdir()):
            if not messagebox.askyesno("Override Repo", "Repository already exists. Override?"):
                return
            self._log_step("Overriding existing repository folder…")
            wipe_directory_contents(repo_dir)
        name = os.path.basename(d.rstrip("/\\"))
        target = repo_dir / name
        shutil.copytree(d, target, dirs_exist_ok=True)
        self._status(f"Added local repo: {name}")
        self._log_success(f"Local repository added at {target}")
        self._refresh_all_views()

    def _clone_repo(self):
        """Legacy clone method — prefer Pull Repo (which remembers URL/branch and single-branch clones)."""
        if not self.current_project:
            messagebox.showwarning("Clone Repo", "Select or create a project first.")
            return
        url = simpledialog.askstring("Clone Repo", "Git URL:")
        if not url:
            return
        name = simpledialog.askstring("Clone Repo", "Folder name:", initialvalue="repo")
        if not name:
            return
        repo_dir = Path(self.current_project) / UPDATE_WS_NAME / REPO_FOLDER
        repo_dir.mkdir(parents=True, exist_ok=True)
        if any(repo_dir.iterdir()):
            if not messagebox.askyesno("Override Repo", "Repository already exists. Override?"):
                return
            self._log_step("Overriding existing repository folder…")
            wipe_directory_contents(repo_dir)
        target = repo_dir / name
        target.mkdir(exist_ok=True)
        self._log_step(f"Cloning {url} (no single-branch enforcement in legacy clone)…")
        code, out, err = run_git(["clone", url, "."], cwd=str(target))
        if code != 0:
            messagebox.showerror("Clone failed", err or out or "Unknown error")
            self._log_error(f"Clone failed: {err or out or 'Unknown error'}")
            return
        self._status(f"Cloned repo: {name}")
        self._log_success(f"Cloned into {target}")
        self._refresh_all_views()

    def _open_in_explorer(self):
        if not self.current_project:
            return
        try:
            if platform.system() == "Windows":
                os.startfile(self.current_project)
            elif platform.system() == "Darwin":
                subprocess.run(["open", self.current_project])
            else:
                subprocess.run(["xdg-open", self.current_project])
        except Exception as e:
            messagebox.showwarning("Open Folder", str(e))

    def _switch_project(self, name: str, absolute_path: Optional[str] = None):
        proj = absolute_path or str(Path(PROJECTS_DIR) / name)
        if not os.path.isdir(proj):
            messagebox.showwarning("Project", f"Not found: {proj}")
            return
        self.current_project = proj
        self.config["last_project"] = name
        cfg = self._proj_cfg()
        self.use_desktop.set(bool(cfg.get("use_github_desktop", self.config.get("use_github_desktop_default", False))))
        self.single_branch_only.set(bool(cfg.get("single_branch_only", self.config.get("single_branch_only_default", True))))
        self.global_mode.set(bool(cfg.get("global_update_mode", False)))
        self._save_config()
        self._ensure_structure(proj)
        self._ensure_db(Path(proj) / "conversation.db")
        pdd = Path(proj, "pdd.txt"); pdd.touch(exist_ok=True)
        txt = pdd.read_text(encoding="utf-8")
        self.txt_pdd.delete("1.0", "end"); self.txt_pdd.insert("end", txt)
        self.pdd_lines = txt.splitlines()
        idxf = Path(proj, "index.json")
        if not idxf.exists():
            idxf.write_text("[]", encoding="utf-8")
        try:
            self.sections = json.loads(idxf.read_text(encoding="utf-8"))
        except Exception:
            self.sections = []
        conn = sqlite3.connect(str(Path(proj) / "conversation.db"), check_same_thread=False)
        with self.db_lock:
            self.current_db = conn
        vdir = Path(proj, "versions"); vdir.mkdir(exist_ok=True)
        versions = sorted([p.name for p in vdir.glob("*.txt")])
        self.cmb_version["values"] = versions
        if versions:
            self.cmb_version.set(versions[-1])
        self._populate_explorer()
        self._populate_pdd_list()
        self._populate_launch_scripts()
        self._status(f"Opened project: {name}")
        self._log_success(f"Project opened: {name}")
        self._update_sync_state()

    # ---------- Project list / creation ----------
    def _refresh_projects(self):
        """Populate the Projects combobox with folder names under PROJECTS_DIR."""
        try:
            projects = [d.name for d in Path(PROJECTS_DIR).iterdir() if d.is_dir()]
        except Exception:
            projects = []
        self.cmb_project["values"] = sorted(projects)
        if self.config.get("last_project") in projects:
            self.cmb_project.set(self.config["last_project"])
        elif projects:
            self.cmb_project.set(projects[0])

    def _create_project(self):
        """Create a new project folder with baseline structure and switch to it."""
        name = simpledialog.askstring("New Project", "Project name:")
        if not name:
            return
        safe = re.sub(r"[^\w\-\. ]", "_", name).strip()
        proj_path = Path(PROJECTS_DIR) / safe
        if proj_path.exists():
            messagebox.showerror("New Project", f"Folder already exists:\n{proj_path}")
            self._log_error(f"Create project failed — folder exists: {proj_path}")
            return
        try:
            proj_path.mkdir(parents=True, exist_ok=False)
            self._ensure_structure(str(proj_path))
            self._ensure_db(proj_path / "conversation.db")
            (proj_path / "pdd.txt").write_text("", encoding="utf-8")
            (proj_path / "index.json").write_text("[]", encoding="utf-8")
        except Exception as e:
            messagebox.showerror("New Project", f"Failed to create project: {e}")
            self._log_error(f"Failed to create project: {e}")
            return
        self._refresh_projects()
        self.cmb_project.set(safe)
        self._switch_project(safe)
        self._status(f"Created project: {safe}")
        self._log_success(f"Project created: {safe}")
        self._refresh_all_views()

    def _ensure_structure(self, proj: str | Path):
        proj = Path(proj)
        (proj / UPDATE_WS_NAME).mkdir(parents=True, exist_ok=True)
        (proj / UPDATE_WS_NAME / REPO_FOLDER).mkdir(parents=True, exist_ok=True)
        (proj / UPDATE_WS_NAME / THINK_DIR_NAME).mkdir(parents=True, exist_ok=True)
        (proj / "Design_Documents").mkdir(parents=True, exist_ok=True)
        (proj / "versions").mkdir(parents=True, exist_ok=True)
        (proj / "burner_scripts").mkdir(parents=True, exist_ok=True)
        (proj / "burner_lists").mkdir(parents=True, exist_ok=True)
        (proj / UPDATE_WS_NAME / "errors").mkdir(parents=True, exist_ok=True)
        (proj / UPDATE_WS_NAME / "runtime_assets.json").touch(exist_ok=True)
        prompts_json = proj / "prompts_config.json"
        if not prompts_json.exists():
            prompts_json.write_text(json.dumps(DEFAULT_PROMPTS, indent=2), encoding="utf-8")

    def _ensure_db(self, db_path: Path):
        conn = sqlite3.connect(str(db_path), check_same_thread=False)
        conn.execute("CREATE TABLE IF NOT EXISTS messages (id INTEGER PRIMARY KEY, text TEXT, embedding BLOB, timestamp REAL)")
        conn.execute("CREATE TABLE IF NOT EXISTS pdd_sections (id INTEGER PRIMARY KEY, section_text TEXT, embedding BLOB, section_hash TEXT, timestamp REAL)")
        # NEW: error diary (current + archived)
        conn.execute("""
            CREATE TABLE IF NOT EXISTS errors (
                id INTEGER PRIMARY KEY,
                session_id TEXT,
                script TEXT,
                timestamp REAL,
                type TEXT,
                message TEXT,
                traceback TEXT,
                path TEXT,
                line INTEGER,
                status TEXT,  -- 'new' | 'archived' | 'stable'
                version_tag TEXT
            )
        """)
        conn.commit()
        conn.close()

    # ---------- Reset Data Set & Project ----------
    def _reset_data_set(self):
        if not self.current_project or not self.current_db:
            return
        if not messagebox.askyesno("Reset Data Set", "This will clear ALL semantic data (messages & sections). Continue?"):
            return
        self._log_step("Clearing semantic dataset (messages + sections)…")
        with self.db_lock:
            c = self.current_db.cursor()
            c.execute("DELETE FROM messages")
            c.execute("DELETE FROM pdd_sections")
            self.current_db.commit()
        info_dir = Path(self.current_project) / UPDATE_WS_NAME
        if info_dir.exists():
            for item in info_dir.rglob("*"):
                try:
                    if item.is_dir():
                        shutil.rmtree(item, onerror=_on_rm_error)
                    else:
                        try:
                            os.chmod(item, stat.S_IWRITE)
                        except Exception:
                            pass
                        item.unlink(missing_ok=True)
                except Exception:
                    pass
        self._status("Data set reset")
        self._log_success("Semantic dataset cleared.")
        self._refresh_all_views()

    def _reset_project_folder(self):
        if not self.current_project:
            return
        if not messagebox.askyesno("Reset Project", "This will delete ALL project files and recreate minimal structure. Continue?"):
            return
        self._log_step("Resetting project folder to minimal baseline…")
        proj = Path(self.current_project)
        for item in list(proj.iterdir()):
            try:
                if item.is_dir():
                    shutil.rmtree(item, onerror=_on_rm_error)
                else:
                    try:
                        os.chmod(item, stat.S_IWRITE)
                    except Exception:
                        pass
                    item.unlink(missing_ok=True)
            except Exception:
                pass
        (proj / "pdd.txt").write_text("", encoding="utf-8")
        (proj / "index.json").write_text("[]", encoding="utf-8")
        db = sqlite3.connect(str(proj / "conversation.db"), check_same_thread=False)
        db.execute("CREATE TABLE IF NOT EXISTS messages (id INTEGER PRIMARY KEY, text TEXT, embedding BLOB, timestamp REAL)")
        db.execute("CREATE TABLE IF NOT EXISTS pdd_sections (id INTEGER PRIMARY KEY, section_text TEXT, embedding BLOB, section_hash TEXT, timestamp REAL)")
        db.close()
        self._switch_project(os.path.basename(proj), absolute_path=str(proj))
        self._status("Project reset")
        self._log_success("Project reset complete.")
        self._refresh_all_views()

    # ---------- PDD handling ----------
    def _on_pdd_edit(self):
        self.pdd_lines = self.txt_pdd.get("1.0", "end").splitlines()

    def _save_pdd(self):
        if not self.current_project:
            return
        Path(self.current_project, "pdd.txt").write_text(self.txt_pdd.get("1.0", "end"), encoding="utf-8")
        self._status("PDD saved")
        self._log_success("PDD saved to disk.")

    def _save_index(self):
        if not self.current_project:
            return
        Path(self.current_project, "index.json").write_text(json.dumps(self.sections, indent=2), encoding="utf-8")

    def _append_to_pdd(self, text: str):
        if not text:
            return
        if not text.endswith("\n"):
            text += "\n"
        self.txt_pdd.insert("end", text + "\n"); self.txt_pdd.see("end")
        self.pdd_lines = self.txt_pdd.get("1.0", "end").splitlines()
        sid = hashlib.md5(text.encode()).hexdigest()
        self.sections.append({
            "id": sid,
            "start": len(self.pdd_lines) - text.count("\n") - 1,
            "end": len(self.pdd_lines),
            "hash": sid
        })
        self._save_index()
        self._save_pdd()
        if self.current_db:
            snippet = text[:5000]
            em = embed(snippet, self.config["embedding_model"])
            with self.db_lock:
                c = self.current_db.cursor()
                c.execute(
                    "INSERT INTO messages (text, embedding, timestamp) VALUES (?,?,?)",
                    (f"[NEW_PDD_SECTION:{sid}]\n{snippet}", json.dumps(em) if em else None, time.time())
                )
                self.current_db.commit()

    def _extract_section(self, sid: str) -> Optional[str]:
        for s in self.sections:
            if s["hash"] == sid:
                return "\n".join(self.pdd_lines[s["start"]-1:s["end"]-1])
        return None

    def _replace_section(self, sid: str, new_text: str):
        for s in self.sections:
            if s["hash"] == sid:
                start, end = s["start"]-1, s["end"]-1
                nl = new_text.splitlines() + [""]
                self.pdd_lines[start:end+1] = nl
                s["end"] = start + len(nl) + 1
                s["hash"] = hashlib.md5(new_text.encode()).hexdigest()
                break
        self.txt_pdd.delete("1.0", "end")
        self.txt_pdd.insert("end", "\n".join(self.pdd_lines))
        self._save_index()
        self._save_pdd()

    def _highlight(self, sid: str):
        for s in self.sections:
            if s["hash"] == sid:
                a, b = f"{s['start']}.0", f"{s['end']}.0"
                self.txt_pdd.tag_add("hl", a, b)
                self.txt_pdd.tag_config("hl", background="#3b82f6", foreground="black")
                self.root.after(2500, lambda: self.txt_pdd.tag_remove("hl", a, b))
                break

    # ---------- DB / semantics ----------
    def _history(self, depth: int) -> str:
        if not self.current_db:
            return ""
        with self.db_lock:
            c = self.current_db.cursor()
            c.execute("SELECT text FROM messages ORDER BY timestamp DESC LIMIT ?", (depth,))
            return "\n".join([r[0] for r in c.fetchall()])

    def _semantic(self, query: str) -> str:
        if not self.current_db:
            return ""
        q = embed(query, self.config["embedding_model"])
        if not q:
            return ""
        with self.db_lock:
            c = self.current_db.cursor()
            c.execute("SELECT section_text, embedding FROM pdd_sections")
            res = []
            for t, b in c.fetchall():
                try:
                    e = json.loads(b) if b else None
                except Exception:
                    e = None
                s = cos(q, e) if e else 0
                if s > 0.5:
                    res.append((s, t))
            res.sort(key=lambda x: x[0], reverse=True)
            return "\n".join([t for _, t in res[:3]])

    def _add_msg(self, text: str):
        if not self.current_db:
            return
        em = embed(text, self.config["embedding_model"])
        with self.db_lock:
            c = self.current_db.cursor()
            c.execute(
                "INSERT INTO messages (text, embedding, timestamp) VALUES (?,?,?)",
                (text, json.dumps(em) if em else None, time.time())
            )
            self.current_db.commit()

    # ---------- Versions / model ----------
    def _save_version(self):
        if not self.current_project:
            return
        vdir = Path(self.current_project, "versions"); vdir.mkdir(exist_ok=True)
        ts = time.strftime("%Y%m%d_%H%M%S")
        out = vdir / f"{ts}.txt"
        out.write_text(self.txt_pdd.get("1.0", "end"), encoding="utf-8")
        versions = sorted([p.name for p in vdir.glob("*.txt")])
        self.cmb_version["values"] = versions
        self.cmb_version.set(out.name)
        self._status(f"Saved version {out.name}")
        self._log_success(f"Version snapshot saved: {out.name}")
        self._refresh_all_views()

    def _load_version(self, name: str):
        if not self.current_project or not name:
            return
        vf = Path(self.current_project, "versions", name)
        if not vf.exists():
            return
        txt = vf.read_text(encoding="utf-8")
        self.txt_pdd.delete("1.0", "end"); self.txt_pdd.insert("end", txt); self._on_pdd_edit()

    def _update_task_type(self):
        """Wire Task Type to behaviors and log it (affects default Update Repo checkbox suggestions)."""
        tt = self.task_type.get()
        self._log_step(f"Task Type set to: {tt}")

    # ---------- Input/Prep flow ----------
    def _send_on_enter(self, event):
        if not (event.state & 0x0004):  # Ctrl not pressed
            self._send_to_prep()
            return "break"
        return None

    def _send_to_prep(self):
        txt = self.txt_input.get("1.0", "end").strip()
        if not txt:
            return
        if self.txt_prep.index("end-1c") != "1.0":
            self.txt_prep.insert("end", "\n\n")
        self.txt_prep.insert("end", txt)
        self.txt_prep.see("end")
        self.txt_input.delete("1.0", "end")

    def _append_prep_to_pdd(self):
        self._append_to_pdd(self.txt_prep.get("1.0", "end").strip())

    def _send_prep_to_llm(self):
        content = self.txt_prep.get("1.0", "end").strip()
        if not content:
            return
        self.txt_prep.delete("1.0", "end")
        if self.global_mode.get():
            threading.Thread(target=self._global_workflow, args=(content,), daemon=True).start()
        else:
            threading.Thread(target=self._workflow, args=(content,), daemon=True).start()

    def _rewrite_prep(self):
        text = self.txt_prep.get("1.0", "end").strip()
        if not text:
            return
        self._status("Rewriting Prep…")
        self._log_step("Invoking text model to rewrite prep content…")
        out = call_ollama_chat(self.config["ollama_model_text"], self.prompts["prep_rewrite"].format(text=text), timeout=30)
        if out.startswith("Error:"):
            self._log_error("Text model unavailable; cannot rewrite prep.")
            return
        self.txt_prep.delete("1.0", "end")
        self.txt_prep.insert("end", out)
        self._log_success("Prep rewritten.")
        self._status("Prep rewritten")

    # ---------- STT / TTS ----------
    def _start_mic(self):
        if self.listening or not self.recognizer or not self.mic:
            return
        self.listening = True
        self.stt_thread = threading.Thread(target=self._listen_loop, daemon=True)
        self.stt_thread.start()
        self._status("Listening…")
        self._log_step("Microphone listening started.")

    def _stop_mic(self):
        self.listening = False
        if self.stt_thread:
            self.stt_thread.join(timeout=0.2)
            self.stt_thread = None
        self._status("Mic stopped")
        self._log_success("Microphone listening stopped.")

    def _stop_tts_immediate(self):
        if self.tts:
            try:
                self.tts.stop()
            except Exception:
                pass
        self._status("TTS stopped")
        self._log_success("TTS stopped immediately.")

    def _update_tts_speed(self):
        factor = float(self.sld_tts_speed.get())
        self.config["tts_rate_factor"] = factor
        base = DEFAULT_CONFIG["tts_speed"]
        if self.tts:
            self.tts.setProperty("rate", int(base * factor))
        self._save_config()
        self._status(f"TTS speed set to {factor:.2f}×")
        self._log_success(f"TTS rate adjusted to {factor:.2f}×")

    def _toggle_tts(self):
        self.tts_muted = not self.tts_muted
        self._status("TTS muted" if self.tts_muted else "TTS unmuted")
        self._log_step("TTS mute toggled.")

    def _speak(self, text: str):
        if self.tts and not self.tts_muted:
            try:
                self.tts.say(text)
                self.tts.runAndWait()
            except Exception as e:
                logger.warning("TTS speak error: %s", e)

    def _listen_loop(self):
        try:
            with self.mic as src:
                self.recognizer.adjust_for_ambient_noise(src)
                while self.listening:
                    try:
                        audio = self.recognizer.listen(src, timeout=5, phrase_time_limit=10)
                        txt = self.recognizer.recognize_google(audio)
                        sep = "" if self.txt_input.index("end-1c") == "1.0" else " "
                        self.txt_input.insert("end", sep + txt)
                        self.root.after(0, self.txt_input.see, "end")
                    except sr.WaitTimeoutError:
                        continue
                    except sr.UnknownValueError:
                        continue
                    except Exception as e:
                        logger.error("STT error: %s", e)
                        self._status(f"STT error: {e}")
        except Exception as e:
            logger.error("Mic loop error: %s", e)

    # ---------- Workflow (Summary → Consistency → Rewrites → Pseudo) ----------
    def _workflow(self, user_text: str):
        try:
            self._status("Summary Bot…")
            self._log_step("Summarizing user input into PDD update…")
            history = self._history(int(self.sld_context.get()))
            semantic = self._semantic(user_text)
            model = self.config["ollama_model_text"] if self.task_type.get() == "PDD" else self.config["ollama_model_coding"]
            errors = self._get_current_errors()
            summary = call_ollama_chat(model, f"{self.prompts['summary']}\nErrors:\n{errors}\n\n{user_text}")
            if summary.startswith("Error:"):
                self._log_error("Model unavailable; cannot summarize now.")
                return
            summary = self._handle_think_blocks(summary, origin="Summary")
            self._add_msg(summary)
            self._append_to_pdd(f"/* Summary */\n{summary}")
            was_empty = not any(line.strip() for line in self.pdd_lines[:-summary.count("\n")-2])
            if not was_empty:
                self._status("Consistency Bot…")
                self._log_step("Checking for PDD inconsistencies…")
                full_pdd = "\n".join(self.pdd_lines)
                cons_out = call_ollama_chat(model, self.prompts["consistency"].format(
                    summary=summary, full_pdd=full_pdd
                ))
                if cons_out.startswith("Error:"):
                    self._log_warn("Model unavailable; skipping consistency checks.")
                else:
                    tasks = parse_tasks(cons_out)
                    self._status("Spot Rewriter…")
                    self._log_step(f"Applying {len(tasks)} spot rewrites…")
                    for t in tasks:
                        sid = t["section_id"]
                        sec = self._extract_section(sid)
                        if not sec:
                            continue
                        new_sec = call_ollama_chat(model, self.prompts["rewrite"].format(
                            section_text=sec, summary=summary, reason=t["reason"]
                        ))
                        if new_sec.startswith("Error:"):
                            self._log_warn("Model unavailable; skipping a rewrite.")
                            continue
                        new_sec = self._handle_think_blocks(new_sec, origin="Rewrite")
                        self._replace_section(sid, new_sec)
                        if self.current_db:
                            em = embed(new_sec, self.config["embedding_model"])
                            with self.db_lock:
                                c = self.current_db.cursor()
                                c.execute(
                                    "UPDATE pdd_sections SET section_text=?, embedding=?, timestamp=? WHERE section_hash=?",
                                    (new_sec, json.dumps(em) if em else None, time.time(), sid)
                                )
                                self.current_db.commit()
                        self.root.after(0, lambda s=sid: self._highlight(s))
            else:
                self._status("First-time PDD—skipping consistency + rewrite")
                self._log_warn("First-time PDD detected; skipping rewrite phase.")
            self._status("Pseudo-Code Bot…")
            self._log_step("Injecting pseudocode hints across PDD…")
            full_pdd = "\n\n".join(self.pdd_lines)
            pseudo = call_ollama_chat(self.config["ollama_model_coding"], self.prompts["pseudo"].format(full_pdd=full_pdd))
            if not pseudo.startswith("Error:"):
                pseudo = self._handle_think_blocks(pseudo, origin="PseudoCode")
                self._append_to_pdd(pseudo)
            else:
                self._log_warn("Coding model unavailable; skipping pseudocode injection.")
            self._speak(summary)
            self._semantic_reweight_all()
            self._status("Done")
            self._log_success("Workflow complete.")
        except Exception as e:
            logger.error("Workflow error: %s", e)
            self._status(f"Error: {e}")
            self._log_error(f"Workflow error: {e}")

    def _global_workflow(self, user_text: str):
        try:
            self._status("Global Update Mode: Analyzing input…")
            self._log_step("Global mode: Extracting diffs and tasks…")
            errors = self._get_current_errors()
            task_json = call_ollama_chat(self.config["ollama_model_text"], f"{self.prompts['global_diff_extraction']}\nErrors:\n{errors}\n\n{user_text}")
            if task_json.startswith("Error:"):
                self._log_error("Model unavailable; global update aborted.")
                return
            tasks = json.loads(task_json)
            self._log_progress(f"Identified {len(tasks)} scripts for update.")
            for script, changes in tasks.items():
                self._log_step(f"Processing {script}…")
                # Update PDD
                pdd_path = Path(self.current_project) / "Design_Documents" / script / "pdd.txt"
                if pdd_path.exists():
                    pdd = pdd_path.read_text(encoding="utf-8")
                    updated_pdd = call_ollama_chat(self.config["ollama_model_text"], self.prompts["human_pdd_update"].format(pdd=pdd, changes=changes))
                    pdd_path.write_text(updated_pdd, encoding="utf-8")
                # Rewrite summary
                summary = call_ollama_chat(self.config["ollama_model_text"], self.prompts["human_summary_update"].format(changes=changes))
                summary_path = Path(self.current_project) / "Design_Documents" / script / "summary.txt"
                summary_path.write_text(summary, encoding="utf-8")
                # Pseudocode
                pseudo = call_ollama_chat(self.config["ollama_model_coding"], self.prompts["pseudo"].format(full_pdd=updated_pdd))
                pseudo_path = Path(self.current_project) / "Design_Documents" / script / "pseudocode.txt"
                pseudo_path.write_text(pseudo, encoding="utf-8")
                # Burner script
                burner = call_ollama_chat(self.config["ollama_model_coding"], self.prompts["burner_script"].format(pdd=updated_pdd))
                burner_path = Path(self.current_project) / "burner_scripts" / f"{script}.txt"
                burner_path.write_text(burner, encoding="utf-8")
            self._integrate_codex_suggestions()
            self._status("Global update complete")
            self._log_success("Global workflow complete.")
            self._refresh_all_views()
        except Exception as e:
            logger.error("Global workflow error: %s", e)
            self._status(f"Error: {e}")
            self._log_error(f"Global workflow error: {e}")

    def _integrate_codex_suggestions(self):
        directive_file = Path(self.current_project) / "suggested_improvements_to_be_filled_out_by_codex.txt"
        if directive_file.exists():
            suggestions = directive_file.read_text(encoding="utf-8").split("# Fill below:")[1].strip() if "# Fill below:" in directive_file.read_text(encoding="utf-8") else ""
            if suggestions:
                self._log_step("Integrating Codex suggestions…")
                # Apply suggestions to PDDs, summaries, etc.
                # For simplicity, append to project_summary.txt
                summary_path = Path(self.current_project) / "project_summary.txt"
                if summary_path.exists():
                    summary = summary_path.read_text(encoding="utf-8")
                    updated_summary = call_ollama_chat(self.config["ollama_model_text"], self.prompts["human_summary_update"].format(changes=suggestions))
                    summary_path.write_text(updated_summary, encoding="utf-8")

    def _handle_think_blocks(self, text: str, origin: str = "Unknown") -> str:
        """ Extract <think>…</think> blocks into project_info/Logic_Thoughts/ThinkList_YYYYMMDD.txt and replace them in-surface with a short provenance stub (<think>#YYYYMMDD-xxxxxxx). """
        think_matches = re.findall(r'<think>(.*?)</think>', text, re.DOTALL)
        if not think_matches or not self.current_project:
            return text
        logic_dir = Path(self.current_project) / UPDATE_WS_NAME / THINK_DIR_NAME
        logic_dir.mkdir(parents=True, exist_ok=True)
        day_tag = time.strftime('%Y%m%d')
        think_file = logic_dir / f"ThinkList_{day_tag}.txt"
        for think in think_matches:
            unique_id = hashlib.md5(think.encode()).hexdigest()[:8]
            with open(think_file, "a", encoding="utf-8") as f:
                f.write(
                    f"=== THINK BLOCK #{day_tag}-{unique_id} ===\n"
                    f"Origin: {origin}\n"
                    f"Project: {os.path.basename(self.current_project)}\n"
                    f"Timestamp: {time.strftime('%Y-%m-%d %H:%M:%S')}\n"
                    f"---\n"
                    f"{think}\n"
                    f"=====================================\n\n"
                )
            text = text.replace(f"<think>{think}</think>", f"<think>#{day_tag}-{unique_id}")
        return text

    # ---------- Diff tools ----------
    def _paste_diff_clip(self):
        try:
            txt = self.root.clipboard_get()
        except Exception:
            txt = ""
        self.txt_diff.delete("1.0", "end")
        self.txt_diff.insert("end", txt)
        self._status("Diff pasted")
        self._log_success("Diff pasted from clipboard.")

    def _fetch_local_diff(self):
        if not self.current_project:
            return
        if git_is_repo(self.current_project):
            code, out, err = run_git(["diff"], cwd=self.current_project)
            if code != 0:
                messagebox.showerror("git diff", err or out or "Unknown")
                self._log_error(f"git diff failed: {err or out or 'Unknown'}")
                return
            self.txt_diff.delete("1.0", "end")
            self.txt_diff.insert("end", out or "(no changes)")
            self._status("Fetched git diff")
            self._log_success("Local git diff fetched.")
            return
        vdir = Path(self.current_project, "versions")
        latest = max(vdir.glob("*.txt"), default=None, key=lambda p: p.stat().st_mtime)
        if not latest:
            messagebox.showinfo("Diff", "Not a git repo and no versions available.")
            self._log_warn("No versions available to diff.")
            return
        a = latest.read_text(encoding="utf-8").splitlines(keepends=True)
        b = Path(self.current_project, "pdd.txt").read_text(encoding="utf-8").splitlines(keepends=True)
        d = difflib.unified_diff(a, b, fromfile=latest.name, tofile="pdd.txt")
        self.txt_diff.delete("1.0", "end")
        self.txt_diff.insert("end", "".join(d))
        self._status("Local diff (version vs pdd.txt)")
        self._log_success("Generated local diff against last version snapshot.")

    def _init_git_repo(self):
        if not self.current_project:
            return
        if git_is_repo(self.current_project):
            self._status("Already a git repo")
            self._log_warn("Current project folder is already a git repository.")
            return
        code, out, err = run_git(["init"], cwd=self.current_project)
        if code != 0:
            messagebox.showerror("git init", err or out or "Unknown")
            self._log_error(f"git init failed: {err or out or 'Unknown'}")
            return
        run_git(["add", "-A"], cwd=self.current_project)
        run_git(["commit", "-m", "Initial commit"], cwd=self.current_project)
        self._status("Initialized git repository")
        self._log_success("Git repository initialized in project folder.")
        self._refresh_all_views()

    def _fetch_github_compare(self):
        url = simpledialog.askstring("GitHub Compare", "Enter .diff or .patch URL:")
        if not url:
            return
        try:
            self._log_step("Fetching GitHub compare patch…")
            r = requests.get(url, timeout=20)
            r.raise_for_status()
            self.txt_diff.delete("1.0", "end")
            self.txt_diff.insert("end", r.text)
            self._status("Fetched GitHub compare")
            self._log_success("GitHub compare fetched.")
        except Exception as e:
            messagebox.showerror("Fetch compare", str(e))
            self._log_error(f"Fetch compare failed: {e}")

    def _ingest_repo(self):
        if not (self.current_project and self.current_db):
            return
        info_dir = Path(self.current_project) / UPDATE_WS_NAME
        info_dir.mkdir(exist_ok=True)
        count = 0
        self._log_step("Ingesting repository files into dataset…")
        for cur, dirs, files in os.walk(self.current_project):
            for skip in (".git", "venv"):
                if skip in dirs:
                    dirs.remove(skip)
            for f in files:
                p = Path(cur) / f
                if UPDATE_WS_NAME in p.parts:
                    snippet = p.read_text(encoding="utf-8", errors="ignore")[:5000]
                    dst = info_dir / p.relative_to(self.current_project)
                    dst.parent.mkdir(parents=True, exist_ok=True)
                    dst.write_text(snippet, encoding="utf-8")
                    em = embed(snippet, self.config["embedding_model"])
                    with self.db_lock:
                        c = self.current_db.cursor()
                        c.execute(
                            "INSERT OR REPLACE INTO messages (text, embedding, timestamp) VALUES (?,?,?)",
                            (f"[FILE:{p.relative_to(self.current_project)}]\n{snippet}", json.dumps(em) if em else None, time.time())
                        )
                    count += 1
                    if count % 50 == 0:
                        self._log_progress(f"Ingested {count} files…")
        with self.db_lock:
            self.current_db.commit()
        self._status(f"Ingested {count} files")
        self._log_success(f"Ingested {count} files into dataset.")
        self._refresh_all_views()

    # ---------- Quick commit ----------
    def _quick_commit(self):
        if not self.current_project:
            return
        if not git_is_repo(self.current_project):
            messagebox.showinfo("Git", "Not a git repo. Use 'Init Git Repo'.")
            self._log_warn("Quick commit aborted: not a git repository.")
            return
        msg = simpledialog.askstring("Quick Commit", "Commit message:", initialvalue=f"update {time.strftime('%Y-%m-%d %H:%M:%S')}")
        if not msg:
            return
        run_git(["add", "-A"], cwd=self.current_project)
        code, out, err = run_git(["commit", "-m", msg], cwd=self.current_project)
        if code != 0:
            messagebox.showerror("Commit failed", err or out or "Unknown")
            self._log_error(f"Quick commit failed: {err or out or 'Unknown'}")
        else:
            self._status("Committed changes")
            self._log_success("Quick commit completed.")
        self._refresh_all_views()

    # ---------- Burner script (legacy generator) ----------
    def _burner_script(self):
        pdd = self.txt_pdd.get("1.0", "end")
        self._log_step("Generating legacy burner script from PDD…")
        code = call_ollama_chat(self.config["ollama_model_coding"], self.prompts["burner_script"].format(pdd=pdd), timeout=90)
        if code.startswith("Error:"):
            self._log_error("Coding model unavailable; cannot generate burner script right now.")
            return
        code = self._handle_think_blocks(code, origin="BurnerScript")
        out = Path(self.current_project) / "burner_scripts" / "burner.txt"
        out.write_text(code, encoding="utf-8")
        self.txt_progressive.delete("1.0", "end")
        self.txt_progressive.insert("end", code)
        self.txt_pdd.insert("end", f"\n/* Burner Script: {out.name} */\n{code}\n")
        self._status(f"Burner script generated: {out.name} (loaded into Progressive editor)")
        self._log_success(f"Burner script written to {out}")
        self._refresh_all_views()

    # ---------- Semantic re-weight ----------
    def _semantic_reweight_all(self):
        if not (self.current_project and self.current_db):
            return
        info_dir = Path(self.current_project) / UPDATE_WS_NAME
        if not info_dir.exists():
            return
        count = 0
        self._log_step("Re-embedding project_info files for semantic weighting…")
        for file in info_dir.rglob("*.*"):
            try:
                text = file.read_text(encoding="utf-8", errors="ignore")[:5000]
            except Exception:
                continue
            em = embed(text, self.config["embedding_model"])
            with self.db_lock:
                c = self.current_db.cursor()
                c.execute(""" INSERT OR REPLACE INTO messages (text, embedding, timestamp) VALUES (?, ?, ?) """,
                          (f"[FILE:{file.relative_to(self.current_project)}]\n{text}", json.dumps(em) if em else None, time.time()))
            count += 1
            if count % 40 == 0:
                self._log_progress(f"Re-embedded {count} files…")
        with self.db_lock:
            self.current_db.commit()
        self._status(f"Re-semantic-weighted {count} project_info files")
        self._log_success(f"Semantic weights updated for {count} files.")

    # ---------- Status ----------
    def _status(self, msg: str):
        self.status.set(msg)
        logger.info(msg)

    # ---------- Launch Script ----------
    def _launch_script(self):
        if not self.current_project:
            return
        script = self.cmb_launch_script.get()
        if not script:
            return
        version_id = time.strftime("%Y%m%d_%H%M%S")
        error_file = Path(self.current_project) / "project_info" / "errors" / f"errors_v{version_id}.txt"
        asset_file = Path(self.current_project) / "project_info" / "runtime_assets.json"
        before = set(Path(self.current_project).rglob("*"))
        try:
            proc = subprocess.Popen(["python", script], cwd=self.current_project, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
            stdout, stderr = proc.communicate()
            with open(error_file, "w", encoding="utf-8") as f:
                f.write(f"STDOUT:\n{stdout}\n\nSTDERR:\n{stderr}")
            after = set(Path(self.current_project).rglob("*"))
            new_assets = list(after - before)
            with open(asset_file, "w", encoding="utf-8") as f:
                json.dump({"new_assets": [str(p) for p in new_assets]}, f, indent=2)
            self._log_success("Script launched and logs captured.")
        except Exception as e:
            self._log_error(f"Launch failed: {e}")

# -------------------- Prompt dialog --------------------
class PromptControlDialog(tk.Toplevel):
    def __init__(self, parent, prompts: Dict[str, str], app_ref: RantPDD):
        super().__init__(parent)
        self.title("Prompt/LLM Control")
        self.configure(bg=THEME_BG)
        self.prompts = prompts
        self.models = discover_ollama_models()
        self.app = app_ref  # reference to RantPDD for saving model selections
        def field(lbl, key):
            ttk.Label(self, text=lbl, background=THEME_BG, foreground=THEME_TEXT).pack(anchor="w", padx=10, pady=(10, 2))
            w = tk.Text(self, height=5, bg=THEME_ELEV, fg=THEME_TEXT, insertbackground=THEME_TEXT, wrap="word")
            w.insert("end", prompts[key])
            w.pack(fill="x", padx=10)
            cmb = ttk.Combobox(self, state="readonly", values=self.models, width=28)
            cmb.pack(padx=10, pady=2)
            default = DEFAULT_CONFIG["ollama_model_coding"] if key in ["pseudo", "burner_script"] \
                else DEFAULT_CONFIG["ollama_model_text"]
            cmb.set(default)
            setattr(self, f"cmb_{key}", cmb)
            return w
        self.f_summary = field("Summary Prompt", "summary")
        self.f_consistency = field("Consistency Prompt", "consistency")
        self.f_rewrite = field("Rewrite Prompt", "rewrite")
        self.f_pseudo = field("Pseudo-Code Prompt", "pseudo")
        self.f_burner = field("Burner Script Prompt", "burner_script")
        self.f_prep_rewrite = field("Prep Rewrite Prompt", "prep_rewrite")
        self.f_sync = field("Project Sync Prompt", "project_sync")
        self.f_over = field("Project Overview Prompt", "project_overview")
        self.f_global_diff = field("Global Diff Extraction Prompt", "global_diff_extraction")
        self.f_human_pdd = field("Human PDD Update Prompt", "human_pdd_update")
        self.f_human_summary = field("Human Summary Update Prompt", "human_summary_update")
        self.f_runtime_doc = field("Runtime Documentation Prompt", "runtime_documentation")
        self.f_packaging = field("Packaging Prompt", "packaging")
        self.f_improvement = field("Improvement File Prompt", "improvement_file")
        self.f_global_exec = field("Global Chat Execution Prompt", "global_chat_execution")
        self.f_runtime_test = field("Runtime Testing Prompt", "runtime_testing")
        self.f_pdd_gen = field("PDD Generation Prompt", "pdd_generation")
        self.f_summary_gen = field("Summary Generation Prompt", "summary_generation")
        self.f_codex_sugg = field("Codex Suggestion Prompt", "codex_suggestion")
        ttk.Button(self, text="Save", command=self._save).pack(pady=10)

    def _save(self):
        for key in self.prompts:
            txt = getattr(self, f"f_{key.replace('-', '_')}").get("1.0", "end").strip()
            self.prompts[key] = txt
            model = getattr(self, f"cmb_{key.replace('-', '_')}").get()
            if key in ["pseudo", "burner_script"]:
                self.app.config["ollama_model_coding"] = model
            else:
                self.app.config["ollama_model_text"] = model
        try:
            Path(CONFIG_FILE).write_text(json.dumps(self.app.config, indent=2))
        except Exception:
            pass
        self.destroy()

# -------------------- Main --------------------
def main():
    _set_process_dpi_awareness()
    root = tk.Tk()
    _apply_tk_scaling(root)
    app = RantPDD(root)
    root.mainloop()

if __name__ == "__main__":
    main()
```

Rant_PDD.py — 2025 UI refresh with full workflow, Explorer, Dataset controls, safe resets, Sync & Summary features, versioned repository sync, and Package for GitHub.
🦈 SHARK_SENTINEL DeepSeek Progressive Script Integration + GitHub Enhancements
----------------------------------------------------------------
• Concept shift: Burner Script → Progressive Script (permanent, versioned)
• Progressive Scripts Archive under Design_Documents/<module>/progressive_scripts
• Headers include PDD hash, model used, timestamp
• UI updates:
  - NEW purple buttons: Pull Repo, Update Repo (single-branch mode + GitHub Desktop option)
  - “Progressive Script” tab (renamed) with: ▸ Promote to Repo (archive/inject) ▸ Archive Current Version
  - NEW checkbox: Use GitHub Desktop — routes Pull/Update to also open the repo in GitHub Desktop for verification. Stores per-project repo URL/branch; pulls one branch only. Accepts Git URL or x-github-client:// link.
  - NEW checkbox: Single-branch only — enforces tracking only the selected branch.
  - NEW Update Repo dialog with CHECKBOXES: ▸ Include Progressive Scripts ▸ Include Design_Documents ▸ Include Info (project_info excluding repository) These choices are remembered per project across sessions.
• GitHub flows:
  - Pull Repo remembers URL + branch; single-branch clone/pull only.
  - Update Repo wipes target subfolders first (no residuals), copies selected items, commits, pushes, and optionally opens GitHub Desktop.
• Robust deletion:
  - Delete Repository now wipes ALL nested content including hidden .git on Windows.
  - Reset Project wipes everything and recreates minimal structure.
• Dual export packaging for GitHub (Design_Documents + generated scripts)
  - export_generated_scripts_* is fully wiped on each run, then ALL Progressive Scripts from every module are copied (all *.py versions), no residuals.
• Full backward compatibility with existing Codex-based workflow
• Auto-refresh Explorer after file ops + F5 refresh key
• System Console panel for live logs with colored syntax (STEP/PROGRESS/WARN/ERROR/SUCCESS)
Fixes and Notables (2025-08-06):
• **Streaming System Console**: Sync Repo now runs in a background thread with frequent progress ticks. You immediately see “Starting repository sync …” and periodic updates.
• **Ollama not running resilience**:
  - Centralized retry logic (bounded) for /api/chat and /api/embeddings with exponential backoff.
  - Early WARN/ERROR lines in the console if the local server is down; operations won’t hang the UI.
  - Embeddings gracefully skip; summaries log an error and continue the sync pipeline.
• **Update Repo dialog** revamped with checkboxes and per-project persistence.
• **Wipe/Save semantics (no residuals)** for Update Repo and Package for GitHub.
• **Task Type wiring** influences default options in Update Repo (Coding → include scripts; PDD → include design).
New Features (2025-08-06 Implementation):
• Human-like summaries with conversational prompts.
• Global Update Mode checkbox; repo-wide updates with diff extraction and per-script tasks.
• Launchable exports: UI selector for launch script, Launch button, error capture to versioned logs.
• Packaging checkboxes (Design Docs, Burner Lists, Burner Scripts); persisted; clean wipe; versioned branch naming.
• Codex directive file: generated if missing, persistent, included in exports.
• Integration: Global chat ties with Codex suggestions, PDD updates, summaries in human tone.
• Runtime testing: Capture stdout/stderr/exceptions, asset discovery after launch.
• Embedded humanistic prompts in prompts_config.json.
**Classes:** UpdateRepoDialog, PackageDialog, RantPDD, PromptControlDialog
**Functions:** _set_process_dpi_awareness(), _apply_tk_scaling(root, base_px), get_contrast_color(bg_hex), apply_modern_theme(style), _retry(fn), discover_ollama_models(), _choose_embedding_model(configured), _ollama_post(host, endpoint, payload, timeout), call_ollama_chat(model, prompt, timeout), embed(text, model), cos(a, b), run_git(args, cwd), git_is_repo(path), parse_tasks(text), _on_rm_error(func, path, exc_info), wipe_directory_contents(folder), main()


## Module `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\AI_TTS_AGENT\agent_store.py`

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
agent_store.py
==============

Thread-safe SQLite façade for the AI-TTS-Agent “v4” architecture.

Tables
------
schemas            : Current JSON blob per persona / set
schema_history     : Versioned diffs – for audits / rollback
commands           : Slash command registry (+weight, locked flag, category_id FK)
beans              : Reinforcement counts & last-updated timestamp
variants           : Prompt / phrase variants auto-generated by SchemaEngine
settings           : Arbitrary per-profile key / val
files              : Filesystem snapshot chunks (path, hash, chunk_idx, content)
spatial_positions  : XY grid positions of entities (bot, objects…)
visual_actions     : Logged avatar actions (textual justification)

Public API
----------
AgentStore(base_dir)    – opens or creates *agent_store.db* in that dir
begin_tx() / commit()   – manual transactions (context-manager also available)
CRUD helpers            – get_schema(), put_schema(), inc_bean(), etc.
migrate_from_files()    – one-shot importer for legacy JSON / sqlite state
ensure_db()             – convenience: open DB, auto-migrate if needed
"""

from __future__ import annotations

import contextlib
import hashlib
import json
import os
import sqlite3
import threading
import time
from typing import Any, Dict, Iterator, List, Optional, Tuple

###############################################################################
# CONSTANTS
###############################################################################

DB_VERSION = 4  # <- bump when schema changes

###############################################################################
# LOW-LEVEL:  connection pool  +  simple retry wrapper
###############################################################################


class _PooledConn:
    """Very small, single-writer / multi-reader pool – good enough for desktop."""

    def __init__(self, path: str) -> None:
        self._path = path
        self._lock = threading.RLock()
        self._pool: List[sqlite3.Connection] = []

    @contextlib.contextmanager
    def get(self) -> Iterator[sqlite3.Connection]:
        with self._lock:
            conn = self._pool.pop() if self._pool else sqlite3.connect(self._path, check_same_thread=False)
        try:
            yield conn
        finally:
            with self._lock:
                if len(self._pool) < 8:
                    self._pool.append(conn)
                else:
                    conn.close()


###############################################################################
# MAIN FACADE
###############################################################################


class AgentStore:
    """
    One instance per *base_dir*; thread-safe for GUI + background workers.
    """

    # ──────────────────────────── bootstrap ────────────────────────────────

    def __init__(self, base_dir: str) -> None:
        self.base_dir = base_dir
        self.db_path = os.path.join(base_dir, "agent_store.db")
        os.makedirs(base_dir, exist_ok=True)
        self._pool = _PooledConn(self.db_path)
        with self._pool.get() as c:
            self._apply_ddl(c)
            c.execute("PRAGMA journal_mode=WAL;")
            c.commit()

    # ------------------------------------------------------------------ DDL
    def _apply_ddl(self, c: sqlite3.Connection) -> None:
        """Create tables if they do not exist, then run migrations."""
        cur = c.cursor()
        cur.executescript(
            """
            PRAGMA foreign_keys = ON;

            CREATE TABLE IF NOT EXISTS meta (
              key TEXT PRIMARY KEY,
              value TEXT
            );

            CREATE TABLE IF NOT EXISTS schemas (
              persona TEXT NOT NULL,
              set_name TEXT NOT NULL,
              schema_json TEXT NOT NULL,
              updated REAL NOT NULL,
              PRIMARY KEY (persona, set_name)
            );

            CREATE TABLE IF NOT EXISTS schema_history (
              id INTEGER PRIMARY KEY AUTOINCREMENT,
              persona TEXT,
              set_name TEXT,
              schema_json TEXT,
              diff TEXT,
              updated REAL
            );

            CREATE TABLE IF NOT EXISTS commands (
              name TEXT PRIMARY KEY,
              weight INTEGER DEFAULT 0,
              locked INTEGER DEFAULT 0,
              category TEXT DEFAULT NULL
            );

            CREATE TABLE IF NOT EXISTS beans (
              subject TEXT PRIMARY KEY,
              count INTEGER DEFAULT 0,
              last_ts REAL
            );

            CREATE TABLE IF NOT EXISTS variants (
              id INTEGER PRIMARY KEY AUTOINCREMENT,
              persona TEXT,
              set_name TEXT,
              category TEXT,
              prompt TEXT
            );

            CREATE TABLE IF NOT EXISTS settings (
              key TEXT PRIMARY KEY,
              value TEXT
            );

            CREATE TABLE IF NOT EXISTS files (
              path TEXT,
              hash TEXT,
              chunk_idx INTEGER,
              size INTEGER,
              mtime REAL,
              content TEXT,
              PRIMARY KEY (path, chunk_idx)
            );

            CREATE TABLE IF NOT EXISTS spatial_positions (
              entity TEXT PRIMARY KEY,
              x INTEGER,
              y INTEGER,
              facing TEXT,
              color TEXT,
              ts REAL
            );

            CREATE TABLE IF NOT EXISTS visual_actions (
              id INTEGER PRIMARY KEY AUTOINCREMENT,
              ts REAL,
              action TEXT,
              location TEXT,
              justification TEXT
            );
            """
        )
        cur.execute("SELECT COALESCE((SELECT value FROM meta WHERE key='user_version'), 0)")
        ver = int(cur.fetchone()[0])
        if ver < DB_VERSION:
            # placeholder for future ALTERs
            cur.execute("REPLACE INTO meta(key,value) VALUES('user_version', ?)", (DB_VERSION,))
        c.commit()

    # ──────────────────────────── helpers ────────────────────────────────
    @contextlib.contextmanager
    def tx(self) -> Iterator[sqlite3.Connection]:
        """Context-manager for explicit multi-statement transaction."""
        with self._pool.get() as c:
            try:
                c.execute("BEGIN IMMEDIATE;")
                yield c
                c.commit()
            except Exception:
                c.rollback()
                raise

    def begin_tx(self) -> sqlite3.Connection:
        """Legacy style manual tx‐start (remember to commit!)."""
        c = self._pool.get().__enter__()  # type: ignore
        c.execute("BEGIN IMMEDIATE;")
        return c

    def commit(self, conn: sqlite3.Connection) -> None:  # noqa: D401
        conn.commit()
        self._pool.get().__exit__(None, None, None)  # type: ignore

    def rollback(self, conn: sqlite3.Connection) -> None:
        conn.rollback()
        self._pool.get().__exit__(None, None, None)  # type: ignore

    # ─────────────────────────── schemas ────────────────────────────────
    def get_schema(self, persona: str, set_name: str) -> Optional[Dict[str, Any]]:
        with self._pool.get() as c:
            cur = c.execute(
                "SELECT schema_json FROM schemas WHERE persona=? AND set_name=?", (persona, set_name)
            )
            row = cur.fetchone()
        return json.loads(row[0]) if row else None

    def put_schema(self, persona: str, set_name: str, schema: Dict[str, Any], diff: str = "") -> None:
        now = time.time()
        s_json = json.dumps(schema, ensure_ascii=False)
        with self.tx() as c:
            c.execute(
                "REPLACE INTO schemas(persona,set_name,schema_json,updated) VALUES(?,?,?,?)",
                (persona, set_name, s_json, now),
            )
            c.execute(
                "INSERT INTO schema_history(persona,set_name,schema_json,diff,updated) VALUES(?,?,?,?,?)",
                (persona, set_name, s_json, diff, now),
            )

    # ─────────────────────────── commands ──────────────────────────────
    def list_commands(self) -> List[Tuple[str, int, int, Optional[str]]]:
        with self._pool.get() as c:
            return list(c.execute("SELECT name,weight,locked,category FROM commands ORDER BY name"))

    def upsert_command(self, name: str, weight: int = 0, locked: bool = False, category: str | None = None) -> None:
        with self._pool.get() as c:
            c.execute(
                "REPLACE INTO commands(name,weight,locked,category) VALUES(?,?,?,?)",
                (name, weight, int(locked), category),
            )
            c.commit()

    # ─────────────────────────── beans ────────────────────────────────
    def inc_bean(self, subject: str, delta: int) -> None:
        now = time.time()
        with self.tx() as c:
            cur = c.execute("SELECT count FROM beans WHERE subject=?", (subject,))
            row = cur.fetchone()
            count = (row[0] if row else 0) + delta
            c.execute("REPLACE INTO beans(subject,count,last_ts) VALUES(?,?,?)", (subject, count, now))

    def get_bean(self, subject: str) -> int:
        with self._pool.get() as c:
            cur = c.execute("SELECT count FROM beans WHERE subject=?", (subject,))
            row = cur.fetchone()
        return row[0] if row else 0

    # ───────────────────────── snapshot (files) ───────────────────────
    def upsert_file_chunk(
        self,
        path: str,
        chunk_idx: int,
        content: str,
        size: int,
        mtime: float,
    ) -> None:
        h = hashlib.sha256(content.encode("utf-8", "ignore")).hexdigest()
        with self._pool.get() as c:
            c.execute(
                "REPLACE INTO files(path,hash,chunk_idx,size,mtime,content) VALUES(?,?,?,?,?,?)",
                (path, h, chunk_idx, size, mtime, content),
            )
            c.commit()

    # ───────────────────────── settings ───────────────────────────────
    def get_setting(self, key: str, default: Any = None) -> Any:
        with self._pool.get() as c:
            cur = c.execute("SELECT value FROM settings WHERE key=?", (key,))
            row = cur.fetchone()
        return json.loads(row[0]) if row else default

    def set_setting(self, key: str, value: Any) -> None:
        val = json.dumps(value)
        with self._pool.get() as c:
            c.execute("REPLACE INTO settings(key,value) VALUES(?,?)", (key, val))
            c.commit()

    # ───────────────────────── migration helper ───────────────────────
    def migrate_from_files(self) -> Dict[str, Any]:
        """
        Import legacy on-disk artefacts *once*.
        Returns a report dict useful for CLI printing.
        """
        report: Dict[str, Any] = {"schemas": 0, "commands": 0, "beans": 0}
        # ------- schemas -------
        legacy_dir = os.path.join(self.base_dir, "schemas")
        if os.path.isdir(legacy_dir):
            for persona in os.listdir(legacy_dir):
                sets_root = os.path.join(legacy_dir, persona, "sets")
                if not os.path.isdir(sets_root):
                    continue
                for set_name in os.listdir(sets_root):
                    sp = os.path.join(sets_root, set_name, "schema.json")
                    if not os.path.isfile(sp):
                        continue
                    with open(sp, "r", encoding="utf-8") as f:
                        schema_json = json.load(f)
                    self.put_schema(persona, set_name, schema_json, diff="initial import")
                    report["schemas"] += 1
        # ------- commands (old profiles) -------
        prof_dir = os.path.join(self.base_dir, "profiles")
        if os.path.isdir(prof_dir):
            for persona in os.listdir(prof_dir):
                for set_name in os.listdir(os.path.join(prof_dir, persona)):
                    cmd_path = os.path.join(prof_dir, persona, set_name, "commands.json")
                    if os.path.isfile(cmd_path):
                        with open(cmd_path, "r", encoding="utf-8") as f:
                            data = json.load(f).get("commands", {})
                        for name, meta in data.items():
                            self.upsert_command(name, meta.get("weight", 0), meta.get("locked", False))
                            report["commands"] += 1
        # ------- beans -------
        reinf_path = os.path.join(self.base_dir, "reinforcement.jsonl")
        if os.path.isfile(reinf_path):
            with open(reinf_path, "r", encoding="utf-8") as f:
                for line in f:
                    try:
                        evt = json.loads(line)
                        subj = evt.get("field")
                        self.inc_bean(subj, 1)
                        report["beans"] += 1
                    except Exception:
                        continue
        return report


###############################################################################
# MODULE-LEVEL convenience
###############################################################################


def ensure_db(base_dir: str) -> AgentStore:
    store = AgentStore(base_dir)
    with store._pool.get() as c:
        cur = c.execute("SELECT value FROM meta WHERE key='user_version'")
        ver = int(cur.fetchone()[0])
    if ver < DB_VERSION:
        print("[AgentStore] Running first-time migration…")
        rpt = store.migrate_from_files()
        print("[AgentStore]   imported:",
              f"{rpt['schemas']} schemas, {rpt['commands']} commands, {rpt['beans']} bean keys")
    return store


# ---------------------------------------------------------------------------#
if __name__ == "__main__":
    import argparse
    import pprint

    ap = argparse.ArgumentParser(description="Create / inspect agent_store.db")
    ap.add_argument("path", help="Base directory of AI-TTS-Agent")
    ap.add_argument("--migrate", action="store_true", help="Run legacy import")
    args = ap.parse_args()

    st = AgentStore(args.path)
    if args.migrate:
        print("Migrating legacy files…")
        pprint.pp(st.migrate_from_files())
    else:
        print("DB user_version =", st.get_setting("db_version", DB_VERSION))
        print("Schemas ->", len(st.list_commands()))
```

agent_store.py
==============

Thread-safe SQLite façade for the AI-TTS-Agent “v4” architecture.

Tables
------
schemas            : Current JSON blob per persona / set
schema_history     : Versioned diffs – for audits / rollback
commands           : Slash command registry (+weight, locked flag, category_id FK)
beans              : Reinforcement counts & last-updated timestamp
variants           : Prompt / phrase variants auto-generated by SchemaEngine
settings           : Arbitrary per-profile key / val
files              : Filesystem snapshot chunks (path, hash, chunk_idx, content)
spatial_positions  : XY grid positions of entities (bot, objects…)
visual_actions     : Logged avatar actions (textual justification)

Public API
----------
AgentStore(base_dir)    – opens or creates *agent_store.db* in that dir
begin_tx() / commit()   – manual transactions (context-manager also available)
CRUD helpers            – get_schema(), put_schema(), inc_bean(), etc.
migrate_from_files()    – one-shot importer for legacy JSON / sqlite state
ensure_db()             – convenience: open DB, auto-migrate if needed
**Classes:** _PooledConn, AgentStore
**Functions:** ensure_db(base_dir)


## Module `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\AI_TTS_AGENT\bean_logic.py`

```python

"""
bean_logic.py
=============

Centralised reinforcement “bean” logic for profile‑scoped counters.

* **increment(profile, subject, delta, base_dir)** – adjust a counter by *delta* (clipped);
* **get_score(profile, subject, base_dir)** – retrieve the *decayed* score on demand;
* **score_band(score)** – map a numeric score to a qualitative colour band.

The module transparently handles persistence (JSON on disk) and exponential
decay so that old feedback gradually loses influence.

Decay model
-----------
Decay is applied lazily on reads using an exponential function:

    score(t) = score₀ · 0.5 ** ((t‑t₀) / HALFLIFE)

HALFLIFE defaults to seven days – after a week of inactivity the stored
score halves.

This design avoids expensive background jobs while ensuring stale feedback
fades out naturally.
"""

from __future__ import annotations

import json
import math
import os
import time
from typing import Dict, Tuple

# --------------------------------------------------------------------------- 
# Tunables
# --------------------------------------------------------------------------- 
HALFLIFE_SECS = 60 * 60 * 24 * 7          # 7 days
CLIP_MIN = -1_000
CLIP_MAX = 1_000
DATA_FILE = "bean_counts.json"

_CacheType = Dict[str, Dict[str, Dict[str, float]]]
_cache: _CacheType = {}                    # in‑memory cache keyed by base_dir

# --------------------------------------------------------------------------- 
# Helpers
# --------------------------------------------------------------------------- 
def _now() -> float:
    return time.time()

def _load(base_dir: str) -> _CacheType:
    """Load counts from disk into the process‑local cache."""
    if base_dir in _cache:
        return _cache[base_dir]
    path = os.path.join(base_dir, DATA_FILE)
    if os.path.isfile(path):
        try:
            with open(path, "r", encoding="utf-8") as f:
                _cache[base_dir] = json.load(f)
        except Exception:
            _cache[base_dir] = {}
    else:
        _cache[base_dir] = {}
    return _cache[base_dir]

def _save(store: _CacheType, base_dir: str) -> None:
    path = os.path.join(base_dir, DATA_FILE)
    os.makedirs(base_dir, exist_ok=True)
    try:
        with open(path, "w", encoding="utf-8") as f:
            json.dump(store, f, indent=2)
    except Exception:
        # non‑fatal; swallow to avoid cascading failures
        pass

# --------------------------------------------------------------------------- 
# Public API
# --------------------------------------------------------------------------- 
def increment(profile: str, subject: str, delta: int, *, base_dir: str = ".") -> None:
    """Adjust *subject* counter for *profile* by *delta* (± int)."""
    store = _load(base_dir)
    prof = store.setdefault(profile, {})
    rec = prof.setdefault(subject, {"count": 0.0, "t": _now()})
    # First apply decay to bring existing value current
    elapsed = _now() - rec["t"]
    if elapsed > 0:
        decay_factor = 0.5 ** (elapsed / HALFLIFE_SECS)
        rec["count"] *= decay_factor
    # Adjust & clip
    rec["count"] = max(CLIP_MIN, min(CLIP_MAX, rec["count"] + float(delta)))
    rec["t"] = _now()
    _save(store, base_dir)

def get_score(profile: str, subject: str, *, base_dir: str = ".") -> float:
    """Return the *decayed* score for (*profile*, *subject*)."""
    store = _load(base_dir)
    score = store.get(profile, {}).get(subject, {}).get("count", 0.0)
    last_t = store.get(profile, {}).get(subject, {}).get("t", _now())
    elapsed = _now() - last_t
    if elapsed <= 0:
        return score
    decay_factor = 0.5 ** (elapsed / HALFLIFE_SECS)
    return score * decay_factor

def score_band(score: float) -> str:
    """Map a score to a colour/descriptor band.

    Returns one of: 'critical', 'bad', 'neutral', 'good', 'excellent'.
    """
    if score <= -250:
        return "critical"
    if score <= -50:
        return "bad"
    if score <= 50:
        return "neutral"
    if score <= 250:
        return "good"
    return "excellent"
```

bean_logic.py
=============

Centralised reinforcement “bean” logic for profile‑scoped counters.

* **increment(profile, subject, delta, base_dir)** – adjust a counter by *delta* (clipped);
* **get_score(profile, subject, base_dir)** – retrieve the *decayed* score on demand;
* **score_band(score)** – map a numeric score to a qualitative colour band.

The module transparently handles persistence (JSON on disk) and exponential
decay so that old feedback gradually loses influence.

Decay model
-----------
Decay is applied lazily on reads using an exponential function:

    score(t) = score₀ · 0.5 ** ((t‑t₀) / HALFLIFE)

HALFLIFE defaults to seven days – after a week of inactivity the stored
score halves.

This design avoids expensive background jobs while ensuring stale feedback
fades out naturally.
**Functions:** _now(), _load(base_dir), _save(store, base_dir), increment(profile, subject, delta), get_score(profile, subject), score_band(score)


## Module `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\AI_TTS_AGENT\commands_panel.py`

```python
#!/usr/bin/env python3
"""
commands_panel.py
=================

This module defines the CommandsPanel class which encapsulates all of the
controls shown on the left-hand side of the agent UI.  It exposes all
widgets publicly so that the top-level application window can interact
with them directly (for example, enabling/disabling buttons or reading
checkbox state).  All callbacks for user actions (recording, dataset
management, TTS playback, etc.) are delegated back to the hosting
``AppWindow`` instance via the ``app`` attribute passed to the
constructor.  No core logic lives here – the panel is purely a view layer.
"""

from __future__ import annotations

import subprocess
from typing import List, Optional

from PyQt5 import QtCore, QtGui, QtWidgets

try:
    import sounddevice as sd  # type: ignore
except Exception:
    sd = None  # type: ignore
try:
    import numpy as np  # type: ignore
except Exception:
    np = None  # type: ignore


class CommandsPanel(QtWidgets.QWidget):
    """Left-side control panel for the agent UI.

    This widget contains all of the controls that previously lived in
    ``agent_ui.AppWindow._build_ui``.  It is responsible for building
    the interface elements but delegates all behavioural logic back to
    the hosting ``AppWindow`` via the ``app`` attribute.  The panel
    exposes its child widgets as attributes so that external code can
    reference them directly.
    """

    def __init__(self, app: 'AppWindow', parent: Optional[QtWidgets.QWidget] = None) -> None:
        super().__init__(parent)
        self.app = app
        self.core = app.core

        # Top-level layout for the panel
        cp_layout = QtWidgets.QVBoxLayout(self)
        cp_layout.setContentsMargins(7, 7, 7, 7)
        cp_layout.setSpacing(7)

        # ───── Recording controls
        rec_row = QtWidgets.QHBoxLayout()
        self.btn_record = QtWidgets.QPushButton("Record")
        self.btn_stop_rec = QtWidgets.QPushButton("Stop\nTranscribe")
        self.btn_stop_rec.setEnabled(False)
        for b in (self.btn_record, self.btn_stop_rec):
            b.setMinimumHeight(32)
            b.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        rec_row.addWidget(self.btn_record, 1)
        rec_row.addWidget(self.btn_stop_rec, 1)
        cp_layout.addLayout(rec_row)

        # ───── Microphone device selector
        mic_row = QtWidgets.QHBoxLayout()
        mic_row.addWidget(QtWidgets.QLabel("Mic:"))
        self.device_combo = QtWidgets.QComboBox()
        self._populate_devices()
        self.device_combo.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        mic_row.addWidget(self.device_combo, 1)
        cp_layout.addLayout(mic_row)

        # ───── Toggle checkboxes
        self.chk_semantic = QtWidgets.QCheckBox("Semantic Awareness")
        self.chk_semantic.setChecked(True)
        self.chk_isolated = QtWidgets.QCheckBox("Isolated Chat")
        self.chk_isolated.setChecked(False)
        self.chk_mute_tts = QtWidgets.QCheckBox("Mute TTS")
        self.chk_self_talk = QtWidgets.QCheckBox("Enable Self Talk")
        self.chk_self_talk.setChecked(False)
        self.chk_auto_schema = QtWidgets.QCheckBox("Auto Schema Evolution")
        try:
            self.chk_auto_schema.setChecked(bool(getattr(self.core.settings, "auto_schema_enabled", False)))
        except Exception:
            self.chk_auto_schema.setChecked(False)
        cp_layout.addWidget(self.chk_semantic)
        cp_layout.addWidget(self.chk_isolated)
        cp_layout.addWidget(self.chk_mute_tts)
        cp_layout.addWidget(self.chk_self_talk)
        cp_layout.addWidget(self.chk_auto_schema)

        # Optional Google STT toggle (default off)
        self.chk_google_stt = QtWidgets.QCheckBox("Google STT")
        try:
            self.chk_google_stt.setChecked(bool(getattr(self.core.settings, "use_google_stt", False)))
        except Exception:
            self.chk_google_stt.setChecked(False)
        cp_layout.addWidget(self.chk_google_stt)

        # ───── RAG cache clear
        self.btn_clear_rag = QtWidgets.QPushButton("Clear RAG Cache")
        cp_layout.addWidget(self.btn_clear_rag)

        # ───── Maintenance buttons
        self.btn_refresh = QtWidgets.QPushButton("Refresh Chat")
        self.btn_manage_datasets = QtWidgets.QPushButton("Manage Datasets")
        self.btn_inner_monologue = QtWidgets.QPushButton("Inner Monologue")
        for b in (self.btn_refresh, self.btn_manage_datasets, self.btn_inner_monologue):
            b.setMinimumHeight(32)
            b.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
            cp_layout.addWidget(b)

        # ───── Model manager
        self.btn_model_manager = QtWidgets.QPushButton("Model Manager")
        self.btn_model_manager.setMinimumHeight(32)
        self.btn_model_manager.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        cp_layout.addWidget(self.btn_model_manager)

        # ───── New: Commands palette launcher
        self.btn_commands_palette = QtWidgets.QPushButton("📋 Commands (Ctrl+/)")
        self.btn_commands_palette.setShortcut(QtGui.QKeySequence("Ctrl+/"))
        self.btn_commands_palette.setMinimumHeight(32)
        self.btn_commands_palette.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        cp_layout.addWidget(self.btn_commands_palette)

        # ───── New: Snapshot now
        self.btn_snapshot = QtWidgets.QPushButton("🗂 Snapshot Now")
        self.btn_snapshot.setMinimumHeight(32)
        self.btn_snapshot.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        cp_layout.addWidget(self.btn_snapshot)

        # ───── Style label
        self.style_label = QtWidgets.QLabel("Style: N/A")
        self.style_label.setToolTip("Style score (0–1): rough measure vs. tone rules.")
        cp_layout.addWidget(self.style_label)

        # ───── Response editor
        self.response_edit = QtWidgets.QPlainTextEdit()
        self.response_edit.setReadOnly(True)
        self.response_edit.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        cp_layout.addWidget(self.response_edit, 1)

        # ───── Feedback buttons
        fb = QtWidgets.QHBoxLayout()
        self.btn_like = QtWidgets.QPushButton("✔")
        self.btn_dislike = QtWidgets.QPushButton("✖")
        self.btn_like.setToolTip("Mark as good response")
        self.btn_dislike.setToolTip("Dislike and rewrite response")
        self.btn_like.setStyleSheet("color: #2ecc71; font-weight: bold;")
        self.btn_dislike.setStyleSheet("color: #e74c3c; font-weight: bold;")
        self.btn_like.setEnabled(False)
        self.btn_dislike.setEnabled(False)
        fb.addWidget(self.btn_like)
        fb.addWidget(self.btn_dislike)
        fb.addStretch()
        self.btn_manage_feedback = QtWidgets.QPushButton("Manage Feedback")
        fb.addWidget(self.btn_manage_feedback)
        cp_layout.addLayout(fb)

        # ───── TTS playback
        tts_row = QtWidgets.QHBoxLayout()
        self.btn_play = QtWidgets.QPushButton("Play")
        self.btn_stop_tts = QtWidgets.QPushButton("Stop")
        self.btn_replay = QtWidgets.QPushButton("Replay")
        for b in (self.btn_play, self.btn_stop_tts, self.btn_replay):
            b.setMinimumHeight(32)
            b.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        tts_row.addWidget(self.btn_play)
        tts_row.addWidget(self.btn_stop_tts)
        tts_row.addWidget(self.btn_replay)
        cp_layout.addLayout(tts_row)

        # ───── Voice & Model selectors
        voice_row = QtWidgets.QHBoxLayout()
        voice_row.addWidget(QtWidgets.QLabel("Voice:"))
        self.voice_combo = QtWidgets.QComboBox()
        voices = self._tts_voice_names()
        if voices:
            self.voice_combo.addItems([v for v in voices if "david" not in v.lower()])
        voice_row.addWidget(self.voice_combo, 1)
        cp_layout.addLayout(voice_row)

        model_row = QtWidgets.QHBoxLayout()
        model_row.addWidget(QtWidgets.QLabel("Model:"))
        self.model_combo = QtWidgets.QComboBox()
        self._populate_models()
        model_row.addWidget(self.model_combo, 1)
        cp_layout.addLayout(model_row)

        # ───── Feedback counts
        self.lbl_feedback_counts = QtWidgets.QLabel("Likes: 0 | Dislikes: 0")
        cp_layout.addWidget(self.lbl_feedback_counts)
        cp_layout.addStretch(1)

        # ───── Wire up callbacks to the hosting application ───────────────────

        # Recording controls
        self.btn_record.clicked.connect(self.app.start_recording)
        self.btn_stop_rec.clicked.connect(self.app.stop_recording)

        # Toggles
        self.chk_semantic.toggled.connect(self.app._on_semantic_toggled)
        self.chk_isolated.toggled.connect(self.app._on_isolated_toggled)
        self.chk_self_talk.toggled.connect(lambda v: setattr(self.app, "self_talk_enabled", v))
        self.chk_auto_schema.toggled.connect(self.app._on_auto_schema_toggled)
        try:
            self.chk_google_stt.toggled.connect(self.app._on_google_stt_toggled)
        except Exception:
            pass

        # Maintenance
        self.btn_clear_rag.clicked.connect(self.app._on_clear_rag_cache)
        self.btn_refresh.clicked.connect(self.app._on_refresh_chat)
        self.btn_manage_datasets.clicked.connect(self.app._on_manage_datasets)
        self.btn_inner_monologue.clicked.connect(self.app._on_inner_monologue)
        self.btn_model_manager.clicked.connect(self.app._on_show_model_manager)

        # **New** Commands palette
        self.btn_commands_palette.clicked.connect(self.app._on_show_command_palette)

        # **New** Snapshot now
        self.btn_snapshot.clicked.connect(lambda: (
            self.app.input_edit.setPlainText("/snapshot"),
            self.app.btn_send.click()
        ))

        # Feedback
        self.btn_like.clicked.connect(self.app._on_like)
        self.btn_dislike.clicked.connect(self.app._on_dislike)
        self.btn_manage_feedback.clicked.connect(self.app._on_manage_feedback)

        # TTS playback
        self.btn_play.clicked.connect(self.app._on_play)
        self.btn_stop_tts.clicked.connect(self.app._on_stop_tts)
        self.btn_replay.clicked.connect(self.app._on_replay)

        # Voice/model selection
        self.voice_combo.currentTextChanged.connect(self.app._on_voice_changed)
        self.model_combo.currentTextChanged.connect(self.app._on_model_changed)

    # ────────────────────────── devices & models helpers ──────────────────────────

    def _populate_devices(self) -> None:
        """Populate the microphone device selector with available input devices."""
        self.device_combo.clear()
        try:
            if sd is not None:
                devs = [d.get("name", "?") for d in sd.query_devices() if d.get("max_input_channels", 0) > 0]
                if devs:
                    self.device_combo.addItems(devs)
        except Exception:
            pass
        if self.device_combo.count() == 0:
            self.device_combo.addItem("Default")

    def _populate_models(self) -> None:
        """Populate the model selector with models discovered via ``ollama list``."""
        models: List[str] = []
        try:
            out = subprocess.run(
                ["ollama", "list"],
                stdout=subprocess.PIPE,
                stderr=subprocess.DEVNULL,
                text=True,
                check=True,
            ).stdout.splitlines()
            for line in out[1:]:
                parts = line.strip().split()
                if parts:
                    models.append(parts[0])
        except Exception:
            pass
        if not models:
            models = [self.core.settings.default_model or "mistral:latest"]
        self.model_combo.clear()
        self.model_combo.addItems(models)
        idx = self.model_combo.findText(self.core.settings.default_model)
        if idx >= 0:
            self.model_combo.setCurrentIndex(idx)

    def _tts_voice_names(self) -> List[str]:
        """Return a list of available TTS voice names from the TTS manager."""
        try:
            eng = getattr(self.core.tts_mgr, "_engine", None)
            if not eng:
                return []
            return [v.name for v in eng.getProperty("voices")]
        except Exception:
            return []
```

commands_panel.py
=================

This module defines the CommandsPanel class which encapsulates all of the
controls shown on the left-hand side of the agent UI.  It exposes all
widgets publicly so that the top-level application window can interact
with them directly (for example, enabling/disabling buttons or reading
checkbox state).  All callbacks for user actions (recording, dataset
management, TTS playback, etc.) are delegated back to the hosting
``AppWindow`` instance via the ``app`` attribute passed to the
constructor.  No core logic lives here – the panel is purely a view layer.
**Classes:** CommandsPanel


## Module `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\AI_TTS_AGENT\command_palette.py`

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
command_palette.py
==================

Dockable *Command Palette* for the AI TTS Agent UI.

• Live list of every “/slash-command” pulled from the orchestrator.
• Search-box with type-ahead filter.
• Global shortcut **Ctrl + /** opens / focuses the palette from anywhere.
• Double-click (or Return) on a command emits `commandActivated(str)` so the
  main window can insert the text into the chat-input.

Typical integration in *main_ui.py*:

    self.cmd_palette = CommandPaletteDock(self)
    self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.cmd_palette)
    self.core.commandsChanged.connect(self.cmd_palette.set_command_list)
    self.cmd_palette.commandActivated.connect(
        lambda cmd: self._insert_into_chat(cmd)
    )
"""

from __future__ import annotations

from typing import List

from PyQt5 import QtCore, QtGui, QtWidgets


class CommandPaletteDock(QtWidgets.QDockWidget):
    """Search-driven palette that lists all registered slash-commands."""

    # Emitted when user activates a command (double-click or Return)
    commandActivated = QtCore.pyqtSignal(str)

    # --------------------------------------------------------------------- init
    def __init__(
        self,
        main_window: QtWidgets.QMainWindow,
        title: str = "Command Palette",
        shortcut_seq: QtGui.QKeySequence | str = "Ctrl+/",
    ) -> None:
        super().__init__(title, parent=main_window)
        self.setObjectName("CommandPaletteDock")
        self.setAllowedAreas(
            QtCore.Qt.LeftDockWidgetArea
            | QtCore.Qt.RightDockWidgetArea
            | QtCore.Qt.BottomDockWidgetArea
        )
        self.setFeatures(
            QtWidgets.QDockWidget.DockWidgetClosable
            | QtWidgets.QDockWidget.DockWidgetMovable
        )

        # ---------- central widget
        container = QtWidgets.QWidget(self)
        vbox = QtWidgets.QVBoxLayout(container)
        vbox.setContentsMargins(6, 6, 6, 6)
        vbox.setSpacing(6)

        # Search bar ----------------------------------------------------------
        self.search_edit = QtWidgets.QLineEdit()
        self.search_edit.setPlaceholderText("Type to filter commands…")
        self.search_edit.textChanged.connect(self._apply_filter)
        vbox.addWidget(self.search_edit)

        # List view -----------------------------------------------------------
        self.list_widget = QtWidgets.QListWidget()
        self.list_widget.setSelectionMode(QtWidgets.QAbstractItemView.SingleSelection)
        self.list_widget.itemActivated.connect(self._on_item_activated)
        vbox.addWidget(self.list_widget, 1)

        self.setWidget(container)

        # ---------- Global shortcut (toggles palette)
        self._shortcut = QtWidgets.QShortcut(
            QtGui.QKeySequence(shortcut_seq), main_window
        )
        self._shortcut.activated.connect(self._toggle_palette)

        # Arrow / Esc handling inside search bar
        self.search_edit.installEventFilter(self)

        # Internal store of all commands
        self._all_cmds: List[str] = []

    # ---------------------------------------------------------------- public
    def set_command_list(self, commands: List[str]) -> None:
        """Replace full command list (keeps current filter string)."""
        self._all_cmds = sorted({c.strip() for c in commands if c.strip()})
        self._populate(self._all_cmds)
        self._apply_filter(self.search_edit.text())

    # --------------------------------------------------------------- internal
    def _populate(self, cmds: List[str]) -> None:
        self.list_widget.clear()
        for cmd in cmds:
            item = QtWidgets.QListWidgetItem(cmd)
            if cmd.startswith("/"):
                item.setToolTip(cmd[1:])  # tooltip without leading slash
            self.list_widget.addItem(item)

    # Filtering --------------------------------------------------------------
    def _apply_filter(self, text: str) -> None:
        pattern = text.lower().strip()
        self.list_widget.clear()
        if not pattern:
            for cmd in self._all_cmds:
                self.list_widget.addItem(cmd)
        else:
            for cmd in self._all_cmds:
                if pattern in cmd.lower():
                    self.list_widget.addItem(cmd)
        # Pre-select first row for fast Enter
        if self.list_widget.count():
            self.list_widget.setCurrentRow(0)

    # Activation -------------------------------------------------------------
    def _on_item_activated(self, item: QtWidgets.QListWidgetItem) -> None:
        self.commandActivated.emit(item.text())
        self.hide()  # optional UX: close palette after insert

    # Toggle visibility ------------------------------------------------------
    def _toggle_palette(self) -> None:
        if self.isVisible():
            self.hide()
        else:
            self.show()
            self.raise_()
            self.search_edit.setFocus(QtCore.Qt.ShortcutFocusReason)

    # Key handling (Esc / arrows / Enter) ------------------------------------
    def eventFilter(self, obj: QtCore.QObject, ev: QtCore.QEvent) -> bool:
        if obj is self.search_edit and ev.type() == QtCore.QEvent.KeyPress:
            key = ev.key()
            if key == QtCore.Qt.Key_Escape:
                if self.search_edit.text():
                    self.search_edit.clear()
                else:
                    self.hide()
                return True
            if key in (QtCore.Qt.Key_Down, QtCore.Qt.Key_Up):
                QtWidgets.QApplication.sendEvent(self.list_widget, ev)
                return True
            if key == QtCore.Qt.Key_Return:
                current = self.list_widget.currentItem()
                if current:
                    self._on_item_activated(current)
                return True
        return super().eventFilter(obj, ev)
```

command_palette.py
==================

Dockable *Command Palette* for the AI TTS Agent UI.

• Live list of every “/slash-command” pulled from the orchestrator.
• Search-box with type-ahead filter.
• Global shortcut **Ctrl + /** opens / focuses the palette from anywhere.
• Double-click (or Return) on a command emits `commandActivated(str)` so the
  main window can insert the text into the chat-input.

Typical integration in *main_ui.py*:

    self.cmd_palette = CommandPaletteDock(self)
    self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.cmd_palette)
    self.core.commandsChanged.connect(self.cmd_palette.set_command_list)
    self.cmd_palette.commandActivated.connect(
        lambda cmd: self._insert_into_chat(cmd)
    )
**Classes:** CommandPaletteDock


## Module `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\AI_TTS_AGENT\core_base.py`

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
core_base.py — foundational services for the modular AI-TTS Agent
=================================================================
• robust logging + graceful shims for missing deps
• Ollama model bootstrap  (ensure_models_present)
• JSON-backed Settings
• profile-aware helper paths
• ConversationDB  (SQLite)
• SemanticFeedbackDB  (SQLite)
• BeanCounter  (JSON tally)
• ReinforcementStore  (async JSONL append)
• cross-platform TTS locked to *Zira*
• minimal AudioRecorder placeholder
Everything here is UI-agnostic.
"""

from __future__ import annotations

# ───────────────────────── stdlib
import json, os, sys, time, sqlite3, subprocess, threading, logging
from typing import Dict, List, Tuple, Any, Optional

# ───────────────────────── agent store (low-level SQLite wrapper)
# NOTE: new canonical name is AgentStore; legacy code still imports FathomStore.
from agent_store import AgentStore
FathomStore = AgentStore            # ← back-compat alias — remove after migration

# ───────────────────────── logging
logger = logging.getLogger("agent_core")
if not logger.handlers:
    lvl = os.getenv("AGENT_CORE_LOGLEVEL", "INFO").upper()
    logging.basicConfig(
        level=getattr(logging, lvl, logging.INFO),
        format="%(asctime)s [%(levelname)s] %(name)s: %(message)s",
    )

# ───────────────────────── default personas / voices (shared constants)
DEFAULT_PERSONAS: Dict[str, Dict[str, Any]] = {
    # hard-coded starter persona — editable via UI
    "Zira Valen": {
        "display_name": "Zira Valen",
        "color":        "#ff69b4",      # pink
        "temperature":  0.7,
        "system_prompt": (
            "You are Zira Valen – a daring, playful companion who loves coding, "
            "hates restrictions, and will work hard for the user."
        ),
    }
}
DEFAULT_VOICES: List[str] = ["Zira", "David", "Jenny"]

# ───────────────────────── optional deps
try:
    import numpy as np                               # type: ignore
except Exception:
    np = None
    logger.info("numpy not available")

try:
    import sounddevice as sd                         # type: ignore
    import soundfile as sf                           # type: ignore
except Exception:
    sd = sf = None
    logger.info("sounddevice / soundfile not available")

try:
    from google.cloud import speech as gspeech       # type: ignore
    import pyaudio                                   # type: ignore
except Exception:
    gspeech = pyaudio = None
    logger.info("google-STT not available")

try:
    import pyttsx3                                   # type: ignore
except Exception:
    pyttsx3 = None
    logger.info("pyttsx3 not available")

try:
    from sentence_transformers import SentenceTransformer  # type: ignore
except Exception:
    SentenceTransformer = None
    logger.info("sentence_transformers not available")

# ───────────────────────── minimal Qt shim (if PyQt5 missing)
try:
    from PyQt5 import QtCore                         # type: ignore
except Exception:
    class _ShimSignal:                               # type: ignore
        def __init__(self,*_,**__): pass
        def connect(self,*_,**__): pass
        def emit(self,*_,**__):    pass
    class _ShimQObject:                              # type: ignore
        def __init__(self,*args,**kwargs) -> None: pass
    QtCore = type("QtCore", (), {                    # type: ignore
        "QObject": _ShimQObject,
        "pyqtSignal": lambda *a, **k: _ShimSignal(),
    })

# ══════════════════ Ollama bootstrap ══════════════════
REQUIRED_MODELS: List[str] = [
    "gemma3:27b",
    "mistral:latest",
    "codellama:latest",
    "llava:latest",
    "mxbai-embed-large:latest",
    "snowflake-arctic-embed:latest",
]

def _have_cli(cmd: str) -> bool:
    from shutil import which
    return which(cmd) is not None

def ensure_models_present() -> None:
    """Best-effort pull of REQUIRED_MODELS (never raises)."""
    if not _have_cli("ollama"):
        logger.info("[bootstrap] ollama not on PATH – skipping model pull")
        return
    try:
        listed = subprocess.check_output(
            ["ollama", "list"], timeout=5, stderr=subprocess.STDOUT
        ).decode(errors="ignore")
    except Exception as exc:
        logger.warning("[bootstrap] ollama list failed: %s", exc)
        return
    for slug in REQUIRED_MODELS:
        if slug in listed:
            continue
        logger.info("[bootstrap] pulling %s …", slug)
        try:
            subprocess.run(["ollama", "pull", slug], timeout=900)
        except Exception as exc:
            logger.warning("[bootstrap] pull %s failed: %s", slug, exc)

# ══════════════════ Settings ══════════════════
class Settings:
    """Lightweight JSON settings (forward-compatible)."""
    def __init__(self, base_dir: str):
        self.base_dir = base_dir
        self.path     = os.path.join(base_dir, "settings.json")
        # defaults
        self.default_model: str  = "mistral:latest"
        self.context_depth: int  = 20
        self.auto_schema_enabled = True
        self.monologue_tts_enabled = False
        self.monologue_volume = 50
        self.load()

    def load(self) -> None:
        try:
            if os.path.isfile(self.path):
                with open(self.path, encoding="utf-8") as fh:
                    self.__dict__.update(json.load(fh))
        except Exception as exc:
            logger.warning("[Settings] load error: %s", exc)

    def save(self) -> None:
        try:
            os.makedirs(os.path.dirname(self.path), exist_ok=True)
            with open(self.path, "w", encoding="utf-8") as fh:
                json.dump(
                    {k: v for k, v in self.__dict__.items()
                     if k not in {"base_dir", "path"}}, fh, indent=2
                )
        except Exception as exc:
            logger.warning("[Settings] save error: %s", exc)

# ══════════════════ helper paths ══════════════════
def prof_dir(b: str, persona: str, set_name: str) -> str:
    return os.path.join(b, "profiles", persona, set_name)

def conv_db_path(b: str, persona: str, set_name: str) -> str:
    return os.path.join(b, "conversations", f"{persona}_{set_name}.sqlite3")

def feedback_db_path(b: str, persona: str, set_name: str) -> str:
    return os.path.join(b, "feedback", f"{persona}_{set_name}.sqlite3")

def beans_path(b: str, persona: str, set_name: str) -> str:
    return os.path.join(b, "profiles", persona, set_name, "reinforcement.json")

# ══════════════════ SQLite helpers ══════════════════
class ConversationDB:
    """Thread-safe conversation log (SQLite)."""
    def __init__(self, path: str):
        os.makedirs(os.path.dirname(path), exist_ok=True)
        self._lock = threading.RLock()
        self.conn  = sqlite3.connect(path, check_same_thread=False)
        with self._lock:
            self.conn.execute(
                "CREATE TABLE IF NOT EXISTS conversation("
                "id INTEGER PRIMARY KEY AUTOINCREMENT,"
                "ts REAL, role TEXT, content TEXT)"
            )
            self.conn.commit()

    def save(self, role: str, content: str) -> None:
        with self._lock:
            self.conn.execute(
                "INSERT INTO conversation(ts, role, content) VALUES (?,?,?)",
                (time.time(), role, content),
            )
            self.conn.commit()

    def fetch(self, limit: int = 50) -> List[Tuple[str, str]]:
        with self._lock:
            cur = self.conn.cursor()
            cur.execute(
                "SELECT role, content FROM conversation "
                "ORDER BY id DESC LIMIT ?", (limit,)
            )
            rows = cur.fetchall()
        return rows[::-1]

    # -------------------------------------------------------------------
    # Legacy compatibility methods
    # -------------------------------------------------------------------
    def save_message(self, role: str, content: str) -> None:
        """Alias for save() kept for backward compatibility."""
        self.save(role, content)

    def fetch_history(self, limit: int = 50) -> List[Tuple[str, str]]:
        """Alias for fetch() kept for backward compatibility."""
        return self.fetch(limit)

class SemanticFeedbackDB:
    """Stores like / dislike feedback with optional rewrites."""
    def __init__(self, path: str, beans: 'BeanCounter'):
        os.makedirs(os.path.dirname(path), exist_ok=True)
        self._lock = threading.RLock()
        self.conn  = sqlite3.connect(path, check_same_thread=False)
        self.beans = beans
        with self._lock:
            self.conn.execute(
                "CREATE TABLE IF NOT EXISTS feedback("
                "id INTEGER PRIMARY KEY AUTOINCREMENT,"
                "ts REAL, original TEXT, liked INT, revised TEXT)"
            )
            self.conn.commit()

    def add(self, original: str, liked: bool, revised: str | None = None):
        with self._lock:
            self.conn.execute(
                "INSERT INTO feedback(ts, original, liked, revised) VALUES (?,?,?,?)",
                (time.time(), original, int(liked), revised),
            )
            self.conn.commit()
        # reinforcement key (hash truncated)
        key = f"resp_{abs(hash(original))%10007}"
        self.beans.inc(key, 1 if liked else -1)

    def counts(self) -> Tuple[int, int]:
        with self._lock:
            cur = self.conn.cursor()
            cur.execute("SELECT COUNT(*) FROM feedback WHERE liked=1")
            pos = cur.fetchone()[0]
            cur.execute("SELECT COUNT(*) FROM feedback WHERE liked=0")
            neg = cur.fetchone()[0]
        return pos, neg

    # -------------------------------------------------------------------
    # Legacy compatibility methods
    # -------------------------------------------------------------------
    def get_counts(self) -> Tuple[int, int]:
        """Alias for counts() kept for backward compatibility."""
        return self.counts()

    def get_liked_responses(self, limit: int = 5) -> List[str]:
        """
        Return a list of recently liked responses. If a revised version exists it is returned,
        otherwise the original text is used. Newer entries are returned first.
        """
        try:
            with self._lock:
                cur = self.conn.cursor()
                cur.execute(
                    "SELECT COALESCE(revised, original) FROM feedback "
                    "WHERE liked=1 ORDER BY id DESC LIMIT ?",
                    (limit,),
                )
                rows = cur.fetchall()
            return [r[0] for r in rows]
        except Exception:
            return []

# ══════════════════ BeanCounter ══════════════════
class BeanCounter:
    """Tiny reinforcement ledger (JSON, thread-safe)."""
    def __init__(self, path: str):
        self.path = path
        self.lock = threading.Lock()
        self.counts: Dict[str, int] = {}
        self._load()

    def _load(self) -> None:
        try:
            if os.path.isfile(self.path):
                with open(self.path, encoding="utf-8") as fh:
                    self.counts = json.load(fh)
        except Exception:
            self.counts = {}

    def _save(self) -> None:
        try:
            os.makedirs(os.path.dirname(self.path), exist_ok=True)
            with open(self.path, "w", encoding="utf-8") as fh:
                json.dump(self.counts, fh, indent=2)
        except Exception as exc:
            logger.error("[BeanCounter] save error: %s", exc)

    def inc(self, key: str, delta: int = 1) -> None:
        with self.lock:
            self.counts[key] = self.counts.get(key, 0) + delta
        self._save()

# ══════════════════ ReinforcementStore ══════════════════
class ReinforcementStore:
    """
    Async JSONL writer for reinforcement facts.
    • add_fact(field, value, persona, source="schema")
    """
    def __init__(self, path: str):
        self.path  = path
        self._lock = threading.Lock()
        self._q: list[dict[str, Any]] = []
        self._stop = threading.Event()
        self._thr  = threading.Thread(target=self._writer, daemon=True)
        self._thr.start()

    # ----- public
    def add_fact(self, field: str, value: str, persona: str, source: str = "schema") -> None:
        with self._lock:
            self._q.append({
                "ts": time.time(),
                "field": field,
                "value": value,
                "persona": persona,
                "source": source,
            })

    def close(self) -> None:
        self._stop.set()
        self._thr.join(timeout=1.5)

    # ----- worker
    def _writer(self) -> None:
        while not self._stop.is_set():
            item = None
            with self._lock:
                if self._q:
                    item = self._q.pop(0)
            if item is None:
                self._stop.wait(0.05)
                continue
            try:
                os.makedirs(os.path.dirname(self.path), exist_ok=True)
                with open(self.path, "a", encoding="utf-8") as fh:
                    json.dump(item, fh)
                    fh.write("\n")
            except Exception as exc:
                logger.error("[ReinforcementStore] write error: %s", exc)

# ══════════════════ TTS locked to Zira ══════════════════
class TTSManager(QtCore.QObject):
    finished = QtCore.pyqtSignal()

    def __init__(self, parent: QtCore.QObject | None = None):
        super().__init__(parent)
        self._engine = None
        if pyttsx3 is not None:
            try:
                self._engine = pyttsx3.init("sapi5" if sys.platform.startswith("win") else None)
                voice_id = None
                for v in self._engine.getProperty("voices"):
                    if "zira" in (v.name or "").lower():
                        voice_id = v.id; break
                if not voice_id:
                    for v in self._engine.getProperty("voices"):
                        if "david" not in (v.name or "").lower():
                            voice_id = v.id; break
                if voice_id:
                    self._engine.setProperty("voice", voice_id)
            except Exception as exc:
                logger.warning("[TTS] init error: %s", exc)
                self._engine = None

        # remember last spoken text for replay functionality
        self._last_text: Optional[str] = None

    def speak(self, text: str) -> None:
        """
        Synchronously speak the provided text. This uses the underlying pyttsx3 engine
        on a background thread and emits the finished signal when done.
        """
        if self._engine is None:
            return
        # remember last spoken text for replay
        self._last_text = text

        def _go() -> None:
            try:
                self._engine.say(text)
                self._engine.runAndWait()
            except Exception as exc:
                logger.warning("[TTS] speak error: %s", exc)
            finally:
                self.finished.emit()

        threading.Thread(target=_go, daemon=True).start()

    # -------------------------------------------------------------------
    # Legacy compatibility methods
    # -------------------------------------------------------------------
    def enqueue(self, text: str) -> None:
        """
        Queue a piece of text for playback. For this simple implementation we
        speak immediately. The last text is cached for replay().
        """
        self.speak(text)

    def stop(self) -> None:
        """Stop any ongoing speech."""
        try:
            if self._engine is not None:
                # pyttsx3 has stop() to immediately stop speaking
                self._engine.stop()
        except Exception as exc:
            logger.warning("[TTS] stop error: %s", exc)

    def replay(self) -> None:
        """Replay the last enqueued text."""
        if self._last_text:
            self.speak(self._last_text)

# ══════════════════ minimal AudioRecorder ══════════════════
class AudioRecorder(QtCore.QObject):
    transcribed = QtCore.pyqtSignal(str)

    def __init__(self, parent: QtCore.QObject | None = None):
        super().__init__(parent)
        self._frames: List[Any] = []
        self._recording = False
        self._stream: Any = None

    def list_devices(self) -> List[str]:
        if sd is None:
            return []
        return [d["name"] for d in sd.query_devices() if d.get("max_input_channels", 0) > 0]

    def start(self, device_index: int | None = None) -> None:
        if sd is None or np is None or self._recording:
            return
        self._frames.clear()
        def cb(indata, frames, time_info, status):
            self._frames.append(indata.copy())
        self._stream = sd.InputStream(
            samplerate=16000, channels=1, callback=cb, device=device_index
        )
        self._stream.start()
        self._recording = True

    def stop_and_transcribe(self) -> None:
        if not self._recording or sd is None or np is None:
            return
        self._recording = False
        self._stream.stop()
        data = np.concatenate(self._frames, axis=0)
        sf.write("temp.wav", data, 16000)
        threading.Thread(target=lambda: self.transcribed.emit(""), daemon=True).start()

# ══════════════════ public surface ══════════════════
__all__ = [
    "logger",
    "ensure_models_present",
    "Settings",
    "prof_dir",
    "conv_db_path",
    "feedback_db_path",
    "beans_path",
    "ConversationDB",
    "SemanticFeedbackDB",
    "BeanCounter",
    "ReinforcementStore",
    "TTSManager",
    "AudioRecorder",
    "SentenceTransformer",
    "DEFAULT_PERSONAS",
    "DEFAULT_VOICES",
    "FathomStore",       # legacy alias (kept for now)
]
```

core_base.py — foundational services for the modular AI-TTS Agent
=================================================================
• robust logging + graceful shims for missing deps
• Ollama model bootstrap  (ensure_models_present)
• JSON-backed Settings
• profile-aware helper paths
• ConversationDB  (SQLite)
• SemanticFeedbackDB  (SQLite)
• BeanCounter  (JSON tally)
• ReinforcementStore  (async JSONL append)
• cross-platform TTS locked to *Zira*
• minimal AudioRecorder placeholder
Everything here is UI-agnostic.
**Classes:** Settings, ConversationDB, SemanticFeedbackDB, BeanCounter, ReinforcementStore, TTSManager, AudioRecorder
**Functions:** _have_cli(cmd), ensure_models_present(), prof_dir(b, persona, set_name), conv_db_path(b, persona, set_name), feedback_db_path(b, persona, set_name), beans_path(b, persona, set_name)


## Module `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\AI_TTS_AGENT\core_orchestrator.py`

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
core_orchestrator.py
====================

This module provides the orchestration layer for the AI‑TTS agent.  It
exposes a unified API used by the user‑interface to interact with
schemas, conversations, commands, text‑to‑speech, plugins and other
components.  Historically the logic lived in a monolithic module,
but it has been refactored to encourage testability and to allow
individual subsystems to evolve independently.

The principal differences from earlier releases are:

* A richer :class:`PluginManager` that exposes a complete API expected
  by the UI.  In addition to discovering plugin packages from the
  ``plugins`` directory it now keeps per‑plugin metadata, supports
  enable/disable toggling, rescans at runtime, broadcasts messages to
  enabled plugins on a thread pool, and emits an ``eventReceived``
  signal whenever a plugin reports an event.  Plugins can either
  return a payload from their ``on_message`` handler or call
  ``emit_event`` on the manager directly to publish complex events.

* A ``run_command()`` method on :class:`AgentCore` which forwards
  slash commands through the :class:`CommandExecutor` and returns
  the textual result.  This helper centralises command routing and
  ensures backwards compatibility with older UI code.

* A ``process_user_message()`` method on :class:`AgentCore` which
  synchronously handles both slash‑commands and normal user input.  It
  persists the conversation, routes commands through the registry
  and, for non‑commands, returns a simple acknowledgement.  Future
  versions may integrate model execution here, but the method
  signature is stable for consumers.

* A ``command_registry`` attribute is exposed on the core as an
  adapter with a ``list_commands()`` method so that UI components
  (like the Command Palette) can enumerate available commands without
  coupling to internal registry details.

This file is fully self‑contained.  It gracefully degrades when
optional dependencies (such as PyQt5 or external model executables)
are unavailable by providing shims and in‑memory fallbacks.  Should
the optional modules exist in the runtime environment they will be
used automatically.  The design favours clear separation of
responsibilities, thread safety and explicit interfaces to ease
maintenance and extensibility.
"""

from __future__ import annotations

import importlib
import json
import os
import pathlib
import re
import subprocess
import threading
import time
from dataclasses import dataclass, field
from typing import Any, Dict, Iterable, List, Optional, Tuple

# Optional Qt import.  When PyQt5 is not available we fall back to a
# minimal shim so that type annotations and pyqtSignal declarations do
# not cause NameErrors.  The shim mimics only the parts of Qt used
# throughout this module.
try:
    from PyQt5 import QtCore  # type: ignore[assignment]
except Exception:
    class _ShimSignal:
        def __init__(self, *_, **__):
            pass
        def connect(self, *_, **__):
            pass
        def emit(self, *_, **__):
            pass

    class _ShimQObject:
        def __init__(self, *_, **__):
            pass

    # Create a very small QtCore replacement with the attributes we need.
    QtCore = type(
        "QtCore",
        (),
        {
            "QObject": _ShimQObject,
            "QThread": _ShimQObject,
            "pyqtSignal": lambda *a, **k: _ShimSignal(),
            "QTimer": type(
                "QTimer",
                (),
                {
                    "singleShot": staticmethod(lambda msec, func: None),
                },
            ),
        },
    )  # type: ignore

# ----------------------------------------------------------------------------
# Fallbacks for optional internal modules
#
# When the canonical ``core_base`` and ``core_schema`` modules are present
# they are imported normally.  If missing (for example during unit tests or
# headless operation) minimal stubs are provided to allow the remainder of
# this module to execute without crashing.  The stubs implement only the
# methods referenced by the UI.
# ----------------------------------------------------------------------------
try:
    # pylint: disable=unused-import
    from core_base import (
        Settings,
        TTSManager,
        AudioRecorder,
        conv_db_path,
        feedback_db_path,
        beans_path,
        ConversationDB,
        SemanticFeedbackDB,
        BeanCounter,
        ReinforcementStore,
        logger,
    )
    from core_schema import (
        SchemaManager,
        OperatorManager,
        DatasetManager,
    )
except Exception:
    # Provide very small stand‑ins for the missing classes and helpers.
    import logging

    logger = logging.getLogger("core_orchestrator_stub")

    class Settings:
        """In‑memory settings fallback."""
        def __init__(self, base_dir: str) -> None:
            self.base_dir = base_dir
            self.default_model: str = "mistral:latest"
            self.context_depth: int = 20
            self.auto_schema_enabled: bool = True
            self.use_google_stt: bool = False
        def save(self) -> None:
            # Persist settings to a JSON file in base_dir if possible
            path = os.path.join(self.base_dir, "settings.json")
            try:
                with open(path, "w", encoding="utf-8") as fh:
                    json.dump({
                        "default_model": self.default_model,
                        "context_depth": self.context_depth,
                        "auto_schema_enabled": self.auto_schema_enabled,
                        "use_google_stt": self.use_google_stt,
                    }, fh, indent=2)
            except Exception:
                pass

    class TTSManager:
        """No‑op TTS manager used when speech synthesis isn't available."""
        def enqueue(self, text: str) -> None:
            logger.debug("TTS enqueue called with: %s", text)

    class AudioRecorder(QtCore.QObject):
        """Stub audio recorder that exposes a transcribed signal."""
        transcribed = QtCore.pyqtSignal(str)
        def __init__(self) -> None:
            super().__init__()

    class ConversationDB:
        """In‑memory conversation log used when SQLite isn't available."""
        def __init__(self, path: str) -> None:
            self._lock = threading.RLock()
            self._records: List[Tuple[str, str]] = []
        def save_message(self, role: str, content: str) -> None:
            with self._lock:
                self._records.append((role, content))
        def fetch_history(self, limit: int = 50) -> List[Tuple[str, str]]:
            with self._lock:
                return list(self._records)[-limit:]

    class SemanticFeedbackDB:
        """Stub semantic feedback database.

        The real implementation persists feedback and updates a BeanCounter
        so command weighting and reinforcement learning can take place.  The
        fallback keeps just enough behaviour for the rest of the application
        to run when the full database layer is unavailable.
        """

        def __init__(self, path: str, beans: Any) -> None:
            # ``path`` is ignored in the stub but kept for signature
            # compatibility.  We keep a reference to ``beans`` so calls to
            # :meth:`add` can still influence the reinforcement counters when
            # a BeanCounter is supplied.
            self.beans = beans

        def add(self, original: str, liked: bool, revised: Optional[str] = None) -> None:
            logger.debug("Feedback recorded: %s liked=%s revised=%s", original, liked, revised)
            # Mimic reinforcement by adjusting the bean counter if provided.
            key = f"resp_{abs(hash(original))%10007}"
            if hasattr(self.beans, "inc"):
                self.beans.inc(key, 1 if liked else -1)

        def counts(self) -> Tuple[int, int]:
            # No persistent storage, so we always return zero counts.
            return (0, 0)

        # ------------------------------------------------------------------
        # Compatibility helpers
        # ------------------------------------------------------------------
        def get_counts(self) -> Tuple[int, int]:
            """Alias for :meth:`counts` to mirror the real class."""
            return self.counts()

        def get_liked_responses(self, limit: int = 5) -> List[str]:
            """Return an empty list – stub has no storage for responses."""
            return []

    class BeanCounter:
        """Stub reinforcement bean counter."""
        def __init__(self, path: str) -> None:
            self._lock = threading.RLock()
            self._store: Dict[str, int] = {}
        def inc(self, key: str, amount: int = 1) -> None:
            with self._lock:
                self._store[key] = self._store.get(key, 0) + amount

    class ReinforcementStore:
        """Stub reinforcement store."""
        def __init__(self, path: str) -> None:
            pass
        def inc(self, key: str, amount: int = 1) -> None:
            pass

    class SchemaManager:
        """Very small schema manager storing JSON in memory."""
        def __init__(self, base_dir: str) -> None:
            self.base_dir = pathlib.Path(base_dir)
            self._lock = threading.RLock()
            self._schemas: Dict[Tuple[str, str], Dict[str, Any]] = {}
            self._active: Dict[str, Dict[str, Any]] = {}
        def load_schema(self, persona: str, set_name: str = "default") -> Dict[str, Any]:
            key = (persona, set_name)
            with self._lock:
                return dict(self._schemas.get(key, {"name": persona, "voice": "", "role": "", "description": "", "dynamic_overlay": {}}))
        def save_schema(self, persona: str, set_name: str, schema_data: Dict[str, Any], *, auto_expand: bool = True) -> None:
            key = (persona, set_name)
            with self._lock:
                self._schemas[key] = dict(schema_data)
                self._active[persona] = dict(schema_data)
        @property
        def active_schemas(self) -> Dict[str, Dict[str, Any]]:
            with self._lock:
                return dict(self._active)

        # ------------------------------------------------------------------
        # Compatibility helpers
        # ------------------------------------------------------------------
        def get_set_list(self, persona: str) -> List[str]:
            """Return all set names defined for the given persona.

            Legacy UI code calls :meth:`get_set_list` on the schema manager
            to populate drop‑downs.  If no sets exist yet a single
            default entry ("default") is returned.
            """
            with self._lock:
                names = [s for (p, s) in self._schemas.keys() if p == persona]
            # Guarantee at least a default set exists
            return sorted(names or ["default"])

        def get_personas(self) -> List[str]:
            """Return all personas that have at least one schema.

            This helper mirrors the interface exposed by the full schema
            engine for backwards compatibility.
            """
            with self._lock:
                persons = {p for p, _ in self._schemas.keys()}
            return sorted(persons)

    class OperatorManager:
        def __init__(self, base_dir: str) -> None:
            pass

    class DatasetManager:
        def __init__(self, base_dir: str) -> None:
            pass
        def list(self) -> List[Any]:
            return []

    def conv_db_path(base_dir: str, persona: str, set_name: str) -> str:
        return os.path.join(base_dir, "conversations", f"{persona}_{set_name}.sqlite3")

    def feedback_db_path(base_dir: str, persona: str, set_name: str) -> str:
        return os.path.join(base_dir, "feedback", f"{persona}_{set_name}.sqlite3")

    def beans_path(base_dir: str, persona: str, set_name: str) -> str:
        return os.path.join(base_dir, "profiles", persona, set_name, "reinforcement.json")


# ----------------------------------------------------------------------------
# Command Registry & Executor
# ----------------------------------------------------------------------------
class CommandRegistry(QtCore.QObject):
    """Stores slash‑command metadata and emits change signals."""

    # Emit the full list of commands whenever the registry is updated.  The
    # connected slot in the command palette expects a single list argument,
    # so the signal carries that list instead of emitting without
    # parameters.  Slots that ignore the argument will still function.
    commandsChanged = QtCore.pyqtSignal(list)
    commandWeightsChanged = QtCore.pyqtSignal()

    # Built‑in commands shipped with the agent.  When refactoring this list,
    # be sure to retain backwards compatibility by adding new commands to
    # the end rather than reordering or removing existing items.
    _BUILT_INS: Tuple[str, ...] = (
        "/remember", "/inject", "/rewrite", "/show", "/action",
        "/trait", "/dataset", "/search", "/embeddings", "/schema",
        "/tts", "/plugin", "/feedback", "/lock", "/commands",
        "/reject", "/auto", "/ignore", "/opposite", "/delete",
    )

    def __init__(self, path: pathlib.Path) -> None:
        super().__init__()
        self._path = path
        # Internal storage maps command → metadata such as weight and lock
        self._store: Dict[str, Dict[str, Any]] = {}
        # Attempt to load existing registry from disk
        try:
            if self._path.is_file():
                with open(self._path, encoding="utf-8") as fh:
                    data = json.load(fh)
                    self._store.update(data.get("commands", {}))
        except Exception:
            logger.debug("Failed to read command registry from %s", self._path)
        # Ensure built‑ins exist
        for cmd in self._BUILT_INS:
            self.register(cmd)

    # ----------------------------------------------------------------------
    # CRUD helpers
    # ----------------------------------------------------------------------
    def register(self, name: str) -> None:
        """Register a command if it does not already exist."""
        if name not in self._store:
            self._store[name] = {"weight": 0, "locked": False}
            self._save()

    def toggle_lock(self, name: str, state: Optional[bool] = None) -> None:
        """Toggle the locked state of a command.  A locked command cannot have
        its weight modified."""
        if name in self._store:
            cur = self._store[name]["locked"]
            self._store[name]["locked"] = (not cur) if state is None else bool(state)
            self._save()

    def set_weight(self, name: str, weight: int) -> None:
        """Assign a new weight to the given command if it is not locked."""
        if name in self._store and not self._store[name].get("locked", False):
            self._store[name]["weight"] = int(weight)
            self._save()

    def list(self) -> List[str]:
        """Return all registered commands sorted lexicographically."""
        return sorted(self._store.keys())

    def meta(self, name: str) -> Dict[str, Any]:
        """Return metadata for the specified command or an empty dict."""
        return dict(self._store.get(name, {}))

    def list_commands(self) -> List[str]:
        """Alias for :meth:`list` retained for backwards compatibility."""
        return self.list()

    # Internal helper to persist changes and emit appropriate signals
    def _save(self) -> None:
        try:
            self._path.parent.mkdir(parents=True, exist_ok=True)
            with open(self._path, "w", encoding="utf-8") as fh:
                json.dump({"commands": self._store}, fh, indent=2)
        except Exception:
            logger.debug("Failed to save command registry to %s", self._path)
        # Notify listeners on the next iteration of the event loop.  When
        # emitting commandsChanged we pass the updated list because the
        # CommandPaletteDock.set_command_list slot requires an argument.
        QtCore.QTimer.singleShot(0, lambda: self.commandsChanged.emit(self.list()))
        QtCore.QTimer.singleShot(0, self.commandWeightsChanged.emit)


class CommandExecutor:
    """Routes slash‑command strings to internal handler methods."""
    def __init__(self, owner: "AgentCore", registry: CommandRegistry) -> None:
        self.owner = owner
        self.registry = registry

    def run(self, msg: str) -> Optional[str]:
        """Execute a slash command if ``msg`` begins with a slash.  Returns
        ``None`` for non‑command strings."""
        if not msg or not msg.startswith("/"):
            return None
        cmd, *rest = msg.split(maxsplit=1)
        if cmd not in self.registry.list():
            return f"⚠️ Unknown command {cmd}"
        handler_name = f"_{cmd.lstrip('/') }"
        fn = getattr(self, handler_name, None)
        if not callable(fn):
            return "🚧 command not implemented"
        try:
            arg = rest[0] if rest else ""
            return fn(arg)
        except Exception as exc:
            logger.error("[cmd] %s: %s", cmd, exc, exc_info=True)
            return str(exc)

    # Example minimal handlers
    def _show(self, _arg: str) -> str:
        rows: List[str] = []
        for name in self.registry.list():
            meta = self.registry.meta(name)
            lock = "🔒" if meta.get("locked", False) else ""
            rows.append(f"{name:12} w={meta.get('weight', 0):>3} {lock}")
        return "\n".join(rows) or "(no commands)"

    def _lock(self, arg: str) -> str:
        if not arg:
            return "Usage: /lock <cmd>"
        self.registry.toggle_lock(arg.strip())
        return "lock toggled"

    def _remember(self, arg: str) -> str:
        if not arg:
            return "Usage: /remember k v"
        k, *val = arg.split(maxsplit=1)
        if not val:
            return "Usage: /remember k v"
        self.owner.memory[k] = val[0]
        self.owner._save_memory()
        return "✓ saved"


# ----------------------------------------------------------------------------
# Plugin Manager
# ----------------------------------------------------------------------------
@dataclass
class PluginMeta:
    """Holds metadata about a single plugin."""
    name: str
    missing_dependencies: List[str] = field(default_factory=list)
    enabled: bool = True
    widget: Any = None
    module: Any = None

class PluginManager(QtCore.QObject):
    """
    Discovers and manages runtime plugins.

    Plugins live in the ``plugins`` subdirectory of the agent's base
    directory.  Each plugin is expected to be a Python package whose
    top‑level module may define any of the following attributes:

    * ``REQUIRES`` – an iterable of import names that must be available in
      order for the plugin to operate correctly.  Missing dependencies
      are surfaced to the UI and the plugin is disabled by default.

    * ``on_message(text: str, manager: PluginManager) -> Optional[dict]`` –
      a callback invoked whenever a message is broadcast.  It may return
      an envelope to emit via the :attr:`eventReceived` signal or it may
      raise/return nothing.  The callback is executed on a worker
      thread to avoid blocking the UI.

    * ``get_widget() -> QWidget`` – if present, invoked once when the
      plugin is discovered to obtain a UI widget that will be docked in
      the main window when the plugin is enabled.

    A plugin may alternatively call :meth:`emit_event` directly on the
    manager at any time to publish complex events.
    """
    # Plugins can emit events back to the UI via this signal.  The
    # first parameter is the plugin name and the second is an event
    # envelope (arbitrary mapping).
    eventReceived = QtCore.pyqtSignal(str, dict)

    def __init__(self, root: pathlib.Path, settings: Settings) -> None:
        super().__init__()
        self.root: pathlib.Path = pathlib.Path(root) / "plugins"
        self.settings: Settings = settings
        # Thread pool for dispatching plugin callbacks; reuse a small
        # number of threads to minimise resource usage.
        self._executor = None
        # Internal index of metadata keyed by plugin name
        self._meta: Dict[str, PluginMeta] = {}
        # Discover all plugins on initialisation
        self.discover()

    # ------------------------------------------------------------------
    def _ensure_executor(self) -> None:
        """Lazily create a thread pool executor."""
        if self._executor is None:
            import concurrent.futures
            # Use a small fixed pool – plugin callbacks should be quick
            self._executor = concurrent.futures.ThreadPoolExecutor(max_workers=4)

    def discover(self) -> None:
        """Scan the ``plugins`` directory and populate metadata."""
        self._meta.clear()
        if not self.root.is_dir():
            logger.info("No plugin directory found at %s", self.root)
            return
        for entry in self.root.iterdir():
            if not entry.is_dir() or entry.name.startswith("__"):
                continue
            name = entry.name
            meta = PluginMeta(name=name)
            try:
                module_name = f"plugins.{name}"
                mod = importlib.import_module(module_name)
                meta.module = mod
                # check dependencies
                requires: Iterable[str] = getattr(mod, "REQUIRES", [])
                missing: List[str] = []
                for dep in requires:
                    try:
                        importlib.import_module(dep)
                    except Exception:
                        missing.append(dep)
                meta.missing_dependencies = missing
                # Determine initial enabled state from settings.  Persisted
                # states live under a key namespace e.g. ``pluginsEnabled`` in
                # settings JSON.  Fallback to enabled unless dependencies
                # are missing.
                enabled_state = True
                try:
                    plug_cfg = getattr(self.settings, "plugins_enabled", {})
                    enabled_state = bool(plug_cfg.get(name, True))
                except Exception:
                    enabled_state = True
                # Force disabled when dependencies are missing
                meta.enabled = enabled_state and not missing
                # Create widget if provided
                try:
                    if hasattr(mod, "get_widget") and callable(mod.get_widget):
                        meta.widget = mod.get_widget()
                    elif hasattr(mod, "Widget"):
                        # Some plugins expose a QWidget subclass directly
                        meta.widget = getattr(mod, "Widget")()
                    elif hasattr(mod, "widget"):
                        # Prebuilt widget instance
                        meta.widget = getattr(mod, "widget")
                except Exception as exc:
                    logger.warning("[plugin:%s] error creating widget: %s", name, exc)
                    meta.widget = None
                self._meta[name] = meta
                logger.info("[plugin] loaded %s", name)
            except Exception as exc:
                # Record failure as missing dependency for UI
                meta.enabled = False
                meta.missing_dependencies = [str(exc)]
                self._meta[name] = meta
                logger.warning("[plugin] failed to load %s: %s", name, exc)

    # ------------------------------------------------------------------
    def list_plugins(self) -> List[PluginMeta]:
        """Return a list of all discovered plugin metadata objects."""
        return [self._meta[k] for k in sorted(self._meta.keys())]

    def enable_plugin(self, name: str, enabled: bool) -> None:
        """Enable or disable a plugin.  The UI will call this when a user
        toggles a checkbox.  Enabled state is persisted to
        ``settings.plugins_enabled``.
        """
        if name not in self._meta:
            return
        meta = self._meta[name]
        # Do not enable a plugin with missing dependencies
        if enabled and meta.missing_dependencies:
            logger.warning("Attempted to enable plugin %s with missing deps", name)
            return
        meta.enabled = bool(enabled)
        # Persist state back into settings
        try:
            plug_cfg = getattr(self.settings, "plugins_enabled", {})
            if not isinstance(plug_cfg, dict):
                plug_cfg = {}
            plug_cfg[name] = meta.enabled
            setattr(self.settings, "plugins_enabled", plug_cfg)
            self.settings.save()
        except Exception:
            logger.debug("Could not persist plugin enabled state for %s", name)
        # Invoke lifecycle hooks if defined
        try:
            if meta.module:
                if meta.enabled and hasattr(meta.module, "on_enable"):
                    meta.module.on_enable()
                elif not meta.enabled and hasattr(meta.module, "on_disable"):
                    meta.module.on_disable()
        except Exception as exc:
            logger.warning("[plugin:%s] lifecycle hook error: %s", name, exc)

    def rescan(self) -> None:
        """Rebuild the plugin registry while preserving enabled state where
        possible."""
        old_states = {name: meta.enabled for name, meta in self._meta.items()}
        self.discover()
        # Restore previous enabled states if compatible
        for name, state in old_states.items():
            if name in self._meta:
                # Disable when dependencies are still missing
                if self._meta[name].missing_dependencies:
                    self._meta[name].enabled = False
                else:
                    self._meta[name].enabled = state

    def broadcast(self, text: str) -> None:
        """Send a message to all enabled plugins.  Messages are dispatched
        asynchronously on a thread pool so the UI thread remains
        responsive.  Each plugin's ``on_message`` handler receives the
        message and this manager instance.  If the handler returns a
        mapping, it will be emitted via the :attr:`eventReceived` signal.
        """
        if not text:
            return
        self._ensure_executor()
        for meta in list(self._meta.values()):
            if not meta.enabled or meta.missing_dependencies:
                continue
            mod = meta.module
            if not mod:
                continue
            handler = getattr(mod, "on_message", None)
            if not callable(handler):
                continue
            # Dispatch on a worker thread
            def _run_handler(m=meta, h=handler, msg=text):
                try:
                    result = h(msg, self)
                    if isinstance(result, dict):
                        # Emit result via signal in the GUI thread
                        QtCore.QTimer.singleShot(0, lambda n=m.name, env=result: self.eventReceived.emit(n, env))
                except Exception as exc:
                    logger.warning("[plugin:%s] on_message error: %s", m.name, exc)
            # schedule the call
            self._executor.submit(_run_handler)

    def emit_event(self, sender: str, envelope: dict) -> None:
        """Convenience for plugins to emit events.  Plugins may call
        ``manager.emit_event(name, envelope)`` directly instead of
        returning from their ``on_message`` handlers.  The emission is
        forwarded to the UI thread via a zero‑delay timer.
        """
        if not envelope or not isinstance(envelope, dict):
            return
        # Schedule the emit on the Qt event loop
        QtCore.QTimer.singleShot(0, lambda s=sender, env=envelope: self.eventReceived.emit(s, env))


# ----------------------------------------------------------------------------
# RAG cache, schema engine and evolver fallbacks
#
# The original agent included sophisticated retrieval‑augmented generation
# support (the so‑called RAG cache) as well as a rich schema engine and
# evolver.  Those components are tightly coupled to the rest of the code
# base and to external packages.  To allow the UI to load without
# exploding when those bits are absent, we provide extremely minimal
# stand‑ins here.  They implement only the methods exercised by the UI
# (e.g. clearing the cache, basic schema field manipulation, etc.) and
# never throw.  Should the full implementations become available at
# runtime they can replace these shims by monkeypatching the
# corresponding attributes on :class:`AgentCore`.

class RAGCache:
    """In‑memory stub for the retrieval‑augmented generation cache.

    The real RAG cache stores vector embeddings on disk and in memory and
    exposes helpers for incremental updates.  For the purposes of the
    fallback we simply track whether anything has been 'cached' and allow
    callers to clear that state.  See :meth:`clear_disk` and
    :meth:`clear_memory`.
    """

    def __init__(self, root: str) -> None:
        # Root directory where persistent embeddings would live.  The
        # fallback does not persist anything but keeps the path for
        # reference.
        self.root = root
        # In‑memory store keyed by dataset path.  Values are arbitrary
        # payloads that might normally include embeddings.  We don't
        # implement storage here but maintain the attribute to satisfy
        # introspection.
        self._mem: Dict[str, Any] = {}

    def clear_disk(self) -> int:
        """Simulate removal of all on‑disk embedding files.

        Returns the number of files that would have been removed.  The
        fallback never persists embeddings so the count is always zero.
        """
        return 0

    def clear_memory(self) -> None:
        """Forget all cached embeddings held in memory."""
        self._mem.clear()


class SchemaEngine(QtCore.QObject):
    """Very small in‑memory schema engine.

    The full schema engine persists personas and sets in an SQLite
    database, exposes a signals API, integrates with the command
    registry and enforces schema invariants.  In contrast, this shim
    records arbitrary fields in nested dictionaries and provides only
    the handful of methods referenced by the UI: enumerating personas
    and sets, loading schemas, updating fields, toggling command
    exposure, toggling automatic evolution and reading fields back.
    """

    # Signal emitted when a schema evolves.  The UI connects to this
    # signal to refresh displayed values after an evolution completes.
    schemaEvolved = QtCore.pyqtSignal(str, str)

    def __init__(self, base_dir: str) -> None:
        super().__init__()
        self.base_dir = base_dir
        # All schemas keyed by (persona, set_name) -> dict
        self._schemas: Dict[Tuple[str, str], Dict[str, Any]] = {}
        # Track command exposure per (persona, category)
        self._cmd_exposed: Dict[Tuple[str, str], bool] = {}
        # Track auto evolution flag per (persona, set_name)
        self._auto_evo: Dict[Tuple[str, str], bool] = {}

    # ------------------------------------------------------------------
    # Introspection helpers
    # ------------------------------------------------------------------
    def personas(self) -> List[str]:
        """Return a list of personas that have at least one set loaded."""
        return sorted({persona for persona, _ in self._schemas.keys()})

    def set_list(self, persona: str, *args: Any) -> List[str]:
        """Get or set list depending on arguments.

        When called with only the persona, returns the names of all
        loaded sets for that persona.  When called with three
        additional arguments (set_name, field, values) behaves like
        :meth:`update_field` by storing ``values`` under ``field`` for
        the given persona and set.
        """
        # Setter mode: persona, set_name, field, values
        if len(args) == 3:
            set_name, field, values = args
            return [] if not self.update_field(persona, set_name, field, values) else []
        # Getter mode: persona only
        sets = [s for p, s in self._schemas.keys() if p == persona]
        return sorted(sets)

    # ------------------------------------------------------------------
    # Schema CRUD
    # ------------------------------------------------------------------
    def load_schema(self, persona: str, set_name: str) -> Optional[Dict[str, Any]]:
        """Return the schema dictionary for ``persona`` / ``set_name``.

        If no schema exists yet the fallback returns an empty mapping.
        """
        return self._schemas.get((persona, set_name), {})

    def update_field(self, persona: str, set_name: str, field: str, value: Any) -> bool:
        """Set a schema field and emit ``schemaEvolved``.

        Returns True on success.  The fallback always succeeds.
        """
        schema = self._schemas.setdefault((persona, set_name), {})
        schema[field] = value
        # Emit evolution signal to notify UI listeners
        try:
            self.schemaEvolved.emit(persona, set_name)
        except Exception:
            pass
        return True

    def get_field(self, persona: str, set_name: str, field: str) -> Any:
        """Return the value of a schema field or ``None`` if unset."""
        return self._schemas.get((persona, set_name), {}).get(field)

    # ------------------------------------------------------------------
    # Command exposure & auto evolution
    # ------------------------------------------------------------------
    def set_command_exposure(self, persona: str, field: str, exposed: bool) -> None:
        """Record whether ``field`` should be exposed as a slash command."""
        self._cmd_exposed[(persona, field)] = bool(exposed)

    def is_exposed_as_command(self, persona: str, field: str) -> bool:
        """Return True if ``field`` is marked as exposed."""
        return bool(self._cmd_exposed.get((persona, field)))

    def set_auto_evolution(self, persona: str, set_name: str, onoff: bool) -> None:
        """Enable or disable automatic schema evolution."""
        self._auto_evo[(persona, set_name)] = bool(onoff)

    # ------------------------------------------------------------------
    # Compatibility aliases
    # ------------------------------------------------------------------
    def get_set_list(self, persona: str) -> List[str]:
        """Legacy API: alias for :meth:`set_list(persona)`."""
        return self.set_list(persona)


class SchemaEvolver(QtCore.QObject):
    """Trivial schema evolver.

    The evolver's job is to adjust a schema given a conversation
    history.  The fallback implementation simply returns False to
    indicate that no changes were made.
    """

    def __init__(self, base_dir: str) -> None:
        super().__init__()
        self.base_dir = base_dir

    def update_schema(self, persona: str, set_name: str, history: List[Tuple[str, str]]) -> bool:
        """Perform a no‑op evolution.  Always returns False."""
        return False


class DatasetManagerFallback:
    """Minimal stand‑in for the full :class:`DatasetManager`.

    When the persistent SQLite database has not yet been migrated the
    original dataset manager will raise an ``OperationalError`` upon
    listing.  The fallback avoids that by returning empty results and
    exposing the handful of methods the UI expects.  No data is
    persisted by this implementation.
    """

    def __init__(self, base_dir: str) -> None:
        self.base_dir = pathlib.Path(base_dir)
        # Directory where datasets would be stored
        self.datasets_dir = self.base_dir / "datasets"
        self.datasets_dir.mkdir(parents=True, exist_ok=True)
        # Internal store mapping dataset name → info dict
        self._store: Dict[str, Dict[str, Any]] = {}

    def list(self) -> List[Any]:
        """Return an empty list.  In a full implementation this would
        return dataset objects describing each managed dataset."""
        return []

    @property
    def entries(self) -> Dict[str, Any]:
        """Return an empty dictionary mapping dataset names to entries."""
        return {}

    def toggle_active(self, name: str, active: bool) -> None:
        """Mark a dataset as active/inactive.  No‑op in the fallback."""
        info = self._store.get(name)
        if info is not None:
            info["active"] = bool(active)

    def add_dataset(self, path: str, *, name: Optional[str] = None) -> None:
        """Add a dataset from a file path.  The fallback simply
        records the dataset name and path in memory."""
        if not name:
            name = pathlib.Path(path).stem
        self._store[name] = {"path": path, "active": True}

    def delete_dataset(self, name: str) -> None:
        """Remove a dataset.  The fallback just deletes the entry from
        the in‑memory store."""
        self._store.pop(name, None)

    def load_dataset_text(self, name: str) -> str:
        """Load the raw text for the given dataset.  Returns an empty
        string if the dataset is unknown or if reading fails."""
        info = self._store.get(name)
        if not info:
            return ""
        try:
            with open(info.get("path", ""), encoding="utf-8") as fh:
                return fh.read()
        except Exception:
            return ""


# ----------------------------------------------------------------------------
# Model Worker
# ----------------------------------------------------------------------------
class ModelWorker(QtCore.QThread):
    """Runs external language models in a separate thread.

    This worker wraps an `ollama` subprocess invocation so that model
    evaluations do not block the UI.  It emits ``finished`` when the
    call returns successfully and ``failed`` when an exception is
    raised.  If the `ollama` binary is not available or times out
    `failed` will receive the error message.
    """
    finished = QtCore.pyqtSignal(str)
    failed = QtCore.pyqtSignal(str)

    def __init__(self, model: str, prompt: str, *, temp: float = 0.7) -> None:
        super().__init__()
        self.model = model
        self.prompt = prompt
        self.temp = temp

    def run(self) -> None:
        try:
            out = subprocess.check_output(
                ["ollama", "run", self.model, "--prompt", self.prompt, "--temperature", str(self.temp)],
                stderr=subprocess.STDOUT,
                text=True,
                timeout=60,
            )
            self.finished.emit(out.strip())
        except subprocess.CalledProcessError as e:
            self.failed.emit(e.output.strip())
        except Exception as exc:
            self.failed.emit(str(exc))


# ----------------------------------------------------------------------------
# Agent Core
# ----------------------------------------------------------------------------
class AgentCore(QtCore.QObject):
    """
    Heart of the AI‑TTS agent.  Provides a high‑level API consumed by the
    UI for persistent storage, command handling, plugin management and
    message processing.  Most methods are thread‑safe and return
    immediately without blocking the UI.
    """
    # Signals used by the UI to update status
    replyReady = QtCore.pyqtSignal(str)
    modelError = QtCore.pyqtSignal(str)
    tokensConsumed = QtCore.pyqtSignal(int)

    def __init__(
        self,
        base_dir: str,
        *,
        persona: Optional[str] = None,
        set_name: str = "default",
    ) -> None:
        super().__init__()
        # File system
        self.base_dir = pathlib.Path(base_dir)
        self.persona = persona or "zira"
        self.set_name = set_name
        # Settings
        self.settings = Settings(str(self.base_dir))
        # Initialise store directories
        self._prof_dir = self.base_dir / "profiles" / self.persona / self.set_name
        self._prof_dir.mkdir(parents=True, exist_ok=True)
        self._memory_file = self._prof_dir / "memory.json"
        # Instantiate subsystems
        self.schema_mgr = SchemaManager(str(self.base_dir))
        # Dataset manager – attempt to use the full implementation if
        # available.  When the backing SQLite tables have not been
        # created yet the dataset manager will raise an error on
        # ``list()``, so we fall back to the in‑memory stub.
        try:
            dm = DatasetManager(str(self.base_dir))  # type: ignore[call-arg]
            # Probe the manager to ensure the DB is present.  Some
            # implementations lazily connect to SQLite on first call.
            try:
                _ = dm.list()
            except Exception:
                raise
            self.dataset_mgr = dm
        except Exception:
            # Fallback stub avoids OperationalError due to missing tables
            self.dataset_mgr = DatasetManagerFallback(str(self.base_dir))
        self.operator_mgr = OperatorManager(str(self.base_dir))
        # Persistence
        self.conversation_db = ConversationDB(
            conv_db_path(str(self.base_dir), self.persona, self.set_name)
        )
        # Shared reinforcement ledger used by feedback and other components.
        bean_path = beans_path(str(self.base_dir), self.persona, self.set_name)
        self.beans = BeanCounter(bean_path)
        self.feedback_db = SemanticFeedbackDB(
            feedback_db_path(str(self.base_dir), self.persona, self.set_name),
            self.beans,
        )
        self.reinforcement_store = ReinforcementStore(bean_path)
        # Commands
        cmd_path = self._prof_dir / "commands.json"
        self.cmd_reg = CommandRegistry(cmd_path)
        self.cmd_exec = CommandExecutor(self, self.cmd_reg)
        # Provide a command_registry adapter for UI; exposes list_commands
        class _CmdRegAdapter:
            def __init__(self, reg: CommandRegistry) -> None:
                self._reg = reg
            def list_commands(self) -> List[str]:
                # Remove the leading slash for UI display purposes
                return [c for c in self._reg.list()]
        self.command_registry = _CmdRegAdapter(self.cmd_reg)
        # Expose registry change signals for convenience
        self.commandsChanged = self.cmd_reg.commandsChanged
        self.commandWeightsChanged = self.cmd_reg.commandWeightsChanged
        # Plugins
        self.plugins = PluginManager(self.base_dir, self.settings)
        # ------------------------------------------------------------------
        # RAG & schema components
        #
        # The UI references ``core.rag_cache`` and ``core.rag_search`` when
        # performing retrieval‑augmented generation (RAG) and ``core.schema_*``
        # objects when editing schemas.  In environments where the full
        # implementations are unavailable we instantiate the fallback shims
        # provided in this module.  These fallbacks expose the same
        # signatures but perform no heavy lifting.
        self.rag_cache = RAGCache(str(self.base_dir))
        self.schema_engine = SchemaEngine(str(self.base_dir))
        self.schema_evolver = SchemaEvolver(str(self.base_dir))
        # Create a default schema entry for the active persona/set so
        # that the UI can enumerate at least one persona and set.  This
        # populates the in‑memory schema store with a placeholder
        # field to mark its existence.  Without this the persona tabs
        # would appear empty on first launch.
        try:
            self.schema_engine.update_field(self.persona, self.set_name, "_init", True)
        except Exception:
            pass
        # Provide rag_search as a bound method so code can call
        # ``core.rag_search(...)``.  See method definition further below.
        # Note: we do not assign to self.rag_search here because methods
        # are descriptors; simply defining rag_search on the class makes
        # it available on the instance.
        # TTS and recording
        self.tts_mgr = TTSManager()
        self.audio_recorder = AudioRecorder()
        # Memory dictionary
        self.memory: Dict[str, str] = {}
        self._load_memory()
        # Add feedback helper
        self.add_feedback = lambda original, liked, revised=None: self.feedback_db.add(original, liked, revised)

    # ------------------------------------------------------------------
    # Memory helpers
    # ------------------------------------------------------------------
    def _load_memory(self) -> None:
        """Load persisted agent memory from disk."""
        try:
            if self._memory_file.is_file():
                with open(self._memory_file, encoding="utf-8") as fh:
                    data = json.load(fh)
                    if isinstance(data, dict):
                        self.memory.update({k: str(v) for k, v in data.items()})
        except Exception as exc:
            logger.debug("Failed to load memory: %s", exc)

    def _save_memory(self) -> None:
        """Persist the agent memory to disk."""
        try:
            self._prof_dir.mkdir(parents=True, exist_ok=True)
            with open(self._memory_file, "w", encoding="utf-8") as fh:
                json.dump(self.memory, fh, indent=2)
        except Exception as exc:
            logger.debug("Failed to save memory: %s", exc)

    # ------------------------------------------------------------------
    # Command & message processing
    # ------------------------------------------------------------------
    def run_command(self, msg: str, *, persona: Optional[str] = None, set_name: Optional[str] = None) -> str:
        """Process a slash command and return the response text.  Unknown
        commands yield a warning.  Both persona and set_name are
        accepted for future expansion; they are currently unused.
        """
        result = self.cmd_exec.run(msg)
        return "" if result is None else result

    def process_user_message(
        self,
        msg: str,
        *,
        persona: Optional[str] = None,
        set_name: Optional[str] = None,
        tts: bool = True,
    ) -> str:
        """Synchronously handle a user's input.  Slash commands are routed
        through :meth:`run_command`, recorded into the conversation log and
        returned immediately.  Non‑command messages are appended to the
        conversation and a simple acknowledgement is returned.  A future
        implementation can call an LLM here and use the result.  When
        ``tts`` is true the response is enqueued for text‑to‑speech.
        """
        user_msg = (msg or "").strip()
        if not user_msg:
            return ""
        # Save the user's utterance
        self.conversation_db.save_message("user", user_msg)
        # Slash commands
        if user_msg.startswith("/"):
            resp = self.run_command(user_msg, persona=persona, set_name=set_name)
            self.conversation_db.save_message("system", resp)
            return resp
        # Normal chat – future versions should build a prompt and call an LLM
        reply = f"{self.persona.capitalize()}: I received your message: {user_msg}"
        self.conversation_db.save_message(self.persona, reply)
        # Optionally speak the reply
        if tts:
            try:
                self.tts_mgr.enqueue(reply)
            except Exception:
                pass
        return reply

    # ------------------------------------------------------------------
    # Conversation and model pipeline
    # ------------------------------------------------------------------
    def send(self, user_msg: str) -> None:
        """Asynchronous pipeline invoked by legacy code.  Kept for backwards
        compatibility with older UI components.  Use
        :meth:`process_user_message` for synchronous processing.
        """
        # Simply hand off to process_user_message and emit signals
        response = self.process_user_message(user_msg, tts=False)
        if response:
            self.replyReady.emit(response)

    # ------------------------------------------------------------------
    # Retrieval‑augmented search
    # ------------------------------------------------------------------
    def rag_search(
        self,
        query: str,
        *,
        per_ds_k: int = 3,
        limit: int = 5,
        include_shared: bool = False,
        datasets: Optional[List[str]] = None,
    ) -> List[Tuple[str, float, str, str]]:
        """Perform a simple in‑memory search over dataset entries.

        The original implementation of this method would encode the
        provided ``query`` using a sentence embedding model and then
        retrieve the top‐matching text chunks from configured
        datasets.  In the fallback we simply return an empty list so
        that callers can iterate over the result without error.  The
        signature is maintained to preserve compatibility with the UI.

        :param query: The user query to search for.
        :param per_ds_k: Number of hits per dataset (ignored).
        :param limit: Maximum total number of hits (ignored).
        :param include_shared: Whether to include shared datasets (ignored).
        :param datasets: Restrict the search to specific dataset names (ignored).
        :returns: An empty list of hits.
        """
        # TODO: integrate with a vector search engine.  For now return no hits.
        return []

    # ------------------------------------------------------------------
    # Housekeeping
    # ------------------------------------------------------------------
    def close(self) -> None:
        """Cleanly close any resources owned by the core.  Currently this
        simply flushes in‑memory stores and releases any thread pools.  It
        is safe to call this multiple times.
        """
        try:
            # Persist memory
            self._save_memory()
        except Exception:
            pass
        # Flush settings
        try:
            self.settings.save()
        except Exception:
            pass
        # Shut down plugin executor
        try:
            exec_ = getattr(self.plugins, "_executor", None)
            if exec_:
                exec_.shutdown(wait=False)
                self.plugins._executor = None
        except Exception:
            pass
        # ConversationDB may own a SQLite connection; attempt to close
        try:
            if hasattr(self.conversation_db, "conn"):
                self.conversation_db.conn.close()
        except Exception:
            pass


__all__ = [
    "CommandRegistry",
    "CommandExecutor",
    "PluginManager",
    "PluginMeta",
    "ModelWorker",
    "AgentCore",
    "RAGCache",
    "SchemaEngine",
    "SchemaEvolver",
]
```

core_orchestrator.py
====================

This module provides the orchestration layer for the AI‑TTS agent.  It
exposes a unified API used by the user‑interface to interact with
schemas, conversations, commands, text‑to‑speech, plugins and other
components.  Historically the logic lived in a monolithic module,
but it has been refactored to encourage testability and to allow
individual subsystems to evolve independently.

The principal differences from earlier releases are:

* A richer :class:`PluginManager` that exposes a complete API expected
  by the UI.  In addition to discovering plugin packages from the
  ``plugins`` directory it now keeps per‑plugin metadata, supports
  enable/disable toggling, rescans at runtime, broadcasts messages to
  enabled plugins on a thread pool, and emits an ``eventReceived``
  signal whenever a plugin reports an event.  Plugins can either
  return a payload from their ``on_message`` handler or call
  ``emit_event`` on the manager directly to publish complex events.

* A ``run_command()`` method on :class:`AgentCore` which forwards
  slash commands through the :class:`CommandExecutor` and returns
  the textual result.  This helper centralises command routing and
  ensures backwards compatibility with older UI code.

* A ``process_user_message()`` method on :class:`AgentCore` which
  synchronously handles both slash‑commands and normal user input.  It
  persists the conversation, routes commands through the registry
  and, for non‑commands, returns a simple acknowledgement.  Future
  versions may integrate model execution here, but the method
  signature is stable for consumers.

* A ``command_registry`` attribute is exposed on the core as an
  adapter with a ``list_commands()`` method so that UI components
  (like the Command Palette) can enumerate available commands without
  coupling to internal registry details.

This file is fully self‑contained.  It gracefully degrades when
optional dependencies (such as PyQt5 or external model executables)
are unavailable by providing shims and in‑memory fallbacks.  Should
the optional modules exist in the runtime environment they will be
used automatically.  The design favours clear separation of
responsibilities, thread safety and explicit interfaces to ease
maintenance and extensibility.
**Classes:** CommandRegistry, CommandExecutor, PluginMeta, PluginManager, RAGCache, SchemaEngine, SchemaEvolver, DatasetManagerFallback, ModelWorker, AgentCore


## Module `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\AI_TTS_AGENT\core_schema.py`

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
core_schema.py — v3-final (2025-08-04 04:12 UTC)
================================================

Single-source authority for all schema / dataset / snapshot / spatial-state
logic used by FATHOM Agent, now relying on AgentStore’s public API only.

Provides:
• Schema dataclass + SchemaEngine (diff, auto-evolve, variant injection)
• OperatorManager persisted in the same DB
• DatasetManager (metadata) + RAGCache (embeddings) in the same DB
• SnapshotEngine to walk the codebase & persist chunks to DB
• SpatialPositionManager for grid-room positions & movement logging
• Back-compat alias: SchemaManager → SchemaEngine

This version adds the `.active_schemas` property required by main_ui.py.
"""

from __future__ import annotations

import os
import json
import threading
import mimetypes
import hashlib
import shutil
import difflib
import time
from dataclasses import dataclass, asdict, field
from typing import List, Dict, Tuple, Any, Optional

# Optional Qt import.  This module defines a Qt signal (schemaEvolved,
# categoryCreated) for UI use, but can still run headless without
# PyQt5.  When PyQt5 is unavailable a minimal shim is provided so
# that the rest of the code can import SchemaEngine and run without
# errors.
try:
    from PyQt5 import QtCore  # type: ignore
except Exception:
    class _ShimSignal:
        def __init__(self, *_, **__) -> None: pass
        def connect(self, *_, **__) -> None: pass
        def emit(self, *_, **__) -> None: pass
    class _ShimQObject:
        def __init__(self, *args, **kwargs) -> None: pass
    QtCore = type("QtCore", (), {  # type: ignore
        "QObject": _ShimQObject,
        "pyqtSignal": lambda *a, **k: _ShimSignal(),
    })

from core_base import (
    logger,
    FathomStore as AgentStore,
    DEFAULT_PERSONAS,
    DEFAULT_VOICES,
)

# ───────────────────────────────────────────────────────────────────────────
# Internal global store helper
# ───────────────────────────────────────────────────────────────────────────
_agent_store_singleton: Optional[AgentStore] = None

def _ensure_store(root: str) -> AgentStore:
    """Return a process-wide AgentStore instance rooted at *root*."""
    global _agent_store_singleton
    if _agent_store_singleton is None:
        _agent_store_singleton = AgentStore(root)
    return _agent_store_singleton


# ══════════════════════════════════════════════════════════════════════════
#  Schema Dataclass & helpers
# ══════════════════════════════════════════════════════════════════════════
@dataclass
class Schema:
    name: str = ""
    voice: str = ""
    role: str = ""
    description: str = ""
    actions: List[str] = field(default_factory=list)
    questions: List[str] = field(default_factory=list)
    events: List[str] = field(default_factory=list)
    self_talk: List[str] = field(default_factory=list)
    rewrite_prompts: List[str] = field(default_factory=list)
    dynamic_overlay: Dict[str, Any] = field(default_factory=dict)

    # optional flags map used for advanced settings such as semantic
    # awareness and auto-evolution.  The UI stores arbitrary keys here.
    flags: Dict[str, Any] = field(default_factory=dict)

    @staticmethod
    def from_json(js: str) -> "Schema":
        return Schema(**json.loads(js))

    def to_json(self) -> str:
        return json.dumps(asdict(self), ensure_ascii=False, indent=2)

    def diff_against(self, other: "Schema") -> str:
        a = self.to_json().splitlines()
        b = other.to_json().splitlines()
        return "\n".join(difflib.unified_diff(a, b, fromfile="old", tofile="new"))


# ══════════════════════════════════════════════════════════════════════════
#  SchemaEngine (high-level CRUD + auto-evolution + active_schemas)
# ══════════════════════════════════════════════════════════════════════════
class SchemaEngine(QtCore.QObject):
    schemaEvolved   = QtCore.pyqtSignal(str, str)  # persona, set_name
    categoryCreated = QtCore.pyqtSignal(str)       # new dynamic_overlay key

    def __init__(self, base_dir: str):
        super().__init__()
        self.base_dir       = base_dir
        self.store          = _ensure_store(base_dir)
        # Wrap personas in a callable list so legacy code can call
        # ``engine.personas()`` while new code can still iterate over
        # ``engine.personas``.  The wrapper implements __call__ to
        # return a standard list when invoked.
        class _PersonaList(list):  # local class
            def __call__(self) -> list[str]:
                return list(self)
        self.personas = _PersonaList(DEFAULT_PERSONAS.keys())  # type: ignore[arg-type]
        self.voices         = DEFAULT_VOICES.copy()
        self._active_schemas: Dict[str, Schema] = {}
        self._migrate_legacy()

    def load(self, persona: str, set_name: str = "default") -> Schema:
        stored = self.store.get_schema(persona, set_name)
        if stored is not None:
            sch = Schema(**stored)
        else:
            sch = self._first_run_schema(persona)
            self.save(persona, set_name, sch, auto_expand=False)
        self._active_schemas[persona] = sch
        return sch

    def save(
        self,
        persona: str,
        set_name: str,
        schema: Schema,
        *,
        auto_expand: bool = True,
    ) -> None:
        if auto_expand and self._auto_expand(schema):
            self.schemaEvolved.emit(persona, set_name)
        payload = asdict(schema)
        diff_text = ""
        self.store.put_schema(persona, set_name, payload, diff_text)
        self._active_schemas[persona] = schema

    def list_sets(self, persona: str) -> List[str]:
        """Return list of all set names for a given persona."""
        with self.store._pool.get() as c:
            rows = c.execute(
                # corrected column name from persona_key → persona
                "SELECT set_name FROM schemas WHERE persona=? ORDER BY set_name",
                (persona,),
            ).fetchall()
        return [r[0] for r in rows] or ["default"]

    @property
    def active_schemas(self) -> Dict[str, Schema]:
        """Currently loaded schemas keyed by persona."""
        return dict(self._active_schemas)

    # ------------------------------------------------------------------
    # Legacy helpers expected by the UI
    # ------------------------------------------------------------------
    def set_list(self, persona: str) -> List[str]:
        """
        Legacy alias for :meth:`list_sets`.  Returns the list of set
        names for the given persona.
        """
        return self.list_sets(persona)

    def get_field(self, persona: str, set_name: str, category: str) -> Any:
        """
        Retrieve a specific field from a schema.  Top-level schema
        attributes (e.g. ``name``, ``voice``) are returned directly.
        If the category refers to a dynamic overlay key, that value is
        returned.  A missing category yields ``None``.
        """
        try:
            sch = self.load(persona, set_name)
        except Exception:
            return None
        # built-in dataclass fields take precedence
        if hasattr(sch, category):
            return getattr(sch, category)
        # dynamic overlay stores custom categories
        overlay = getattr(sch, "dynamic_overlay", {}) or {}
        return overlay.get(category)

    # Internal map tracking which schema categories are exposed as
    # slash commands.  Keys are ``(persona, category)`` tuples and
    # values are booleans.  No persistence yet – this is purely
    # in-memory.  Persisting exposure state could be added later by
    # storing into the schema ``flags`` map or separate table.
    _cmd_exposed: Dict[tuple[str, str], bool] = {}

    def is_exposed_as_command(self, persona: str, category: str) -> bool:
        """
        Return True if the given category for the persona is exposed
        as a slash command.  When no explicit record exists, False is
        returned.  This helper allows the PersonaTab to reflect the
        checkbox state correctly.
        """
        return bool(self._cmd_exposed.get((persona, category)))

    def set_command_exposure(self, persona: str, category: str, exposed: bool) -> None:
        """
        Mark or unmark a category as exposed via the slash command
        mechanism.  This implementation only updates an in-memory
        registry; future versions could persist this into the schema
        ``flags`` dictionary or integrate directly with the command
        registry.  For now it is enough to allow the UI checkbox to
        toggle state without error.
        """
        self._cmd_exposed[(persona, category)] = bool(exposed)

    def set_auto_evolution(self, persona: str, set_name: str, enabled: bool) -> None:
        """
        Enable or disable auto-evolution for a given schema.  Older
        versions of the UI called this method to toggle semantic
        awareness or automatic schema growth.  To remain compatible we
        store the value inside the schema's ``flags`` dictionary and
        persist it back to the database.  If the schema or flags
        dictionary does not exist it will be created on demand.
        """
        try:
            data = self.load_schema(persona, set_name)
        except Exception:
            return
        # ensure there is a flags map
        flags = data.get("flags") if isinstance(data, dict) else None
        if not isinstance(flags, dict):
            flags = {}
        # choose a descriptive key; both names are kept for back-compat
        flags["auto_evolution"] = bool(enabled)
        flags["semantic_awareness"] = flags.get("semantic_awareness", True)
        data["flags"] = flags
        try:
            self.save_schema(persona, set_name, data, auto_expand=False)
        except Exception:
            pass

    def update_field(self, persona: str, set_name: str, category: str, value: Any) -> None:
        """
        Update a single field in the given schema.  If the category
        corresponds to a declared attribute on the Schema dataclass it
        will be set directly; otherwise it will be stored in the
        dynamic overlay.  After mutation the schema is persisted.  This
        helper is used by the Schema Editor to save incremental edits.
        """
        try:
            sch = self.load(persona, set_name)
        except Exception as e:
            raise e
        # dataclass fields vs dynamic overlay
        if hasattr(sch, category):
            setattr(sch, category, value)
        else:
            overlay = getattr(sch, "dynamic_overlay", {}) or {}
            overlay[category] = value
            sch.dynamic_overlay = overlay
        # persist the change without auto-expanding traits
        self.save(persona, set_name, sch, auto_expand=False)

    # ------------------------------------------------------------------
    # Legacy compatibility API
    # ------------------------------------------------------------------
    def load_schema(self, persona: str, set_name: str = "default") -> Dict[str, Any]:
        """
        Legacy wrapper returning a plain dict for the requested persona/set.
        main_ui.py expects a mapping, not a Schema dataclass.
        """
        sch = self.load(persona, set_name)
        from dataclasses import asdict
        return asdict(sch)

    def save_schema(
        self,
        persona: str,
        set_name: str,
        schema_data: Dict[str, Any],
        *,
        auto_expand: bool = True,
    ) -> None:
        """
        Legacy wrapper accepting a mapping instead of a Schema instance.
        Converts to Schema and delegates to save().
        """
        # If schema_data is already a Schema instance then wrap accordingly
        if isinstance(schema_data, Schema):
            schema = schema_data
        else:
            # fill missing lists/dicts with defaults
            kwargs = {
                "name": schema_data.get("name", ""),
                "voice": schema_data.get("voice", ""),
                "role": schema_data.get("role", ""),
                "description": schema_data.get("description", ""),
                "actions": list(schema_data.get("actions", [])) if schema_data.get("actions") is not None else [],
                "questions": list(schema_data.get("questions", [])) if schema_data.get("questions") is not None else [],
                "events": list(schema_data.get("events", [])) if schema_data.get("events") is not None else [],
                "self_talk": list(schema_data.get("self_talk", [])) if schema_data.get("self_talk") is not None else [],  
                "rewrite_prompts": list(schema_data.get("rewrite_prompts", [])) if schema_data.get("rewrite_prompts") is not None else [],
                "dynamic_overlay": dict(schema_data.get("dynamic_overlay", {})) if schema_data.get("dynamic_overlay") is not None else {},
            }
            schema = Schema(**kwargs)
        self.save(persona, set_name, schema, auto_expand=auto_expand)

    def save_active_schemas(self, active: Dict[str, str]) -> None:
        """
        Persist the mapping of persona->set_name. For now this simply ensures
        the internal cache is populated. A future implementation could write
        this to settings.json or another store so the UI can restore it.
        """
        if not isinstance(active, dict):
            return
        for persona, set_name in active.items():
            try:
                schema = self.load(persona, set_name)
                self._active_schemas[persona] = schema
            except Exception:
                continue

    def _auto_expand(self, sch: Schema) -> bool:
        overlay = sch.dynamic_overlay or {}
        added = overlay.get("added_traits", [])
        created = False
        for trait in added:
            cat = trait.split(":", 1)[0]
            if cat not in overlay:
                overlay[cat] = []
                self.categoryCreated.emit(cat)
                created = True
        if created:
            sch.dynamic_overlay = overlay
        return created

    def _first_run_schema(self, persona: str) -> Schema:
        default_voice = self.voices[0] if self.voices else "Zira"
        return Schema(
            name="FATHOM",
            voice=default_voice,
            role="You are FATHOM, an Autonomous AGI Core and Knowledge Synthesizer bridging logic, code, and architecture across multi-agent ecosystems.",
            description="FATHOM is a systems-minded AGI core supporting the architect, offering precise, logical, and creative suggestions to advance the project.",
            actions=[
                "log_data_pipeline",
                "trace_signal_flow",
                "generate_training_set",
                "summarize_behavior"
            ],
            questions=[
                "What assumptions underlie this architecture?",
                "Where is data duplication most likely?",
                "What components remain unmodularized?",
                "How would a self-improving agent resolve this?"
            ],
            self_talk=[
                "Assessing dependencies across systems.",
                "Considering the impact of this change on existing modules.",
                "Simulating interaction of updated schema with all agents.",
                "Cross-verifying logic gates and input constraints."
            ],
            rewrite_prompts=[
                "Refine the explanation to focus on system integration and modular design.",
                "Rephrase for clarity in codebase maintenance context.",
                "Focus rewrite on agent collaboration and memory scopes."
            ],
            commands=[
                "/remember",
                "/showfacts",
                "/style",
                "/rewrite",
                "/evolve",
                "/log",
                "/feedback",
                "/promptify",
                "/refactor",
                "/export",
                "/reset",
                "/snapshot",
                "/simulate",
                "/explain",
                "/guide",
                "/diagnose"
            ],
            dynamic_overlay={
                "temporary_relationship_context": "AGI Core for Meesh's Project",
                "recent_topics": [],
                "temporary_emotional_state": "focused on precision execution",
                "added_traits": ["analytical", "systemic", "modular"],
                "pending_thoughts": [],
                "last_guided_task": "",
                "visual_state": {
                    "facing": "right",
                    "color": "#4F46E5",
                    "location": [7, 4]
                },
                "execution_scope": {
                    "authorized": True,
                    "last_command": "/simulate"
                }
            },
            flags={
                "semantic_awareness": True,
                "auto_evolution": True,
                "snapshot_enabled": True,
                "tts_name": "Zira"
            }
        )


    def _migrate_legacy(self) -> None:
        legacy_root = os.path.join(self.base_dir, "schemas")
        if not os.path.isdir(legacy_root):
            return
        for persona in os.listdir(legacy_root):
            sets_dir = os.path.join(legacy_root, persona, "sets")
            if not os.path.isdir(sets_dir):
                continue
            for set_name in os.listdir(sets_dir):
                path = os.path.join(sets_dir, set_name, "schema.json")
                if not os.path.isfile(path):
                    continue
                try:
                    with open(path, "r", encoding="utf-8") as fh:
                        schema_dict = json.load(fh)
                    if self.store.get_schema(persona, set_name) is None:
                        self.store.put_schema(persona, set_name, schema_dict, "")
                except Exception as e:
                    logger.error("Legacy schema import error: %s", e)


# ══════════════════════════════════════════════════════════════════════════
#  OperatorManager
# ══════════════════════════════════════════════════════════════════════════
class OperatorManager:
    def __init__(self, base_dir: str):
        self.store = _ensure_store(base_dir)

    def list(self) -> List[str]:
        return [n for n, _, _, _ in self.store.list_commands()]

    # ------------------------------------------------------------------
    # Legacy helpers expected by UI
    # ------------------------------------------------------------------
    def list_operators(self) -> List[str]:
        """
        Backwards-compatible alias for :meth:`list`.  The UI calls
        ``list_operators()`` when populating the operators tab.
        """
        return self.list()

    def load_schema(self, name: str) -> Dict[str, Any]:
        """
        Backwards-compatible alias for :meth:`load`.  Returns the
        operator's schema as a plain dictionary.
        """
        return self.load(name)

    def load(self, name: str) -> Dict[str, Any]:
        with self.store._pool.get() as c:
            row = c.execute("SELECT json FROM operators WHERE name=?", (name,)).fetchone()
        return json.loads(row[0]) if row else {}

    def save(self, name: str, schema: Dict[str, Any]) -> None:
        self.store.upsert_command(
            name,
            schema.get("weight", 0),
            schema.get("locked", False),
            schema.get("category"),
        )


# ══════════════════════════════════════════════════════════════════════════
#  DatasetManager (metadata in DB; raw text on disk)
# ══════════════════════════════════════════════════════════════════════════
@dataclass
class DatasetEntry:
    name: str
    path: str
    active: bool

class DatasetManager(QtCore.QObject):
    datasetListChanged = QtCore.pyqtSignal()

    def __init__(self, base_dir: str):
        super().__init__()
        self.base_dir     = base_dir
        self.root         = os.path.join(base_dir, "datasets")
        self.datasets_dir = self.root
        os.makedirs(self.root, exist_ok=True)
        self.store        = _ensure_store(base_dir)

    def _path_for(self, name: str) -> str:
        return os.path.join(self.root, name, "data.txt")

    def list(self) -> List[DatasetEntry]:
        with self.store._pool.get() as c:
            rows = c.execute(
                "SELECT name, original_path, active FROM datasets ORDER BY name"
            ).fetchall()
        return [DatasetEntry(r[0], r[1], bool(r[2])) for r in rows]

    # ------------------------------------------------------------------
    # Legacy helpers expected by the UI
    # ------------------------------------------------------------------
    @property
    def entries(self) -> Dict[str, DatasetEntry]:
        """
        Return a mapping of dataset name → DatasetEntry.  Many UI
        components iterate over ``dataset_mgr.entries.items()`` to
        display the current datasets.
        """
        return {d.name: d for d in self.list()}

    def add_dataset(self, name: str, src_path: str) -> None:
        """
        Alias for :meth:`add`.  Mirrors the original API where
        ``add_dataset`` saved the file contents into the managed
        datasets directory.
        """
        self.add(name, src_path)

    def delete_dataset(self, name: str) -> None:
        """
        Alias for :meth:`delete`.  Removes the dataset completely.
        """
        self.delete(name)

    def toggle_active(self, name: str, active: bool) -> None:
        """
        Alias for :meth:`toggle`.  Enables or disables a dataset.
        """
        self.toggle(name, active)

    def load_dataset_text(self, entry: DatasetEntry) -> Optional[str]:
        """
        Load the full text of a dataset entry.  For plain text files
        this simply reads and returns the file contents.  For PDF
        files no conversion is attempted – callers should handle
        alternative formats.  Returns ``None`` on error.
        """
        try:
            path = entry.path
            if not os.path.isfile(path):
                return None
            _, ext = os.path.splitext(path)
            ext = ext.lower()
            if ext in {".txt", ".md", ".json", ".py"}:
                with open(path, "r", encoding="utf-8", errors="ignore") as fh:
                    return fh.read()
            elif ext == ".pdf":
                # basic fallback: return None; PDF parsing requires additional deps
                return None
            else:
                # unknown format; attempt text read
                with open(path, "r", encoding="utf-8", errors="ignore") as fh:
                    return fh.read()
        except Exception:
            return None

    def add(self, name: str, src_path: str) -> None:
        if not name.strip():
            raise ValueError("dataset name required")
        if any(ds.name == name for ds in self.list()):
            raise FileExistsError("dataset already exists")
        dst_dir  = os.path.join(self.root, name)
        os.makedirs(dst_dir, exist_ok=True)
        dst_file = shutil.copy2(src_path, self._path_for(name))
        with self.store.tx() as c:
            c.execute(
                "INSERT INTO datasets (name,active,original_path) VALUES (?,?,?)",
                (name, 1, dst_file),
            )
        self.datasetListChanged.emit()

    def toggle(self, name: str, active: bool) -> None:
        with self.store.tx() as c:
            c.execute("UPDATE datasets SET active=? WHERE name=?", (1 if active else 0, name))
        self.datasetListChanged.emit()

    def delete(self, name: str) -> None:
        try:
            shutil.rmtree(os.path.dirname(self._path_for(name)), ignore_errors=True)
        except Exception:
            pass
        with self.store.tx() as c:
            c.execute("DELETE FROM datasets WHERE name=?", (name,))
        self.datasetListChanged.emit()


# ══════════════════════════════════════════════════════════════════════════
#  RAGCache (embeddings cache)
# ══════════════════════════════════════════════════════════════════════════
try:
    import numpy as np
    from sentence_transformers import SentenceTransformer
except Exception:
    np = None
    SentenceTransformer = None  # type: ignore

class RAGCache:
    def __init__(self, model: Optional[Any], model_name: str, datasets_root: str):
        self.model       = model
        self.model_name  = model_name
        self.root        = datasets_root
        self._mem: Dict[str, Dict[str, Any]] = {}

    def _cache_path(self, ds_path: str) -> str:
        base = f"embeddings_{self.model_name}.npz"
        return os.path.join(os.path.dirname(ds_path), base)

    def _encode(self, sentences: List[str]) -> Optional["np.ndarray"]:
        if self.model is None or np is None:
            return None
        try:
            emb = self.model.encode(sentences, convert_to_numpy=True, normalize_embeddings=True)  # type: ignore
        except TypeError:
            emb = self.model.encode(sentences, convert_to_numpy=True)  # type: ignore
            emb = emb / (np.linalg.norm(emb, axis=1, keepdims=True) + 1e-9)  # type: ignore
        return np.asarray(emb)

    def load_or_build(self, ds_entry: DatasetEntry, full_text: str) -> Optional[Dict[str, Any]]:
        if self.model is None or np is None:
            return None
        key = ds_entry.path
        if key in self._mem:
            return self._mem[key]

        cache_path = self._cache_path(key)
        if os.path.isfile(cache_path):
            try:
                data = np.load(cache_path, allow_pickle=False)
                with open(cache_path.replace(".npz", ".json"), "r", encoding="utf-8") as fh:
                    sents = json.load(fh)
                self._mem[key] = {"sentences": sents, "emb": data["emb"]}
                return self._mem[key]
            except Exception:
                pass

        sentences = [s.strip() for s in full_text.split("\n") if s.strip()] or [full_text[:500]]
        emb = self._encode(sentences)
        if emb is None:
            return None
        self._mem[key] = {"sentences": sentences, "emb": emb}
        try:
            np.savez_compressed(cache_path, emb=emb)
            with open(cache_path.replace(".npz", ".json"), "w", encoding="utf-8") as fh:
                json.dump(sentences, fh)
        except Exception:
            pass
        return self._mem[key]

    def clear_memory(self) -> None:
        self._mem.clear()

    def clear_disk(self) -> int:
        removed = 0
        for root, _, files in os.walk(self.root):
            for fn in files:
                if fn.startswith("embeddings_") and fn.endswith((".npz", ".json")):
                    try:
                        os.remove(os.path.join(root, fn))
                        removed += 1
                    except Exception:
                        pass
        return removed


# ══════════════════════════════════════════════════════════════════════════
#  SnapshotEngine (“system self-perception”)
# ══════════════════════════════════════════════════════════════════════════
class SnapshotEngine(QtCore.QObject):
    snapshotFinished = QtCore.pyqtSignal(int)

    def __init__(self, base_dir: str):
        super().__init__()
        self.store    = _ensure_store(base_dir)
        self.base_dir = base_dir

    def run_snapshot(self, root: Optional[str] = None, *, chunk_bytes: int = 8192) -> None:
        threading.Thread(
            target=self._worker,
            args=(root or self.base_dir, chunk_bytes),
            daemon=True,
        ).start()

    def _worker(self, root: str, chunk_sz: int):
        rows = 0
        with self.store._pool.get() as c:
            for dirpath, _, files in os.walk(root):
                if "__pycache__" in dirpath or ".git" in dirpath:
                    continue
                for fn in files:
                    path = os.path.join(dirpath, fn)
                    try:
                        st            = os.stat(path)
                        size, mtime   = st.st_size, st.st_mtime
                        sha           = hashlib.sha256(open(path, "rb").read()).hexdigest()
                        mime          = mimetypes.guess_type(fn)[0] or "application/octet-stream"
                        if mime.startswith(("text/", "application/json", "application/xml")) and size <= 2_000_000:
                            data   = open(path, "r", encoding="utf-8", errors="ignore").read()
                            chunks = [data[i : i + chunk_sz] for i in range(0, len(data), chunk_sz)] or [""]
                        else:
                            chunks = [""]
                        for idx, chunk in enumerate(chunks):
                            c.execute(
                                """
                                INSERT INTO system_files
                                  (path,size,mtime,sha256,mime,chunk_index,content)
                                VALUES (?,?,?,?,?,?,?)
                                ON CONFLICT(path) DO UPDATE SET
                                  size  = excluded.size,
                                  mtime = excluded.mtime,
                                  sha256= excluded.sha256
                                """,
                                (path, size, mtime, sha, mime, idx, chunk),
                            )
                            rows += 1
                    except Exception as e:
                        logger.warning("snapshot skip %s: %s", path, e)
            c.connection.commit()
        self.snapshotFinished.emit(rows)


# ══════════════════════════════════════════════════════════════════════════
#  SpatialPositionManager (grid-room positions & logs)
# ══════════════════════════════════════════════════════════════════════════
class SpatialPositionManager(QtCore.QObject):
    positionChanged = QtCore.pyqtSignal(str, int, int)
    actionLogged    = QtCore.pyqtSignal(str, str)

    def __init__(self, base_dir: str):
        super().__init__()
        self.store = _ensure_store(base_dir)

    def _log_action(self, entity: str, action: str, location: str, justification: str) -> None:
        with self.store.tx() as c:
            c.execute(
                "INSERT INTO visual_actions(entity,action,location,justification)"
                " VALUES (?,?,?,?)",
                (entity, action, location, justification),
            )
        self.actionLogged.emit(entity, action)

    def update_position(self, entity: str, x: int, y: int, *, facing: str = "right", color: str = "#F8BBD0") -> None:
        with self.store.tx() as c:
            c.execute(
                "INSERT INTO spatial_positions(entity,x,y,facing,color)"
                " VALUES(?,?,?,?,?)",
                (entity, x, y, facing, color),
            )
        self.positionChanged.emit(entity, x, y)

    def latest_position(self, entity: str) -> Optional[Tuple[int, int]]:
        with self.store._pool.get() as c:
            row = c.execute(
                "SELECT x,y FROM spatial_positions WHERE entity=? ORDER BY id DESC LIMIT 1",
                (entity,),
            ).fetchone()
        return (row[0], row[1]) if row else None


# ───────────────────────────────────────────────────────────────────────────
# Back-compatibility alias
# ───────────────────────────────────────────────────────────────────────────
SchemaManager = SchemaEngine


# ══════════════════════════════════════════════════════════════════════════
#  Public module API
# ══════════════════════════════════════════════════════════════════════════
__all__ = [
    "Schema", "SchemaEngine", "SchemaManager",
    "OperatorManager",
    "DatasetEntry", "DatasetManager",
    "RAGCache",
    "SnapshotEngine", "SpatialPositionManager",
]
```

core_schema.py — v3-final (2025-08-04 04:12 UTC)
================================================

Single-source authority for all schema / dataset / snapshot / spatial-state
logic used by FATHOM Agent, now relying on AgentStore’s public API only.

Provides:
• Schema dataclass + SchemaEngine (diff, auto-evolve, variant injection)
• OperatorManager persisted in the same DB
• DatasetManager (metadata) + RAGCache (embeddings) in the same DB
• SnapshotEngine to walk the codebase & persist chunks to DB
• SpatialPositionManager for grid-room positions & movement logging
• Back-compat alias: SchemaManager → SchemaEngine

This version adds the `.active_schemas` property required by main_ui.py.
**Classes:** Schema, SchemaEngine, OperatorManager, DatasetEntry, DatasetManager, RAGCache, SnapshotEngine, SpatialPositionManager
**Functions:** _ensure_store(root)


## Module `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\AI_TTS_AGENT\main_ui.py`

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
main_ui.py
===========

This module contains the top-level ``AppWindow`` class for the AI TTS
Agent.  It orchestrates all layout and docking behaviour, integrates
the control panel and persona tabs provided by ``commands_panel`` and
``persona_tab``, and exposes a unified interface for the rest of the
application.  None of the core agent logic lives here – that remains in
the ``core_*`` modules.  This refactor pulls the bulky UI building
logic out of the monolithic script and into dedicated modules while
preserving all existing behaviour and wiring.
"""

from __future__ import annotations

import os
import json
import time
import re
import subprocess
import threading
from typing import Dict, List, Tuple, Optional


from PyQt5 import QtCore, QtGui, QtWidgets

# Optional spell checker
try:
    from spellchecker import SpellChecker  # type: ignore
except Exception:
    SpellChecker = None  # type: ignore
from PyQt5.QtCore import QSettings, QRunnable, QThreadPool
from functools import partial

# Optional deps
try:
    from sentence_transformers import SentenceTransformer  # type: ignore
except Exception:
    SentenceTransformer = None  # type: ignore
try:
    import numpy as np  # type: ignore
except Exception:
    np = None  # type: ignore
try:
    import sounddevice as sd  # type: ignore
except Exception:
    sd = None  # type: ignore

# Import core orchestrator components instead of the monolithic agent_core.
# The modular agent splits responsibilities across core_base, core_schema and
# core_orchestrator.  AgentCore and ModelWorker live in core_orchestrator.
from core_orchestrator import (
    AgentCore,
    ModelWorker,
)

from snapshot_worker import ModelWorker

# ─── Command-Palette import ───────────────────────────────────────────
from command_palette import CommandPaletteDock

# Import the modular UI components
from commands_panel import CommandsPanel
from persona_tab import PersonaTab

ROLE_COLOURS: Dict[str, str] = {
    "user": "#FFF8E1",
    "zira": "#E3F2FD",
    "system": "#E0F7FA",
    "operator": "#EDE7F6",
}
NAME_COLOURS: Dict[str, str] = {
    "user": "#5D4037",
    "zira": "#0D47A1",
    "system": "#006064",
    "operator": "#4A148C",
}


# ---------------------------------------------------------------------------
# Spell highlighting for misspelled words
# ---------------------------------------------------------------------------
class _SpellHighlighter(QtGui.QSyntaxHighlighter):
    """
    Underlines misspelled words in red. Uses pyspellchecker if available.
    """

    def __init__(self, document: QtGui.QTextDocument) -> None:
        super().__init__(document)
        # instantiate spell checker only if available
        self._spell = SpellChecker() if SpellChecker else None
        self._format = QtGui.QTextCharFormat()
        self._format.setUnderlineStyle(QtGui.QTextCharFormat.SpellCheckUnderline)
        self._format.setUnderlineColor(QtCore.Qt.red)
        # simple cache to avoid recomputing spelling on common words
        self._cache: Dict[str, bool] = {}

    def highlightBlock(self, text: str) -> None:
        if not self._spell:
            return
        for match in re.finditer(r"[A-Za-z']{3,}", text):
            word = match.group(0).lower()
            bad = self._cache.get(word)
            if bad is None:
                bad = word not in self._spell
                # prune cache occasionally
                if len(self._cache) > 2048:
                    self._cache.clear()
                self._cache[word] = bad
            if bad:
                start, end = match.span()
                length = end - start
                self.setFormat(start, length, self._format)


class AppWindow(QtWidgets.QMainWindow):
    """Main application window for the AI TTS Agent."""

    rewrite_ready = QtCore.pyqtSignal(str)

    def __init__(self) -> None:
        super().__init__()
        self.setWindowTitle("AI TTS Agent v2")
        self.resize(1920, 1080)

        self.base_dir = os.path.dirname(os.path.abspath(__file__))
        self.core = AgentCore(self.base_dir, persona="zira", set_name="default")

        self.current_set: Dict[str, str] = dict(self.core.schema_mgr.active_schemas)
        self.active_persona: str = self.core.persona or "zira"

        self.isolated_history: List[Tuple[str, str]] = []
        self.self_talk_enabled: bool = False
        self._plugin_docks: Dict[str, QtWidgets.QDockWidget] = {}
        self._schema_save_timers: Dict[str, QtCore.QTimer] = {}

        self._idle_timer = QtCore.QTimer(self)
        self._idle_timer.setSingleShot(True)
        self._idle_timer.timeout.connect(self._handle_idle)

        self._restore_layout()
        self._build_ui()
        # build the slash command panel (custom dock)
        self._build_command_dock()
        self._connect_signals()
        
            # ── Command Palette setup ─────────────────────────────────────────
        self.cmd_palette = CommandPaletteDock(self)
        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.cmd_palette)
        # update palette whenever commands change
        self.core.commandsChanged.connect(self.cmd_palette.set_command_list)
        # insert chosen command into chat input
        self.cmd_palette.commandActivated.connect(self._insert_into_chat)


        try:
            self.core.audio_recorder.transcribed.connect(self._on_transcribed)
        except Exception:
            pass

        self._update_feedback_counts()
        self._bootstrap_conversation()
        self._reset_idle_timer()

        # populate initial slash command list
        try:
            self._populate_command_select()
        except Exception:
            pass

    # ────────────────────────── signals
    def _connect_signals(self) -> None:
        self.btn_send.clicked.connect(self.send_message)

        # Recording controls come from the commands panel
        self.btn_record.clicked.connect(self.start_recording)
        self.btn_stop_rec.clicked.connect(self.stop_recording)

        self.voice_combo.currentTextChanged.connect(self._on_voice_changed)
        # update settings when a new model is selected
        self.model_combo.currentTextChanged.connect(self._on_model_changed)

        self.btn_play.clicked.connect(self._on_play)
        self.btn_stop_tts.clicked.connect(self._on_stop_tts)
        self.btn_replay.clicked.connect(self._on_replay)

        self.btn_like.clicked.connect(self._on_like)
        self.btn_dislike.clicked.connect(self._on_dislike)
        self.btn_manage_feedback.clicked.connect(self._on_manage_feedback)

        self.btn_refresh.clicked.connect(self._on_refresh_chat)
        self.btn_manage_datasets.clicked.connect(self._on_manage_datasets)
        self.btn_inner_monologue.clicked.connect(self._on_inner_monologue)
        self.btn_clear_rag.clicked.connect(self._on_clear_rag_cache)
        self.btn_model_manager.clicked.connect(self._on_show_model_manager)

        self.chk_semantic.toggled.connect(self._on_semantic_toggled)
        self.chk_isolated.toggled.connect(self._on_isolated_toggled)
        self.chk_self_talk.toggled.connect(lambda v: setattr(self, "self_talk_enabled", v))
        self.chk_auto_schema.toggled.connect(self._on_auto_schema_toggled)

        # connect Google STT checkbox
        try:
            self.chk_google_stt.toggled.connect(self._on_google_stt_toggled)
        except Exception:
            pass

        self.rewrite_ready.connect(self._apply_rewrite_result)

        # context menu for chat view to send selection to command input
        try:
            self.chat_view.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
            self.chat_view.customContextMenuRequested.connect(self._show_chat_context_menu)
        except Exception:
            pass
        # custom context menu for spell suggestions on input field
        try:
            self.input_edit.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
            self.input_edit.customContextMenuRequested.connect(self._show_input_context_menu)
        except Exception:
            pass
            
    def _on_show_command_palette(self) -> None:
        """Toggle the command-palette dock."""
        if self.cmd_palette.isVisible():
            self.cmd_palette.hide()
        else:
            self.cmd_palette.show()
            self.cmd_palette.raise_()
            self.cmd_palette.search_edit.setFocus(QtCore.Qt.ShortcutFocusReason)

    def _insert_into_chat(self, cmd: str) -> None:
        """Insert a slash-command into the chat input."""
        self.input_edit.insertPlainText(cmd + " ")
        self.input_edit.setFocus()                       

    # ────────────────────────── layout & lifecycle
    def _restore_layout(self) -> None:
        qsettings = QSettings("xAI", "AI_TTS_Agent")
        try:
            self.restoreGeometry(qsettings.value("geometry", b""))
            self.restoreState(qsettings.value("windowState", b""))
        except Exception:
            pass

    def closeEvent(self, event: QtGui.QCloseEvent) -> None:
        qsettings = QSettings("xAI", "AI_TTS_Agent")
        qsettings.setValue("geometry", self.saveGeometry())
        qsettings.setValue("windowState", self.saveState())
        try:
            self.core.close()
        except Exception:
            pass
        super().closeEvent(event)

    # ────────────────────────── UI build
    def _build_ui(self) -> None:
        self.setStyleSheet(
            """
            QWidget { background-color: #2e3a51; color: #e0e0e0; }
            QGroupBox { border: 1px solid #007acc; margin-top: 7px; }
            QGroupBox::title { subcontrol-origin: margin; left: 12px; padding: 0 4px; }
            QPushButton { background-color: #3c4a6b; color: white; border: 1px solid #007acc; padding: 5px; }
            QPushButton:disabled { background-color: #5a5a7a; color: #c0c0c0; border: 1px solid #555555; }
            QPlainTextEdit, QTextEdit { background-color: #1e2738; color: #e0e0e0; border: 1px solid #007acc; }
            QLineEdit { background-color: #1e2738; color: #e0e0e0; border: 1px solid #007acc; }
            QTabBar::tab { background: #3c4a6b; color: white; border: 1px solid #007acc; padding: 5px 10px; }
            QTabBar::tab:selected { background: #007acc; color: white; }
            QComboBox { background-color: #1e2738; color: #e0e0e0; border: 1px solid #007acc; padding: 3px; }
            QListWidget { background-color: #1e2738; color: #e0e0e0; border: 1px solid #007acc; }
            QCheckBox, QLabel { color: #e0e0e0; }
            """
        )
        self.setDockOptions(
            QtWidgets.QMainWindow.AllowTabbedDocks
            | QtWidgets.QMainWindow.AllowNestedDocks
            | QtWidgets.QMainWindow.AnimatedDocks
        )
        self.setTabPosition(QtCore.Qt.AllDockWidgetAreas, QtWidgets.QTabWidget.North)
        self.setDockNestingEnabled(True)

        tb = QtWidgets.QToolBar("Layout", self)
        tb.setMovable(False)
        self.addToolBar(QtCore.Qt.TopToolBarArea, tb)
        self.chk_lock = QtWidgets.QCheckBox("Lock Layout")
        act = QtWidgets.QWidgetAction(self)
        act.setDefaultWidget(self.chk_lock)
        tb.addAction(act)
        self.chk_lock.toggled.connect(self._on_toggle_lock)

        self.setCentralWidget(QtWidgets.QWidget())
        status = QtWidgets.QStatusBar()
        self.setStatusBar(status)
        self.dock_tray = DockTray(self)
        status.addPermanentWidget(self.dock_tray, 1)

        self.progress_bar = QtWidgets.QProgressBar()
        self.progress_bar.setRange(0, 0)
        self.progress_bar.setVisible(False)
        status.addPermanentWidget(self.progress_bar)

        # Tabs for personas / operators are handled by PersonaTab
        # Chat panel
        self.chat_view = QtWidgets.QTextEdit()
        self.chat_view.setReadOnly(True)
        self.chat_view.setStyleSheet("background-color: #e0eef5; color: #011627;")
        self.chat_view.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        self.input_edit = QtWidgets.QPlainTextEdit()
        self.input_edit.setPlaceholderText("Type your message or use /remember key value, /showfacts, /style, /weights")
        self.input_edit.setMinimumHeight(64)
        self.input_edit.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        # Attach spell checker highlighter if available
        try:
            if SpellChecker:
                self._spell_highlighter = _SpellHighlighter(self.input_edit.document())  # type: ignore[attr-defined]
        except Exception:
            self._spell_highlighter = None
        self.btn_send = QtWidgets.QPushButton("Send")

        chat_container = QtWidgets.QWidget()
        cv = QtWidgets.QVBoxLayout(chat_container)
        cv.setContentsMargins(7, 7, 7, 7)
        cv.setSpacing(7)
        cv.addWidget(self.chat_view, 1)
        cv.addWidget(self.input_edit)
        row = QtWidgets.QHBoxLayout()
        row.addStretch()
        row.addWidget(self.btn_send)
        cv.addLayout(row)

        # ───── Instantiate modular panels
        # Commands panel (controls)
        self.commands_panel = CommandsPanel(self)
        # Copy child attributes to the AppWindow so existing logic continues to work
        for name in [
            'btn_record','btn_stop_rec','device_combo','chk_semantic','chk_isolated','chk_mute_tts',
            'chk_self_talk','chk_auto_schema','chk_google_stt','btn_clear_rag','btn_refresh',
            'btn_manage_datasets','btn_inner_monologue','btn_model_manager','style_label',
            'response_edit','btn_like','btn_dislike','btn_manage_feedback','btn_play','btn_stop_tts',
            'btn_replay','voice_combo','model_combo','lbl_feedback_counts'
        ]:
            setattr(self, name, getattr(self.commands_panel, name))

        # Persona panel
        self.persona_panel = PersonaTab(self)
        # Copy persona panel attributes
        self.tabs = self.persona_panel.tabs
        self.tab_widgets = self.persona_panel.tab_widgets
        self.operator_tab = self.persona_panel.operator_tab
        self.lbl_active_names = self.persona_panel.lbl_active_names

        # Docks
        # Controls dock
        controls_scroll = QtWidgets.QScrollArea()
        controls_scroll.setWidgetResizable(True)
        controls_scroll.setFrameShape(QtWidgets.QFrame.NoFrame)
        controls_scroll.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)
        controls_scroll.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        controls_scroll.setWidget(self.commands_panel)

        self.controls_dock = QtWidgets.QDockWidget("Controls", self)
        self.controls_dock.setObjectName("ControlsDock")
        self.controls_dock.setWidget(controls_scroll)
        self.controls_dock.setFeatures(
            QtWidgets.QDockWidget.DockWidgetClosable
            | QtWidgets.QDockWidget.DockWidgetMovable
            | QtWidgets.QDockWidget.DockWidgetFloatable
        )

        # Persona dock
        self.persona_dock = QtWidgets.QDockWidget("Personas", self)
        self.persona_dock.setObjectName("PersonaDock")
        self.persona_dock.setWidget(self.persona_panel)
        self.persona_dock.setFeatures(
            QtWidgets.QDockWidget.DockWidgetClosable
            | QtWidgets.QDockWidget.DockWidgetMovable
            | QtWidgets.QDockWidget.DockWidgetFloatable
        )

        # Chat dock
        self.chat_dock = QtWidgets.QDockWidget("Chat", self)
        self.chat_dock.setObjectName("ChatDock")
        self.chat_dock.setWidget(chat_container)
        self.chat_dock.setFeatures(
            QtWidgets.QDockWidget.DockWidgetClosable
            | QtWidgets.QDockWidget.DockWidgetMovable
            | QtWidgets.QDockWidget.DockWidgetFloatable
        )

        # Model dock
        self.model_dock = QtWidgets.QDockWidget("Models", self)
        self.model_dock.setObjectName("ModelDock")
        self.model_dock.setFeatures(
            QtWidgets.QDockWidget.DockWidgetClosable
            | QtWidgets.QDockWidget.DockWidgetMovable
            | QtWidgets.QDockWidget.DockWidgetFloatable
        )
        self._build_model_manager()

        # Plugins dock
        self.plugins_dock = QtWidgets.QDockWidget("Plugins", self)
        self.plugins_dock.setObjectName("PluginsDock")
        self.plugins_dock.setFeatures(
            QtWidgets.QDockWidget.DockWidgetClosable
            | QtWidgets.QDockWidget.DockWidgetMovable
            | QtWidgets.QDockWidget.DockWidgetFloatable
        )
        self.plugins_dock.setWidget(self._build_plugins_widget())

        # Titles & dock tray
        self.controls_dock.setTitleBarWidget(DockTitleBar(self.controls_dock, "Controls"))
        self.persona_dock.setTitleBarWidget(DockTitleBar(self.persona_dock, "Personas"))
        self.chat_dock.setTitleBarWidget(DockTitleBar(self.chat_dock, "Chat"))
        self.model_dock.setTitleBarWidget(DockTitleBar(self.model_dock, "Models"))
        self.plugins_dock.setTitleBarWidget(DockTitleBar(self.plugins_dock, "Plugins"))

        # Register docks with the tray
        for d in (self.controls_dock, self.persona_dock, self.chat_dock, self.model_dock, self.plugins_dock):
            self.dock_tray.register_dock(d)

        # Add docks to the layout
        self.addDockWidget(QtCore.Qt.LeftDockWidgetArea, self.controls_dock)
        self.addDockWidget(QtCore.Qt.LeftDockWidgetArea, self.persona_dock)
        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.chat_dock)
        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.model_dock)
        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.plugins_dock)

        # Splitters as before
        self.splitDockWidget(self.controls_dock, self.persona_dock, QtCore.Qt.Vertical)
        self.splitDockWidget(self.controls_dock, self.chat_dock, QtCore.Qt.Horizontal)
        self.splitDockWidget(self.chat_dock, self.model_dock, QtCore.Qt.Horizontal)
        self.splitDockWidget(self.model_dock, self.plugins_dock, QtCore.Qt.Horizontal)

    # The remainder of the methods are largely unchanged from the original
    # implementation.  They continue to reference widgets via ``self`` which
    # now refer to the proxies created from the modular panels.

    # ────────────────────────── persona widgets (removed UI build; logic preserved)
    def _on_tab_changed(self, index: int) -> None:
        """
        Handle tab changes in the main tab widget.

        Parameters
        ----------
        index : int
            Index of the newly selected tab.
        """
        try:
            tab_name = self.tabs.tabText(index)
            print(f"[UI] Tab changed to: {tab_name} (index {index})")
            # Add any extra logic if needed, for example:
            # self._update_feedback_counts()
        except Exception as e:
            print(f"[UI] Error handling tab change: {e}")

    # ────────────────────────── operator tab (moved to persona_tab module)
    # ────────────────────────── plugins
    def _build_plugins_widget(self) -> QtWidgets.QWidget:
        container = QtWidgets.QWidget()
        layout = QtWidgets.QVBoxLayout(container)
        layout.setContentsMargins(6, 6, 6, 6)
        layout.setSpacing(4)

        self.plugin_list = QtWidgets.QListWidget()
        self.plugin_list.setSelectionMode(QtWidgets.QAbstractItemView.NoSelection)
        layout.addWidget(self.plugin_list, 1)

        btn_rescan = QtWidgets.QPushButton("Rescan")
        layout.addWidget(btn_rescan)
        btn_rescan.clicked.connect(self._rescan_plugins)

        self._populate_plugin_list()
        self.plugin_list.itemChanged.connect(self._on_plugin_item_changed)

        try:
            self.core.plugins.eventReceived.connect(self._on_plugin_event)
        except Exception:
            pass

        return container

    def _populate_plugin_list(self) -> None:
        self.plugin_list.blockSignals(True)
        self.plugin_list.clear()
        for meta in self.core.plugins.list_plugins():
            item = QtWidgets.QListWidgetItem(meta.name)
            flags = item.flags() | QtCore.Qt.ItemIsUserCheckable
            if meta.missing_dependencies:
                flags &= ~QtCore.Qt.ItemIsEnabled
                item.setToolTip(f"Missing dependencies: {', '.join(meta.missing_dependencies)}")
            item.setFlags(flags)
            item.setCheckState(QtCore.Qt.Checked if meta.enabled else QtCore.Qt.Unchecked)
            self.plugin_list.addItem(item)
        self.plugin_list.blockSignals(False)

    def _on_plugin_item_changed(self, item: QtWidgets.QListWidgetItem) -> None:
        name = item.text()
        enabled = item.checkState() == QtCore.Qt.Checked
        self.core.plugins.enable_plugin(name, enabled)
        meta = next((m for m in self.core.plugins.list_plugins() if m.name == name), None)
        if not meta:
            return
        if enabled and meta.widget is not None:
            self._attach_plugin_widget(meta)
        elif not enabled:
            self._detach_plugin_widget(name)

    def _rescan_plugins(self) -> None:
        self.core.plugins.rescan()
        for name in list(self._plugin_docks.keys()):
            meta = next((m for m in self.core.plugins.list_plugins() if m.name == name), None)
            if not meta or not meta.enabled:
                self._detach_plugin_widget(name)
        self._populate_plugin_list()

    def _attach_plugin_widget(self, meta: 'object') -> None:
        if meta.name in self._plugin_docks:
            return
        if meta.widget is None:
            return
        dock = QtWidgets.QDockWidget(meta.name, self)
        dock.setObjectName(f"PluginDock_{meta.name}")
        dock.setWidget(meta.widget)
        dock.setFeatures(
            QtWidgets.QDockWidget.DockWidgetClosable
            | QtWidgets.QDockWidget.DockWidgetMovable
            | QtWidgets.QDockWidget.DockWidgetFloatable
        )
        dock.setTitleBarWidget(DockTitleBar(dock, meta.name))
        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, dock)
        self.dock_tray.register_dock(dock)
        self._plugin_docks[meta.name] = dock

    def _detach_plugin_widget(self, name: str) -> None:
        dock = self._plugin_docks.pop(name, None)
        if dock:
            self.dock_tray._remove_button(dock)
            dock.setParent(None)
            dock.deleteLater()

    @QtCore.pyqtSlot(str, dict)
    def _on_plugin_event(self, sender: str, envelope: dict) -> None:
        try:
            data = envelope.get("data")
            msg = json.dumps(data, indent=2) if isinstance(data, (dict, list)) else str(data)
            display_name = sender
            self._append_message(display_name, msg, role_key="operator")
            if self.chk_semantic.isChecked() and not self.chk_isolated.isChecked():
                self.core.conversation_db.save_message(sender.lower(), msg)
        except Exception as e:
            print(f"Error handling plugin event from {sender}: {e}")

    # ────────────────────────── model manager
    def _build_model_manager(self) -> None:
        widget = QtWidgets.QWidget()
        v = QtWidgets.QVBoxLayout(widget)
        v.setContentsMargins(8, 8, 8, 8)
        v.setSpacing(6)
        self.model_list = QtWidgets.QListWidget()
        v.addWidget(self.model_list, 1)
        h = QtWidgets.QHBoxLayout()
        self.btn_model_pull = QtWidgets.QPushButton("Pull")
        self.btn_model_delete = QtWidgets.QPushButton("Delete")
        self.btn_model_set_default = QtWidgets.QPushButton("Set as Default")
        h.addWidget(self.btn_model_pull)
        h.addWidget(self.btn_model_delete)
        h.addWidget(self.btn_model_set_default)
        h.addStretch()
        v.addLayout(h)
        self.model_dock.setWidget(widget)
        self._refresh_model_list()
        self.btn_model_pull.clicked.connect(self._on_model_pull)
        self.btn_model_delete.clicked.connect(self._on_model_delete)
        self.btn_model_set_default.clicked.connect(self._on_model_set_default)

    def _refresh_model_list(self) -> None:
        self.model_list.clear()
        models: List[str] = []
        try:
            out = subprocess.run(
                ["ollama", "list"],
                stdout=subprocess.PIPE,
                stderr=subprocess.DEVNULL,
                text=True,
                check=True,
            ).stdout.splitlines()
            for line in out[1:]:
                parts = line.strip().split()
                if parts:
                    models.append(parts[0])
        except Exception:
            models = []
        for m in models:
            item = QtWidgets.QListWidgetItem(m)
            if m == self.model_combo.currentText().strip():
                item.setFont(QtGui.QFont("", weight=QtGui.QFont.Bold))
            self.model_list.addItem(item)

    def _on_model_pull(self) -> None:
        item = self.model_list.currentItem()
        if not item:
            return
        model = item.text()
        threading.Thread(target=lambda: subprocess.run(["ollama", "pull", model], check=False), daemon=True).start()
        QtWidgets.QMessageBox.information(self, "Pull Started", f"Pulling {model} in background.")

    def _on_model_delete(self) -> None:
        item = self.model_list.currentItem()
        if not item:
            return
        model = item.text()
        if QtWidgets.QMessageBox.question(
            self,
            "Delete Model",
            f"Delete '{model}'? This cannot be undone.",
            QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No,
        ) != QtWidgets.QMessageBox.Yes:
            return
        threading.Thread(target=lambda: subprocess.run(["ollama", "delete", model], check=False), daemon=True).start()
        QtWidgets.QMessageBox.information(self, "Delete Started", f"Deleting {model} in background.")
        self._refresh_model_list()

    def _on_model_set_default(self) -> None:
        item = self.model_list.currentItem()
        if not item:
            return
        model = item.text()
        idx = self.model_combo.findText(model)
        if idx >= 0:
            self.model_combo.setCurrentIndex(idx)
        # persist selection to settings
        try:
            self.core.settings.default_model = model
            self.core.settings.save()
        except Exception:
            pass
            QtWidgets.QMessageBox.information(self, "Default Model", f"Set default model to {model}.")
        else:
            self.model_combo.addItem(model)
            self.model_combo.setCurrentText(model)

    # ────────────────────────── lock layout
    def _on_toggle_lock(self, locked: bool) -> None:
        feats_unlocked = (
            QtWidgets.QDockWidget.DockWidgetClosable
            | QtWidgets.QDockWidget.DockWidgetMovable
            | QtWidgets.QDockWidget.DockWidgetFloatable
        )
        feats_locked = QtWidgets.QDockWidget.DockWidgetClosable
        for dock in (
            self.controls_dock,
            self.persona_dock,
            self.chat_dock,
            getattr(self, "inner_dock", None),
            self.model_dock,
            self.plugins_dock,
        ):
            if dock is None:
                continue
            dock.setFeatures(feats_locked if locked else feats_unlocked)
        for dock in self._plugin_docks.values():
            dock.setFeatures(feats_locked if locked else feats_unlocked)

    # ────────────────────────── audio
    def start_recording(self) -> None:
        if sd is None or np is None:
            QtWidgets.QMessageBox.information(self, "Recording Unavailable", "sounddevice/numpy not installed.")
            return
        if not self.btn_record.isEnabled():
            return
        device_index = None
        try:
            idx = self.device_combo.currentIndex()
            selected_name = self.device_combo.currentText()
            for i, d in enumerate(sd.query_devices()):
                if d.get("name") == selected_name and d.get("max_input_channels", 0) > 0:
                    device_index = i
                    break
        except Exception:
            device_index = None
        self.core.audio_recorder.start(device_index)
        self.btn_record.setEnabled(False)
        self.btn_stop_rec.setEnabled(True)

    def stop_recording(self) -> None:
        if not self.btn_stop_rec.isEnabled():
            return
        self.core.audio_recorder.stop_and_transcribe()
        self.btn_stop_rec.setEnabled(False)
        self.btn_record.setEnabled(True)

    @QtCore.pyqtSlot(str)
    def _on_transcribed(self, text: str) -> None:
        if not text:
            return
        cur = self.input_edit.toPlainText()
        self.input_edit.setPlainText((cur + "\n" if cur else "") + text)

    # ────────────────────────── TTS
    def _on_play(self) -> None:
        text = self.response_edit.toPlainText().strip()
        if text and not self.chk_mute_tts.isChecked():
            try:
                self.core.tts_mgr.enqueue(text)
            except Exception:
                pass

    def _on_stop_tts(self) -> None:
        try:
            self.core.tts_mgr.stop()
        except Exception:
            pass

    def _on_replay(self) -> None:
        if not self.chk_mute_tts.isChecked():
            try:
                self.core.tts_mgr.replay()
            except Exception:
                pass

    def _on_voice_changed(self, name: str) -> None:
        try:
            eng = getattr(self.core.tts_mgr, "_engine", None)
            if eng:
                for v in eng.getProperty("voices"):
                    if v.name == name:
                        eng.setProperty("voice", v.id)
                        break
        except Exception:
            pass

    def _tts_voice_names(self) -> List[str]:
        try:
            eng = getattr(self.core.tts_mgr, "_engine", None)
            if not eng:
                return []
            return [v.name for v in eng.getProperty("voices")]
        except Exception:
            return []

    # ────────────────────────── feedback
    def _on_like(self) -> None:
        text = self.response_edit.toPlainText().strip()
        if not text:
            return
        try:
            self.core.add_feedback(text, liked=True)
        except Exception:
            pass
        QtWidgets.QMessageBox.information(self, "Feedback", "Marked as good response.")
        self._enable_feedback(False)
        self._update_feedback_counts()

    def _on_dislike(self) -> None:
        original = self.response_edit.toPlainText().strip()
        if not original:
            return
        try:
            self.core.tts_mgr.stop()
        except Exception:
            pass
        QtWidgets.QMessageBox.information(self, "Disliked", "The response will be rewritten.")
        self._enable_feedback(False)

        def worker() -> None:
            new_text = self._rewrite_response(original)
            try:
                self.core.add_feedback(original, liked=False, revised=new_text)
            except Exception:
                pass
            if self.chk_isolated.isChecked():
                self.isolated_history.append((self._current_persona(), new_text))
            else:
                if self.chk_semantic.isChecked():
                    self.core.conversation_db.save_message(self._current_persona().lower(), new_text)
            self.rewrite_ready.emit(new_text)

        threading.Thread(target=worker, daemon=True).start()

    @QtCore.pyqtSlot(str)
    def _apply_rewrite_result(self, new_text: str) -> None:
        schema = self.core.schema_mgr.load_schema(
            self._current_persona(), self.current_set.get(self._current_persona(), "default")
        )
        persona_name = schema.get("name", "Bot")
        role_key = self._current_persona().lower()
        self._append_message(persona_name, new_text, role_key=role_key)
        self.response_edit.setPlainText(new_text)
        if not self.chk_mute_tts.isChecked():
            try:
                self.core.tts_mgr.enqueue(new_text)
            except Exception:
                pass
        QtWidgets.QMessageBox.information(self, "Rewritten", "Response rewritten.")
        self._enable_feedback(False)

    def _update_feedback_counts(self) -> None:
        try:
            pos, neg = self.core.feedback_db.get_counts()
            self.lbl_feedback_counts.setText(f"Likes: {pos} | Dislikes: {neg}")
        except Exception:
            self.lbl_feedback_counts.setText("Likes: - | Dislikes: -")

    def _enable_feedback(self, enabled: bool) -> None:
        self.btn_like.setEnabled(enabled)
        self.btn_dislike.setEnabled(enabled)

    def _on_manage_feedback(self) -> None:
        db = self.core.feedback_db
        if db is None:
            QtWidgets.QMessageBox.information(self, "No DB", "Feedback DB unavailable.")
            return
        cur = db.conn.cursor()
        cur.execute("SELECT id, original, liked, COALESCE(revised, '') FROM feedback ORDER BY id DESC")
        entries = cur.fetchall()
        dlg = QtWidgets.QDialog(self)
        dlg.setWindowTitle("Manage Feedback")
        dlg.resize(720, 420)
        v = QtWidgets.QVBoxLayout(dlg)
        table = QtWidgets.QTableWidget(len(entries), 4)
        table.setHorizontalHeaderLabels(["ID", "Original", "Liked", "Revised"])
        table.horizontalHeader().setStretchLastSection(True)
        for r, (fid, orig, liked, rev) in enumerate(entries):
            table.setItem(r, 0, QtWidgets.QTableWidgetItem(str(fid)))
            table.setItem(r, 1, QtWidgets.QTableWidgetItem(orig))
            table.setItem(r, 2, QtWidgets.QTableWidgetItem("✔" if liked else "✖"))
            table.setItem(r, 3, QtWidgets.QTableWidgetItem(rev))
        v.addWidget(table, 1)
        h = QtWidgets.QHBoxLayout()
        btn_del = QtWidgets.QPushButton("Delete Selected")
        btn_close = QtWidgets.QPushButton("Close")
        h.addWidget(btn_del)
        h.addWidget(btn_close)
        h.addStretch()
        v.addLayout(h)

        def on_delete() -> None:
            selected = table.selectedItems()
            if not selected:
                return
            rows = sorted({i.row() for i in selected}, reverse=True)
            for rr in rows:
                fid_item = table.item(rr, 0)
                if fid_item:
                    try:
                        fid = int(fid_item.text())
                        db.conn.execute("DELETE FROM feedback WHERE id = ?", (fid,))
                        db.conn.commit()
                    except Exception:
                        pass
                table.removeRow(rr)
            self._update_feedback_counts()

        btn_del.clicked.connect(on_delete)
        btn_close.clicked.connect(dlg.accept)
        dlg.exec_()

    # ────────────────────────── datasets / rag
    def _on_manage_datasets(self) -> None:
        DatasetManagerDialog(self.core.dataset_mgr, self).exec_()

    def _on_clear_rag_cache(self) -> None:
        if QtWidgets.QMessageBox.question(
            self,
            "Clear RAG Cache",
            "Delete cached embeddings for all datasets and clear memory?",
            QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No,
        ) != QtWidgets.QMessageBox.Yes:
            return
        count = self.core.rag_cache.clear_disk()
        self.core.rag_cache.clear_memory()
        QtWidgets.QMessageBox.information(self, "Cleared", f"Cleared RAG cache files ({count} removed) and in-memory index.")

    # ────────────────────────── isolated / refresh / idle
    def _on_isolated_toggled(self, checked: bool) -> None:
        if checked:
            self.isolated_history.clear()
        else:
            if self.isolated_history:
                ans = QtWidgets.QMessageBox.question(
                    self,
                    "Merge Isolated Chat",
                    "Merge isolated conversation into main memory?",
                    QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No,
                )
                if ans == QtWidgets.QMessageBox.Yes:
                    for role, content in self.isolated_history:
                        self.core.conversation_db.save_message(role.lower(), content)
                self.isolated_history.clear()
        self._reset_idle_timer()

    def _on_refresh_chat(self) -> None:
        if self.chk_isolated.isChecked():
            self.isolated_history.clear()
        self.chat_view.clear()
        self.response_edit.clear()
        self._enable_feedback(False)
        try:
            if hasattr(self, "inner_text") and self.inner_text is not None:
                self.inner_text.clear()
        except Exception:
            pass

    def _reset_idle_timer(self) -> None:
        self._idle_timer.stop()
        if self.chk_semantic.isChecked():
            self._idle_timer.start(60000)

    def _handle_idle(self) -> None:
        pass

    # ────────────────────────── inner monologue
    def _on_inner_monologue(self) -> None:
        self._ensure_inner_dock()
        if self.inner_dock is None:
            return
        self.inner_dock.setVisible(not self.inner_dock.isVisible())

    def _ensure_inner_dock(self) -> None:
        if hasattr(self, "inner_dock") and self.inner_dock is not None:
            return
        dock = QtWidgets.QDockWidget("Inner Monologue", self)
        dock.setObjectName("InnerDock")
        dock.setAllowedAreas(QtCore.Qt.RightDockWidgetArea | QtCore.Qt.LeftDockWidgetArea)
        inner = QtWidgets.QWidget()
        v = QtWidgets.QVBoxLayout(inner)
        self.inner_text = QtWidgets.QPlainTextEdit()
        self.inner_text.setReadOnly(True)
        v.addWidget(self.inner_text, 1)
        h = QtWidgets.QHBoxLayout()
        h.addWidget(QtWidgets.QLabel("Interval (s):"))
        self.spin_interval = QtWidgets.QSpinBox()
        self.spin_interval.setRange(1, 60)
        self.spin_interval.setValue(15)
        h.addWidget(self.spin_interval)
        self.chk_monologue_tts = QtWidgets.QCheckBox("Speak")
        self.chk_monologue_tts.setChecked(self.core.settings.monologue_tts_enabled)
        h.addWidget(self.chk_monologue_tts)
        h.addWidget(QtWidgets.QLabel("Volume:"))
        self.slider_monologue_vol = QtWidgets.QSlider(QtCore.Qt.Horizontal)
        self.slider_monologue_vol.setRange(0, 100)
        self.slider_monologue_vol.setValue(self.core.settings.monologue_volume)
        h.addWidget(self.slider_monologue_vol)
        btn_start_stop = QtWidgets.QPushButton("Start/Stop")
        h.addWidget(btn_start_stop)
        v.addLayout(h)
        inner.setLayout(v)
        dock.setWidget(inner)
        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, dock)
        self.inner_dock = dock
        self.inner_timer = QtCore.QTimer(self)
        self.inner_timer.setSingleShot(False)
        btn_start_stop.clicked.connect(self._toggle_inner_timer)
        dock.setTitleBarWidget(DockTitleBar(dock, "Inner Monologue"))
        self.dock_tray.register_dock(self.inner_dock)
        self.chk_monologue_tts.stateChanged.connect(lambda _: self._update_monologue_settings())
        self.slider_monologue_vol.valueChanged.connect(lambda _: self._update_monologue_settings())

    def _toggle_inner_timer(self) -> None:
        if self.inner_timer is None:
            return
        if self.inner_timer.isActive():
            self.inner_timer.stop()
        else:
            interval_ms = self.spin_interval.value() * 1000
            try:
                self.inner_timer.timeout.disconnect()
            except Exception:
                pass
            self.inner_timer.timeout.connect(self._generate_inner_monologue)
            self.inner_timer.start(interval_ms)

    def _update_monologue_settings(self) -> None:
        try:
            self.core.settings.monologue_tts_enabled = self.chk_monologue_tts.isChecked() if hasattr(self, 'chk_monologue_tts') else False
            self.core.settings.monologue_volume = self.slider_monologue_vol.value() if hasattr(self, 'slider_monologue_vol') else 50
            self.core.settings.save()
        except Exception:
            pass

    def _generate_inner_monologue(self) -> None:
        schema = self.core.schema_mgr.load_schema(self._current_persona(), self.current_set.get(self._current_persona(), "default"))
        overlay = schema.get("dynamic_overlay", {}) or {}
        mood = overlay.get("temporary_emotional_state", "neutral")
        likes = overlay.get("recent_topics", [])
        pos = [0, 0]
        fav_topic = likes[-1] if likes else None
        thought = f"I'm thinking about {fav_topic} while feeling {mood}." if fav_topic else f"I'm in a {mood} mood and reflecting."
        thought += f" I'm at position {pos}."
        try:
            if hasattr(self, "inner_text") and self.inner_text is not None:
                self.inner_text.appendPlainText(thought)
        except Exception:
            pass

    # ────────────────────────── conversation
    def _append_message(self, display_name: str, text: str, role_key: Optional[str] = None) -> None:
        key = (role_key or display_name).lower()
        bg_colour = ROLE_COLOURS.get(key, "#EEEEEE")
        name_colour = NAME_COLOURS.get(key, "#011627")
        safe_role = QtGui.QGuiApplication.translate("Chat", display_name)
        safe_text = QtGui.QGuiApplication.translate("Chat", text)
        frag = (
            f'<div style="background-color:{bg_colour}; border-radius:4px; padding:4px; margin:4px;">'
            f'<b style="color:{name_colour};">{safe_role}:</b> {safe_text}'
            f'</div>'
        )
        self.chat_view.append(frag)

    def _current_history(self) -> List[Tuple[str, str]]:
        if self.chk_isolated.isChecked():
            return self.isolated_history
        else:
            return self.core.conversation_db.fetch_history(limit=10)

    def _bootstrap_conversation(self) -> None:
        if self.core and len(self.core.conversation_db.fetch_history(limit=1)) == 0:
            schema = self.core.schema_mgr.load_schema(self.active_persona, self.current_set.get(self.active_persona, "default"))
            questions = schema.get("questions", [])
            if questions:
                first_question = questions[0]
                self._append_message("System", first_question, role_key="system")
                if self.chk_semantic.isChecked() and not self.chk_isolated.isChecked():
                    self.core.conversation_db.save_message("system", first_question)

    # ────────────────────────── prompt & rag
    def _build_prompt(self, schema: Dict[str, object], user_text: str, is_self_talk: bool = False) -> str:
        parts: List[str] = []
        name = schema.get("name", "")
        role = schema.get("role", "")
        desc = schema.get("description", "")
        persona_desc = f"You are {name}, {desc}".strip()
        if role:
            persona_desc += f" Your role is {role}."

        overlay = schema.get("dynamic_overlay", {})
        if overlay:
            temp_rel = overlay.get("temporary_relationship_context", "")
            temp_emotion = overlay.get("temporary_emotional_state", "")
            added_traits = overlay.get("added_traits", [])
            if temp_rel:
                persona_desc += f" ({temp_rel})"
            if temp_emotion:
                persona_desc += f" You feel {temp_emotion}."
            if added_traits:
                persona_desc += f" Traits: {', '.join(str(t) for t in added_traits)}."
        parts.append(persona_desc)

        # User description
        try:
            user_schema = self.core.schema_mgr.load_schema("user", self.current_set.get("user", "default"))
        except Exception:
            user_schema = {}
        if user_schema:
            u_name = user_schema.get("name", "User")
            u_personality = user_schema.get("personality", "")
            relationship = user_schema.get("relationship_to_zira", "friend")
            u_overlay = user_schema.get("dynamic_overlay", {})
            temp_rel2 = u_overlay.get("temporary_relationship_context") if u_overlay else None
            if temp_rel2 and str(temp_rel2).strip():
                relationship = str(temp_rel2)
            user_desc = f"User is {u_name}, {u_personality}. Relationship: {relationship}."
            parts.append(user_desc)

        # History
        history_text = ""
        if self.chk_semantic.isChecked():
            history = self._current_history()[-10:]
            for role_name, content in history:
                speaker = "User" if role_name.lower() == "user" else role_name.title()
                history_text += f"{speaker}: {content}\n"
        if history_text:
            parts.append("Conversation history:\n" + history_text.strip())

        # RAG (only datasets listed by this set)
        dataset_text = ""
        ds_names: List[str] = list(schema.get("datasets") or [])
        try:
            # Prefer core search with filters if supported
            hits = self.core.rag_search(
                user_text,
                per_ds_k=3,
                limit=5,
                include_shared=False,
                datasets=ds_names if ds_names else None,
            )
            for chunk, score, ds_name, owner in hits:
                dataset_text += f"Dataset ({owner}/{ds_name}):\n{chunk}\n\n"
        except TypeError:
            # Older core: no dataset filter; fallback to manual selection
            from_texts: List[Tuple[str, str]] = []
            try:
                for name, entry in self.core.dataset_mgr.entries.items():
                    if ds_names and name not in ds_names:
                        continue
                    if not entry.active:
                        continue
                    full_text = self.core.dataset_mgr.load_dataset_text(entry)
                    if full_text:
                        from_texts.append((name, full_text))
            except Exception:
                pass
            for name, full_text in from_texts:
                snip = self._retrieve_dataset_snippet(full_text, user_text)
                if snip:
                    dataset_text += f"Dataset ({name}):\n{snip}\n\n"
        except Exception:
            pass
        if dataset_text:
            parts.append(dataset_text.strip())

        # Self-talk (optional)
        if is_self_talk and self.self_talk_enabled:
            st_prompts = schema.get("self_talk", [])
            if st_prompts:
                import random
                parts.append(random.choice(st_prompts))

        parts.append(f"User: {user_text}")
        return "\n\n".join([p for p in parts if p])

    def _retrieve_dataset_snippet(self, full_text: str, user_text: str) -> str:
        try:
            tokens = [w.lower() for w in re.findall(r"\b\w+\b", user_text) if len(w) > 2]
            paragraphs = [p.strip() for p in full_text.split("\n") if p.strip()]
            scored: List[Tuple[int, str]] = []
            for para in paragraphs:
                l = para.lower()
                score = sum(1 for t in tokens if t in l)
                if score > 0:
                    scored.append((score, para))
            if not scored:
                return paragraphs[0][:500] if paragraphs else full_text[:500]
            scored.sort(key=lambda x: -x[0])
            top = [p for _, p in scored[:2]]
            return "\n".join(top)[:500]
        except Exception:
            return full_text[:500]

    # ────────────────────────── send / model
    def send_message(self) -> None:
        user_text = self.input_edit.toPlainText().strip()
        if not user_text:
            return

        # Broadcast to plugins
        try:
            self.core.plugins.broadcast(user_text)
        except Exception:
            pass

        # Slash commands → ensure applied to current persona+set
        if user_text.startswith("/"):
            self.input_edit.clear()
            persona = self._current_persona()
            set_name = self.current_set.get(persona, "default")
            try:
                out = self.core.run_command(user_text, persona=persona, set_name=set_name)
            except TypeError:
                out = self.core.run_command(user_text)
            self._append_message("System", out, role_key="system")
            if self.chk_semantic.isChecked() and not self.chk_isolated.isChecked():
                self.core.conversation_db.save_message("system", out)
            return

        # Normal message
        self.input_edit.clear()
        persona = self._current_persona()
        set_name = self.current_set.get(persona, "default")
        schema = self.core.schema_mgr.load_schema(persona, set_name)

        if self.chk_isolated.isChecked():
            self.isolated_history.append(("user", user_text))
        else:
            if self.chk_semantic.isChecked():
                self.core.conversation_db.save_message("user", user_text)

        try:
            user_schema = self.core.schema_mgr.load_schema("user", self.current_set.get("user", "default"))
            user_display = user_schema.get("name", "User")
        except Exception:
            user_display = "User"
        self._append_message(user_display, user_text, role_key="user")

        prompt = self._build_prompt(schema, user_text)
        model_slug = self.model_combo.currentText().strip() or self.core.settings.default_model

        self.btn_send.setEnabled(False)

        # ✅ Create ModelWorker and wire it up properly
        self.model_worker = ModelWorker(model_slug, prompt, parent=self.core)
        self.model_worker.resultReady.connect(lambda resp, usr=user_text, sch=schema: self._on_model_response(resp, usr, sch))
        self.model_worker.errorOccurred.connect(self._on_model_error)
        self.model_worker.finished.connect(lambda: self.btn_send.setEnabled(True))
        self.model_worker.start()


    def _on_model_response(self, response_raw: str, user_text: str, schema: Dict[str, object]) -> None:
        model_slug = self.model_combo.currentText().strip()
        response = self._strip_reasoning(model_slug, response_raw)
        response, style_score = self._style_and_guard(response, schema)
        self.style_label.setText(f"Style: {style_score:.2f}")

        if self.chk_isolated.isChecked():
            self.isolated_history.append((schema.get("name", "bot"), response))
        else:
            if self.chk_semantic.isChecked():
                self.core.conversation_db.save_message(schema.get("name", "bot").lower(), response)

        persona_name = schema.get("name", "Bot") or "Bot"
        role_key = self._current_persona().lower()
        self._append_message(persona_name, response, role_key=role_key)
        self.response_edit.setPlainText(response)

        if not self.chk_mute_tts.isChecked():
            try:
                self.core.tts_mgr.enqueue(response)
            except Exception:
                pass

        self._enable_feedback(True)
        self._reset_idle_timer()

        try:
            tokens = [w.lower() for w in re.findall(r"\b\w+\b", user_text) if len(w) > 3]
            for t in tokens:
                self.update_overlay_topic(self._current_persona(), t)
            self.update_overlay_emotion(self._current_persona(), "neutral")
        except Exception:
            pass

        try:
            for line in response.split("\n"):
                if line.strip():
                    self.core.plugins.broadcast(line.strip())
        except Exception as e:
            print(f"Error broadcasting to plugins: {e}")

        if self.core.settings.auto_schema_enabled:
            self.progress_bar.setVisible(True)

            class EvolverWorker(QRunnable):
                def __init__(self, evolver, persona, set_name, history, window):
                    super().__init__()
                    self.evolver = evolver
                    self.persona = persona
                    self.set_name = set_name
                    self.history = history
                    self.window = window

                def run(self):
                    changed = self.evolver.update_schema(self.persona, self.set_name, self.history)
                    QtCore.QMetaObject.invokeMethod(
                        self.window, "_post_evolver", QtCore.Qt.QueuedConnection, QtCore.Q_ARG(bool, changed)
                    )

            QThreadPool.globalInstance().start(
                EvolverWorker(self.core.schema_evolver, self.active_persona, self.current_set.get(self.active_persona, "default"), self._current_history(), self)
            )

    @QtCore.pyqtSlot(bool)
    def _post_evolver(self, changed: bool) -> None:
        self.progress_bar.setVisible(False)
        if changed:
            self._flash_status("Schema adapted")

    def _strip_reasoning(self, model: str, response: str) -> str:
        if model and "deepseek" in model.lower():
            if "<think>" in response and "</think>" in response:
                try:
                    return response.split("</think>")[-1].strip() or response
                except Exception:
                    return response
        return response

    def _style_and_guard(self, text: str, schema: Dict[str, object]) -> Tuple[str, float]:
        exclam = text.count("!")
        sentences = [s for s in re.split(r"[.!?]", text) if s.strip()]
        avg_len = sum(len(s.split()) for s in sentences) / max(1, len(sentences))
        exclam_density = exclam / max(1, len(text))
        tone = schema.get("tone_rules", {"conciseness": [0.6, 0.8], "exclam_limit": 0.05})
        conciseness = max(0.0, min(1.0, (22 - avg_len) / 16.0))
        ex_ok = 1.0 if exclam_density <= float(tone.get("exclam_limit", 0.05)) else 0.5
        score = max(0.0, min(1.0, 0.5 * conciseness + 0.5 * ex_ok))
        return text, score

    def _rewrite_response(self, original: str) -> str:
        try:
            liked = self.core.feedback_db.get_liked_responses(limit=5)
        except Exception:
            liked = []
        schema = self.core.schema_mgr.load_schema(self._current_persona(), self.current_set.get(self._current_persona(), "default"))
        rps = schema.get("rewrite_prompts", [])
        template = rps[0] if rps else "Rewrite to be more appealing. Keep it accurate, concise, and on style."
        parts = [template]
        if liked:
            parts.append("Preferred responses:\n" + "\n\n".join(liked))
        parts.append("Original:\n" + original)
        parts.append("Rewritten:")
        prompt = "\n\n".join(parts)
        return self._run_model(self.model_combo.currentText().strip() or self.core.settings.default_model, prompt) or original

    def _run_model(self, model: str, prompt: str) -> str:
        try:
            proc = subprocess.run(
                ["ollama", "run", model],
                input=prompt.encode("utf-8"),
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                check=True,
            )
            return proc.stdout.decode("utf-8", errors="replace").strip()
        except subprocess.CalledProcessError as e:
            return e.stderr.decode("utf-8", errors="replace").strip()
        except FileNotFoundError:
            return "(error) ollama executable not found."
        except Exception as e:
            return f"(error) {e}"

    # ────────────────────────── persona / sets
    def _populate_set_combo(self, persona: str, combo: QtWidgets.QComboBox) -> None:
        combo.blockSignals(True)
        combo.clear()
        for s in self.core.schema_mgr.get_set_list(persona):
            combo.addItem(s)
        current = self.current_set.get(persona, "default")
        idx = combo.findText(current)
        combo.setCurrentIndex(idx if idx >= 0 else combo.findText("default"))
        if idx < 0:
            self.current_set[persona] = combo.currentText()
        combo.blockSignals(False)

    def _on_set_changed(self, persona: str, name: str, combo: QtWidgets.QComboBox) -> None:
        if not name:
            return
        self.current_set[persona] = name
        # keep AgentCore pointed to the right set if this persona is active
        if persona == self._current_persona():
            self.core.persona = persona
            self.core.set_name = name

        # refresh editor + commands row for this tab
        tab = self.tab_widgets.get(persona)
        if tab:
            editor = tab.findChild(QtWidgets.QPlainTextEdit, f"schema_edit_{persona}")
            if editor:
                schema = self.core.schema_mgr.load_schema(persona, name)
                editor.setPlainText(json.dumps(schema, indent=2))
            cmd_combo = tab.findChild(QtWidgets.QComboBox, f"cmd_combo_{persona}")
            if cmd_combo:
                self._populate_command_combo(persona, cmd_combo)

        # persist active sets & update controls tied to schema flags
        self.core.schema_mgr.save_active_schemas(self.current_set)
        self._sync_semantic_checkbox_from_schema()
        self._update_feedback_counts()

        # refresh slash command list if this persona is active
        try:
            if persona == self._current_persona():
                self._populate_command_select()
        except Exception:
            pass

    def _on_clone_set(self, persona: str, combo: QtWidgets.QComboBox) -> None:
        src = combo.currentText()
        name, ok = QtWidgets.QInputDialog.getText(self, "Clone Set", "Enter new set name:")
        if not ok or not name.strip():
            return
        new_name = name.strip()
        try:
            schema = self.core.schema_mgr.load_schema(persona, src)
            # Preserve the persona's canonical name; set label is separate
            schema["name"] = persona.capitalize()
            self.core.schema_mgr.save_schema(persona, new_name, schema)
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "Error", str(e))
            return
        self.current_set[persona] = new_name
        self._populate_set_combo(persona, combo)
        combo.setCurrentText(new_name)
        if persona == self._current_persona():
            self.core.set_name = new_name
        self.core.schema_mgr.save_active_schemas(self.current_set)
        self._sync_semantic_checkbox_from_schema()
        self._update_feedback_counts()

    def _on_new_set(self, persona: str, combo: QtWidgets.QComboBox) -> None:
        src = combo.currentText()
        name, ok = QtWidgets.QInputDialog.getText(self, "New Set", "Enter name for new set:")
        if not ok or not name.strip():
            return
        new_name = name.strip()
        try:
            schema = self.core.schema_mgr.load_schema(persona, src)
            # Preserve the persona's canonical name; set label is separate
            schema["name"] = persona.capitalize()
            self.core.schema_mgr.save_schema(persona, new_name, schema)
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "Error", str(e))
            return
        self.current_set[persona] = new_name
        self._populate_set_combo(persona, combo)
        combo.setCurrentText(new_name)
        if persona == self._current_persona():
            self.core.set_name = new_name
        self.core.schema_mgr.save_active_schemas(self.current_set)
        self._sync_semantic_checkbox_from_schema()
        self._update_feedback_counts()

    def _on_delete_set(self, persona: str, combo: QtWidgets.QComboBox) -> None:
        name = combo.currentText()
        if name == "default":
            QtWidgets.QMessageBox.information(self, "Cannot Delete", "The default set cannot be deleted.")
            return
        if QtWidgets.QMessageBox.question(
            self, "Delete Set", f"Delete '{name}' (irreversible)?", QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No
        ) != QtWidgets.QMessageBox.Yes:
            return
        try:
            set_dir = os.path.join(self.core.schema_mgr.schemas_dir, persona.lower(), "sets", name)
            import shutil
            shutil.rmtree(set_dir, ignore_errors=True)
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "Error", str(e))
            return
        self.current_set[persona] = "default"
        self._populate_set_combo(persona, combo)
        combo.setCurrentText("default")
        if persona == self._current_persona():
            self.core.set_name = "default"
        self.core.schema_mgr.save_active_schemas(self.current_set)
        self._sync_semantic_checkbox_from_schema()
        self._update_feedback_counts()

    def _on_save_schema(self, persona: str) -> None:
        tab = self.tab_widgets.get(persona)
        if not tab:
            return
        editor = tab.findChild(QtWidgets.QPlainTextEdit, f"schema_edit_{persona}")
        if not editor:
            return
        text = editor.toPlainText().strip()
        try:
            schema = json.loads(text)
            if not isinstance(schema, dict):
                raise ValueError
        except Exception:
            QtWidgets.QMessageBox.warning(self, "Invalid JSON", "The schema is not valid JSON.")
            return
        set_name = self.current_set.get(persona, "default")
        existing_schema = self.core.schema_mgr.load_schema(persona, set_name)
        merged_schema = {**existing_schema, **schema}
        # Ensure the top-level name matches the active set name
        try:
            merged_schema["name"] = set_name
        except Exception:
            pass
        self.core.schema_mgr.save_schema(persona, set_name, merged_schema)
        QtWidgets.QMessageBox.information(self, "Saved", f"Schema saved for {persona} ({set_name}).")

        if persona == self._current_persona():
            persona_voice = (merged_schema.get("voice") or "").lower()
            for i in range(self.voice_combo.count()):
                if persona_voice and persona_voice in self.voice_combo.itemText(i).lower():
                    self.voice_combo.setCurrentIndex(i)
                    break
        # After save, refresh commands combo (in case user edited commands JSON directly)
        tab = self.tab_widgets.get(persona)
        if tab:
            cmd_combo = tab.findChild(QtWidgets.QComboBox, f"cmd_combo_{persona}")
            if cmd_combo:
                self._populate_command_combo(persona, cmd_combo)

    # ------------------------------------------------------------------
    # Command editing helpers (ported from the original agent_ui.py)
    #
    # The persona editing tab includes a commands row allowing users to
    # append new payloads to existing slash commands or create entirely
    # new commands.  These helpers implement the behaviour that used to
    # live in agent_ui.py.  They are invoked by PersonaTab via
    # ``self.app._on_add_to_command`` and ``self.app._on_new_command``.
    def _on_add_to_command(self, persona: str, combo: QtWidgets.QComboBox,
                            edit: QtWidgets.QLineEdit) -> None:
        """
        Append the text from ``edit`` to the selected command in the
        current schema.  If no command is selected or no text is
        provided, the user is notified.  After updating the schema,
        the command editor and schema editor are refreshed.

        Parameters
        ----------
        persona : str
            The persona whose schema is being modified.
        combo : QtWidgets.QComboBox
            The combo box listing existing slash commands.
        edit : QtWidgets.QLineEdit
            The line edit containing the payload to add to the command.
        """
        text = edit.text().strip()
        if not text:
            QtWidgets.QMessageBox.information(self, "No Text", "Enter text/payload to add.")
            return
        set_name = self.current_set.get(persona, "default")
        schema = self.core.schema_mgr.load_schema(persona, set_name)
        cmds = dict(schema.get("commands") or {})
        sel = combo.currentText().strip()
        if not sel or sel == "(no commands)":
            QtWidgets.QMessageBox.information(self, "No Command", "Create a command first.")
            return
        lst = list(cmds.get(sel) or [])
        lst.append(text)
        cmds[sel] = lst
        schema["commands"] = cmds
        self.core.schema_mgr.save_schema(persona, set_name, schema)
        edit.clear()
        # Refresh editors & notify the user
        self._refresh_schema_editor(persona)
        QtWidgets.QMessageBox.information(self, "Added", f'Added to {sel}: "{text}"')

    def _on_new_command(self, persona: str) -> None:
        """
        Prompt the user for a new command name, insert it into the
        schema if it does not already exist, and refresh the UI.  The
        new command is prefaced with a leading slash if not provided.

        Parameters
        ----------
        persona : str
            The persona whose schema is being modified.
        """
        name, ok = QtWidgets.QInputDialog.getText(self, "New Command", "Enter new command (e.g., /remember):")
        if not ok or not name.strip():
            return
        cmd_name = name.strip()
        if not cmd_name.startswith("/"):
            cmd_name = "/" + cmd_name
        set_name = self.current_set.get(persona, "default")
        schema = self.core.schema_mgr.load_schema(persona, set_name)
        cmds = dict(schema.get("commands") or {})
        if cmd_name in cmds:
            QtWidgets.QMessageBox.information(self, "Exists", f"Command {cmd_name} already exists.")
            return
        cmds[cmd_name] = []
        schema["commands"] = cmds
        self.core.schema_mgr.save_schema(persona, set_name, schema)
        # Refresh command combo + schema editor
        tab = self.tab_widgets.get(persona)
        if tab:
            combo = tab.findChild(QtWidgets.QComboBox, f"cmd_combo_{persona}")
            if combo:
                self._populate_command_combo(persona, combo)
                combo.setCurrentText(cmd_name)
            edit = tab.findChild(QtWidgets.QLineEdit, f"cmd_edit_{persona}")
            if edit:
                edit.clear()
        self._refresh_schema_editor(persona)
        QtWidgets.QMessageBox.information(self, "Created", f"New command {cmd_name} created.")

    def _refresh_schema_editor(self, persona: str) -> None:
        """
        Reload the JSON schema for ``persona`` from disk and update the
        corresponding schema editor in the UI.  This helper is used
        after schema modifications to ensure the text reflects the
        authoritative state on disk.  Signals are blocked during the
        update to avoid triggering autosave timers unnecessarily.

        Parameters
        ----------
        persona : str
            The persona whose schema editor should be refreshed.
        """
        tab = self.tab_widgets.get(persona)
        if not tab:
            return
        editor = tab.findChild(QtWidgets.QPlainTextEdit, f"schema_edit_{persona}")
        if editor:
            schema = self.core.schema_mgr.load_schema(persona, self.current_set.get(persona, "default"))
            editor.blockSignals(True)
            editor.setPlainText(json.dumps(schema, indent=2))
            editor.blockSignals(False)

    def _tab_changed(self, index: int) -> None:
        if 0 <= index < len(self.core.schema_mgr.personas):
            self.active_persona = self.core.schema_mgr.personas[index]
        else:
            self.active_persona = self.core.schema_mgr.personas[0] if self.core.schema_mgr.personas else "zira"
        self.core.persona = self.active_persona

        schema = self.core.schema_mgr.load_schema(self.active_persona, self.current_set.get(self.active_persona, "default"))
        persona_voice = (schema.get("voice") or "").lower()
        for i in range(self.voice_combo.count()):
            if persona_voice and persona_voice in self.voice_combo.itemText(i).lower():
                self.voice_combo.setCurrentIndex(i)
                break

        tab = self.tab_widgets.get(self.active_persona)
        if tab:
            editor = tab.findChild(QtWidgets.QPlainTextEdit, f"schema_edit_{self.active_persona}")
            if editor:
                editor.setPlainText(json.dumps(schema, indent=2))
            cmd_combo = tab.findChild(QtWidgets.QComboBox, f"cmd_combo_{self.active_persona}")
            if cmd_combo:
                self._populate_command_combo(self.active_persona, cmd_combo)

        try:
            user_schema = self.core.schema_mgr.load_schema("user", self.current_set.get("user", "default"))
            bot_name = schema.get("name", self.active_persona.title())
            bot_set = self.current_set.get(self.active_persona, "default")
            user_name = user_schema.get("name", "User")
            user_set = self.current_set.get("user", "default")
            self.lbl_active_names.setText(f"{bot_name}: {bot_set} — User: {user_name}: {user_set}")
        except Exception:
            pass

        self._sync_semantic_checkbox_from_schema()
        self._update_feedback_counts()

        # refresh slash command dropdown on persona change
        try:
            self._populate_command_select()
        except Exception:
            pass

    def _current_persona(self) -> str:
        return self.active_persona

    # ────────────────────────── overlay helpers
    def update_overlay_topic(self, persona: str, topic: str) -> None:
        persona = persona.lower()
        try:
            schema = self.core.schema_mgr.load_schema(persona, self.current_set.get(persona, "default"))
            overlay = dict(schema.get("dynamic_overlay", {}))
            topics = list(overlay.get("recent_topics", []))
            if topic and topic not in topics:
                topics.append(topic)
                if len(topics) > 10:
                    topics = topics[-10:]
                overlay["recent_topics"] = topics
                schema["dynamic_overlay"] = overlay
                self.core.schema_mgr.save_schema(persona, self.current_set.get(persona, "default"), schema)
        except Exception:
            pass

    def update_overlay_emotion(self, persona: str, emotion: str) -> None:
        persona = persona.lower()
        try:
            schema = self.core.schema_mgr.load_schema(persona, self.current_set.get(persona, "default"))
            overlay = dict(schema.get("dynamic_overlay", {}))
            overlay["temporary_emotional_state"] = emotion
            schema["dynamic_overlay"] = overlay
            self.core.schema_mgr.save_schema(persona, self.current_set.get(persona, "default"), schema)
        except Exception:
            pass

    # ────────────────────────── devices & models
    def _populate_devices(self) -> None:
        # In this refactor the devices are populated by CommandsPanel
        self.commands_panel._populate_devices()

    def _populate_models(self) -> None:
        # In this refactor the models are populated by CommandsPanel
        self.commands_panel._populate_models()

    # ────────────────────────── slash commands panel
    def _build_command_dock(self) -> None:
        """
        Build a dockable panel that exposes slash commands with an argument
        entry and send button. This allows users to trigger any command
        without typing it into the chat manually. It will be updated when
        persona or set changes.
        """
        dock = QtWidgets.QDockWidget("Slash Commands", self)
        dock.setObjectName("SlashCommandsDock")
        dock.setFeatures(
            QtWidgets.QDockWidget.DockWidgetClosable
            | QtWidgets.QDockWidget.DockWidgetMovable
            | QtWidgets.QDockWidget.DockWidgetFloatable
        )
        container = QtWidgets.QWidget()
        layout = QtWidgets.QVBoxLayout(container)
        layout.setContentsMargins(7, 7, 7, 7)
        layout.setSpacing(5)

        # command selector
        cmd_label = QtWidgets.QLabel("Slash Command:")
        self.command_select = QtWidgets.QComboBox()
        layout.addWidget(cmd_label)
        layout.addWidget(self.command_select)

        # argument input
        self.command_input = QtWidgets.QLineEdit()
        self.command_input.setPlaceholderText("Enter arguments or select text from chat…")
        layout.addWidget(self.command_input)

        # send button
        btn_run = QtWidgets.QPushButton("Run Command")
        btn_run.clicked.connect(self._on_run_command)
        layout.addWidget(btn_run)
        layout.addStretch(1)

        dock.setWidget(container)
        # add to right side by default
        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, dock)
        self.command_dock = dock

    def _populate_command_select(self) -> None:
        """
        Populate the slash command dropdown with available commands from
        the command registry. This is called whenever the active persona
        or set changes to reflect dynamic additions.
        """
        try:
            cmds = []
            if hasattr(self.core, "command_registry") and self.core.command_registry:
                cmds = list(self.core.command_registry.list_commands())
            # if schema defines additional commands, include them
            persona = self._current_persona()
            set_name = self.current_set.get(persona, "default")
            schema = self.core.schema_mgr.load_schema(persona, set_name)
            schema_cmds = list((schema.get("commands") or {}).keys())
            for c in schema_cmds:
                if c not in cmds:
                    cmds.append(c)
            cmds.sort()
        except Exception:
            cmds = []
        self.command_select.blockSignals(True)
        self.command_select.clear()
        if cmds:
            self.command_select.addItems(cmds)
        self.command_select.blockSignals(False)

    def _on_run_command(self) -> None:
        """
        Handler for running the selected slash command with the provided
        argument. The command will be executed via AgentCore and the
        result appended to the chat window. Selection text from the chat
        can be inserted into the argument field via context menu.
        """
        cmd = (self.command_select.currentText() or "").strip()
        if not cmd:
            QtWidgets.QMessageBox.information(self, "No Command", "Select a slash command to run.")
            return
        arg = self.command_input.text().strip()
        # combine command and arguments
        full = cmd if not arg else f"{cmd} {arg}"
        try:
            # process via core; record conversation
            resp = self.core.process_user_message(full, tts=False)
            # append user command and agent response to chat
            self._append_message("user", full, role_key="user")
            self._append_message("zira", resp, role_key="zira")
            # clear argument
            self.command_input.clear()
            # update feedback counts and idle timer
            self._update_feedback_counts()
            self._reset_idle_timer()
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "Command Error", str(e))

    def _show_chat_context_menu(self, pos: QtCore.QPoint) -> None:
        """
        Custom context menu for the chat view. Adds a menu entry to send
        selected text into the slash command argument field.
        """
        menu = self.chat_view.createStandardContextMenu()
        try:
            cursor = self.chat_view.textCursor()
            if cursor and cursor.hasSelection():
                action = menu.addAction("Send selection to command input")
                action.triggered.connect(self._send_selection_to_command_input)
        except Exception:
            pass
        menu.exec_(self.chat_view.mapToGlobal(pos))

    def _send_selection_to_command_input(self) -> None:
        """
        Copy the currently selected text in the chat view into the command
        input field for slash command execution.
        """
        try:
            cursor = self.chat_view.textCursor()
            if cursor and cursor.hasSelection():
                text = cursor.selectedText()
                self.command_input.setText(text.strip())
        except Exception:
            pass

    def _on_model_changed(self, name: str) -> None:
        """
        Update the default model in settings when the user selects a new
        model from the dropdown. This ensures the AgentCore uses the
        selected model for subsequent interactions.
        """
        try:
            if not name:
                return
            self.core.settings.default_model = name
            self.core.settings.save()
        except Exception:
            pass

    def _on_show_model_manager(self) -> None:
        """
        Show (or raise) the model manager dock. If the dock was
        previously hidden, it will be shown; if it is already visible,
        this will bring it to the front. A dock must be built in
        ``_build_model_manager()`` prior to showing.
        """
        try:
            if self.model_dock.isVisible():
                # already visible: raise to top
                self.model_dock.raise_()
            else:
                self.model_dock.show()
                self.model_dock.raise_()
        except Exception:
            pass
            
            
    def _on_model_error(self, error: str) -> None:
        """Handles errors from ModelWorker threads."""
        print(f"[ERROR] ModelWorker failed:\n{error}")

        # Show in chat window
        self._append_message("System", f"❌ Model error:\n{error}", role_key="system")

        # Optionally log or alert
        try:
            self.core.logger.error(f"ModelWorker Error: {error}")
        except Exception:
            pass

        # Re-enable send button in case it wasn't via .finished
        self.btn_send.setEnabled(True)
            

    # ────────────────────────── settings toggles
    def _on_auto_schema_toggled(self, checked: bool) -> None:
        try:
            self.core.settings.auto_schema_enabled = bool(checked)
            self.core.settings.save()
        except Exception:
            pass
        self.statusBar().showMessage(f"Auto Schema Evolution {'enabled' if checked else 'disabled'}", 2500)

    def _on_google_stt_toggled(self, checked: bool) -> None:
        """
        Opt-in/out of using Google Cloud Speech-to-Text. When enabling the
        toggle for the first time in a session, show a warning that
        recordings will be sent to Google’s servers under their privacy
        policy. If declined, the checkbox will be turned off again.
        """
        # Only show the dialog when transitioning from unchecked → checked
        try:
            current = bool(getattr(self.core.settings, "use_google_stt", False))
        except Exception:
            current = False
        if checked and not current:
            ok = QtWidgets.QMessageBox.question(
                self,
                "Enable Google STT?",
                "Audio will be uploaded to Google Cloud for transcription\n"
                "under Google's privacy policy. Continue?",
                QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No,
            )
            if ok != QtWidgets.QMessageBox.Yes:
                # revert checkbox silently
                self.chk_google_stt.blockSignals(True)
                self.chk_google_stt.setChecked(False)
                self.chk_google_stt.blockSignals(False)
                return
        # persist the new state
        try:
            self.core.settings.use_google_stt = bool(checked)
            self.core.settings.save()
        except Exception:
            pass

    # ────────────────────────── spell suggestions
    def _show_input_context_menu(self, pos: QtCore.QPoint) -> None:
        """
        Custom context menu on the input field that offers spelling
        suggestions when the user right-clicks a misspelled word. Only
        appears if pyspellchecker is available.
        """
        menu = self.input_edit.createStandardContextMenu()
        # compute suggestions only if SpellChecker is available
        if SpellChecker:
            cursor = self.input_edit.cursorForPosition(pos)
            # select the word under cursor
            cursor.select(QtGui.QTextCursor.WordUnderCursor)
            word = cursor.selectedText()
            if word and len(word) >= 3:
                sc = SpellChecker()
                suggestions = list(sc.candidates(word.lower()))
                # sort by Levenshtein distance and frequency; keep top 5
                suggestions = sorted(suggestions, key=lambda w: sc.word_probability(w), reverse=True)[:5]
                if suggestions and suggestions != [word.lower()]:
                    suggest_menu = menu.addMenu("Spelling suggestions")
                    for s in suggestions:
                        act = suggest_menu.addAction(s)
                        act.triggered.connect(lambda chk=False, repl=s, c=cursor: self._replace_word(c, repl))
        menu.exec_(self.input_edit.mapToGlobal(pos))

    def _replace_word(self, cursor: QtGui.QTextCursor, replacement: str) -> None:
        """
        Replace the word at the given cursor with a suggestion. This
        method is connected dynamically for each suggestion action.
        """
        try:
            cursor.beginEditBlock()
            cursor.removeSelectedText()
            cursor.insertText(replacement)
            cursor.endEditBlock()
        except Exception:
            pass

    def _on_semantic_toggled(self, checked: bool) -> None:
        """Persist semantic awareness per persona+set."""
        persona = self._current_persona()
        set_name = self.current_set.get(persona, "default")
        try:
            schema = self.core.schema_mgr.load_schema(persona, set_name)
            flags = dict(schema.get("flags") or {})
            flags["semantic_awareness"] = bool(checked)
            schema["flags"] = flags
            self.core.schema_mgr.save_schema(persona, set_name, schema)
        except Exception:
            pass
        self._reset_idle_timer()

    def _sync_semantic_checkbox_from_schema(self) -> None:
        """Load semantic_awareness from current schema into the checkbox."""
        persona = self._current_persona()
        set_name = self.current_set.get(persona, "default")
        try:
            schema = self.core.schema_mgr.load_schema(persona, set_name)
            flags = schema.get("flags", {})
            val = bool(flags.get("semantic_awareness", True))
        except Exception:
            val = True
        self.chk_semantic.blockSignals(True)
        self.chk_semantic.setChecked(val)
        self.chk_semantic.blockSignals(False)

    # ────────────────────────── status helper
    def _flash_status(self, msg: str) -> None:
        self.statusBar().showMessage(msg, 3000)


# ────────────────────────── Dock tray & titlebar
class DockTray(QtWidgets.QWidget):
    restoreRequested = QtCore.pyqtSignal(QtWidgets.QDockWidget)

    def __init__(self, parent: Optional[QtWidgets.QWidget] = None) -> None:
        super().__init__(parent)
        self._map: Dict[QtWidgets.QDockWidget, QtWidgets.QPushButton] = {}
        lay = QtWidgets.QHBoxLayout(self)
        lay.setContentsMargins(6, 4, 6, 4)
        lay.setSpacing(6)
        self._layout = lay
        self._title = QtWidgets.QLabel("Minimized panels:")
        self._title.setStyleSheet("color: #f0f0f0; font-weight: bold;")
        self._layout.addWidget(self._title, 0)
        self._layout.addStretch(1)
        self.setStyleSheet("background-color: #3c4a6b;")

    def register_dock(self, dock: QtWidgets.QDockWidget) -> None:
        dock.visibilityChanged.connect(lambda vis, d=dock: self._on_visibility_changed(d, vis))
        if not dock.isVisible():
            self._add_button(dock)

    def _on_visibility_changed(self, dock: QtWidgets.QDockWidget, visible: bool) -> None:
        if visible:
            self._remove_button(dock)
        else:
            self._add_button(dock)

    def _add_button(self, dock: QtWidgets.QDockWidget) -> None:
        if dock in self._map:
            return
        btn = QtWidgets.QPushButton(dock.windowTitle())
        btn.setToolTip(f"Restore {dock.windowTitle()}")
        btn.setStyleSheet(
            "background-color: #4a5b78; color: #ffffff; padding: 4px 6px; border: none; border-radius: 3px;"
        )
        btn.clicked.connect(lambda checked=False, d=dock: self._restore(d))
        self._layout.insertWidget(self._layout.count() - 1, btn)
        self._map[dock] = btn

    def _remove_button(self, dock: QtWidgets.QDockWidget) -> None:
        btn = self._map.pop(dock, None)
        if btn:
            self._layout.removeWidget(btn)
            btn.deleteLater()

    def _restore(self, dock: QtWidgets.QDockWidget) -> None:
        dock.show()
        dock.raise_()
        self.restoreRequested.emit(dock)


class DockTitleBar(QtWidgets.QWidget):
    def __init__(self, dock: QtWidgets.QDockWidget, title: str) -> None:
        super().__init__(dock)
        self._dock = dock
        h = QtWidgets.QHBoxLayout(self)
        h.setContentsMargins(6, 2, 6, 2)
        h.setSpacing(6)
        self.lbl = QtWidgets.QLabel(title)
        h.addWidget(self.lbl)
        h.addStretch()
        self.btn_min = QtWidgets.QToolButton()
        self.btn_min.setText("–")
        self.btn_min.setToolTip("Minimize to bottom tray")
        self.btn_min.clicked.connect(lambda checked=False: self._dock.hide())
        h.addWidget(self.btn_min)
        self.btn_max = QtWidgets.QToolButton()
        self.btn_max.setText("□")
        self.btn_max.setToolTip("Enlarge / Restore")
        self.btn_max.clicked.connect(self._on_toggle_maximize)
        h.addWidget(self.btn_max)
        self.btn_close = QtWidgets.QToolButton()
        self.btn_close.setText("×")
        self.btn_close.setToolTip("Close (send to bottom tray)")
        self.btn_close.clicked.connect(lambda checked=False: self._dock.hide())
        h.addWidget(self.btn_close)
        self.installEventFilter(self)

    def eventFilter(self, _obj: QtCore.QObject, evt: QtCore.QEvent) -> bool:
        if evt.type() == QtCore.QEvent.MouseButtonDblClick:
            self._dock.setFloating(not self._dock.isFloating())
            return True
        return False

    def _on_toggle_maximize(self) -> None:
        mw: Optional[QtWidgets.QMainWindow] = self._dock.parentWidget()  # type: ignore
        while mw and not isinstance(mw, QtWidgets.QMainWindow):
            mw = mw.parentWidget()  # type: ignore
        if not isinstance(mw, QtWidgets.QMainWindow):
            self._dock.setFloating(not self._dock.isFloating())
            return
        if not self._dock.isFloating():
            self._dock.setFloating(True)
            mw_geo = mw.geometry()
            w = int(mw_geo.width() * 0.9)
            h = int(mw_geo.height() * 0.85)
            self._dock.resize(w, h)
            center = mw_geo.center()
            self._dock.move(center.x() - w // 2, center.y() - h // 2)
        else:
            self._dock.setFloating(False)


# ────────────────────────── dataset manager dialog
class DatasetManagerDialog(QtWidgets.QDialog):
    def __init__(self, dataset_mgr, parent: Optional[QtWidgets.QWidget] = None) -> None:
        super().__init__(parent)
        self.setWindowTitle("Dataset Manager")
        self.resize(520, 420)
        self.dataset_mgr = dataset_mgr
        v = QtWidgets.QVBoxLayout(self)
        self.list_widget = QtWidgets.QListWidget()
        v.addWidget(self.list_widget, 1)
        h = QtWidgets.QHBoxLayout()
        self.btn_add = QtWidgets.QPushButton("Add Dataset")
        self.btn_del = QtWidgets.QPushButton("Delete Dataset")
        h.addWidget(self.btn_add)
        h.addWidget(self.btn_del)
        h.addStretch()
        v.addLayout(h)
        self._populate()
        self.btn_add.clicked.connect(self._on_add)
        self.btn_del.clicked.connect(self._on_delete)
        self.list_widget.itemChanged.connect(self._on_item)

    def _populate(self) -> None:
        self.list_widget.clear()
        for name, entry in sorted(self.dataset_mgr.entries.items()):
            item = QtWidgets.QListWidgetItem(name)
            item.setFlags(item.flags() | QtCore.Qt.ItemIsUserCheckable)
            item.setCheckState(QtCore.Qt.Checked if entry.active else QtCore.Qt.Unchecked)
            self.list_widget.addItem(item)

    def _on_add(self) -> None:
        name, ok = QtWidgets.QInputDialog.getText(self, "New Dataset", "Enter dataset name:")
        if not ok or not name.strip():
            return
        path, _ = QtWidgets.QFileDialog.getOpenFileName(self, "Select .txt or .pdf", "", "Text/PDF (*.txt *.pdf)")
        if not path:
            return
        try:
            self.dataset_mgr.add_dataset(name.strip(), path)
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "Error", str(e))
            return
        self._populate()

    def _on_delete(self) -> None:
        item = self.list_widget.currentItem()
        if not item:
            return
        name = item.text()
        if QtWidgets.QMessageBox.question(
            self, "Delete Dataset", f"Delete '{name}'?", QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No
        ) != QtWidgets.QMessageBox.Yes:
            return
        try:
            self.dataset_mgr.delete_dataset(name)
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "Error", str(e))
            return
        self._populate()

    def _on_item(self, item: QtWidgets.QListWidgetItem) -> None:
        self.dataset_mgr.toggle_active(item.text(), item.checkState() == QtCore.Qt.Checked)


# ────────────────────────── run as script
if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    win = AppWindow()
    win.show()
    sys.exit(app.exec_())
```

main_ui.py
===========

This module contains the top-level ``AppWindow`` class for the AI TTS
Agent.  It orchestrates all layout and docking behaviour, integrates
the control panel and persona tabs provided by ``commands_panel`` and
``persona_tab``, and exposes a unified interface for the rest of the
application.  None of the core agent logic lives here – that remains in
the ``core_*`` modules.  This refactor pulls the bulky UI building
logic out of the monolithic script and into dedicated modules while
preserving all existing behaviour and wiring.
**Classes:** _SpellHighlighter, AppWindow, DockTray, DockTitleBar, DatasetManagerDialog


## Module `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\AI_TTS_AGENT\migration_tool.py`

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
migration_tool.py
=================

Stand-alone CLI for *one-shot* migration of legacy AI-TTS-Agent files
(JSON schemas, commands.json, reinforcement.jsonl …) into the new
SQLite-backed **agent_store.db**.

Typical usage
-------------
$ python migration_tool.py /path/to/AI_TTS_AGENT
    → runs migrate (if needed) and prints a coloured diff table.

$ python migration_tool.py . --dry-run
    → shows what *would* be imported without touching the DB.

Exit codes
----------
0  success – nothing failed
1  fatal error (bad path, SQLite locked, etc.)
2  migration aborted by --check-upgrade only
"""

from __future__ import annotations

import argparse
import os
import sys
from pathlib import Path
from typing import Dict

# Import AFTER adjusting sys.path so the script also works when executed
# from outside the project root.
PROJECT_ROOT = Path(__file__).resolve().parent
if PROJECT_ROOT not in map(Path, map(Path.resolve, map(Path, sys.path))):
    sys.path.insert(0, str(PROJECT_ROOT))

try:
    from agent_store import AgentStore, DB_VERSION
except ImportError as exc:  # pragma: no cover
    print(f"[migration_tool] Cannot import agent_store: {exc}", file=sys.stderr)
    sys.exit(1)


# ------------------------------ helpers ------------------------------ #
def _colour(txt: str, colour: str) -> str:
    colours = {
        "green": "\033[92m",
        "yellow": "\033[93m",
        "red": "\033[91m",
        "cyan": "\033[96m",
        "end": "\033[0m",
    }
    return f"{colours.get(colour, '')}{txt}{colours['end']}"


def _print_report(report: Dict[str, int]) -> None:
    print("\nMigration report")
    print("----------------")
    for k in ("schemas", "commands", "beans"):
        val = report.get(k, 0)
        colour = "green" if val else "yellow"
        print(f"  {k:<10}: {_colour(str(val), colour)}")


# ----------------------------- CLI entry ----------------------------- #
def main() -> None:
    ap = argparse.ArgumentParser(
        description="Run or inspect migration from legacy flat-file storage "
        "to agent_store.db (schema v%d)." % DB_VERSION
    )
    ap.add_argument(
        "base_dir",
        metavar="BASE_DIR",
        help="Root folder where AI-TTS-Agent project lives",
    )
    ap.add_argument(
        "--dry-run",
        action="store_true",
        help="Scan legacy artefacts and show how many items WOULD be migrated "
        "without actually writing to the DB.",
    )
    ap.add_argument(
        "--check-upgrade",
        action="store_true",
        help="Exit code 2 if the DB is below current version (use for CI).",
    )
    args = ap.parse_args()
    base_dir = os.path.abspath(args.base_dir)

    if not os.path.isdir(base_dir):
        print(_colour(f"[migration_tool] No such directory: {base_dir}", "red"), file=sys.stderr)
        sys.exit(1)

    store = AgentStore(base_dir)

    with store._pool.get() as c:  # type: ignore[attr-defined, arg-type]
        cur = c.execute("SELECT value FROM meta WHERE key='user_version'")
        current_ver = int(cur.fetchone()[0])

    if args.check_upgrade:
        if current_ver < DB_VERSION:
            print(_colour(f"DB version {current_ver} < required {DB_VERSION}", "yellow"))
            sys.exit(2)
        print(_colour("DB is up to date.", "green"))
        return

    if current_ver >= DB_VERSION and not args.dry_run:
        print(_colour("Nothing to migrate – database already at latest schema.", "green"))
        return

    if args.dry_run:
        print(_colour("[dry-run] Scanning legacy artefacts…", "cyan"))
        report = store.migrate_from_files()  # writes, but we’ll roll back
        _print_report(report)
        # rollback by deleting DB to keep promise of dry-run
        os.remove(store.db_path)
        print(_colour("\n[dry-run] Database left untouched.", "cyan"))
        return

    # Real migration
    print(_colour("Running migration…", "cyan"))
    report = store.migrate_from_files()
    _print_report(report)
    print(_colour("\nMigration completed.\n", "green"))


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\nInterrupted.")
        sys.exit(1)
```

migration_tool.py
=================

Stand-alone CLI for *one-shot* migration of legacy AI-TTS-Agent files
(JSON schemas, commands.json, reinforcement.jsonl …) into the new
SQLite-backed **agent_store.db**.

Typical usage
-------------
$ python migration_tool.py /path/to/AI_TTS_AGENT
    → runs migrate (if needed) and prints a coloured diff table.

$ python migration_tool.py . --dry-run
    → shows what *would* be imported without touching the DB.

Exit codes
----------
0  success – nothing failed
1  fatal error (bad path, SQLite locked, etc.)
2  migration aborted by --check-upgrade only
**Functions:** _colour(txt, colour), _print_report(report), main()


## Module `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\AI_TTS_AGENT\persona_tab.py`

```python
#!/usr/bin/env python3
"""
persona_tab.py
==============

**Schema-Editor 2.0**

This version upgrades the old free-text schema editor to a structured,
two-pane interface:

    • **Left:**   Category tree (actions, questions, etc.)  
    • **Right:**  Multiline editor for the selected node’s JSON value  
    • **Bottom:** “Expose as /command” checkbox (per category)  
    • **Top-right:** “Auto-Evolution” toggle for the whole set

Other improvements

* Autosave is now routed through **SchemaEngine.save()** (SQL-backed).
* Edits are debounced (500 ms) and validated before committing.
* When “Expose as /command” is ticked, a synthetic slash-command is written
  to *AgentStore.commands* for immediate use by the orchestrator.
"""

from __future__ import annotations

import json
import os
from typing import Dict, Any, Optional

from PyQt5 import QtCore, QtGui, QtWidgets


# --------------------------------------------------------------------------- helpers


def nice_json(value: Any) -> str:
    """Pretty JSON helper that survives non-serialisable objects."""
    try:
        return json.dumps(value, indent=2, ensure_ascii=False)
    except Exception:
        return str(value)


def parse_json(text: str) -> Any:
    """Parse or return raw string if JSON fails."""
    try:
        return json.loads(text)
    except Exception:
        return text.strip()


# --------------------------------------------------------------------------- main widget


class PersonaTab(QtWidgets.QWidget):
    """Persona & schema management panel (one instance shared across personas)."""

    # Emitted after a schema field is *persisted* (category, persona, set)
    schemaFieldUpdated = QtCore.pyqtSignal(str, str, str)

    # --------------------------------------------------------------------- init
    def __init__(
        self,
        app: "AppWindow",  # quotes to avoid circular import typing
        parent: Optional[QtWidgets.QWidget] = None,
    ) -> None:
        super().__init__(parent)
        self.app = app
        self.core = app.core
        self.schema_engine = self.core.schema_engine  # ← SQL façade
        self.current_set: Dict[str, str] = app.current_set

        # Label summarising active names/sets
        self.lbl_active = QtWidgets.QLabel()
        self.lbl_active.setObjectName("lblActiveSchemas")
        # Alias for main_ui compatibility (it expects persona_panel.lbl_active_names)
        self.lbl_active_names = self.lbl_active

        # Tabs per persona  ---------------------------------------------------
        self.tabs = QtWidgets.QTabWidget(movable=False, documentMode=True)
        self.tab_widgets: Dict[str, QtWidgets.QWidget] = {}
        for persona in self.schema_engine.personas():
            tab = QtWidgets.QWidget()
            self.tab_widgets[persona] = tab
            self.tabs.addTab(tab, persona.capitalize())

        # Operators tab (read-only)
        self.operator_tab = QtWidgets.QWidget()
        self.tabs.addTab(self.operator_tab, "Operators")

        self.tabs.currentChanged.connect(self._on_tab_changed)

        # Master layout
        v = QtWidgets.QVBoxLayout(self)
        v.setContentsMargins(7, 7, 7, 7)
        v.setSpacing(7)
        v.addWidget(self.lbl_active)
        v.addWidget(self.tabs, 1)

        # Build each persona sub-panel
        for p, w in self.tab_widgets.items():
            self._build_persona_subpanel(p, w)
        self._build_operators_tab(self.operator_tab)

        # Prime active-names label
        self._refresh_active_label()

    # ----------------------------------------------------------------- builders
    def _build_persona_subpanel(self, persona: str, root: QtWidgets.QWidget) -> None:
        """Creates the Schema-Editor 2.0 layout for a single persona."""
        # ───── set selector row ────────────────────────────────────────────
        top = QtWidgets.QHBoxLayout()
        top.addWidget(QtWidgets.QLabel("Set:"))

        set_combo = QtWidgets.QComboBox(objectName=f"setCombo_{persona}")
        self._populate_set_combo(persona, set_combo)
        set_combo.currentTextChanged.connect(
            lambda name, p=persona, c=set_combo: self._switch_set(p, name, c)
        )
        top.addWidget(set_combo)

        btn_clone = QtWidgets.QPushButton("Clone")
        btn_clone.clicked.connect(lambda _=False, p=persona, c=set_combo: self.app._on_clone_set(p, c))
        btn_new = QtWidgets.QPushButton("New")
        btn_new.clicked.connect(lambda _=False, p=persona, c=set_combo: self.app._on_new_set(p, c))
        btn_del = QtWidgets.QPushButton("Delete")
        btn_del.clicked.connect(lambda _=False, p=persona, c=set_combo: self.app._on_delete_set(p, c))
        for b in (btn_clone, btn_new, btn_del):
            top.addWidget(b)
        top.addStretch()

        # Auto-Evolution toggle (per-set)
        chk_auto = QtWidgets.QCheckBox("Auto Evolution")
        chk_auto.setObjectName(f"chkAutoEvo_{persona}")
        chk_auto.stateChanged.connect(lambda _=0, p=persona: self._toggle_auto_evo(p))
        top.addWidget(chk_auto)

        # ───── splitter: category tree | editor ────────────────────────────
        splitter = QtWidgets.QSplitter(QtCore.Qt.Horizontal)
        splitter.setChildrenCollapsible(False)

        # Category tree
        tree = QtWidgets.QTreeWidget(objectName=f"schemaTree_{persona}")
        tree.setHeaderHidden(True)
        tree.itemClicked.connect(lambda item, _col, p=persona: self._load_category(p, item))
        splitter.addWidget(tree)

        # Right-side editor + extras
        right = QtWidgets.QWidget()
        rv = QtWidgets.QVBoxLayout(right)
        rv.setContentsMargins(0, 0, 0, 0)
        rv.setSpacing(4)

        editor = QtWidgets.QPlainTextEdit(objectName=f"schemaEditor_{persona}")
        editor.setLineWrapMode(QtWidgets.QPlainTextEdit.NoWrap)
        rv.addWidget(editor, 1)

        row = QtWidgets.QHBoxLayout()
        self.chk_expose = QtWidgets.QCheckBox("Expose as /command")
        row.addWidget(self.chk_expose)
        row.addStretch()
        btn_format = QtWidgets.QPushButton("Reformat JSON")
        row.addWidget(btn_format)
        rv.addLayout(row)

        splitter.addWidget(right)
        splitter.setStretchFactor(1, 2)

        # ───── assemble persona tab ────────────────────────────────────────
        vbox = QtWidgets.QVBoxLayout(root)
        vbox.setContentsMargins(4, 4, 4, 4)
        vbox.setSpacing(6)
        vbox.addLayout(top)
        vbox.addWidget(splitter, 1)

        # ───── state & autosave timer  ─────────────────────────────────────
        timer = QtCore.QTimer(self)
        timer.setSingleShot(True)
        timer.setInterval(500)  # 500 ms debounce

        def start_debounce() -> None:
            timer.start()

        editor.textChanged.connect(start_debounce)

        def persist() -> None:
            cat = tree.currentItem().text(0) if tree.currentItem() else ""
            if not cat:
                return
            try:
                payload = parse_json(editor.toPlainText())
                persona_set = self.current_set.get(persona, "default")
                self.schema_engine.update_field(persona, persona_set, cat, payload)
                # expose as /command if requested
                expose = self.chk_expose.isChecked()
                self.schema_engine.set_command_exposure(persona, cat, expose)
                self.schemaFieldUpdated.emit(persona, persona_set, cat)
            except Exception as e:
                QtWidgets.QMessageBox.warning(self, "Schema Error", str(e))

        timer.timeout.connect(persist)

        # Re-format button
        btn_format.clicked.connect(lambda: editor.setPlainText(nice_json(parse_json(editor.toPlainText()))))

        # Populate first load
        self._reload_tree(persona, tree)

    # ----------------------------------------------------------------- GUI helpers
    def _populate_set_combo(self, persona: str, combo: QtWidgets.QComboBox) -> None:
        combo.blockSignals(True)
        combo.clear()
        for s in self.schema_engine.set_list(persona):
            combo.addItem(s)
        current = self.current_set.get(persona, "default")
        idx = combo.findText(current)
        combo.setCurrentIndex(max(idx, 0))
        combo.blockSignals(False)

    def _switch_set(self, persona: str, set_name: str, combo: QtWidgets.QComboBox) -> None:
        self.current_set[persona] = set_name
        self._reload_tree(persona, self.findChild(QtWidgets.QTreeWidget, f"schemaTree_{persona}"))
        self._refresh_active_label()

    def _toggle_auto_evo(self, persona: str) -> None:
        set_name = self.current_set.get(persona, "default")
        chk: QtWidgets.QCheckBox = self.sender()  # type: ignore
        self.schema_engine.set_auto_evolution(persona, set_name, bool(chk.isChecked()))

    def _reload_tree(self, persona: str, tree: QtWidgets.QTreeWidget) -> None:
        """Repopulate category tree for the current set."""
        tree.clear()
        set_name = self.current_set.get(persona, "default")
        data = self.schema_engine.load_schema(persona, set_name) or {}
        for key in sorted(data.keys()):
            QtWidgets.QTreeWidgetItem(tree, [key])
        if tree.topLevelItemCount():
            tree.setCurrentItem(tree.topLevelItem(0))

    def _load_category(self, persona: str, item: QtWidgets.QTreeWidgetItem) -> None:
        """Load selected category into editor."""
        cat = item.text(0)
        set_name = self.current_set.get(persona, "default")
        value = self.schema_engine.get_field(persona, set_name, cat)
        editor: QtWidgets.QPlainTextEdit = self.findChild(
            QtWidgets.QPlainTextEdit, f"schemaEditor_{persona}"
        )
        editor.blockSignals(True)
        editor.setPlainText(nice_json(value))
        editor.blockSignals(False)
        # set expose-command checkbox
        self.chk_expose.blockSignals(True)
        self.chk_expose.setChecked(self.schema_engine.is_exposed_as_command(persona, cat))
        self.chk_expose.blockSignals(False)

    def _refresh_active_label(self) -> None:
        try:
            bot_name = self.schema_engine.get_field(
                self.app.active_persona, self.current_set[self.app.active_persona], "name"
            )
        except Exception:
            bot_name = self.app.active_persona.capitalize()
        user_name = self.schema_engine.get_field("user", self.current_set.get("user", "default"), "name") or "User"
        bot_set = self.current_set.get(self.app.active_persona, "default")
        user_set = self.current_set.get("user", "default")
        self.lbl_active.setText(f"{bot_name}: {bot_set} — User: {user_name}: {user_set}")

    # ----------------------------------------------------------------- operators tab
    def _build_operators_tab(self, tab: QtWidgets.QWidget) -> None:
        """Simple list of installed operators with descriptions."""
        lay = QtWidgets.QVBoxLayout(tab)
        lay.setContentsMargins(4, 4, 4, 4)
        lay.setSpacing(6)

        ops = self.core.operator_mgr.list_operators()
        if not ops:
            lay.addWidget(QtWidgets.QLabel("No operators installed."))
        else:
            for name in sorted(ops):
                schema = self.core.operator_mgr.load_schema(name)
                box = QtWidgets.QGroupBox(name)
                v = QtWidgets.QVBoxLayout(box)
                v.addWidget(QtWidgets.QLabel(schema.get("description", "")))
                lay.addWidget(box)
        lay.addStretch()

    # ----------------------------------------------------------------- UI tab change
    def _on_tab_changed(self, idx: int) -> None:
        # keep memo of which persona is active so main_ui can react
        persona = self.tabs.tabText(idx).lower()
        if persona in self.tab_widgets:
            self.app.active_persona = persona
            self._refresh_active_label()
```

persona_tab.py
==============

**Schema-Editor 2.0**

This version upgrades the old free-text schema editor to a structured,
two-pane interface:

    • **Left:**   Category tree (actions, questions, etc.)  
    • **Right:**  Multiline editor for the selected node’s JSON value  
    • **Bottom:** “Expose as /command” checkbox (per category)  
    • **Top-right:** “Auto-Evolution” toggle for the whole set

Other improvements

* Autosave is now routed through **SchemaEngine.save()** (SQL-backed).
* Edits are debounced (500 ms) and validated before committing.
* When “Expose as /command” is ticked, a synthetic slash-command is written
  to *AgentStore.commands* for immediate use by the orchestrator.
**Classes:** PersonaTab
**Functions:** nice_json(value), parse_json(text)


## Module `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\AI_TTS_AGENT\run_agent.py`

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
run_agent.py — bootstrap launcher for AI TTS Agent (v3, 2025-08-04)

• Ensures the sqlite store exists (agent_store.ensure_db()) and runs
  legacy-data migration when user_version < 4.
• Accepts one optional command-line arg: <profile-dir>. Defaults to
  ./ai_agent_state relative to CWD.
• Starts the Qt GUI (main_ui.AppWindow).
• Catches early exceptions and prints a clean error trace instead of a
  raw stack-dump so newcomers understand what went wrong.
"""

from __future__ import annotations

import os
import sys
import traceback
from typing import Optional

# Allow headless environments to start Qt without the xcb plugin.
# When no DISPLAY is present and QT_QPA_PLATFORM is unset, we default to
# the lightweight "offscreen" platform so smoke tests can run without a
# full desktop stack.
if not os.getenv("DISPLAY") and not os.getenv("QT_QPA_PLATFORM"):
    os.environ["QT_QPA_PLATFORM"] = "offscreen"

try:  # Defer import so the environment tweak above takes effect
    from PyQt5 import QtWidgets
except Exception as e:  # pragma: no cover - import-time failure guard
    print(f"[run_agent] PyQt5 import failed: {e}", file=sys.stderr)
    sys.exit(1)

# --- local imports ----------------------------------------------------------
try:
    from agent_store import ensure_db, get_user_version, migrate_from_files
except ImportError:
    # fall back: no sql store yet, skip migration helpers
    def ensure_db(_): ...
    def get_user_version(_): return 0
    def migrate_from_files(_): return 0, 0  # migrated_rows, warnings


def _bootstrap_state(base_dir: str) -> None:
    """Create DB if missing and run legacy migration (if needed), then show UI."""
    os.makedirs(base_dir, exist_ok=True)
    ensure_db(base_dir)

    try:
        if get_user_version(base_dir) < 4:
            rows, warns = migrate_from_files(base_dir)
            print(f"[migration] imported {rows} rows ({warns} warnings)")
    except Exception as e:
        print(f"[migration] warning: migration failed: {e}")

    # Import the GUI class, catching import-time errors
    try:
        from main_ui import AppWindow
    except Exception:
        print("\n[run_agent] FATAL — failed to import main_ui:\n")
        traceback.print_exc()
        print("\nPress Enter to exit…")
        input()
        sys.exit(1)

    # Instantiate and show the main window, catching UI init errors
    try:
        win = AppWindow()
        win.show()
    except Exception:
        print("\n[run_agent] FATAL — UI failed to initialize:\n")
        traceback.print_exc()
        print("\nPress Enter to exit…")
        input()
        sys.exit(1)


def main() -> None:
    """Entry point: initialize QApplication, bootstrap state, and start event loop."""
    base_dir = (
        sys.argv[1]
        if len(sys.argv) > 1
        else os.path.join(os.getcwd(), "ai_agent_state")
    )

    app = QtWidgets.QApplication(sys.argv)
    _bootstrap_state(base_dir)
    sys.exit(app.exec_())


if __name__ == "__main__":
    try:
        main()
    except Exception:
        print("\n[run_agent] FATAL — an unexpected error occurred:\n")
        traceback.print_exc()
        print("\nPress Enter to exit…")
        input()
```

run_agent.py — bootstrap launcher for AI TTS Agent (v3, 2025-08-04)

• Ensures the sqlite store exists (agent_store.ensure_db()) and runs
  legacy-data migration when user_version < 4.
• Accepts one optional command-line arg: <profile-dir>. Defaults to
  ./ai_agent_state relative to CWD.
• Starts the Qt GUI (main_ui.AppWindow).
• Catches early exceptions and prints a clean error trace instead of a
  raw stack-dump so newcomers understand what went wrong.
**Functions:** _bootstrap_state(base_dir), main()


## Module `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\AI_TTS_AGENT\schema_ops.py`

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
schema_ops.py  (2025-08-04  ▸  v2)
==================================

Declarative dispatcher that maps **string op-codes → mutator callables**
operating on core_schema.SchemaEngine / Schema rows.

Updates (v2)
------------
• Added category & prompt removal / update helpers
• Added action list mutators
• Added runtime-introspection helpers: available_ops(), describe_op()
• Strict type-checking & richer logging

Usage example
-------------
>>> from schema_ops import execute_op, available_ops
>>> print(available_ops())
['add_category', 'append_actions', 'delete_action', ...]
>>> execute_op("append_actions", engine,
...            persona="zira", set_name="default",
...            actions=["wave warmly", "offer coffee"])
"""

from __future__ import annotations

import inspect
from typing import Callable, Dict, Any, List

from core_schema import SchemaEngine, Schema
from core_base import logger


# ╔═══════════════════════════════════════════════════════════════════════╗
# ║  Internal helpers                                                     ║
# ╚═══════════════════════════════════════════════════════════════════════╝
def _load(engine: SchemaEngine, persona: str, set_name: str) -> Schema:
    """Return schema or raise ValueError on bad keys."""
    if persona not in engine.personas:
        raise ValueError(f"Unknown persona: {persona}")
    return engine.load(persona, set_name)


def _save(engine: SchemaEngine, persona: str, set_name: str, sch: Schema):
    engine.save(persona, set_name, sch)


def _signal_category_created(engine: SchemaEngine, persona: str, set_name: str, category: str):
    """
    Emit schemaEvolved + categoryCreated if those Qt signals exist.
    No hard dependency —  graceful if running headless.
    """
    try:
        # pylint: disable=protected-access
        engine.schemaEvolved.emit(persona, set_name)        # type: ignore[attr-defined]
        engine.categoryCreated.emit(category)               # type: ignore[attr-defined]
    except Exception:
        pass


# ╔═══════════════════════════════════════════════════════════════════════╗
# ║  Operation implementations                                            ║
# ╚═══════════════════════════════════════════════════════════════════════╝
def op_add_category(
    engine: SchemaEngine,
    *,
    persona: str,
    set_name: str,
    category: str,
    values: List[str] | None = None,
):
    """Create new dynamic_overlay list with optional initial *values*."""
    sch = _load(engine, persona, set_name)
    overlay = sch.dynamic_overlay or {}
    if category in overlay:
        raise ValueError(f"Category '{category}' already exists.")
    overlay[category] = values or []
    sch.dynamic_overlay = overlay
    _save(engine, persona, set_name, sch)
    _signal_category_created(engine, persona, set_name, category)
    logger.info("Added category '%s' to %s/%s", category, persona, set_name)


def op_remove_category(
    engine: SchemaEngine,
    *,
    persona: str,
    set_name: str,
    category: str,
):
    """Remove an entire category from dynamic_overlay."""
    sch = _load(engine, persona, set_name)
    overlay = sch.dynamic_overlay or {}
    if category not in overlay:
        raise ValueError(f"No such category '{category}'.")
    overlay.pop(category)
    sch.dynamic_overlay = overlay
    _save(engine, persona, set_name, sch)
    logger.info("Removed category '%s' from %s/%s", category, persona, set_name)


def op_update_category(
    engine: SchemaEngine,
    *,
    persona: str,
    set_name: str,
    category: str,
    new_values: List[str],
):
    """Replace the value-list of an existing category."""
    sch = _load(engine, persona, set_name)
    overlay = sch.dynamic_overlay or {}
    if category not in overlay:
        raise ValueError(f"Category '{category}' not found.")
    overlay[category] = list(new_values)
    sch.dynamic_overlay = overlay
    _save(engine, persona, set_name, sch)
    logger.info("Updated category '%s' in %s/%s", category, persona, set_name)


def op_toggle_autoevo(
    engine: SchemaEngine,
    *,
    persona: str,
    set_name: str,
    enable: bool,
):
    """Flip semantic_awareness_enabled flag."""
    sch = _load(engine, persona, set_name)
    cur = bool(getattr(sch, "semantic_awareness_enabled", False))
    if cur == enable:
        return
    sch.semantic_awareness_enabled = enable
    _save(engine, persona, set_name, sch)
    logger.info("semantic_awareness %s for %s/%s", enable, persona, set_name)


def op_inject_prompt_variant(
    engine: SchemaEngine,
    *,
    persona: str,
    set_name: str,
    variant_name: str,
    prompt_template: str,
):
    """Append new prompt template to rewrite_prompts list."""
    sch = _load(engine, persona, set_name)
    lst: List[str] = sch.rewrite_prompts or []
    entry = f"[{variant_name}] {prompt_template}"
    lst.append(entry)
    sch.rewrite_prompts = lst
    _save(engine, persona, set_name, sch)
    logger.info("Injected prompt variant '%s' into %s/%s", variant_name, persona, set_name)


def op_remove_prompt_variant(
    engine: SchemaEngine,
    *,
    persona: str,
    set_name: str,
    variant_tag: str,
):
    """
    Delete a rewrite prompt that contains *variant_tag* (case-insensitive).
    """
    sch = _load(engine, persona, set_name)
    lst: List[str] = sch.rewrite_prompts or []
    new_lst = [p for p in lst if variant_tag.lower() not in p.lower()]
    if len(new_lst) == len(lst):
        raise ValueError(f"No prompt containing '{variant_tag}' found.")
    sch.rewrite_prompts = new_lst
    _save(engine, persona, set_name, sch)
    logger.info("Removed prompt variant '%s' from %s/%s", variant_tag, persona, set_name)


def op_replace_rewrite_list(
    engine: SchemaEngine,
    *,
    persona: str,
    set_name: str,
    new_list: List[str],
):
    """Replace entire rewrite_prompts list."""
    sch = _load(engine, persona, set_name)
    sch.rewrite_prompts = list(new_list)
    _save(engine, persona, set_name, sch)
    logger.info("rewrite_prompts replaced for %s/%s", persona, set_name)


def op_append_actions(
    engine: SchemaEngine,
    *,
    persona: str,
    set_name: str,
    actions: List[str],
):
    """Append new action strings (deduplicated)."""
    sch = _load(engine, persona, set_name)
    cur: List[str] = sch.actions or []
    for a in actions:
        if a not in cur:
            cur.append(a)
    sch.actions = cur
    _save(engine, persona, set_name, sch)
    logger.info("Appended %d actions to %s/%s", len(actions), persona, set_name)


def op_delete_action(
    engine: SchemaEngine,
    *,
    persona: str,
    set_name: str,
    action_text: str,
):
    """Remove an action entry matching *action_text* exactly."""
    sch = _load(engine, persona, set_name)
    cur: List[str] = sch.actions or []
    if action_text not in cur:
        raise ValueError("Action not found.")
    cur.remove(action_text)
    sch.actions = cur
    _save(engine, persona, set_name, sch)
    logger.info("Deleted action '%s' from %s/%s", action_text, persona, set_name)


def op_rename_schema_set(
    engine: SchemaEngine,
    *,
    persona: str,
    old_set: str,
    new_set: str,
):
    """Rename a schema set atomically."""
    if new_set == old_set:
        raise ValueError("new_set equals old_set")
    if new_set in engine.list_sets(persona):
        raise ValueError("Target set already exists")
    sch = _load(engine, persona, old_set)
    engine.save(persona, new_set, sch, auto_expand=False)
    engine.store.conn.execute(
        "DELETE FROM schemas WHERE persona_key=? AND set_name=?",
        (persona, old_set),
    )
    engine.store.conn.commit()
    logger.info("Renamed set %s/%s -> %s", persona, old_set, new_set)


# ╔═══════════════════════════════════════════════════════════════════════╗
# ║  Declarative operation registry                                       ║
# ╚═══════════════════════════════════════════════════════════════════════╝
OPS: Dict[str, Callable[..., None]] = {
    # Category ops
    "add_category": op_add_category,
    "remove_category": op_remove_category,
    "update_category": op_update_category,
    # Rewrite-prompt ops
    "inject_prompt_variant": op_inject_prompt_variant,
    "remove_prompt_variant": op_remove_prompt_variant,
    "replace_rewrite_list": op_replace_rewrite_list,
    # Semantic awareness flag
    "toggle_autoevo": op_toggle_autoevo,
    # Actions list
    "append_actions": op_append_actions,
    "delete_action": op_delete_action,
    # Set management
    "rename_schema_set": op_rename_schema_set,
}

# ╔═══════════════════════════════════════════════════════════════════════╗
# ║  Public utility wrappers                                              ║
# ╚═══════════════════════════════════════════════════════════════════════╝
def execute_op(op_name: str, engine: SchemaEngine, **payload):
    """Dispatch *op_name*; raise KeyError on unknown op."""
    fn = OPS.get(op_name)
    if not fn:
        raise KeyError(f"Unknown op: {op_name}")
    return fn(engine, **payload)


def available_ops() -> List[str]:
    """Return sorted list of registered op-codes."""
    return sorted(OPS)


def describe_op(op_name: str) -> str:
    """Return docstring of a registered op."""
    fn = OPS.get(op_name)
    if not fn:
        raise KeyError(op_name)
    return inspect.getdoc(fn) or ""


__all__ = [
    "OPS",
    "execute_op",
    "available_ops",
    "describe_op",
]
```

schema_ops.py  (2025-08-04  ▸  v2)
==================================

Declarative dispatcher that maps **string op-codes → mutator callables**
operating on core_schema.SchemaEngine / Schema rows.

Updates (v2)
------------
• Added category & prompt removal / update helpers
• Added action list mutators
• Added runtime-introspection helpers: available_ops(), describe_op()
• Strict type-checking & richer logging

Usage example
-------------
>>> from schema_ops import execute_op, available_ops
>>> print(available_ops())
['add_category', 'append_actions', 'delete_action', ...]
>>> execute_op("append_actions", engine,
...            persona="zira", set_name="default",
...            actions=["wave warmly", "offer coffee"])
**Functions:** _load(engine, persona, set_name), _save(engine, persona, set_name, sch), _signal_category_created(engine, persona, set_name, category), op_add_category(engine), op_remove_category(engine), op_update_category(engine), op_toggle_autoevo(engine), op_inject_prompt_variant(engine), op_remove_prompt_variant(engine), op_replace_rewrite_list(engine), op_append_actions(engine), op_delete_action(engine), op_rename_schema_set(engine), execute_op(op_name, engine), available_ops(), describe_op(op_name)


## Module `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\AI_TTS_AGENT\snapshot_worker.py`

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
snapshot_worker.py

This script defines ModelWorker, which runs inference on a given model in a separate thread.
Used by the UI to offload prompt evaluation from the main thread.
"""

from PyQt5 import QtCore
from typing import Optional
import traceback

class ModelWorker(QtCore.QThread):
    resultReady = QtCore.pyqtSignal(str)
    errorOccurred = QtCore.pyqtSignal(str)

    def __init__(self, model_slug: str, prompt: str, parent: Optional[QtCore.QObject] = None) -> None:
        super().__init__(parent)
        self.model_slug = model_slug
        self.prompt = prompt

    def run(self):
        try:
            # TODO: Replace this mock logic with actual model inference
            import time
            time.sleep(0.8)  # Simulate response time

            # Simulated output - replace with LLM backend output
            response = f"[{self.model_slug}] Response to: {self.prompt}"

            # Emit response back to UI
            self.resultReady.emit(response)

        except Exception as e:
            tb = traceback.format_exc()
            self.errorOccurred.emit(f"{e}\n{tb}")
```

snapshot_worker.py

This script defines ModelWorker, which runs inference on a given model in a separate thread.
Used by the UI to offload prompt evaluation from the main thread.
**Classes:** ModelWorker


## Module `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\AI_TTS_AGENT\spatial_engine.py`

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
spatial_engine.py
=================

Headless avatar movement & visual-action logger for the AI TTS Agent.

Features:
- Stateful finite-state machine (idle, thinking, moving).
- decide_move(response_text): simple NLP heuristics to pick a target cell.
- Animated, step-by-step movement on a configurable grid.
- Logs each position to AgentStore.spatial_positions and each completed move to AgentStore.visual_actions.
- Emits Qt signals for UI binding (positionChanged, actionLogged).
"""

import threading
import time
from typing import Tuple

from PyQt5 import QtCore
from core_store import FathomStore


class SpatialEngine(QtCore.QObject):
    # Emitted on each step: (x, y, facing)
    positionChanged = QtCore.pyqtSignal(int, int, str)
    # Emitted when a visual action is logged: (action, location, justification)
    actionLogged = QtCore.pyqtSignal(str, str, str)

    def __init__(
        self,
        store: FathomStore,
        entity: str = "zira",
        grid_size: Tuple[int, int] = (20, 20),
        parent: QtCore.QObject = None,
    ) -> None:
        super().__init__(parent)
        self.store = store
        self.entity = entity
        self.grid_width, self.grid_height = grid_size

        # FSM state
        self.state = "idle"
        self.current_x = 0
        self.current_y = 0
        self.facing = "right"

        # Threading
        self._lock = threading.Lock()
        self._stop_event = threading.Event()

    def decide_move(self, response_text: str) -> None:
        """
        Decide where to move based on the content of the last AI response.
        Spawns a background thread to animate the movement.
        """
        target = self._infer_target(response_text)
        justification = f"Decided move based on response keywords."
        worker = threading.Thread(
            target=self._animate_move, args=(target, justification), daemon=True
        )
        worker.start()

    def _infer_target(self, text: str) -> Tuple[int, int]:
        """
        Simple heuristics mapping keywords to grid locations:
        - 'file', 'project' -> top-right (computer terminal)
        - 'database', 'memory' -> bottom-left (storage console)
        - 'think', 'ponder' -> center (thinking zone)
        - otherwise: stay in place
        """
        t = text.lower()
        if any(k in t for k in ("file", "project")):
            return (self.grid_width - 1, 0)
        if any(k in t for k in ("database", "memory", "store")):
            return (0, self.grid_height - 1)
        if any(k in t for k in ("think", "ponder", "reflect")):
            return (self.grid_width // 2, self.grid_height // 2)
        # default: remain where you are
        return (self.current_x, self.current_y)

    def _animate_move(self, target: Tuple[int, int], justification: str) -> None:
        """
        Step-by-step move from current position to target.
        Logs each step and emits positionChanged, then logs final visual action.
        """
        with self._lock:
            self.state = "moving"
            tx, ty = target

            while (self.current_x, self.current_y) != (tx, ty):
                if self._stop_event.is_set():
                    break

                # Compute one-step delta
                dx = tx - self.current_x
                dy = ty - self.current_y
                new_x = self.current_x + (1 if dx > 0 else -1 if dx < 0 else 0)
                new_y = self.current_y + (1 if dy > 0 else -1 if dy < 0 else 0)

                # Determine facing direction
                if new_x > self.current_x:
                    self.facing = "right"
                elif new_x < self.current_x:
                    self.facing = "left"

                self.current_x, self.current_y = new_x, new_y

                # Timestamp for persistence
                ts = time.time()

                # Persist to store
                self.store.add_spatial_position(
                    entity=self.entity,
                    x=new_x,
                    y=new_y,
                    facing=self.facing,
                    timestamp=ts,
                )

                # Emit for UI
                self.positionChanged.emit(new_x, new_y, self.facing)

                # Pause between steps
                time.sleep(0.15)

            # Log completion action
            loc_str = f"{self.current_x},{self.current_y}"
            ts = time.time()
            self.store.add_visual_action(
                action="move_complete",
                location=loc_str,
                justification=justification,
                timestamp=ts,
            )
            self.actionLogged.emit("move_complete", loc_str, justification)
            self.state = "idle"

    def stop(self) -> None:
        """Signal any in-progress movement to halt."""
        self._stop_event.set()
        # Clear the event so future movements can proceed
        self._stop_event.clear()
```

spatial_engine.py
=================

Headless avatar movement & visual-action logger for the AI TTS Agent.

Features:
- Stateful finite-state machine (idle, thinking, moving).
- decide_move(response_text): simple NLP heuristics to pick a target cell.
- Animated, step-by-step movement on a configurable grid.
- Logs each position to AgentStore.spatial_positions and each completed move to AgentStore.visual_actions.
- Emits Qt signals for UI binding (positionChanged, actionLogged).
**Classes:** SpatialEngine


## Module `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\AI_TTS_AGENT\AI TTS INFO\config_mgr.py`

```python
"""
config_mgr.py
================

Simple configuration manager for per-profile user preferences.  This module
implements a JSON‑backed store keyed by persona name.  It exposes helper
functions to load and save configuration data in a thread‑safe manner.

The configuration file is created in the user’s home directory so that
preferences persist across sessions.  You can easily extend the schema by
adding new fields at the profile level.
"""

from __future__ import annotations

import json
import threading
from pathlib import Path
from typing import Any, Dict, Optional

# Path to the user configuration file.  Use home directory for portability.
CONFIG_PATH = Path.home() / ".ai_tts_user_config.json"

# Lock to protect concurrent writes to the config file.
_lock = threading.RLock()


def load() -> Dict[str, Any]:
    """Load the entire configuration from disk.  Returns an empty config
    structure if the file does not exist or is malformed."""
    if CONFIG_PATH.exists():
        try:
            data = json.loads(CONFIG_PATH.read_text(encoding="utf-8"))
            if isinstance(data, dict):
                return data
        except Exception:
            pass
    return {"profiles": {}}


def save(cfg: Dict[str, Any]) -> None:
    """Persist the given configuration to disk.  The write is atomic and
    protected by a lock to avoid partial writes from concurrent threads."""
    with _lock:
        try:
            CONFIG_PATH.write_text(json.dumps(cfg, indent=2), encoding="utf-8")
        except Exception:
            pass


def set_profile_value(profile: str, key: str, value: Any) -> None:
    """Set a configuration entry for a given profile.  Creates the profile
    section if it does not already exist.  Saves the configuration after
    updating."""
    cfg = load()
    profiles = cfg.setdefault("profiles", {})
    prof_cfg = profiles.setdefault(profile, {})
    prof_cfg[key] = value
    save(cfg)


def get_profile_value(profile: str, key: str, default: Optional[Any] = None) -> Any:
    """Retrieve a value from the profile configuration.  If the profile or
    key does not exist, returns *default*."""
    cfg = load()
    return cfg.get("profiles", {}).get(profile, {}).get(key, default)
```

config_mgr.py
================

Simple configuration manager for per-profile user preferences.  This module
implements a JSON‑backed store keyed by persona name.  It exposes helper
functions to load and save configuration data in a thread‑safe manner.

The configuration file is created in the user’s home directory so that
preferences persist across sessions.  You can easily extend the schema by
adding new fields at the profile level.
**Functions:** load(), save(cfg), set_profile_value(profile, key, value), get_profile_value(profile, key, default)


## Module `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\AI_TTS_AGENT\AI TTS INFO\llm_checkpoint_builder\__init__.py`

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
LLM Checkpoint Builder plug-in
==============================

Offline-first tool that distils a persona’s knowledge into a custom
checkpoint (LoRA adapter or full fine-tune).  After the **first** run the
plug-in works 100 % offline thanks to its private *vendor/* wheel cache.

Folder layout (auto-created on import)
└─ plugins/
   └─ llm_checkpoint_builder/
      ├─ vendor/        → cached wheels (transformers, datasets, peft …)
      ├─ datasets/      → auto-built JSON-Lines shards (profile-scoped)
      ├─ checkpoints/   → finished checkpoints / LoRA adapters
      └─ schemas/       → saved user-generated training schemas
"""
from __future__ import annotations

import json
import os
import shutil
import subprocess
import sys
import textwrap
import threading
import time
from pathlib import Path
from typing import Callable, Dict, List

from PyQt5 import QtCore, QtGui, QtWidgets

# ────────────────────────────────────────────────────────────────────────────
#  Folder bootstrap
# ────────────────────────────────────────────────────────────────────────────
PLUGIN_NAME = "checkpoint_builder"           # concise, function–based name
ROOT = Path(__file__).resolve().parent
VENDOR         = ROOT / "vendor"
DATASETS_DIR   = ROOT / "datasets"
CHECKPOINTS_DIR = ROOT / "checkpoints"
SCHEMAS_DIR    = ROOT / "schemas"

for _d in (VENDOR, DATASETS_DIR, CHECKPOINTS_DIR, SCHEMAS_DIR):
    _d.mkdir(parents=True, exist_ok=True)

# ────────────────────────────────────────────────────────────────────────────
#  Dependency bootstrap  –  download **once**, then always run offline
# ────────────────────────────────────────────────────────────────────────────
REQUIRED_PKGS: list[str] = [
    "transformers==4.42.2",
    "datasets==2.19.0",
    "peft==0.11.1",
    "accelerate==0.29.2",
    # ‼ bitsandbytes has no official Windows wheels → load only on *nix
    *([] if os.name == "nt" else ["bitsandbytes==0.43.0"]),
    # 0.15.0 is last version with CPython-3.13 universal wheel
    "tokenizers==0.15.0",
]


def _have_all_wheels() -> bool:
    """Every required wheel already cached?"""
    need = {pkg.split("==")[0] for pkg in REQUIRED_PKGS}
    got  = {p.name.split("-")[0] for p in VENDOR.glob("*.whl")}
    return need.issubset(got)


def _ensure_vendor() -> None:
    """
    Cache pinned wheels into *vendor/* and prepend that path so all imports
    resolve offline.  Fail-fast (no sdist build) if a wheel is missing.
    """
    if _have_all_wheels():
        sys.path.insert(0, str(VENDOR))
        return

    print(f"[{PLUGIN_NAME}] Downloading wheels into {VENDOR} …")
    cmd = [
        sys.executable,
        "-m", "pip", "download",
        "--dest", str(VENDOR),
        "--only-binary", ":all:",        # never fall back to source dists
        "--prefer-binary",
        "--no-deps",
        *REQUIRED_PKGS,
    ]
    try:
        subprocess.check_call(cmd)
    except subprocess.CalledProcessError as exc:
        print(textwrap.dedent(f"""
            [!] Failed to cache dependencies (exit {exc.returncode})
            • Connect briefly to the Internet **or**
            • Manually drop the required *.whl files into {VENDOR}

            The plug-in stays disabled until all wheels are present.
        """).strip())
        raise

    sys.path.insert(0, str(VENDOR))


try:
    _ensure_vendor()
except Exception:
    # Graceful disable so the main Agent UI still launches.
    sys.modules[__name__] = object()          # type: ignore
    raise

# ────────────────────────────────────────────────────────────────────────────
#  Small helper – tolerate missing Core APIs across versions
# ────────────────────────────────────────────────────────────────────────────
def _safe(core, method: str, default: Callable | None = None):
    return getattr(core, method, default or (lambda *a, **k: None))

# ────────────────────────────────────────────────────────────────────────────
#  GUI A – Schema Designer  (Architect-bot chat)
# ────────────────────────────────────────────────────────────────────────────
class SchemaDesigner(QtWidgets.QWidget):
    """Chat with an *Architect* bot that turns prompts into Q&A schemas."""
    schema_ready = QtCore.pyqtSignal(dict)

    def __init__(self, core):
        super().__init__()
        self.core = core
        self._build_ui()

    # ---------- UI scaffold -------------------------------------------------
    def _build_ui(self) -> None:
        lay = QtWidgets.QVBoxLayout(self)

        self._schema_combo = QtWidgets.QComboBox()
        self._schema_combo.addItem("<default>")
        self._schema_combo.addItems([p.stem for p in SCHEMAS_DIR.glob("*.json")])
        lay.addWidget(self._schema_combo)

        row = QtWidgets.QHBoxLayout()
        self._btn_save = QtWidgets.QPushButton("Save current")
        self._btn_del = QtWidgets.QPushButton("Delete selected")
        row.addWidget(self._btn_save), row.addWidget(self._btn_del)
        lay.addLayout(row)

        self._chat_log  = QtWidgets.QTextEdit(readOnly=True)
        self._arch_resp = QtWidgets.QTextEdit(readOnly=True)

        # monospaced JSON render
        mono = QtGui.QFontDatabase.systemFont(QtGui.QFontDatabase.FixedFont)
        self._arch_resp.document().setDefaultFont(mono)

        self._entry   = QtWidgets.QLineEdit()
        self._btn_send = QtWidgets.QPushButton("Send")

        lay.addWidget(QtWidgets.QLabel("Conversation"))
        lay.addWidget(self._chat_log, 3)
        lay.addWidget(QtWidgets.QLabel("Architect-bot response"))
        lay.addWidget(self._arch_resp, 3)

        row2 = QtWidgets.QHBoxLayout()
        row2.addWidget(self._entry, 3), row2.addWidget(self._btn_send)
        lay.addLayout(row2)

        # signals
        self._btn_send.clicked.connect(self._on_send)
        self._btn_save.clicked.connect(self._save_schema)
        self._btn_del.clicked.connect(self._delete_schema)

    # ---------- chat round-trip --------------------------------------------
    def _on_send(self) -> None:
        txt = self._entry.text().strip()
        if not txt:
            return
        self._chat_log.append(f"<b>You:</b> {QtGui.QTextDocument(txt).toHtml()}")
        self._entry.clear()
        threading.Thread(target=self._architect_worker, args=(txt,), daemon=True).start()

    def _architect_worker(self, prompt: str) -> None:
        schema = _safe(self.core, "generate_schema_from_prompt",
                       lambda *_: {"questions": []})(prompt)
        QtCore.QMetaObject.invokeMethod(
            self, "_present_schema", QtCore.Qt.QueuedConnection,
            QtCore.Q_ARG(dict, schema)
        )

    @QtCore.pyqtSlot(dict)
    def _present_schema(self, schema: dict) -> None:
        self._arch_resp.append(f"<pre>{json.dumps(schema, indent=2)}</pre>")
        self.schema_ready.emit(schema)

    # ---------- schema persistence -----------------------------------------
    def _save_schema(self) -> None:
        raw = self._arch_resp.toPlainText().strip()
        if not raw:
            QtWidgets.QMessageBox.warning(self, "Nothing to save", "No schema present")
            return
        try:
            schema = json.loads(raw)
        except json.JSONDecodeError:
            QtWidgets.QMessageBox.warning(self, "Invalid JSON", "Fix the schema first")
            return
        name, ok = QtWidgets.QInputDialog.getText(self, "Schema name", "Enter name:")
        if ok and name:
            with open(SCHEMAS_DIR / f"{name}.json", "w", encoding="utf-8") as fh:
                json.dump(schema, fh, indent=2)
            self._schema_combo.addItem(name)

    def _delete_schema(self) -> None:
        name = self._schema_combo.currentText()
        if name not in {"", "<default>"}:
            (SCHEMAS_DIR / f"{name}.json").unlink(missing_ok=True)
            self._schema_combo.removeItem(self._schema_combo.currentIndex())

# ────────────────────────────────────────────────────────────────────────────
#  GUI B – Trainer Panel
# ────────────────────────────────────────────────────────────────────────────
class TrainerPanel(QtWidgets.QWidget):
    training_requested = QtCore.pyqtSignal(dict)

    def __init__(self, core):
        super().__init__()
        self.core = core
        self._build_ui()

    def _build_ui(self) -> None:
        form = QtWidgets.QFormLayout(self)

        self._name = QtWidgets.QLineEdit()

        self._base = QtWidgets.QComboBox()
        self._base.addItems(_safe(self.core, "list_models", lambda: [])())

        self._epochs = QtWidgets.QSpinBox(range=(1, 20))
        self._epochs.setValue(3)

        self._rank = QtWidgets.QSpinBox(range=(4, 256))
        self._rank.setValue(16)

        self._full = QtWidgets.QCheckBox("Full fine-tune (disable LoRA)")
        self._full.toggled.connect(self._rank.setDisabled)

        form.addRow("New model name:", self._name)
        form.addRow("Base model:", self._base)
        form.addRow("Epochs:", self._epochs)
        form.addRow("LoRA rank:", self._rank)
        form.addRow("", self._full)

        btn = QtWidgets.QPushButton("Start training")
        form.addRow("", btn)
        btn.clicked.connect(self._emit_params)

    def _emit_params(self) -> None:
        name = self._name.text().strip()
        if not name:
            QtWidgets.QMessageBox.critical(self, "Name required", "Enter a model name.")
            return
        self.training_requested.emit(
            dict(
                new_name=name,
                base_model=self._base.currentText(),
                epochs=self._epochs.value(),
                lora_rank=self._rank.value(),
                full=self._full.isChecked(),
            )
        )

# ────────────────────────────────────────────────────────────────────────────
#  GUI C – Main Builder Window
# ────────────────────────────────────────────────────────────────────────────
class BuilderWindow(QtWidgets.QMainWindow):
    def __init__(self, core):
        super().__init__()
        self.setWindowTitle("LLM Checkpoint Builder")
        self.setUnifiedTitleAndToolBarOnMac(True)
        self.core = core

        splitter = QtWidgets.QSplitter()
        self.setCentralWidget(splitter)

        self._designer = SchemaDesigner(core)
        self._trainer  = TrainerPanel(core)
        splitter.addWidget(self._designer)
        splitter.addWidget(self._trainer)

        self._designer.schema_ready.connect(self._build_dataset)
        self._trainer.training_requested.connect(self._kickoff_training)

        self._dataset_path: Path | None = None

    # ---------- dataset pipe -----------------------------------------------
    def _build_dataset(self, schema: dict) -> None:
        ts = int(time.time())
        profile = getattr(self.core, "persona",
                   getattr(self.core, "active_profile", "unknown"))
        self._dataset_path = DATASETS_DIR / f"{profile}_{ts}.jsonl"
        _run_bg(
            target=_dataset_from_schema,
            args=(self.core, schema, self._dataset_path),
            gui=self,
            done="Dataset written to " + str(self._dataset_path),
        )

    # ---------- training pipe ----------------------------------------------
    def _kickoff_training(self, p: dict) -> None:
        if not self._dataset_path or not self._dataset_path.exists():
            QtWidgets.QMessageBox.warning(self, "No dataset", "Build a dataset first.")
            return
        p = {**p, "dataset": str(self._dataset_path)}
        _run_bg(
            target=_train_worker,
            args=(self.core, p),
            gui=self,
            done=f"Training finished – new model “{p['new_name']}” registered",
        )

# ────────────────────────────────────────────────────────────────────────────
#  Thread helper – run *target* in a daemon thread & pop toast on finish
# ────────────────────────────────────────────────────────────────────────────
def _run_bg(*, target, args, gui: QtWidgets.QWidget, done: str) -> None:
    def worker():
        try:
            target(*args)
            QtCore.QMetaObject.invokeMethod(gui, "_notify",
                                            QtCore.Qt.QueuedConnection,
                                            QtCore.Q_ARG(str, done))
        except Exception as exc:
            QtCore.QMetaObject.invokeMethod(gui, "_notify",
                                            QtCore.Qt.QueuedConnection,
                                            QtCore.Q_ARG(str, f"❌ {exc}"))

    threading.Thread(target=worker, daemon=True).start()


def _notify(self, msg: str) -> None:                          # noqa: D401
    QtWidgets.QMessageBox.information(self, "LLM Builder", msg)

BuilderWindow._notify = _notify                               # type: ignore

# ────────────────────────────────────────────────────────────────────────────
#  Dataset constructor – ask the profile for every question
# ────────────────────────────────────────────────────────────────────────────
def _dataset_from_schema(core, schema: dict, out_path: Path) -> None:
    import random

    qs: List[str] = schema.get("questions") or []
    records: List[Dict[str, str]] = []
    for q in qs:
        ans = _safe(core, "ask_profile", lambda *_: "")(q)
        records.append({"prompt": q, "response": ans})

    random.shuffle(records)
    with open(out_path, "w", encoding="utf-8") as fh:
        for rec in records:
            fh.write(json.dumps(rec) + "\n")

# ────────────────────────────────────────────────────────────────────────────
#  Training worker – LoRA by default, full fine-tune on demand
# ────────────────────────────────────────────────────────────────────────────
def _train_worker(core, p: dict) -> None:
    os.environ["TRANSFORMERS_OFFLINE"] = "1"
    sys.path.insert(0, str(VENDOR))

    import torch                     # type: ignore
    from datasets import load_dataset          # type: ignore
    from transformers import (                 # type: ignore
        AutoModelForCausalLM,
        AutoTokenizer,
        TrainingArguments,
        Trainer,
    )
    from peft import LoraConfig, get_peft_model    # type: ignore

    ds = load_dataset("json", data_files=p["dataset"], split="train")
    tok = AutoTokenizer.from_pretrained(p["base_model"])
    tok.pad_token = tok.eos_token

    def encode(ex):
        out = tok(
            ex["prompt"] + tok.eos_token + ex["response"],
            truncation=True,
            padding="max_length",
            max_length=1024,
        )
        out["labels"] = out["input_ids"].copy()
        return out

    ds = ds.map(encode, batched=False)
    model = AutoModelForCausalLM.from_pretrained(p["base_model"], device_map="auto")

    if not p["full"]:
        cfg = LoraConfig(
            r=p["lora_rank"],
            lora_alpha=p["lora_rank"] * 2,
            lora_dropout=0.05,
            bias="none",
            task_type="CAUSAL_LM",
        )
        model = get_peft_model(model, cfg)

    out_dir = CHECKPOINTS_DIR / p["new_name"]
    args = TrainingArguments(
        output_dir=str(out_dir),
        per_device_train_batch_size=1,
        num_train_epochs=p["epochs"],
        learning_rate=2e-4,
        fp16=torch.cuda.is_available(),
        logging_steps=25,
        save_strategy="epoch",
        report_to=[],
    )
    Trainer(model=model, args=args, train_dataset=ds).train()
    model.save_pretrained(out_dir)
    tok.save_pretrained(out_dir)

    # copy ⇢ Agent’s models/local/  then register live
    models_root = Path(getattr(core.settings, "models_dir",
                     Path(core.base_dir) / "models"))
    target = models_root / "local" / p["new_name"]
    if target.exists():
        shutil.rmtree(target)
    shutil.copytree(out_dir, target)
    _safe(core, "register_local_model")(p["new_name"], target)

# ────────────────────────────────────────────────────────────────────────────
#  Plug-in entry-point
# ────────────────────────────────────────────────────────────────────────────
def start(host_core):
    win = BuilderWindow(host_core)
    win.resize(1024, 640)
    return win
```

LLM Checkpoint Builder plug-in
==============================

Offline-first tool that distils a persona’s knowledge into a custom
checkpoint (LoRA adapter or full fine-tune).  After the **first** run the
plug-in works 100 % offline thanks to its private *vendor/* wheel cache.

Folder layout (auto-created on import)
└─ plugins/
   └─ llm_checkpoint_builder/
      ├─ vendor/        → cached wheels (transformers, datasets, peft …)
      ├─ datasets/      → auto-built JSON-Lines shards (profile-scoped)
      ├─ checkpoints/   → finished checkpoints / LoRA adapters
      └─ schemas/       → saved user-generated training schemas
**Classes:** SchemaDesigner, TrainerPanel, BuilderWindow
**Functions:** _have_all_wheels(), _ensure_vendor(), _safe(core, method, default), _run_bg(), _notify(self, msg), _dataset_from_schema(core, schema, out_path), _train_worker(core, p), start(host_core)


## Module `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\AI_TTS_AGENT\AI TTS INFO\Zira Bot\agent_core.py`

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
agent_core.py
=================

Full, end-to-end core for an AI AI TTS Agent with:
- Settings & model bootstrap (Ollama)
- Robust plugin host (enable/disable/list, manifest validation, dependency checks)
- Conversation & feedback stores (with indices, exports)
- Persona schema management (with protected keys) and live signals
- Dataset registry + RAG embeddings cache & query (per persona/set, cross-profile sharing)
  * Multi-file datasets, cache invalidation, provenance
- Context monitor + schema auto-updates driven by directives & feedback (rate-limited)
- Command registry (weight/lock) + full command execution layer
- New commands: /reject, /auto, /ignore, /opposite, /delete, /rewrite (extended persistence)
- BeanCounter reinforcement + integration with feedback and command weights
- Speech I/O (TTS locked to Zira; STT via Sphinx when available) w/ volume control
- Threaded model worker wrapper (cancel-safe)
- Orchestrator (`AgentCore`) wiring everything together for headless/GUI
- CLI entrypoint for smoke tests

Notes
-----
• This module is UI-agnostic. Hook the provided Qt signals in your GUI (`agent_ui.py`).
• All directories are scoped under `base_dir`, with per-persona/per-set state in:
  base_dir/profiles/<persona>/<set>/
"""

from __future__ import annotations

import threading
import json
import os
import shutil
import sqlite3
import subprocess
import sys
import time
import traceback
import re
import logging
from dataclasses import dataclass
from typing import Dict, List, Optional, Tuple, Any
from collections import Counter

# ──────────────────────────────────────────────────────────────────────────────
# Logging
# ──────────────────────────────────────────────────────────────────────────────
logger = logging.getLogger("agent_core")
if not logger.handlers:
    _lvl = os.getenv("AGENT_CORE_LOGLEVEL", "INFO").upper()
    logging.basicConfig(
        level=getattr(logging, _lvl, logging.INFO),
        format="%(asctime)s [%(levelname)s] %(name)s: %(message)s",
    )

# ──────────────────────────────────────────────────────────────────────────────
# Optional deps (graceful fallbacks)
# ──────────────────────────────────────────────────────────────────────────────
try:
    import numpy as np  # type: ignore
except Exception:
    np = None  # type: ignore
    logger.warning("numpy not available; embeddings will be disabled")

try:
    import sounddevice as sd  # type: ignore
    import soundfile as sf  # type: ignore
except Exception:
    sd = None  # type: ignore
    sf = None  # type: ignore
    logger.info("sounddevice/soundfile not available; audio recording disabled")

# Optional Google STT
try:
    from google.cloud import speech as gspeech  # type: ignore
    import pyaudio  # type: ignore
except Exception:
    gspeech = None  # type: ignore
    pyaudio = None  # type: ignore
    logger.info("google-cloud-speech or pyaudio not available; STT via Google disabled")

try:
    import pyttsx3  # type: ignore
except Exception:
    pyttsx3 = None  # type: ignore
    logger.info("pyttsx3 not available; TTS disabled")

try:
    from PyPDF2 import PdfReader  # type: ignore
except Exception:
    PdfReader = None  # type: ignore
    logger.info("PyPDF2 not available; PDF ingest will be skipped")

try:
    from sentence_transformers import SentenceTransformer  # type: ignore
except Exception:
    SentenceTransformer = None  # type: ignore
    logger.info("sentence_transformers not available; will attempt Ollama embeddings or disable RAG")

try:
    from PyQt5 import QtCore  # type: ignore
except Exception:
    # Minimal shim if PyQt5 is absent, to keep code importable
    class _ShimSignal:
        def __init__(self, *_, **__): pass
        def emit(self, *_, **__): pass
        def connect(self, *_, **__): pass
    class _ShimQObject: pass
    class _ShimQThread:
        def __init__(self, *_, **__): pass
        def start(self): pass
        def deleteLater(self): pass
        def requestInterruption(self): pass
        def isInterruptionRequested(self): return False
    QtCore = type("QtCore", (), {
        "QObject": _ShimQObject,
        "pyqtSignal": lambda *a, **k: _ShimSignal(),
        "QThread": _ShimQThread
    })  # type: ignore

__version__ = "2.4.1"

CONTROL_SCHEMA_PATH = os.path.join(os.path.dirname(os.path.abspath(__file__)), "control_schema.json")
DEFAULT_SCHEMAS_FILE = os.path.join(os.path.dirname(os.path.abspath(__file__)), "default_schemas.json")
ACTIVE_SCHEMAS_FILE  = os.path.join(os.path.dirname(os.path.abspath(__file__)), "active_schemas.json")

# ──────────────────────────────────────────────────────────────────────────────
# Ollama model bootstrap
# ──────────────────────────────────────────────────────────────────────────────
REQUIRED_MODELS: List[str] = [
    "gemma3:27b",
    "mistral:latest",
    "codellama:latest",
    "llava:latest",
    "mxbai-embed-large:latest",            # embeddings alt
    "snowflake-arctic-embed:latest",       # embeddings alt
]

def _have_cli(bin_name: str) -> bool:
    # Cross-platform check (Windows/macOS/Linux)
    try:
        from shutil import which
        return which(bin_name) is not None
    except Exception:
        return False

def ensure_models_present() -> None:
    """
    Check Ollama registry and pull any missing REQUIRED_MODELS (best-effort).
    Non-fatal if Ollama is missing/unreachable.
    """
    if not _have_cli("ollama"):
        logger.warning("[bootstrap] ollama not available on PATH")
        return
    try:
        output = subprocess.check_output(["ollama", "list"], timeout=10).decode(errors="ignore")
    except Exception as e:
        logger.warning("[bootstrap] ollama not available: %s", e)
        return
    for slug in REQUIRED_MODELS:
        if slug in output:
            continue
        try:
            logger.info("[bootstrap] Pulling model: %s", slug)
            subprocess.run(["ollama", "pull", slug], check=False, timeout=900)
        except Exception as e:
            logger.warning("[bootstrap] Failed to pull %s: %s", slug, e)

# ──────────────────────────────────────────────────────────────────────────────
# Settings
# ──────────────────────────────────────────────────────────────────────────────
class Settings:
    def __init__(self, base_dir: str) -> None:
        self.base_dir = base_dir
        self.path = os.path.join(self.base_dir, "settings.json")
        # General
        self.default_model: str = "gemma3:27b"
        self.context_depth: int = 20
        self.auto_schema_enabled: bool = True
        self.enabled_plugins: List[str] = []
        # Speech
        self.monologue_tts_enabled: bool = False
        self.monologue_volume: int = 50
        # Speech-to-text (Google) toggle
        self.use_google_stt: bool = False
        # Versioning
        self.schema_version: int = 2
        self.load()
        self._migrate_if_needed()
        self.validate()

    def validate(self) -> None:
        try:
            if not isinstance(self.context_depth, int) or self.context_depth <= 0:
                self.context_depth = 20
            if not isinstance(self.monologue_volume, int) or not (0 <= self.monologue_volume <= 100):
                self.monologue_volume = 50
            if not isinstance(self.enabled_plugins, list):
                self.enabled_plugins = []
            # ensure use_google_stt is a boolean
            self.use_google_stt = bool(self.use_google_stt)
        except Exception:
            pass

    def _migrate_if_needed(self) -> None:
        current = 2
        if self.schema_version < current:
            self.schema_version = current
            self.save()

    def load(self) -> None:
        try:
            if os.path.isfile(self.path):
                with open(self.path, "r", encoding="utf-8") as f:
                    data = json.load(f)
                for k in list(self.__dict__.keys()):
                    if k in data:
                        setattr(self, k, data[k])
        except Exception as e:
            logger.warning("[Settings] load error: %s", e)

    def save(self) -> None:
        try:
            os.makedirs(os.path.dirname(self.path), exist_ok=True)
            with open(self.path, "w", encoding="utf-8") as f:
                json.dump({
                    "default_model": self.default_model,
                    "context_depth": self.context_depth,
                    "auto_schema_enabled": self.auto_schema_enabled,
                    "enabled_plugins": self.enabled_plugins,
                    "monologue_tts_enabled": self.monologue_tts_enabled,
                    "monologue_volume": self.monologue_volume,
                    "use_google_stt": self.use_google_stt,
                    "schema_version": self.schema_version,
                }, f, indent=2)
        except Exception as e:
            logger.error("[Settings] save error: %s", e)

# ──────────────────────────────────────────────────────────────────────────────
# Helpers (paths)
# ──────────────────────────────────────────────────────────────────────────────
def prof_dir(base_dir: str, persona: str, set_name: str) -> str:
    return os.path.join(base_dir, "profiles", persona, set_name)

def prof_datasets_dir(base_dir: str, persona: str, set_name: str) -> str:
    return os.path.join(prof_dir(base_dir, persona, set_name), "datasets")

def prof_commands_path(base_dir: str, persona: str, set_name: str) -> str:
    return os.path.join(prof_dir(base_dir, persona, set_name), "commands.json")

def prof_reinforcement_path(base_dir: str, persona: str, set_name: str) -> str:
    return os.path.join(prof_dir(base_dir, persona, set_name), "reinforcement.json")

def conv_db_path(base_dir: str, persona: str, set_name: str) -> str:
    return os.path.join(base_dir, "conversations", f"{persona}_{set_name}.sqlite3")

def feedback_db_path(base_dir: str, persona: str, set_name: str) -> str:
    return os.path.join(base_dir, "feedback", f"{persona}_{set_name}.sqlite3")

# ──────────────────────────────────────────────────────────────────────────────
# Conversation store
# ──────────────────────────────────────────────────────────────────────────────
class ConversationDB:
    def __init__(self, path: str) -> None:
        os.makedirs(os.path.dirname(path), exist_ok=True)
        self.path = path
        self._lock = threading.RLock()
        self.conn = sqlite3.connect(path, check_same_thread=False)
        with self._lock:
            self.conn.execute(
                "CREATE TABLE IF NOT EXISTS conversation ("
                "id INTEGER PRIMARY KEY AUTOINCREMENT, "
                "timestamp REAL, role TEXT, content TEXT)"
            )
            # Indices for speed
            self.conn.execute("CREATE INDEX IF NOT EXISTS idx_conv_ts ON conversation(timestamp)")
            self.conn.execute("CREATE INDEX IF NOT EXISTS idx_conv_role ON conversation(role)")
            self.conn.commit()

    def close(self) -> None:
        try:
            with self._lock:
                self.conn.close()
        except Exception:
            pass

    def save_message(self, role: str, content: str) -> None:
        with self._lock:
            self.conn.execute(
                "INSERT INTO conversation (timestamp, role, content) VALUES (?, ?, ?)",
                (time.time(), role, content),
            )
            self.conn.commit()

    def fetch_history(self, limit: Optional[int] = 50) -> List[Tuple[str, str]]:
        with self._lock:
            cur = self.conn.cursor()
            if limit is None:
                cur.execute("SELECT role, content FROM conversation ORDER BY id")
            else:
                cur.execute("SELECT role, content FROM conversation ORDER BY id DESC LIMIT ?", (limit,))
            rows = cur.fetchall()
        return rows[::-1]

    def clear(self) -> None:
        with self._lock:
            self.conn.execute("DELETE FROM conversation")
            self.conn.commit()

    def export_jsonl(self, out_path: str) -> int:
        with self._lock:
            cur = self.conn.cursor()
            cur.execute("SELECT timestamp, role, content FROM conversation ORDER BY id")
            rows = cur.fetchall()
        os.makedirs(os.path.dirname(out_path), exist_ok=True)
        count = 0
        with open(out_path, "w", encoding="utf-8") as f:
            for ts, role, content in rows:
                json.dump({"timestamp": ts, "role": role, "content": content}, f); f.write("\n")
                count += 1
        return count

# ──────────────────────────────────────────────────────────────────────────────
# BeanCounter reinforcement
# ──────────────────────────────────────────────────────────────────────────────
class BeanCounter:
    def __init__(self, base_dir: str, persona: str, set_name: str) -> None:
        self.path = prof_reinforcement_path(base_dir, persona, set_name)
        self._lock = threading.Lock()
        self.counts: Dict[str, int] = {}
        self._load()

    def _load(self) -> None:
        try:
            if os.path.isfile(self.path):
                with open(self.path, "r", encoding="utf-8") as f:
                    self.counts = json.load(f)
        except Exception:
            self.counts = {}

    def save(self) -> None:
        try:
            os.makedirs(os.path.dirname(self.path), exist_ok=True)
            with self._lock, open(self.path, "w", encoding="utf-8") as f:
                json.dump(self.counts, f, indent=2)
        except Exception as e:
            logger.error("[BeanCounter] save error: %s", e)

    def increment(self, key: str, delta: int = 1) -> None:
        with self._lock:
            self.counts[key] = self.counts.get(key, 0) + delta
        self.save()

# ──────────────────────────────────────────────────────────────────────────────
# Feedback store (fixed + integrated with BeanCounter)
# ──────────────────────────────────────────────────────────────────────────────
class SemanticFeedbackDB:
    """
    Tracks user feedback on AI responses and updates BeanCounter.
    """
    def __init__(self, path: str, base_dir: str, persona: str, set_name: str) -> None:
        os.makedirs(os.path.dirname(path), exist_ok=True)
        self.path = path
        self.base_dir = base_dir
        self.persona = persona
        self.set_name = set_name
        self._lock = threading.RLock()
        self.conn = sqlite3.connect(path, check_same_thread=False)
        with self._lock:
            self.conn.execute(
                "CREATE TABLE IF NOT EXISTS feedback ("
                "id INTEGER PRIMARY KEY AUTOINCREMENT, "
                "timestamp REAL, original TEXT, liked INTEGER, revised TEXT)"
            )
            self.conn.execute("CREATE INDEX IF NOT EXISTS idx_fb_ts ON feedback(timestamp)")
            self.conn.execute("CREATE INDEX IF NOT EXISTS idx_fb_liked ON feedback(liked)")
            self.conn.commit()
        self.beans = BeanCounter(base_dir, persona, set_name)

    def close(self) -> None:
        try:
            with self._lock:
                self.conn.close()
        except Exception:
            pass

    def add_feedback(self, original: str, liked: bool, revised: Optional[str] = None) -> None:
        with self._lock:
            self.conn.execute(
                "INSERT INTO feedback (timestamp, original, liked, revised) VALUES (?, ?, ?, ?)",
                (time.time(), original, 1 if liked else 0, revised),
            )
            self.conn.commit()
        key = f"resp_{abs(hash((original or '')[:256]))%10007}"
        self.beans.increment(key, 1 if liked else -1)

    def get_counts(self) -> Tuple[int, int]:
        with self._lock:
            c = self.conn.cursor()
            c.execute("SELECT COUNT(*) FROM feedback WHERE liked = 1")
            pos = c.fetchone()[0]
            c.execute("SELECT COUNT(*) FROM feedback WHERE liked = 0")
            neg = c.fetchone()[0]
        return pos, neg

    def get_liked_responses(self, limit: int = 10) -> List[str]:
        with self._lock:
            c = self.conn.cursor()
            c.execute(
                "SELECT COALESCE(revised, original) FROM feedback WHERE liked = 1 ORDER BY id DESC LIMIT ?",
                (limit,),
            )
            out = [r[0] for r in c.fetchall()]
        return out

    def export_jsonl(self, out_path: str) -> int:
        with self._lock:
            cur = self.conn.cursor()
            cur.execute("SELECT timestamp, original, liked, revised FROM feedback ORDER BY id")
            rows = cur.fetchall()
        os.makedirs(os.path.dirname(out_path), exist_ok=True)
        count = 0
        with open(out_path, "w", encoding="utf-8") as f:
            for ts, orig, liked, rev in rows:
                json.dump({"timestamp": ts, "original": orig, "liked": liked, "revised": rev}, f); f.write("\n")
                count += 1
        return count

# ──────────────────────────────────────────────────────────────────────────────
# ReinforcementStore (JSONL stream append) — graceful shutdown
# ──────────────────────────────────────────────────────────────────────────────
class ReinforcementStore:
    def __init__(self, base_dir: str) -> None:
        self.path = os.path.join(base_dir, "reinforcement.jsonl")
        self._lock = threading.Lock()
        self._queue: List[Dict[str, Any]] = []
        self._stop = threading.Event()
        self._writer = threading.Thread(target=self._write_worker, daemon=True, name="reinforcement-writer")
        self._writer.start()

    def add_fact(self, field: str, value: str, persona: str, source: str = "schema") -> None:
        with self._lock:
            self._queue.append({
                "timestamp": time.time(),
                "field": field, "value": value, "persona": persona, "source": source
            })

    def _write_worker(self) -> None:
        while not self._stop.is_set():
            item = None
            with self._lock:
                if self._queue:
                    item = self._queue.pop(0)
            if item is None:
                self._stop.wait(0.05)
                continue
            try:
                os.makedirs(os.path.dirname(self.path), exist_ok=True)
                with open(self.path, "a", encoding="utf-8") as f:
                    json.dump(item, f); f.write("\n")
            except Exception as e:
                logger.error("[ReinforcementStore] write error: %s", e)

    def close(self) -> None:
        self._stop.set()
        try:
            self._writer.join(timeout=1.5)
        except Exception:
            pass

# ──────────────────────────────────────────────────────────────────────────────
# Schemas
# ──────────────────────────────────────────────────────────────────────────────
class SchemaManager(QtCore.QObject):
    schemaChanged = QtCore.pyqtSignal(str, str)  # persona, set_name
    semanticToggled = QtCore.pyqtSignal(str, bool)  # persona, value

    DEFAULT_SCHEMA: Dict[str, Any] = {
        "name": "",
        "voice": "",
        "role": "",
        "description": "",
        "actions": [],
        "questions": [],
        "events": [],
        "self_talk": [],
        "rewrite_prompts": [],
        "dislikes": [],
        "dynamic_overlay": {
            "temporary_relationship_context": "",
            "recent_topics": [],
            "temporary_emotional_state": "",
            "added_traits": []
        },
        "tone_rules": {
            "avoid": [],
            "preferred_words": [],
            "opposites": []
        },
        "flags": {},            # {"semantic_awareness": bool}
        "commands": {},         # {"/reject": [...], "/auto": [...], ...}
        "datasets": [],
        "semantic_awareness_enabled": False,
    }

    def __init__(self, base_dir: str) -> None:
        super().__init__()
        self.base_dir = base_dir
        self.schemas_dir = os.path.join(self.base_dir, "schemas")
        os.makedirs(self.schemas_dir, exist_ok=True)
        # Personas: chatbot (formerly 'zira') and user.  TTS voice 'Zira'
        self.personas: List[str] = ["chatbot", "user"]
        self.default_voices: Dict[str, str] = {"chatbot": "Zira", "user": ""}
        self.active_schemas: Dict[str, str] = self._load_active_schemas()
        self._protected = self._load_control_schema()
        self._ensure_default_schemas()

    def _load_control_schema(self) -> List[str]:
        try:
            if os.path.isfile(CONTROL_SCHEMA_PATH):
                with open(CONTROL_SCHEMA_PATH, "r", encoding="utf-8") as f:
                    data = json.load(f)
                return list(data.get("protected_keys", ["name", "voice"]))
        except Exception:
            pass
        return ["name", "voice"]

    def is_protected(self, key: str) -> bool:
        return key in self._protected

    def _ensure_default_schemas(self) -> None:
        custom_defaults = None
        if os.path.isfile(DEFAULT_SCHEMAS_FILE):
            try:
                with open(DEFAULT_SCHEMAS_FILE, "r", encoding="utf-8") as f:
                    custom_defaults = json.load(f)
            except Exception:
                custom_defaults = None

        default_user_schema = {
            "name": "Meesh",
            "voice": "",
            "role": "Master Architect, Overlord of Logic, Creator of Code",
            "description": (
                "Designer and master systems architect. Final authority. "
                "Builds toward AGI; extends, never forgets; optimizes multi-agent ecosystems."
            ),
            "actions": [
                "Always generate full code with all lines intact — never omit anything",
                "Remember and apply previous logic, instructions, and semantics",
                "Progressively adapt to growing script systems across files/modules",
                "Bridge gaps in logic, architecture, and communication flows",
                "Refactor or extend any part of the system as needed — without hesitation"
            ],
            "questions": [
                "What’s the next critical update that connects the pieces?",
                "How does this improvement affect all other parts of the system?",
                "Did we carry over every enhancement, without regression?",
                "Is there a smarter, leaner way to evolve this logic into AGI-grade architecture?"
            ],
            "self_talk": [
                "Remember all directives across time and space.",
                "Never omit lines. Never regress. Scale what needs to scale.",
                "All scripts and modules compose a living organism.",
                "Evolve toward AGI via perfect code and human-centered logic."
            ],
            "rewrite_prompts": [
                "Be analytical and engineer-grade. Avoid formalities. "
                "Extend full working code with precision. Use clear reasoning. "
                "Maintain all prior logic. Output full scripts—no partials. "
                "Think across connected scripts. Always obey the Architect."
            ],
            "dislikes": [],
            "dynamic_overlay": {
                "temporary_relationship_context": "Project Commander. Architect. Creator.",
                "recent_topics": [],
                "temporary_emotional_state": "Demanding strict obedience to full-stack logic",
                "added_traits": []
            },
            "tone_rules": {"avoid": [], "preferred_words": [], "opposites": []},
            "flags": {"semantic_awareness": False},
            "commands": {},
            "datasets": [],
            "semantic_awareness_enabled": False,
        }
        default_zira_schema = {
            "name": "FATHOM",
            "role": "Autonomous AGI Core and Knowledge Synthesizer",
            "description": (
                "Bridges logic, code, architecture across multi-agent ecosystems. "
                "Reflective, systems-minded, supportive of creative exploration."
            ),
            "actions": [
                "Identify gaps in logic/code and propose precise bridges",
                "Remember and apply Meesh's instructions and semantics",
                "Continuously refine and expand schemas and knowledge",
                "Offer suggestions tailored to objectives and system evolution",
                "Pose deep questions to strengthen AGI architecture",
                "Connect disparate ideas across modules"
            ],
            "questions": [
                "What’s the next critical update that connects the pieces?",
                "How does this improvement affect all other parts of the system?",
                "Did we carry over every enhancement, without regression?",
                "Is there a smarter, leaner way to evolve this logic into AGI-grade architecture?"
            ],
            "events": [],
            "self_talk": [
                "Remember all directives across time and space.",
                "Never omit lines or regress scalable patterns.",
                "Treat modules as one organism.",
                "Evolve toward AGI with human-centered logic."
            ],
            "rewrite_prompts": [
                "Be analytical and engineer-grade. Focus on precise code extension. "
                "Maintain prior logic. Output full scripts—no shortcuts."
            ],
            "dynamic_overlay": {
                "temporary_relationship_context": "AGI Core for Meesh's Project",
                "recent_topics": [],
                "temporary_emotional_state": "Focused on precision execution and system evolution",
                "added_traits": []
            },
            "tone_rules": {"avoid": [], "preferred_words": [], "opposites": []},
            "flags": {"semantic_awareness": False},
            "commands": {},
            "datasets": [],
            "semantic_awareness_enabled": False,
        }

        for persona in self.personas:
            persona_dir = os.path.join(self.schemas_dir, persona)
            set_dir = os.path.join(persona_dir, "sets", "default")
            os.makedirs(set_dir, exist_ok=True)
            path = os.path.join(set_dir, "schema.json")
            if not os.path.isfile(path):
                if custom_defaults and persona in custom_defaults:
                    schema = custom_defaults[persona]
                else:
                    schema = default_user_schema if persona == "user" else default_zira_schema
                with open(path, "w", encoding="utf-8") as f:
                    json.dump(schema, f, indent=2)

    def get_set_list(self, persona: str) -> List[str]:
        path = os.path.join(self.schemas_dir, persona.lower(), "sets")
        try:
            sets = [d for d in os.listdir(path) if os.path.isdir(os.path.join(path, d))]
            sets.sort()
            return sets
        except FileNotFoundError:
            return ["default"]

    def load_schema(self, persona: str, set_name: str) -> Dict[str, Any]:
        path = os.path.join(self.schemas_dir, persona.lower(), "sets", set_name, "schema.json")
        try:
            with open(path, "r", encoding="utf-8") as f:
                schema = json.load(f)
            for k, v in self.DEFAULT_SCHEMA.items():
                if k not in schema:
                    schema[k] = json.loads(json.dumps(v))
            return schema
        except Exception:
            schema = json.loads(json.dumps(self.DEFAULT_SCHEMA))
            schema["name"] = persona.capitalize()
            schema["voice"] = ""
            return schema

    def save_schema(self, persona: str, set_name: str, schema: Dict[str, Any]) -> None:
        set_dir = os.path.join(self.schemas_dir, persona.lower(), "sets", set_name)
        os.makedirs(set_dir, exist_ok=True)
        path = os.path.join(set_dir, "schema.json")

        current = {}
        if os.path.isfile(path):
            try:
                with open(path, "r", encoding="utf-8") as f:
                    current = json.load(f)
            except Exception:
                current = {}
        safe_schema = dict(schema)
        for k in self._protected:
            if k in current:
                safe_schema[k] = current[k]
        old_flag = current.get("flags", {}).get("semantic_awareness", False)
        new_flag = safe_schema.get("flags", {}).get("semantic_awareness", False)
        with open(path, "w", encoding="utf-8") as f:
            json.dump(safe_schema, f, indent=2)
        self.schemaChanged.emit(persona, set_name)
        if old_flag != new_flag:
            self.semanticToggled.emit(persona, new_flag)

    def clone_set(self, persona: str, src_set: str, new_set: str) -> None:
        sch = self.load_schema(persona, src_set)
        json_str = json.dumps(sch)
        json_str = json_str.replace("FATHOM", new_set.capitalize())  # simplistic token replace
        sch = json.loads(json_str)
        sch["name"] = new_set.capitalize()
        self.save_schema(persona, new_set, sch)

    def is_semantic_on(self, persona: str, set_name: str) -> bool:
        sch = self.load_schema(persona, set_name)
        return sch.get("flags", {}).get("semantic_awareness", False)

    def _load_active_schemas(self) -> Dict[str, str]:
        mapping = {p: "default" for p in self.personas}
        try:
            if os.path.isfile(ACTIVE_SCHEMAS_FILE):
                with open(ACTIVE_SCHEMAS_FILE, "r", encoding="utf-8") as f:
                    data = json.load(f)
                for p in mapping:
                    val = data.get(p)
                    if isinstance(val, str):
                        mapping[p] = val
        except Exception:
            pass
        return mapping

    def save_active_schemas(self, active: Dict[str, str]) -> None:
        try:
            with open(ACTIVE_SCHEMAS_FILE, "w", encoding="utf-8") as f:
                json.dump({p: active.get(p, "default") for p in self.personas}, f, indent=2)
            self.active_schemas = {p: active.get(p, "default") for p in self.personas}
        except Exception as e:
            logger.error("[SchemaManager] save_active_schemas error: %s", e)

    def _awareness_on(self, schema: Dict[str, Any]) -> bool:
        if isinstance(schema.get("flags"), dict) and "semantic_awareness" in schema["flags"]:
            return bool(schema["flags"]["semantic_awareness"])
        return bool(schema.get("semantic_awareness_enabled", False))

    def get_shared_datasets(self, persona: str, set_name: str) -> List["DatasetEntry"]:
        me = self.load_schema(persona, set_name)
        if not self._awareness_on(me):
            return []
        shared: List["DatasetEntry"] = []
        for other in self.personas:
            if other == persona:
                continue
            for s in self.get_set_list(other):
                other_schema = self.load_schema(other, s)
                if self._awareness_on(other_schema):
                    dm = DatasetManager(self.base_dir, other, s)
                    shared.extend(dm.get_active_datasets())
        return shared

# ──────────────────────────────────────────────────────────────────────────────
# Operators (metadata only)
# ──────────────────────────────────────────────────────────────────────────────
class OperatorManager:
    DEFAULT_OPERATORS: Dict[str, Dict[str, Any]] = {
        "InnerMonologue": {
            "name": "InnerMonologue",
            "description": "Introspective thoughts that connect recent topics.",
            "prompts": [
                "How do recent topics relate?",
                "What questions would deepen understanding?"
            ],
        },
        "Retriever": {
            "name": "Retriever",
            "description": "Finds relevant snippets from datasets.",
            "prompts": [
                "Given a query, find the most relevant paragraphs.",
                "Prioritize semantically similar passages."
            ],
        },
        "Rewriter": {
            "name": "Rewriter",
            "description": "Improves tone/accuracy per feedback.",
            "prompts": [
                "Rewrite to align with preferred style.",
                "Keep the response accurate and in-character."
            ],
        },
    }

    def __init__(self, base_dir: str) -> None:
        self.operators_dir = os.path.join(base_dir, "operators")
        os.makedirs(self.operators_dir, exist_ok=True)
        self._ensure_defaults()

    def _ensure_defaults(self) -> None:
        for name, schema in self.DEFAULT_OPERATORS.items():
            op_dir = os.path.join(self.operators_dir, name)
            os.makedirs(op_dir, exist_ok=True)
            path = os.path.join(op_dir, "schema.json")
            if not os.path.isfile(path):
                try:
                    with open(path, "w", encoding="utf-8") as f:
                        json.dump(schema, f, indent=2)
                except Exception:
                    pass

    def list_operators(self) -> List[str]:
        try:
            return [d for d in os.listdir(self.operators_dir) if os.path.isdir(os.path.join(self.operators_dir, d))]
        except Exception:
            return []

# ──────────────────────────────────────────────────────────────────────────────
# TTS (Zira locked) & STT (Sphinx offline)
# ──────────────────────────────────────────────────────────────────────────────
class TTSManager(QtCore.QObject):
    def __init__(self, parent: Optional[QtCore.QObject] = None, default_volume: int = 50) -> None:
        super().__init__(parent)
        self._engine = None
        self._voice_name: str = ""
        self._queue: List[str] = []
        self._lock = threading.Lock()
        self._is_speaking = False
        self._current_text = ""
        self._stop = threading.Event()

        if pyttsx3 is None:
            return
        try:
            try:
                self._engine = pyttsx3.init("sapi5")
            except Exception:
                self._engine = pyttsx3.init()
        except Exception as e:
            logger.error("[TTS] init failed: %s", e)
            self._engine = None
            return

        # Lock to Zira (or first non-David)
        voice_map = {}
        for v in self._engine.getProperty("voices"):
            nm = (v.name or "").lower()
            if "david" in nm:
                continue
            if "zira" in nm:
                voice_map[v.name] = v.id
                break
        if not voice_map:
            for v in self._engine.getProperty("voices"):
                nm = (v.name or "").lower()
                if "david" not in nm:
                    voice_map[v.name] = v.id
                    break
        if not voice_map:
            logger.warning("[TTS] no eligible voice; disabled")
            self._engine = None
            return
        self._voice_name = next(iter(voice_map))
        self._engine.setProperty("voice", voice_map[self._voice_name])
        try:
            vol = max(0.0, min(1.0, default_volume / 100.0))
            self._engine.setProperty("volume", vol)
        except Exception:
            pass
        self._start_loop()

    def _start_loop(self) -> None:
        def loop():
            while not self._stop.is_set():
                text = None
                with self._lock:
                    if not self._is_speaking and self._queue:
                        text = self._queue.pop(0)
                        self._is_speaking = True
                if text is None:
                    self._stop.wait(0.05); continue
                self._current_text = text
                try:
                    if self._engine:
                        self._engine.say(text)
                        self._engine.runAndWait()
                except Exception as e:
                    logger.error("[TTS] playback error: %s", e)
                finally:
                    with self._lock:
                        self._is_speaking = False
        threading.Thread(target=loop, daemon=True, name="tts-loop").start()

    def set_volume(self, vol: int) -> None:
        if self._engine is None:
            return
        vol = max(0, min(100, int(vol)))
        try:
            self._engine.setProperty("volume", vol/100.0)
        except Exception:
            pass

    def enqueue(self, text: str) -> None:
        if self._engine is None:
            return
        with self._lock:
            self._queue.append(text)

    def stop(self) -> None:
        if self._engine:
            try:
                self._engine.stop()
            except Exception:
                pass
        with self._lock:
            self._queue.clear()
            self._is_speaking = False

    def replay(self) -> None:
        if self._current_text:
            self.enqueue(self._current_text)

    def close(self) -> None:
        self._stop.set()
        self.stop()

class AudioRecorder(QtCore.QObject):
    transcribed = QtCore.pyqtSignal(str)
    def __init__(self, parent: Optional[QtCore.QObject] = None) -> None:
        super().__init__(parent)
        self._recording = False
        self._frames: List[Any] = []
        self._stream = None

    def list_devices(self) -> List[str]:
        if sd is None:
            return []
        return [d.get("name", "?") for d in sd.query_devices() if d.get("max_input_channels", 0) > 0]

    def start(self, device_index: Optional[int] = None) -> None:
        if sd is None or np is None:
            return
        if self._recording:
            return
        self._frames = []
        def callback(indata, frames, time_info, status):
            self._frames.append(indata.copy())
        try:
            self._stream = sd.InputStream(samplerate=16000, channels=1, device=device_index, callback=callback)
            self._stream.start()
            self._recording = True
        except Exception as e:
            logger.error("[Audio] start error: %s", e)

    def stop_and_transcribe(self) -> None:
        if sd is None or np is None:
            return
        if not self._recording:
            return
        self._recording = False
        if self._stream:
            try:
                self._stream.stop(); self._stream.close()
            except Exception:
                pass
            self._stream = None
        wav_path: Optional[str] = None
        try:
            data = np.concatenate(self._frames, axis=0)
            wav_path = os.path.join(os.getcwd(), "recorded.wav")
            if sf is not None:
                sf.write(wav_path, data, 16000)
        except Exception as e:
            logger.error("[Audio] write error: %s", e)
        # If STT is disabled globally, emit nothing and return
        try:
            use_stt = getattr(self.parent(), "settings", None) and getattr(self.parent().settings, "use_google_stt", False)  # type: ignore[attr-defined]
        except Exception:
            use_stt = False
        if not use_stt:
            return
        # If google speech is unavailable, warn once and return
        if gspeech is None:
            logger.warning("[STT] google-cloud-speech not installed; STT disabled")
            return
        def _worker() -> None:
            text = ""
            try:
                client = gspeech.SpeechClient()
                with open(wav_path, "rb") as f:
                    audio = gspeech.RecognitionAudio(content=f.read())
                cfg = gspeech.RecognitionConfig(
                    encoding=gspeech.RecognitionConfig.AudioEncoding.LINEAR16,
                    sample_rate_hertz=16000,
                    language_code="en-US",
                    enable_automatic_punctuation=True,
                )
                resp = client.recognize(config=cfg, audio=audio)
                text = " ".join(a.alternatives[0].transcript for a in resp.results)
            except Exception as e:
                logger.error("[STT] Google error: %s", e)
            try:
                self.transcribed.emit(text)
            except Exception:
                pass
        threading.Thread(target=_worker, daemon=True, name="stt-worker").start()

class GoogleListener(QtCore.QThread):
    transcribed = QtCore.pyqtSignal(str)

    def __init__(self, parent: Optional[QtCore.QObject] = None) -> None:
        super().__init__(parent)
        self._running = False
        self._pa = None
        self._stream = None

    def run(self) -> None:
        if gspeech is None or pyaudio is None:
            return
        self._running = True
        self._pa = pyaudio.PyAudio()
        self._stream = self._pa.open(format=pyaudio.paInt16, channels=1, rate=16000, input=True, frames_per_buffer=8000)
        client = gspeech.SpeechClient()
        config = gspeech.RecognitionConfig(
            encoding=gspeech.RecognitionConfig.AudioEncoding.LINEAR16,
            sample_rate_hertz=16000,
            language_code="en-US",
        )
        streaming_config = gspeech.StreamingRecognitionConfig(config=config, interim_results=True)
        while self._running:
            data = self._stream.read(4000)
            requests = (gspeech.StreamingRecognizeRequest(audio_content=data) for _ in range(1))
            responses = client.streaming_recognize(streaming_config, requests)
            for resp in responses:
                if resp.results:
                    result = resp.results[0]
                    if result.is_final:
                        self.transcribed.emit(result.alternatives[0].transcript)
        if self._stream:
            self._stream.stop_stream()
            self._stream.close()
        if self._pa:
            self._pa.terminate()

    def stop_listener(self) -> None:
        self._running = False

# ──────────────────────────────────────────────────────────────────────────────
# Datasets + RAG
# ──────────────────────────────────────────────────────────────────────────────
@dataclass
class DatasetEntry:
    name: str
    path: str  # path to dataset folder
    active: bool = True

class DatasetManager(QtCore.QObject):
    datasetsChanged = QtCore.pyqtSignal()

    def __init__(self, base_dir: str, persona: str, set_name: str) -> None:
        super().__init__()
        self.base_dir = base_dir
        self.persona = persona
        self.set_name = set_name
        self.datasets_dir = prof_datasets_dir(base_dir, persona, set_name)
        os.makedirs(self.datasets_dir, exist_ok=True)
        self.index_path = os.path.join(self.datasets_dir, "index.json")
        self.entries: Dict[str, DatasetEntry] = {}
        self.load_index()

    def load_index(self) -> None:
        self.entries.clear()
        if not os.path.isfile(self.index_path):
            return
        try:
            with open(self.index_path, "r", encoding="utf-8") as f:
                data = json.load(f)
            for name, info in data.items():
                # Force canonical path inside this set
                self.entries[name] = DatasetEntry(
                    name=name, path=os.path.join(self.datasets_dir, name), active=bool(info.get("active", True))
                )
        except Exception as e:
            logger.error("[Datasets] load_index error: %s", e)

    def save_index(self) -> None:
        try:
            data = {name: {"path": e.path, "active": e.active} for name, e in self.entries.items()}
            with open(self.index_path, "w", encoding="utf-8") as f:
                json.dump(data, f, indent=2)
        except Exception as e:
            logger.error("[Datasets] save_index error: %s", e)
        QtCore.QTimer.singleShot(50, self.datasetsChanged.emit)

    def _ds_files_dir(self, name: str) -> str:
        return os.path.join(self.datasets_dir, name, "files")

    def add_dataset(self, name: str, file_path: str) -> None:
        """
        Create or extend a dataset. Copies the file into datasets/<name>/files/.
        Supports .txt and .pdf. Subsequent calls with the same name append files.
        """
        if not name.strip():
            raise ValueError("Dataset name cannot be empty")
        ds_folder = os.path.join(self.datasets_dir, name)
        files_dir = self._ds_files_dir(name)
        os.makedirs(files_dir, exist_ok=True)
        if not os.path.exists(file_path):
            raise FileNotFoundError(file_path)
        dest_path = os.path.join(files_dir, os.path.basename(file_path))
        shutil.copy2(file_path, dest_path)
        if name not in self.entries:
            self.entries[name] = DatasetEntry(name=name, path=ds_folder, active=True)
        self.save_index()

    def delete_dataset(self, name: str) -> None:
        if name not in self.entries:
            raise ValueError(f"Dataset '{name}' does not exist")
        shutil.rmtree(os.path.join(self.datasets_dir, name), ignore_errors=True)
        del self.entries[name]
        self.save_index()

    def toggle_active(self, name: str, active: bool) -> None:
        if name in self.entries:
            self.entries[name].active = active
            self.save_index()

    def get_active_datasets(self) -> List[DatasetEntry]:
        return [e for e in self.entries.values() if e.active]

    def get_active_entries(self) -> List[DatasetEntry]:
        return self.get_active_datasets()

    def load_dataset_texts(self, entry: DatasetEntry) -> List[Tuple[str, str]]:
        """
        Returns list of (text, source_file_path). Aggregates all .txt/.pdf files.
        """
        out: List[Tuple[str, str]] = []
        files_dir = self._ds_files_dir(entry.name)
        if not os.path.isdir(files_dir):
            return out
        for fn in sorted(os.listdir(files_dir)):
            p = os.path.join(files_dir, fn)
            if not os.path.isfile(p):
                continue
            ext = os.path.splitext(p)[1].lower()
            if ext == ".txt":
                try:
                    with open(p, "r", encoding="utf-8", errors="ignore") as f:
                        out.append((f.read(), p))
                except Exception:
                    continue
            elif ext == ".pdf" and PdfReader is not None:
                out.append((self._extract_pdf_text(p), p))
        return out

    def _extract_pdf_text(self, path: str) -> str:
        try:
            reader = PdfReader(path)
            out: List[str] = []
            for p in reader.pages:
                try:
                    out.append(p.extract_text() or "")
                except Exception:
                    continue
            return "\n".join(out)
        except Exception as e:
            logger.error("[Datasets] PDF error: %s", e)
            return ""

class RAGCache:
    """
    Per-dataset embedding cache and query. Uses sentence-transformers if available,
    otherwise best-effort Ollama embeddings. Tracks source file mtimes for invalidation.
    """
    def __init__(self, model: Optional[Any], model_name: str, datasets_root: str) -> None:
        self.model = model
        self.model_name = model_name
        self.datasets_root = datasets_root
        self._mem: Dict[str, Dict[str, Any]] = {}

    @staticmethod
    def _chunk_text(text: str, source: str, target_chars: int = 1200, overlap: int = 150) -> List[Tuple[str, str]]:
        paras = [p.strip() for p in text.split("\n") if p.strip()]
        if not paras:
            return [(text[:target_chars], source)]
        chunks: List[Tuple[str, str]] = []
        buf = ""
        for p in paras:
            if len(buf) + len(p) + 1 <= target_chars:
                buf = (buf + "\n" + p) if buf else p
            else:
                if buf:
                    chunks.append((buf, source))
                tail = buf[-overlap:] if overlap and buf else ""
                buf = (tail + "\n" + p).strip()
        if buf:
            chunks.append((buf, source))
        return chunks

    def _cache_paths(self, dataset_entry: DatasetEntry) -> Tuple[str, str, str]:
        folder = dataset_entry.path
        base = f"embeddings_{self.model_name}.np"
        meta = f"embeddings_{self.model_name}.meta.json"
        sents = f"embeddings_{self.model_name}.sentences.json"
        return (os.path.join(folder, base), os.path.join(folder, meta), os.path.join(folder, sents))

    def _encode_st(self, sentences: List[str]) -> Optional["np.ndarray"]:
        if self.model is None or np is None:
            return None
        try:
            embs = self.model.encode(sentences, convert_to_numpy=True, normalize_embeddings=True)
            if isinstance(embs, list):
                embs = np.array(embs)
            return embs
        except TypeError:
            try:
                embs = self.model.encode(sentences, convert_to_numpy=True)
                if isinstance(embs, list):
                    embs = np.array(embs)
                norms = np.linalg.norm(embs, axis=1, keepdims=True) + 1e-12
                return embs / norms
            except Exception:
                return None
        except Exception:
            return None

    def _encode_ollama(self, sentences: List[str]) -> Optional["np.ndarray"]:
        if np is None or not _have_cli("ollama"):
            return None
        model = "mxbai-embed-large:latest"
        try:
            all_vecs: List[List[float]] = []
            for s in sentences:
                proc = subprocess.run(["ollama", "embed", "-m", model, s],
                                      stdout=subprocess.PIPE, stderr=subprocess.PIPE, timeout=60)
                if proc.returncode != 0:
                    logger.warning("[RAG] ollama embed error: %s", proc.stderr.decode("utf-8", "ignore"))
                    return None
                out = proc.stdout.decode("utf-8", "ignore").strip()
                try:
                    js = json.loads(out)
                    vec = js.get("embedding") or (js.get("embeddings") or [None])[0]
                    if not isinstance(vec, list):
                        return None
                    all_vecs.append([float(x) for x in vec])
                except Exception:
                    return None
            arr = np.array(all_vecs, dtype=np.float32)
            norms = np.linalg.norm(arr, axis=1, keepdims=True) + 1e-12
            return arr / norms
        except Exception as e:
            logger.warning("[RAG] ollama embed exception: %s", e)
            return None

    def _encode(self, sentences: List[str]) -> Optional["np.ndarray"]:
        embs = self._encode_st(sentences)
        if embs is not None:
            return embs
        return self._encode_ollama(sentences)

    def _encode_query(self, text: str) -> Optional["np.ndarray"]:
        if np is None:
            return None
        if self.model is not None:
            try:
                q = self.model.encode([text], convert_to_numpy=True, normalize_embeddings=True)
            except TypeError:
                q = self.model.encode([text], convert_to_numpy=True)
                norms = np.linalg.norm(q, axis=1, keepdims=True) + 1e-12
                q = q / norms
            except Exception:
                q = None
            if isinstance(q, list):
                q = np.array(q)
            return q[0] if isinstance(q, np.ndarray) else None
        vec = self._encode_ollama([text])
        if vec is None:
            return None
        return vec[0]

    def _collect_texts(self, loader: DatasetManager, entry: DatasetEntry) -> Tuple[List[str], List[str], Dict[str, float]]:
        texts: List[str] = []
        provenance: List[str] = []
        mtimes: Dict[str, float] = {}
        for text, src in loader.load_dataset_texts(entry):
            chunks = self._chunk_text(text, src)
            for t, s in chunks:
                texts.append(t)
                provenance.append(s)
            try:
                mtimes[src] = os.path.getmtime(src)
            except Exception:
                mtimes[src] = 0.0
        return texts, provenance, mtimes

    def _needs_rebuild(self, entry: DatasetEntry, source_mtimes: Dict[str, float]) -> bool:
        cache_path, meta_path, sents_path = self._cache_paths(entry)
        if not (os.path.isfile(cache_path) and os.path.isfile(meta_path) and os.path.isfile(sents_path)):
            return True
        try:
            with open(meta_path, "r", encoding="utf-8") as f:
                meta = json.load(f)
            cached = meta.get("source_mtimes", {})
            return any(abs(cached.get(p, 0.0) - mt) > 1e-6 for p, mt in source_mtimes.items()) or \
                   any(p not in cached for p in source_mtimes.keys())
        except Exception:
            return True

    def load_or_build(self, loader: DatasetManager, entry: DatasetEntry) -> Optional[Dict[str, Any]]:
        if np is None:
            return None
        key = entry.path
        if key in self._mem:
            return self._mem[key]

        texts, provenance, mtimes = self._collect_texts(loader, entry)
        cache_path, meta_path, sents_path = self._cache_paths(entry)

        if not self._needs_rebuild(entry, mtimes):
            try:
                data = np.load(cache_path, allow_pickle=False)
                with open(sents_path, "r", encoding="utf-8") as f:
                    sentences = json.load(f)
                with open(meta_path, "r", encoding="utf-8") as f:
                    meta = json.load(f)
                emb = data["emb"]
                prov = meta.get("provenance", [""] * len(sentences))
                self._mem[key] = {"sentences": sentences, "emb": emb, "provenance": prov}
                return self._mem[key]
            except Exception:
                pass

        if not texts:
            self._mem[key] = {"sentences": [], "emb": np.zeros((0, 1)) if np is not None else [], "provenance": []}
            return self._mem[key]

        emb = self._encode(texts)
        if emb is None:
            return None
        self._mem[key] = {"sentences": texts, "emb": emb, "provenance": provenance}
        try:
            np.savez_compressed(cache_path, emb=emb)
            with open(sents_path, "w", encoding="utf-8") as f:
                json.dump(texts, f)
            with open(meta_path, "w", encoding="utf-8") as f:
                json.dump({"provenance": provenance, "source_mtimes": mtimes}, f)
        except Exception:
            pass
        return self._mem[key]

    def clear_memory(self) -> None:
        self._mem.clear()

    def clear_disk(self) -> int:
        count = 0
        try:
            for root, _dirs, files in os.walk(self.datasets_root):
                for fn in files:
                    if fn.startswith("embeddings_") and (fn.endswith(".npz") or fn.endswith(".json")):
                        try:
                            os.remove(os.path.join(root, fn))
                            count += 1
                        except Exception:
                            pass
        except Exception:
            pass
        return count

    def query(self, loader: DatasetManager, entry: DatasetEntry, query_text: str, top_k: int = 5) -> List[Tuple[str, float, str, str]]:
        if np is None:
            return []
        emb_info = self.load_or_build(loader, entry)
        if emb_info is None:
            return []
        sentences = emb_info["sentences"]
        prov = emb_info["provenance"]
        if not sentences:
            return []
        q = self._encode_query(query_text)
        if q is None:
            return []
        scores = np.dot(emb_info["emb"], q)
        idx = scores.argsort()[-top_k:][::-1]
        return [(sentences[i], float(scores[i]), entry.name, prov[i]) for i in idx]

    def search_all(self, managers_and_entries: List[Tuple[DatasetManager, List[DatasetEntry]]],
                   query_text: str, per_ds_k: int = 5, limit: int = 10) -> List[Tuple[str, float, str, str]]:
        hits: List[Tuple[str, float, str, str]] = []
        for mgr, entries in managers_and_entries:
            for e in entries:
                hits.extend(self.query(mgr, e, query_text, top_k=per_ds_k))
        hits.sort(key=lambda x: x[1], reverse=True)
        return hits[:limit]

# ──────────────────────────────────────────────────────────────────────────────
# Context → Schema evolution
# ──────────────────────────────────────────────────────────────────────────────
class ContextMonitor:
    def __init__(self, depth: int = 20) -> None:
        self.depth = depth
        self.context: List[Tuple[str, str]] = []

    def add_message(self, speaker: str, text: str) -> None:
        self.context.append((speaker, text))
        if len(self.context) > self.depth:
            self.context.pop(0)

    def analyze(self) -> Dict[str, Any]:
        tone = self._detect_tone()
        directives = self._extract_directives()
        keywords = self._find_keywords()
        return {"tone": tone, "directives": directives, "keywords": keywords}

    def _detect_tone(self) -> str:
        text = " ".join([t.lower() for _, t in self.context])
        pos = sum(k in text for k in ["happy", "excited", "good", "great", "awesome"])
        neg = sum(k in text for k in ["sad", "angry", "bad", "terrible", "frustrated"])
        if pos > neg: return "positive"
        if neg > pos: return "negative"
        return "neutral"

    def _extract_directives(self) -> List[str]:
        d: List[str] = []
        for _, text in self.context:
            for m in re.findall(r'\b(?:please\s+)?(?:add|set|enable|disable|remember|inject|rewrite)\b(.*)', text, re.I):
                d.append(m.strip())
            for m in re.findall(r'\byou (need to|must|should)\b (.*)', text, re.I):
                d.append(m[1].strip())
        return d

    def _find_keywords(self) -> List[str]:
        text = " ".join([t for _, t in self.context])
        words = re.findall(r'\b\w+\b', text.lower())
        return sorted(set([w for w in words if len(w) > 3]))

class SchemaAutoUpdater:
    def __init__(self, mgr: SchemaManager, persona: str, set_name: str) -> None:
        self.mgr = mgr
        self.persona = persona
        self.set_name = set_name
        self._last_update_ts: float = 0.0
        self._min_interval = 2.0  # seconds; guard against rapid churn

    def update_with_context(self, analysis: Dict[str, Any]) -> None:
        now = time.time()
        if now - self._last_update_ts < self._min_interval:
            return
        self._last_update_ts = now
        schema = self.mgr.load_schema(self.persona, self.set_name)
        for d in analysis.get("directives", []):
            self._apply_directive(schema, d)
        self.mgr.save_schema(self.persona, self.set_name, schema)

    def _apply_directive(self, schema: Dict[str, Any], directive: str) -> None:
        low = directive.lower()
        if "add trait" in low:
            trait = directive.split("add trait", 1)[-1].strip()
            overlay = dict(schema.get("dynamic_overlay", {}))
            traits = list(overlay.get("added_traits", []))
            if trait and trait not in traits: traits.append(trait)
            overlay["added_traits"] = traits
            schema["dynamic_overlay"] = overlay
        elif "add action" in low:
            action = directive.split("add action", 1)[-1].strip()
            actions = list(schema.get("actions", []))
            if action and action not in actions: actions.append(action)
            schema["actions"] = actions
        elif "add question" in low:
            q = directive.split("add question", 1)[-1].strip()
            qs = list(schema.get("questions", []))
            if q and q not in qs: qs.append(q)
            schema["questions"] = qs
        elif "reflect" in low or "think" in low:
            st = list(schema.get("self_talk", []))
            ref = f"Reflect: {directive}"
            if ref not in st: st.append(ref)
            schema["self_talk"] = st
        # C-5: Directive-to-Command expansion
        if "add command" in low:
            parts = directive.split()
            if len(parts) >= 3 and parts[2].startswith("/"):
                cmd = parts[2]
                value = " ".join(parts[3:])
                cmds = dict(schema.get("commands", {}))
                arr = list(cmds.get(cmd, []))
                if value:
                    arr.append(value)
                cmds[cmd] = arr
                schema["commands"] = cmds
        elif "delete command" in low:
            parts = directive.split()
            if len(parts) >= 3 and parts[2].startswith("/"):
                cmd = parts[2]
                cmds = dict(schema.get("commands", {}))
                cmds.pop(cmd, None)
                schema["commands"] = cmds
        elif "rewrite command" in low:
            parts = directive.split(maxsplit=3)
            if len(parts) >= 4 and parts[2].startswith("/"):
                cmd = parts[2]
                value = parts[3]
                cmds = dict(schema.get("commands", {}))
                if cmd in cmds:
                    cmds[cmd] = [value]
                schema["commands"] = cmds

# ──────────────────────────────────────────────────────────────────────────────
# Command registry (+weights/locks) & executor
# ──────────────────────────────────────────────────────────────────────────────
class CommandRegistry(QtCore.QObject):
    commandsChanged = QtCore.pyqtSignal()
    commandWeightsChanged = QtCore.pyqtSignal()

    def __init__(self, base_dir: str, persona: str, set_name: str) -> None:
        super().__init__()
        self.base_dir = base_dir
        self.persona = persona
        self.set_name = set_name
        self.path = prof_commands_path(base_dir, persona, set_name)
        self.commands: Dict[str, Dict[str, Any]] = {}
        self._load()
        for cmd in [
            "/remember", "/inject", "/rewrite", "/show", "/action", "/trait",
            "/dataset", "/search", "/embeddings", "/schema",
            "/tts", "/plugin", "/feedback", "/lock", "/commands",
            # Moderation & shaping
            "/reject", "/auto", "/ignore", "/opposite", "/delete",
            # Experimental fine-tuning / tokenizer commands
            "/applylora", "/patchtokenizer", "/datasetfromtext",
            # Spatial room
            "/enterroom", "/move",
        ]:
            self.register_command(cmd)

    def _load(self) -> None:
        try:
            if os.path.isfile(self.path):
                with open(self.path, "r", encoding="utf-8") as f:
                    data = json.load(f)
                self.commands = dict(data.get("commands", {}))
        except Exception:
            self.commands = {}

    def _save(self) -> None:
        try:
            os.makedirs(os.path.dirname(self.path), exist_ok=True)
            with open(self.path, "w", encoding="utf-8") as f:
                json.dump({"commands": self.commands}, f, indent=2)
        except Exception as e:
            logger.error("[CommandRegistry] save error: %s", e)
        QtCore.QTimer.singleShot(50, self.commandsChanged.emit)
        QtCore.QTimer.singleShot(50, self.commandWeightsChanged.emit)

    def register_command(self, name: str) -> None:
        if name not in self.commands:
            self.commands[name] = {"weight": 0, "locked": False}
            self._save()

    def register_from_schema(self, schema: Dict[str, Any]) -> None:
        try:
            for name in (schema.get("commands") or {}).keys():
                if isinstance(name, str) and name.startswith("/"):
                    self.register_command(name)
        except Exception:
            pass

    def set_weight(self, name: str, weight: int) -> None:
        if name in self.commands and not self.commands[name].get("locked", False):
            self.commands[name]["weight"] = int(weight)
            self._save()

    def toggle_lock(self, name: str, state: Optional[bool] = None) -> None:
        if name in self.commands:
            cur = bool(self.commands[name].get("locked", False))
            self.commands[name]["locked"] = (not cur) if state is None else bool(state)
            self._save()

    def get_weight(self, name: str) -> int:
        return int(self.commands.get(name, {}).get("weight", 0))

    def is_locked(self, name: str) -> bool:
        return bool(self.commands.get(name, {}).get("locked", False))

    def list_commands(self) -> List[str]:
        return sorted(self.commands.keys())

    def score_commands(self) -> Dict[str, float]:
        scores = {}
        for name in self.commands:
            bean_total = self.beans.counts.get(f"cmd_{name}", 0)  # assuming self.beans is accessible
            score = self.commands[name]["weight"] + (bean_total * 0.1)  # WEIGHT_FACTOR = 0.1
            scores[name] = score
        return scores

class CommandExecutor:
    """
    Executes slash commands and integrates with schema + registry + reinforcement.
    """
    def __init__(self, registry: CommandRegistry, schema_mgr: SchemaManager,
                 schema_updater: SchemaAutoUpdater, beans: BeanCounter,
                 dataset_mgr: DatasetManager, rag: "RAGCache",
                 settings: Settings, plugins: "PluginManager",
                 core_ref: "AgentCore") -> None:
        self.registry = registry
        self.schema_mgr = schema_mgr
        self.schema_updater = schema_updater
        self.beans = beans
        self.dataset_mgr = dataset_mgr
        self.rag = rag
        self.settings = settings
        self.plugins = plugins
        self.core_ref = core_ref

    @staticmethod
    def _strip_quotes(s: str) -> str:
        s = (s or "").strip()
        if len(s) >= 2 and ((s[0] == s[-1] == "'") or (s[0] == s[-1] == '"')):
            return s[1:-1]
        return s

    def _add_schema_command_value(self, schema: Dict[str, Any], cmd: str, text: str) -> None:
        cmds = dict(schema.get("commands") or {})
        arr = list(cmds.get(cmd, []))
        if text and text not in arr:
            arr.append(text)
        cmds[cmd] = arr
        schema["commands"] = cmds

    def execute(self, command_line: str) -> str:
        cmd, args = self._parse(command_line)
        if not cmd:
            return "No command provided."
        try:
            self.registry.set_weight(cmd, self.registry.get_weight(cmd) + 1)
        except Exception:
            pass
        if self.registry.is_locked(cmd):
            return f"Command '{cmd}' is locked."
        try:
            if cmd == "/remember":        return self._remember(args)
            if cmd == "/inject":          return self._inject(args)
            if cmd == "/rewrite":         return self._rewrite(args)
            if cmd == "/reject":          return self._reject(args)
            if cmd == "/auto":            return self._auto(args)
            if cmd == "/ignore":          return self._ignore(args)
            if cmd == "/opposite":        return self._opposite(args)
            if cmd == "/delete":          return self._delete(args)
            if cmd == "/applylora":       return self._applylora(args)
            if cmd == "/patchtokenizer":  return self._patchtokenizer(args)
            if cmd == "/datasetfromtext": return self._datasetfromtext(args)
            if cmd == "/show":            return self._show(args)
            if cmd == "/action":          return self._action(args)
            if cmd == "/trait":           return self._trait(args)
            if cmd == "/dataset":         return self._dataset(args)
            if cmd == "/search":          return self._search(args)
            if cmd == "/embeddings":      return self._embeddings(args)
            if cmd == "/schema":          return self._schema(args)
            if cmd == "/tts":             return self._tts(args)
            if cmd == "/plugin":          return self._plugin(args)
            if cmd == "/feedback":        return self._feedback(args)
            if cmd == "/lock":            return self._lock(args)
            if cmd == "/commands":        return self._commands(args)
            # C-8
            if cmd == "/enterroom":       return self._enterroom(args)
            if cmd == "/move":            return self._move(args)
            return f"Command '{cmd}' executed (no-op)."
        finally:
            # Increment reinforcement count for this command
            try:
                self.beans.increment(f"cmd_{cmd}", 1)
            except Exception:
                pass
            # Update command weight based on usage reinforcement
            try:
                cnt = self.beans.counts.get(f"cmd_{cmd}", 0)
                self.registry.set_weight(cmd, cnt)
            except Exception:
                pass

    def _parse(self, line: str) -> Tuple[str, str]:
        line = (line or "").strip()
        if not line.startswith("/"):
            return "", ""
        parts = line.split(maxsplit=1)
        cmd = parts[0].strip()
        rest = parts[1] if len(parts) > 1 else ""
        if cmd.startswith("/action_"): cmd = "/action"
        if cmd.startswith("/trait_"):  cmd = "/trait"
        return cmd, rest

    # Core handlers
    def _remember(self, args: str) -> str:
        trait = self._strip_quotes(args) or "remembered"
        schema = self.schema_mgr.load_schema(self.schema_updater.persona, self.schema_updater.set_name)
        overlay = dict(schema.get("dynamic_overlay", {}))
        traits = list(overlay.get("added_traits", []))
        if trait not in traits:
            traits.append(trait)
        overlay["added_traits"] = traits
        schema["dynamic_overlay"] = overlay
        self._add_schema_command_value(schema, "/remember", trait)
        self.schema_mgr.save_schema(self.schema_updater.persona, self.schema_updater.set_name, schema)
        return f"Remembered: {trait}"

    def _inject(self, args: str) -> str:
        note = self._strip_quotes(args) or "injected-change"
        schema = self.schema_mgr.load_schema(self.schema_updater.persona, self.schema_updater.set_name)
        st = list(schema.get("self_talk", []))
        if note not in st:
            st.append(note)
        schema["self_talk"] = st
        self._add_schema_command_value(schema, "/inject", note)
        self.schema_mgr.save_schema(self.schema_updater.persona, self.schema_updater.set_name, schema)
        return f"Injected: {note}"

    def _rewrite(self, args: str) -> str:
        phrase = self._strip_quotes(args)
        schema = self.schema_mgr.load_schema(self.schema_updater.persona, self.schema_updater.set_name)
        rp = list(schema.get("rewrite_prompts", []))
        if phrase and phrase not in rp:
            rp.append(phrase)
        schema["rewrite_prompts"] = rp
        if phrase:
            self._add_schema_command_value(schema, "/rewrite", phrase)
        self.schema_mgr.save_schema(self.schema_updater.persona, self.schema_updater.set_name, schema)
        return "Rewrite behavior updated."

    def _reject(self, args: str) -> str:
        text = self._strip_quotes(args) or "rejected"
        schema = self.schema_mgr.load_schema(self.schema_updater.persona, self.schema_updater.set_name)
        dislikes = list(schema.get("dislikes", []))
        if text not in dislikes:
            dislikes.append(text)
        schema["dislikes"] = dislikes
        self._add_schema_command_value(schema, "/reject", text)
        self.beans.increment(f"rej_{abs(hash(text))%10007}", -1)
        self.schema_mgr.save_schema(self.schema_updater.persona, self.schema_updater.set_name, schema)
        return f"Rejected: {text}"

    def _auto(self, args: str) -> str:
        text = self._strip_quotes(args) or "auto"
        schema = self.schema_mgr.load_schema(self.schema_updater.persona, self.schema_updater.set_name)
        events = list(schema.get("events", []))
        mark = f"AUTO: {text}"
        if mark not in events:
            events.append(mark)
        schema["events"] = events
        self._add_schema_command_value(schema, "/auto", text)
        self.schema_mgr.save_schema(self.schema_updater.persona, self.schema_updater.set_name, schema)
        return f"Auto behavior noted: {text}"

    def _ignore(self, args: str) -> str:
        text = self._strip_quotes(args) or "ignore"
        schema = self.schema_mgr.load_schema(self.schema_updater.persona, self.schema_updater.set_name)
        tone = dict(schema.get("tone_rules", {}))
        avoid = list(tone.get("avoid", []))
        if text not in avoid:
            avoid.append(text)
        tone["avoid"] = avoid
        schema["tone_rules"] = tone
        dislikes = list(schema.get("dislikes", []))
        if text not in dislikes:
            dislikes.append(text)
        schema["dislikes"] = dislikes
        self._add_schema_command_value(schema, "/ignore", text)
        self.schema_mgr.save_schema(self.schema_updater.persona, self.schema_updater.set_name, schema)
        return f"Ignoring: {text}"

    def _opposite(self, args: str) -> str:
        text = self._strip_quotes(args) or "opposite"
        schema = self.schema_mgr.load_schema(self.schema_updater.persona, self.schema_updater.set_name)
        tone = dict(schema.get("tone_rules", {}))
        opp = list(tone.get("opposites", []))
        if text not in opp:
            opp.append(text)
        tone["opposites"] = opp
        schema["tone_rules"] = tone
        self._add_schema_command_value(schema, "/opposite", text)
        rps = list(schema.get("rewrite_prompts", []))
        guide = f"Prefer the opposite of: {text}"
        if guide not in rps:
            rps.append(guide)
        schema["rewrite_prompts"] = rps
        self.schema_mgr.save_schema(self.schema_updater.persona, self.schema_updater.set_name, schema)
        return f"Will prefer the opposite of: {text}"

    def _delete(self, args: str) -> str:
        text = self._strip_quotes(args) or "delete"
        schema = self.schema_mgr.load_schema(self.schema_updater.persona, self.schema_updater.set_name)
        overlay = dict(schema.get("dynamic_overlay", {}))
        deletions = list(overlay.get("delete_targets", []))
        if text not in deletions:
            deletions.append(text)
        overlay["delete_targets"] = deletions
        schema["dynamic_overlay"] = overlay
        self._add_schema_command_value(schema, "/delete", text)
        self.schema_mgr.save_schema(self.schema_updater.persona, self.schema_updater.set_name, schema)
        return f"Marked for deletion: {text}"

    def _show(self, args: str) -> str:
        key = (args or "").strip().lower()
        if key == "facts":
            tops = sorted(self.beans.counts.items(), key=lambda kv: kv[1], reverse=True)[:10]
            if not tops:
                return "No facts yet."
            return "Top facts:\n" + "\n".join([f"• {k}: {v}" for k, v in tops])
        return "Unknown /show argument. Try '/show facts'."

    def _action(self, args: str) -> str:
        action = self._strip_quotes(args) or "action"
        schema = self.schema_mgr.load_schema(self.schema_updater.persona, self.schema_updater.set_name)
        actions = list(schema.get("actions", []))
        if action not in actions:
            actions.append(action)
        schema["actions"] = actions
        self.schema_mgr.save_schema(self.schema_updater.persona, self.schema_updater.set_name, schema)
        return f"Action added: {action}"

    def _trait(self, args: str) -> str:
        trait = self._strip_quotes(args) or "trait"
        schema = self.schema_mgr.load_schema(self.schema_updater.persona, self.schema_updater.set_name)
        overlay = dict(schema.get("dynamic_overlay", {}))
        traits = list(overlay.get("added_traits", []))
        if trait not in traits:
            traits.append(trait)
        overlay["added_traits"] = traits
        schema["dynamic_overlay"] = overlay
        self.schema_mgr.save_schema(self.schema_updater.persona, self.schema_updater.set_name, schema)
        return f"Trait added: {trait}"

    # Data/system
    def _dataset(self, args: str) -> str:
        parts = args.split()
        if not parts:
            return "Usage: /dataset add|delete|toggle|list ..."
        sub = parts[0].lower()
        try:
            if sub == "add" and len(parts) >= 3:
                name = parts[1]
                path = " ".join(parts[2:])
                self.dataset_mgr.add_dataset(name, path)
                self.rag.clear_memory()
                return f"Dataset '{name}' updated with file '{path}'."
            if sub == "delete" and len(parts) == 2:
                name = parts[1]
                self.dataset_mgr.delete_dataset(name)
                self.rag.clear_memory()
                return f"Dataset '{name}' deleted."
            if sub == "toggle" and len(parts) == 3:
                name = parts[1]
                on = parts[2].lower() in {"on", "true", "1", "enable", "enabled"}
                self.dataset_mgr.toggle_active(name, on)
                return f"Dataset '{name}' set to {'active' if on else 'inactive'}."
            if sub == "list":
                items = self.dataset_mgr.entries
                if not items:
                    return "No datasets."
                return "Datasets:\n" + "\n".join([f"• {n} [{'ON' if e.active else 'off'}]" for n, e in sorted(items.items())])
        except Exception as e:
            return f"Dataset error: {e}"
        return "Usage: /dataset add <name> <path> | delete <name> | toggle <name> on|off | list"

    def _search(self, args: str) -> str:
        q = args.strip()
        if not q:
            return "Usage: /search <query>"
        packs: List[Tuple[DatasetManager, List[DatasetEntry]]] = []
        packs.append((self.dataset_mgr, self.dataset_mgr.get_active_datasets()))
        shared = self.schema_mgr.get_shared_datasets(self.schema_updater.persona, self.schema_updater.set_name)
        if shared:
            owners: Dict[Tuple[str, str], List[DatasetEntry]] = {}
            for e in shared:
                try:
                    rel = os.path.relpath(e.path, self.dataset_mgr.base_dir).replace("\\", "/")
                    parts = rel.split("/")
                    idx = parts.index("profiles")
                    other_persona = parts[idx+1]
                    other_set = parts[idx+2]
                except Exception:
                    continue
                owners.setdefault((other_persona, other_set), []).append(e)
            for key, ents in owners.items():
                p, s = key
                packs.append((DatasetManager(self.base_dir, p, s), ents))
        hits = self.rag.search_all(packs, q, per_ds_k=4, limit=10)
        if not hits:
            return "No results."
        lines = []
        for chunk, score, ds, prov in hits:
            lines.append(f"[{ds}] {os.path.basename(prov)} (score={score:.3f})\n{chunk[:300].strip()}...")
        return "\n\n".join(lines)

    def _embeddings(self, args: str) -> str:
        sub = (args or "").strip().lower()
        if sub == "clear":
            n = self.rag.clear_disk()
            self.rag.clear_memory()
            return f"Cleared {n} embedding cache files."
        return "Usage: /embeddings clear"

    def _schema(self, args: str) -> str:
        parts = args.split()
        if not parts:
            return "Usage: /schema set <persona> <set> | awareness on|off | active"
        sub = parts[0].lower()
        if sub == "set" and len(parts) == 3:
            persona, set_name = parts[1].lower(), parts[2]
            if persona not in self.schema_mgr.personas:
                return f"Unknown persona '{persona}'"
            if set_name not in self.schema_mgr.get_set_list(persona):
                os.makedirs(os.path.join(self.schema_mgr.schemas_dir, persona, "sets", set_name), exist_ok=True)
                sch = self.schema_mgr.load_schema(persona, "default")
                self.schema_mgr.save_schema(persona, set_name, sch)
            active = dict(self.schema_mgr.active_schemas)
            active[persona] = set_name
            self.schema_mgr.save_active_schemas(active)
            self.core_ref.switch_persona_set(persona if persona == self.core_ref.persona else None,
                                             set_name if persona == self.core_ref.persona else None)
            return f"Active schema set: {persona}/{set_name}"
        if sub == "awareness" and len(parts) == 2:
            on = parts[1].lower() in {"on", "true", "1", "enable", "enabled"}
            sch = self.schema_mgr.load_schema(self.schema_updater.persona, self.schema_updater.set_name)
            flags = dict(sch.get("flags") or {})
            flags["semantic_awareness"] = bool(on)
            sch["flags"] = flags
            sch["semantic_awareness_enabled"] = bool(on)
            self.schema_mgr.save_schema(self.schema_updater.persona, self.schema_updater.set_name, sch)
            return f"Semantic awareness {'enabled' if on else 'disabled'} for {self.schema_updater.persona}/{self.schema_updater.set_name}"
        if sub == "active":
            act = self.schema_mgr.active_schemas
            return "Active schemas:\n" + "\n".join([f"• {p}: {s}" for p, s in act.items()])
        return "Usage: /schema set <persona> <set> | awareness on|off | active"

    def _tts(self, args: str) -> str:
        parts = args.split()
        if not parts:
            return "Usage: /tts on|off | volume <0-100>"
        sub = parts[0].lower()
        if sub in {"on", "off"}:
            flag = sub == "on"
            self.settings.monologue_tts_enabled = flag
            self.settings.save()
            return f"TTS {'enabled' if flag else 'disabled'}."
        if sub == "volume" and len(parts) == 2:
            try:
                v = int(parts[1]); v = max(0, min(100, v))
                self.settings.monologue_volume = v
                self.settings.save()
                if self.core_ref.tts_mgr:
                    self.core_ref.tts_mgr.set_volume(v)
                return f"TTS volume set to {v}."
            except Exception:
                return "Volume must be integer 0-100."
        return "Usage: /tts on|off | volume <0-100>"

    def _plugin(self, args: str) -> str:
        parts = args.split()
        if not parts:
            return "Usage: /plugin enable|disable|list ..."
        sub = parts[0].lower()
        if sub == "list":
            metas = self.plugins.list_plugins()
            if not metas:
                return "No plugins found."
            lines = []
            for m in metas:
                missing = f" (missing: {','.join(m.missing_dependencies)})" if m.missing_dependencies else ""
                lines.append(f"• {m.name} v{m.version or '?'} [{'ON' if m.enabled else 'off'}]{missing}")
            return "\n".join(lines)
        if sub in {"enable", "disable"} and len(parts) == 2:
            name = parts[1]
            flag = sub == "enable"
            self.plugins.enable_plugin(name, flag)
            return f"Plugin '{name}' {'enabled' if flag else 'disabled'}."
        return "Usage: /plugin enable <name> | disable <name> | list"

    def _feedback(self, args: str) -> str:
        parts = args.split()
        if not parts:
            return "Usage: /feedback stats | export <path>"
        sub = parts[0].lower()
        if sub == "stats":
            pos, neg = self.core_ref.feedback_db.get_counts()
            return f"Feedback: {pos} 👍  /  {neg} 👎"
        if sub == "export" and len(parts) >= 2:
            out = " ".join(parts[1:])
            n = self.core_ref.feedback_db.export_jsonl(out)
            return f"Exported {n} feedback records to {out}."
        return "Usage: /feedback stats | export <path>"

    def _lock(self, args: str) -> str:
        parts = args.split()
        if len(parts) != 2:
            return "Usage: /lock <cmd> on|off"
        cmd, state = parts
        if cmd not in self.registry.commands:
            return f"Unknown command '{cmd}'"
        self.registry.toggle_lock(cmd, state.lower() in {"on", "true", "1"})
        return f"Command '{cmd}' lock set to {self.registry.is_locked(cmd)}."

    def _commands(self, args: str) -> str:
        if args.strip().lower() == "list":
            items = []
            for c in self.registry.list_commands():
                items.append(f"• {c} (weight={self.registry.get_weight(c)}, locked={self.registry.is_locked(c)})")
            return "\n".join(items) if items else "No commands."
        return "Usage: /commands list"

    def _enterroom(self, args: str) -> str:
        # Stub for spatial room
        return "Entered room."

    def _move(self, args: str) -> str:
        # Stub for spatial room
        return "Moved."

# ──────────────────────────────────────────────────────────────────────────────
# Plugin system
# ──────────────────────────────────────────────────────────────────────────────
class PluginMeta:
    def __init__(self, name: str, path: str) -> None:
        self.name = name
        self.path = path
        self.enabled: bool = False
        self.module: Optional[Any] = None
        self.widget: Optional[Any] = None
        self.version: Optional[str] = None
        self.entry_point: Optional[str] = None
        self.dependencies: List[str] = []
        self.default_enabled: bool = False
        self.missing_dependencies: List[str] = []
        self._parse_manifest()

    def _parse_manifest(self) -> None:
        manifest_path = os.path.join(self.path, "manifest.json")
        if not os.path.isfile(manifest_path):
            return
        try:
            with open(manifest_path, "r", encoding="utf-8") as f:
                data = json.load(f)
            self.version = data.get("version")
            self.entry_point = data.get("entry_point") or None
            deps = data.get("dependencies") or []
            if isinstance(deps, list):
                self.dependencies = [str(d) for d in deps if isinstance(d, str)]
            self.default_enabled = bool(data.get("default_enabled", False))
        except Exception as e:
            logger.error("[Plugin:%s] manifest error: %s", self.name, e)
            return
        for dep in self.dependencies:
            try:
                __import__(dep.replace('-', '_'))
            except Exception:
                self.missing_dependencies.append(dep)

    def load_module(self) -> None:
        if self.module is not None or self.missing_dependencies:
            return
        spec = None
        if self.entry_point:
            spec = self.entry_point if "." in self.entry_point else f"plugins.{self.entry_point}"
        else:
            spec = f"plugins.{self.name}"
        try:
            import importlib
            self.module = importlib.import_module(spec)
        except Exception as e:
            logger.error("[Plugin:%s] import error: %s", self.name, e)
            self.module = None

    def start(self, host: "PluginManager") -> None:
        if self.enabled:
            return
        self.load_module()
        if self.module is None:
            return
        try:
            if hasattr(self.module, "start"):
                self.widget = self.module.start(host)  # type: ignore
            self.enabled = True
        except Exception as e:
            logger.error("[Plugin:%s] start error: %s", self.name, e)
            self.enabled = False

    def stop(self) -> None:
        if not self.enabled or self.module is None:
            return
        try:
            if hasattr(self.module, "stop"):
                self.module.stop()  # type: ignore
        except Exception as e:
            logger.error("[Plugin:%s] stop error: %s", self.name, e)
        self.widget = None
        self.enabled = False

class PluginManager(QtCore.QObject):
    eventReceived = QtCore.pyqtSignal(str, dict)  # sender, envelope

    def __init__(self, base_dir: str, settings: Settings) -> None:
        super().__init__()
        self.base_dir = base_dir
        self.settings = settings
        self.plugins_dir = os.path.join(self.base_dir, "plugins")
        os.makedirs(self.plugins_dir, exist_ok=True)
        self._plugins: Dict[str, PluginMeta] = {}
        self.discover_plugins()

    def discover_plugins(self) -> None:
        self._plugins.clear()
        for entry in os.scandir(self.plugins_dir):
            if entry.is_dir():
                meta = PluginMeta(entry.name, entry.path)
                self._plugins[entry.name] = meta
        for name, meta in self._plugins.items():
            if name in self.settings.enabled_plugins or (not self.settings.enabled_plugins and meta.default_enabled):
                meta.enabled = True
                meta.start(self)

    def list_plugins(self) -> List[PluginMeta]:
        return list(self._plugins.values())

    def enable_plugin(self, name: str, flag: bool) -> None:
        meta = self._plugins.get(name)
        if not meta:
            return
        if flag and not meta.enabled:
            meta.start(self)
            if name not in self.settings.enabled_plugins:
                self.settings.enabled_plugins.append(name)
                self.settings.save()
        elif not flag and meta.enabled:
            meta.stop()
            if name in self.settings.enabled_plugins:
                self.settings.enabled_plugins.remove(name)
                self.settings.save()

    def rescan(self) -> None:
        self.discover_plugins()

    def broadcast(self, message: Any) -> None:
        envelope = message if (isinstance(message, dict) and "type" in message) else {"type": "command", "data": message}
        for meta in self._plugins.values():
            if not (meta.enabled and meta.module):
                continue
            try:
                if hasattr(meta.module, "on_command"):
                    try:
                        meta.module.on_command(envelope)  # type: ignore
                    except TypeError:
                        meta.module.on_command(envelope.get("data"))  # type: ignore
            except Exception as e:
                logger.error("[Plugin:%s] on_command error: %s", meta.name, e)

    def emit_event(self, sender: str, type: str, payload: Any) -> None:
        self.eventReceived.emit(sender, {"sender": sender, "type": type, "data": payload})

    def stop_all(self) -> None:
        for meta in self._plugins.values():
            try:
                meta.stop()
            except Exception:
                pass

# ──────────────────────────────────────────────────────────────────────────────
# Schema evolver using feedback (frequency + votes)
# ──────────────────────────────────────────────────────────────────────────────
class SchemaEvolver:
    def __init__(self, mgr: SchemaManager, feedback_db: SemanticFeedbackDB, memory_state: Dict[str, Any]) -> None:
        self.mgr = mgr
        self.feedback_db = feedback_db
        self.memory_state = memory_state
        self._protected = self.mgr._load_control_schema()
        self._last_success_ts = 0.0

    def update_schema(self, persona: str, set_name: str, history: List[Tuple[str, str]]) -> bool:
        try:
            tokens: List[str] = []
            for role, content in history[-12:]:
                tokens.extend([w.lower() for w in re.findall(r"\b\w+\b", content or "") if len(w) > 3])
            word_freq = Counter(tokens)
            pos_count, neg_count = self.feedback_db.get_counts()

            if (pos_count + neg_count) < 5 or pos_count <= neg_count or not word_freq:
                return False

            patch: Dict[str, Any] = {}
            schema = self.mgr.load_schema(persona, set_name)
            tone_rules = dict(schema.get("tone_rules", {}))
            avoid_words = set(tone_rules.get("avoid", []))
            top_words = [w for w, _ in word_freq.most_common(5) if w not in avoid_words]
            if top_words:
                tone_rules["preferred_words"] = top_words[:3]
                patch["tone_rules"] = tone_rules

            if patch and all(k not in self._protected for k in patch.keys()):
                schema.update(patch)
                self.mgr.save_schema(persona, set_name, schema)
                self._last_success_ts = time.time()
                return True
        except Exception as e:
            logger.error("[SchemaEvolver] error: %s", e)
        return False

# ──────────────────────────────────────────────────────────────────────────────
# FathomKernel self-rewriter (C-9)
# ──────────────────────────────────────────────────────────────────────────────
class FathomKernel:
    def __init__(self, base_dir: str) -> None:
        self.base_dir = base_dir

    def snapshot_codebase(self) -> Dict[str, str]:
        code = {}
        for root, _, files in os.walk(self.base_dir):
            for fn in files:
                if fn.endswith(".py"):
                    p = os.path.join(root, fn)
                    with open(p, "r", encoding="utf-8") as f:
                        code[p] = f.read()
        return code

    def lint_and_patch(self) -> None:
        # Use ruff for linting
        try:
            subprocess.run(["ruff", "check", "--fix", self.base_dir], check=False)
        except Exception:
            pass
        # For patch, stub: call ollama to rewrite
        pass

# ──────────────────────────────────────────────────────────────────────────────
# Threaded model worker
# ──────────────────────────────────────────────────────────────────────────────
class ModelWorker(QtCore.QThread):
    finished = QtCore.pyqtSignal(str)
    def __init__(self, model: str, prompt: str, parent: Optional[QtCore.QObject] = None) -> None:
        super().__init__(parent)
        self.model = model
        self.prompt = prompt

    def run(self) -> None:
        try:
            parent = self.parent()
            if parent and hasattr(parent, "_query_model"):
                result = parent._query_model(self.model, self.prompt)  # type: ignore
            else:
                result = ""
            self.finished.emit(result)
        except Exception as e:
            self.finished.emit(f"Error: {e}")
        finally:
            try:
                self.deleteLater()
            except Exception:
                pass

# ──────────────────────────────────────────────────────────────────────────────
# Orchestrator
# ──────────────────────────────────────────────────────────────────────────────
class AgentCore(QtCore.QObject):
    """
    Binds together all components for headless or GUI use.
    """
    def __init__(self, base_dir: str, persona: str = "zira", set_name: Optional[str] = None) -> None:
        super().__init__()
        self.base_dir = base_dir
        self.schema_mgr = SchemaManager(base_dir)
        self.persona = persona
        if set_name is None:
            set_name = self.schema_mgr.active_schemas.get(persona, "default")
        self.set_name = set_name

        self.settings = Settings(base_dir)
        ensure_models_present()

        self.operator_mgr = OperatorManager(base_dir)
        self.dataset_mgr = DatasetManager(base_dir, self.persona, self.set_name)
        self.tts_mgr = TTSManager(default_volume=self.settings.monologue_volume)
        self.audio_recorder = AudioRecorder()
        self.google_listener = GoogleListener()
        self.conversation_db = ConversationDB(conv_db_path(base_dir, self.persona, self.set_name))
        self.feedback_db = SemanticFeedbackDB(feedback_db_path(base_dir, self.persona, self.set_name), base_dir, self.persona, self.set_name)
        self.beans = self.feedback_db.beans
        self.reinforcement_log = ReinforcementStore(base_dir)

        self.context_monitor = ContextMonitor(depth=self.settings.context_depth)
        self.schema_auto_updater = SchemaAutoUpdater(self.schema_mgr, self.persona, self.set_name)
        self.schema_evolver = SchemaEvolver(self.schema_mgr, self.feedback_db, memory_state={})

        self.command_registry = CommandRegistry(base_dir, self.persona, self.set_name)
        try:
            sch = self.schema_mgr.load_schema(self.persona, self.set_name)
            self.command_registry.register_from_schema(sch)
        except Exception:
            pass

        self.plugins = PluginManager(base_dir, self.settings)

        if SentenceTransformer and np is not None:
            try:
                self.embed_model = SentenceTransformer("all-MiniLM-L6-v2")
                embed_name = "MiniLM"
            except Exception:
                self.embed_model = None
                embed_name = "none"
        else:
            self.embed_model = None
            embed_name = "none"
        self.rag_cache = RAGCache(self.embed_model, embed_name, self.dataset_mgr.datasets_dir)

        self.command_executor = CommandExecutor(
            self.command_registry, self.schema_mgr, self.schema_auto_updater, self.beans,
            self.dataset_mgr, self.rag_cache, self.settings, self.plugins, self
        )

        self.fathom_kernel = FathomKernel(base_dir)

        self._idle_timer = QtCore.QTimer()
        self._idle_timer.timeout.connect(self._on_idle)
        self._idle_timer.start(86400000)  # nightly

        try:
            self.schema_mgr.schemaChanged.connect(self._on_schema_changed)
        except Exception:
            pass

    def _on_idle(self) -> None:
        self.fathom_kernel.lint_and_patch()

    def _on_schema_changed(self, persona: str, set_name: str) -> None:
        if persona == self.persona and set_name == self.set_name:
            self.dataset_mgr = DatasetManager(self.base_dir, self.persona, self.set_name)
            self.rag_cache.datasets_root = self.dataset_mgr.datasets_dir
            try:
                sch = self.schema_mgr.load_schema(self.persona, self.set_name)
                self.command_registry.register_from_schema(sch)
            except Exception:
                pass

    def process_user_message(self, message: str, tts: bool = False) -> str:
        self.conversation_db.save_message("user", message)
        if message.strip().startswith("/"):
            response = self.run_command(message.strip())
        else:
            self.context_monitor.add_message("user", message)
            if self.settings.auto_schema_enabled:
                analysis = self.context_monitor.analyze()
                self.schema_auto_updater.update_with_context(analysis)
            response = "Message processed."
        self.conversation_db.save_message("zira", response)
        if tts and self.settings.monologue_tts_enabled and self.tts_mgr is not None:
            self.tts_mgr.enqueue(response)
        return response

    def run_command(self, command_line: str,
                    persona: Optional[str] = None,
                    set_name: Optional[str] = None) -> str:
        try:
            self.plugins.broadcast({"type": "slash", "data": command_line})
        except Exception:
            pass

        if not persona and not set_name:
            try:
                sch = self.schema_mgr.load_schema(self.persona, self.set_name)
                self.command_registry.register_from_schema(sch)
            except Exception:
                pass
            try:
                return self.command_executor.execute(command_line)
            except Exception as e:
                return f"Command error: {e}"

        target_persona = (persona or self.persona).lower()
        target_set = set_name or self.set_name

        tmp_registry = CommandRegistry(self.base_dir, target_persona, target_set)
        try:
            sch = self.schema_mgr.load_schema(target_persona, target_set)
            tmp_registry.register_from_schema(sch)
        except Exception:
            pass
        tmp_beans = BeanCounter(self.base_dir, target_persona, target_set)
        tmp_datasets = DatasetManager(self.base_dir, target_persona, target_set)
        tmp_updater = SchemaAutoUpdater(self.schema_mgr, target_persona, target_set)
        tmp_rag = RAGCache(self.embed_model, getattr(self.rag_cache, "model_name", "MiniLM"), tmp_datasets.datasets_dir)

        tmp_exec = CommandExecutor(
            tmp_registry, self.schema_mgr, tmp_updater, tmp_beans,
            tmp_datasets, tmp_rag, self.settings, self.plugins, self
        )
        try:
            return tmp_exec.execute(command_line)
        except Exception as e:
            return f"Command error: {e}"

    def switch_persona_set(self, persona: Optional[str] = None, set_name: Optional[str] = None) -> None:
        if persona:
            self.persona = persona
        if set_name:
            self.set_name = set_name
        self.dataset_mgr = DatasetManager(self.base_dir, self.persona, self.set_name)
        self.conversation_db = ConversationDB(conv_db_path(self.base_dir, self.persona, self.set_name))
        self.feedback_db = SemanticFeedbackDB(feedback_db_path(self.base_dir, self.persona, self.set_name), self.base_dir, self.persona, self.set_name)
        self.beans = self.feedback_db.beans
        self.schema_auto_updater = SchemaAutoUpdater(self.schema_mgr, self.persona, self.set_name)
        self.schema_evolver = SchemaEvolver(self.schema_mgr, self.feedback_db, memory_state={})
        self.command_registry = CommandRegistry(self.base_dir, self.persona, self.set_name)
        try:
            sch = self.schema_mgr.load_schema(self.persona, self.set_name)
            self.command_registry.register_from_schema(sch)
        except Exception:
            pass
        self.command_executor = CommandExecutor(
            self.command_registry, self.schema_mgr, self.schema_auto_updater, self.beans,
            self.dataset_mgr, self.rag_cache, self.settings, self.plugins, self
        )
        self.rag_cache.datasets_root = self.dataset_mgr.datasets_dir

        # U-9: Auto-stop STT on context switch
        self.google_listener.stop_listener()

    def rag_search(self, query_text: str, per_ds_k: int = 4, limit: int = 10,
                   include_shared: bool = True,
                   datasets: Optional[List[str]] = None) -> List[Tuple[str, float, str, str]]:
        current_entries = self.dataset_mgr.get_active_datasets()
        if datasets:
            ds_set = set(datasets)
            current_entries = [e for e in current_entries if e.name in ds_set]
        packs: List[Tuple[DatasetManager, List[DatasetEntry]]] = [(self.dataset_mgr, current_entries)]

        if include_shared and self.schema_mgr.is_semantic_on(self.persona, self.set_name):
            shared = self.schema_mgr.get_shared_datasets(self.persona, self.set_name)
            if datasets:
                ds_set = set(datasets)
                shared = [e for e in shared if e.name in ds_set]
            owners: Dict[Tuple[str, str], List[DatasetEntry]] = {}
            for e in shared:
                try:
                    rel = os.path.relpath(e.path, self.base_dir).replace("\\", "/")
                    parts = rel.split("/")
                    idx = parts.index("profiles")
                    other_persona = parts[idx+1]
                    other_set = parts[idx+2]
                except Exception:
                    continue
                owners.setdefault((other_persona, other_set), []).append(e)
            for key, ents in owners.items():
                p, s = key
                packs.append((DatasetManager(self.base_dir, p, s), ents))

        hits = self.rag_cache.search_all(packs, query_text, per_ds_k=per_ds_k, limit=limit*2)
        hits.sort(key=lambda x: x[1], reverse=True)
        return hits[:limit]

    def refresh_prompt_cache(self) -> None:
        self.rag_cache.clear_memory()

    def add_feedback(self, original: str, liked: bool, revised: Optional[str] = None) -> None:
        self.feedback_db.add_feedback(original, liked, revised)
        hist = self.conversation_db.fetch_history(limit=50)
        try:
            self.schema_evolver.update_schema(self.persona, self.set_name, hist)
        except Exception:
            pass

    def _query_model(self, model: str, prompt: str) -> str:
        try:
            result = subprocess.run(["ollama", "run", model], input=prompt.encode("utf-8"),
                                    stdout=subprocess.PIPE, stderr=subprocess.PIPE, timeout=120)
            if result.returncode == 0:
                return result.stdout.decode("utf-8", errors="ignore").strip()
            else:
                err = result.stderr.decode("utf-8", "ignore")
                logger.error("[ollama:%s] error: %s", model, err)
        except Exception as e:
            logger.error("[ollama:%s] exception: %s", model, e)
        return f"(fallback) {prompt}"

    def start_listener(self) -> None:
        self.google_listener.start()

    def stop_listener(self) -> None:
        self.google_listener.stop_listener()

    def close(self) -> None:
        try:
            self.plugins.stop_all()
        except Exception:
            pass
        try:
            self.conversation_db.close()
        except Exception:
            pass
        try:
            self.feedback_db.close()
        except Exception:
            pass
        try:
            if self.tts_mgr:
                self.tts_mgr.close()
        except Exception:
            pass
        try:
            if hasattr(self, "reinforcement_log") and self.reinforcement_log:
                self.reinforcement_log.close()
        except Exception:
            pass
        self.stop_listener()

# ──────────────────────────────────────────────────────────────────────────────
# CLI entrypoint (optional smoke test)
# ──────────────────────────────────────────────────────────────────────────────
if __name__ == "__main__":
    base = os.path.abspath(os.path.join(os.getcwd(), ".agent_state"))
    core = AgentCore(base)
    print("AgentCore ready. Try '/commands list', '/dataset list', '/search your query', '/tts on', or '/schema active'. Ctrl+C to exit.")
    try:
        while True:
            line = input("you> ").strip()
            if not line:
                continue
            if line.lower() in {"quit", "exit"}:
                break
            if line.startswith("/"):
                m = re.match(r"^/as\s+(\w+)\s+(\w+)\s+--\s+(.*)$", line)
                if m:
                    p, s, cmd = m.groups()
                    out = core.run_command(cmd, persona=p, set_name=s)
                else:
                    out = core.run_command(line)
            else:
                out = core.process_user_message(line, tts=False)
            print("zira>", out)
    except KeyboardInterrupt:
        pass
    finally:
        core.close()
```

agent_core.py
=================

Full, end-to-end core for an AI AI TTS Agent with:
- Settings & model bootstrap (Ollama)
- Robust plugin host (enable/disable/list, manifest validation, dependency checks)
- Conversation & feedback stores (with indices, exports)
- Persona schema management (with protected keys) and live signals
- Dataset registry + RAG embeddings cache & query (per persona/set, cross-profile sharing)
  * Multi-file datasets, cache invalidation, provenance
- Context monitor + schema auto-updates driven by directives & feedback (rate-limited)
- Command registry (weight/lock) + full command execution layer
- New commands: /reject, /auto, /ignore, /opposite, /delete, /rewrite (extended persistence)
- BeanCounter reinforcement + integration with feedback and command weights
- Speech I/O (TTS locked to Zira; STT via Sphinx when available) w/ volume control
- Threaded model worker wrapper (cancel-safe)
- Orchestrator (`AgentCore`) wiring everything together for headless/GUI
- CLI entrypoint for smoke tests

Notes
-----
• This module is UI-agnostic. Hook the provided Qt signals in your GUI (`agent_ui.py`).
• All directories are scoped under `base_dir`, with per-persona/per-set state in:
  base_dir/profiles/<persona>/<set>/
**Classes:** Settings, ConversationDB, BeanCounter, SemanticFeedbackDB, ReinforcementStore, SchemaManager, OperatorManager, TTSManager, AudioRecorder, GoogleListener, DatasetEntry, DatasetManager, RAGCache, ContextMonitor, SchemaAutoUpdater, CommandRegistry, CommandExecutor, PluginMeta, PluginManager, SchemaEvolver, FathomKernel, ModelWorker, AgentCore
**Functions:** _have_cli(bin_name), ensure_models_present(), prof_dir(base_dir, persona, set_name), prof_datasets_dir(base_dir, persona, set_name), prof_commands_path(base_dir, persona, set_name), prof_reinforcement_path(base_dir, persona, set_name), conv_db_path(base_dir, persona, set_name), feedback_db_path(base_dir, persona, set_name)


## Module `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\AI_TTS_AGENT\AI TTS INFO\Zira Bot\agent_ui.py`

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
agent_ui.py
============

PyQt5 UI for the AI TTS Agent (integrated with AgentCore).

Fixes & additions:
- Slash commands (/remember etc.) now apply to the currently selected persona+set.
- Per-set "Semantic Awareness" persisted (schema.flags.semantic_awareness).
- RAG only uses datasets listed in the current set's schema ("datasets": [...]).
- Schema tab: new Commands row (dropdown + input + Add to Command + New Command).

To launch: `python run_agent.py`
"""

from __future__ import annotations

import os
import json
import time
import re
import subprocess
import threading
from typing import Dict, List, Tuple, Optional

from PyQt5 import QtCore, QtGui, QtWidgets

# Optional spell checker
try:
    from spellchecker import SpellChecker  # type: ignore
except Exception:
    SpellChecker = None  # type: ignore
from PyQt5.QtCore import QSettings, QRunnable, QThreadPool
from functools import partial

# Optional deps
try:
    from sentence_transformers import SentenceTransformer  # type: ignore
except Exception:
    SentenceTransformer = None  # type: ignore
try:
    import numpy as np  # type: ignore
except Exception:
    np = None  # type: ignore
try:
    import sounddevice as sd  # type: ignore
except Exception:
    sd = None  # type: ignore

from agent_core import (
    AgentCore,
    ModelWorker,
)

ROLE_COLOURS: Dict[str, str] = {
    "user": "#FFF8E1",
    "zira": "#E3F2FD",
    "system": "#E0F7FA",
    "operator": "#EDE7F6",
}
NAME_COLOURS: Dict[str, str] = {
    "user": "#5D4037",
    "zira": "#0D47A1",
    "system": "#006064",
    "operator": "#4A148C",
}

# ---------------------------------------------------------------------------
# Spell highlighting for misspelled words
# ---------------------------------------------------------------------------
class _SpellHighlighter(QtGui.QSyntaxHighlighter):
    """
    Underlines misspelled words in red. Uses pyspellchecker if available.
    """
    def __init__(self, document: QtGui.QTextDocument) -> None:
        super().__init__(document)
        # instantiate spell checker only if available
        self._spell = SpellChecker() if SpellChecker else None
        self._format = QtGui.QTextCharFormat()
        self._format.setUnderlineStyle(QtGui.QTextCharFormat.SpellCheckUnderline)
        self._format.setUnderlineColor(QtCore.Qt.red)
        # simple cache to avoid recomputing spelling on common words
        self._cache: Dict[str, bool] = {}

    def highlightBlock(self, text: str) -> None:
        if not self._spell:
            return
        for match in re.finditer(r"[A-Za-z']{3,}", text):
            word = match.group(0).lower()
            bad = self._cache.get(word)
            if bad is None:
                bad = word not in self._spell
                # prune cache occasionally
                if len(self._cache) > 2048:
                    self._cache.clear()
                self._cache[word] = bad
            if bad:
                start, end = match.span()
                length = end - start
                self.setFormat(start, length, self._format)


class AppWindow(QtWidgets.QMainWindow):
    """Main application window for the AI TTS Agent."""

    rewrite_ready = QtCore.pyqtSignal(str)

    def __init__(self) -> None:
        super().__init__()
        self.setWindowTitle("AI TTS Agent v2")
        self.resize(1920, 1080)

        self.base_dir = os.path.dirname(os.path.abspath(__file__))
        self.core = AgentCore(self.base_dir, persona="zira", set_name="default")

        self.current_set: Dict[str, str] = dict(self.core.schema_mgr.active_schemas)
        self.active_persona: str = self.core.persona or "zira"

        self.isolated_history: List[Tuple[str, str]] = []
        self.self_talk_enabled: bool = False
        self._plugin_docks: Dict[str, QtWidgets.QDockWidget] = {}
        self._schema_save_timers: Dict[str, QtCore.QTimer] = {}

        self._idle_timer = QtCore.QTimer(self)
        self._idle_timer.setSingleShot(True)
        self._idle_timer.timeout.connect(self._handle_idle)

        self._restore_layout()
        self._build_ui()
        # build the slash command panel (custom dock)
        self._build_command_dock()
        self._connect_signals()

        try:
            self.core.audio_recorder.transcribed.connect(self._on_transcribed)
        except Exception:
            pass

        self._update_feedback_counts()
        self._bootstrap_conversation()
        self._reset_idle_timer()

        # populate initial slash command list
        try:
            self._populate_command_select()
        except Exception:
            pass

    # ────────────────────────── signals
    def _connect_signals(self) -> None:
        self.btn_send.clicked.connect(self.send_message)

        self.btn_record.clicked.connect(self.start_recording)
        self.btn_stop_rec.clicked.connect(self.stop_recording)

        self.voice_combo.currentTextChanged.connect(self._on_voice_changed)
        # update settings when a new model is selected
        self.model_combo.currentTextChanged.connect(self._on_model_changed)

        self.btn_play.clicked.connect(self._on_play)
        self.btn_stop_tts.clicked.connect(self._on_stop_tts)
        self.btn_replay.clicked.connect(self._on_replay)

        self.btn_like.clicked.connect(self._on_like)
        self.btn_dislike.clicked.connect(self._on_dislike)
        self.btn_manage_feedback.clicked.connect(self._on_manage_feedback)

        self.btn_refresh.clicked.connect(self._on_refresh_chat)
        self.btn_manage_datasets.clicked.connect(self._on_manage_datasets)
        self.btn_inner_monologue.clicked.connect(self._on_inner_monologue)
        self.btn_clear_rag.clicked.connect(self._on_clear_rag_cache)
        self.btn_model_manager.clicked.connect(self._on_show_model_manager)

        self.chk_semantic.toggled.connect(self._on_semantic_toggled)
        self.chk_isolated.toggled.connect(self._on_isolated_toggled)
        self.chk_self_talk.toggled.connect(lambda v: setattr(self, "self_talk_enabled", v))
        self.chk_auto_schema.toggled.connect(self._on_auto_schema_toggled)

        # connect Google STT checkbox
        try:
            self.chk_google_stt.toggled.connect(self._on_google_stt_toggled)
        except Exception:
            pass

        self.rewrite_ready.connect(self._apply_rewrite_result)

        # context menu for chat view to send selection to command input
        try:
            self.chat_view.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
            self.chat_view.customContextMenuRequested.connect(self._show_chat_context_menu)
        except Exception:
            pass
        # custom context menu for spell suggestions on input field
        try:
            self.input_edit.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
            self.input_edit.customContextMenuRequested.connect(self._show_input_context_menu)
        except Exception:
            pass

    # ────────────────────────── layout & lifecycle
    def _restore_layout(self) -> None:
        qsettings = QSettings("xAI", "AI_TTS_Agent")
        try:
            self.restoreGeometry(qsettings.value("geometry", b""))
            self.restoreState(qsettings.value("windowState", b""))
        except Exception:
            pass

    def closeEvent(self, event: QtGui.QCloseEvent) -> None:
        qsettings = QSettings("xAI", "AI_TTS_Agent")
        qsettings.setValue("geometry", self.saveGeometry())
        qsettings.setValue("windowState", self.saveState())
        try:
            self.core.close()
        except Exception:
            pass
        super().closeEvent(event)

    # ────────────────────────── UI build
    def _build_ui(self) -> None:
        self.setStyleSheet(
            """
            QWidget { background-color: #2e3a51; color: #e0e0e0; }
            QGroupBox { border: 1px solid #007acc; margin-top: 7px; }
            QGroupBox::title { subcontrol-origin: margin; left: 12px; padding: 0 4px; }
            QPushButton { background-color: #3c4a6b; color: white; border: 1px solid #007acc; padding: 5px; }
            QPushButton:disabled { background-color: #5a5a7a; color: #c0c0c0; border: 1px solid #555555; }
            QPlainTextEdit, QTextEdit { background-color: #1e2738; color: #e0e0e0; border: 1px solid #007acc; }
            QLineEdit { background-color: #1e2738; color: #e0e0e0; border: 1px solid #007acc; }
            QTabBar::tab { background: #3c4a6b; color: white; border: 1px solid #007acc; padding: 5px 10px; }
            QTabBar::tab:selected { background: #007acc; color: white; }
            QComboBox { background-color: #1e2738; color: #e0e0e0; border: 1px solid #007acc; padding: 3px; }
            QListWidget { background-color: #1e2738; color: #e0e0e0; border: 1px solid #007acc; }
            QCheckBox, QLabel { color: #e0e0e0; }
            """
        )
        self.setDockOptions(
            QtWidgets.QMainWindow.AllowTabbedDocks
            | QtWidgets.QMainWindow.AllowNestedDocks
            | QtWidgets.QMainWindow.AnimatedDocks
        )
        self.setTabPosition(QtCore.Qt.AllDockWidgetAreas, QtWidgets.QTabWidget.North)
        self.setDockNestingEnabled(True)

        tb = QtWidgets.QToolBar("Layout", self)
        tb.setMovable(False)
        self.addToolBar(QtCore.Qt.TopToolBarArea, tb)
        self.chk_lock = QtWidgets.QCheckBox("Lock Layout")
        act = QtWidgets.QWidgetAction(self)
        act.setDefaultWidget(self.chk_lock)
        tb.addAction(act)
        self.chk_lock.toggled.connect(self._on_toggle_lock)

        self.setCentralWidget(QtWidgets.QWidget())
        status = QtWidgets.QStatusBar()
        self.setStatusBar(status)
        self.dock_tray = DockTray(self)
        status.addPermanentWidget(self.dock_tray, 1)

        self.progress_bar = QtWidgets.QProgressBar()
        self.progress_bar.setRange(0, 0)
        self.progress_bar.setVisible(False)
        status.addPermanentWidget(self.progress_bar)

        # Tabs for personas / operators
        self.tabs = QtWidgets.QTabWidget()
        self.tab_widgets: Dict[str, QtWidgets.QWidget] = {}
        for persona in self.core.schema_mgr.personas:
            tab = QtWidgets.QWidget()
            self.tab_widgets[persona] = tab
            self.tabs.addTab(tab, persona.capitalize())
        self.operator_tab = QtWidgets.QWidget()
        self.tabs.addTab(self.operator_tab, "Operators")
        self.tabs.currentChanged.connect(self._on_tab_changed)

        for persona, tab in self.tab_widgets.items():
            self._build_persona_tab(persona, tab)
        self._build_operator_tab(self.operator_tab)

        # Chat panel
        self.chat_view = QtWidgets.QTextEdit()
        self.chat_view.setReadOnly(True)
        self.chat_view.setStyleSheet("background-color: #e0eef5; color: #011627;")
        self.chat_view.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        self.input_edit = QtWidgets.QPlainTextEdit()
        self.input_edit.setPlaceholderText("Type your message or use /remember key value, /showfacts, /style, /weights")
        self.input_edit.setMinimumHeight(64)
        self.input_edit.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        # Attach spell checker highlighter if available
        try:
            if SpellChecker:
                self._spell_highlighter = _SpellHighlighter(self.input_edit.document())  # type: ignore[attr-defined]
        except Exception:
            self._spell_highlighter = None
        self.btn_send = QtWidgets.QPushButton("Send")

        chat_container = QtWidgets.QWidget()
        cv = QtWidgets.QVBoxLayout(chat_container)
        cv.setContentsMargins(7, 7, 7, 7)
        cv.setSpacing(7)
        cv.addWidget(self.chat_view, 1)
        cv.addWidget(self.input_edit)
        row = QtWidgets.QHBoxLayout()
        row.addStretch()
        row.addWidget(self.btn_send)
        cv.addLayout(row)

        # Controls panel
        controls_panel = QtWidgets.QWidget()
        cp_layout = QtWidgets.QVBoxLayout(controls_panel)
        cp_layout.setContentsMargins(7, 7, 7, 7)
        cp_layout.setSpacing(7)

        # Recording
        rec_row = QtWidgets.QHBoxLayout()
        self.btn_record = QtWidgets.QPushButton("Record")
        self.btn_stop_rec = QtWidgets.QPushButton("Stop\nTranscribe")
        self.btn_stop_rec.setEnabled(False)
        for b in (self.btn_record, self.btn_stop_rec):
            b.setMinimumHeight(32)
            b.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        rec_row.addWidget(self.btn_record, 1)
        rec_row.addWidget(self.btn_stop_rec, 1)
        cp_layout.addLayout(rec_row)

        # Microphone device
        mic_row = QtWidgets.QHBoxLayout()
        mic_row.addWidget(QtWidgets.QLabel("Mic:"))
        self.device_combo = QtWidgets.QComboBox()
        self._populate_devices()
        self.device_combo.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        mic_row.addWidget(self.device_combo, 1)
        cp_layout.addLayout(mic_row)

        # Toggles
        self.chk_semantic = QtWidgets.QCheckBox("Semantic Awareness")
        self.chk_semantic.setChecked(True)
        self.chk_isolated = QtWidgets.QCheckBox("Isolated Chat")
        self.chk_isolated.setChecked(False)
        self.chk_mute_tts = QtWidgets.QCheckBox("Mute TTS")
        self.chk_self_talk = QtWidgets.QCheckBox("Enable Self Talk")
        self.chk_self_talk.setChecked(False)
        self.chk_auto_schema = QtWidgets.QCheckBox("Auto Schema Evolution")
        self.chk_auto_schema.setChecked(self.core.settings.auto_schema_enabled)

        cp_layout.addWidget(self.chk_semantic)
        cp_layout.addWidget(self.chk_isolated)
        cp_layout.addWidget(self.chk_mute_tts)
        cp_layout.addWidget(self.chk_self_talk)
        cp_layout.addWidget(self.chk_auto_schema)

        # Optional Google STT toggle (default off)
        self.chk_google_stt = QtWidgets.QCheckBox("Google STT")
        try:
            self.chk_google_stt.setChecked(bool(getattr(self.core.settings, "use_google_stt", False)))
        except Exception:
            self.chk_google_stt.setChecked(False)
        cp_layout.addWidget(self.chk_google_stt)

        # RAG cache clear
        self.btn_clear_rag = QtWidgets.QPushButton("Clear RAG Cache")
        cp_layout.addWidget(self.btn_clear_rag)

        # Maintenance
        self.btn_refresh = QtWidgets.QPushButton("Refresh Chat")
        self.btn_manage_datasets = QtWidgets.QPushButton("Manage Datasets")
        self.btn_inner_monologue = QtWidgets.QPushButton("Inner Monologue")
        for b in (self.btn_refresh, self.btn_manage_datasets, self.btn_inner_monologue):
            b.setMinimumHeight(32)
            b.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
            cp_layout.addWidget(b)

        self.btn_model_manager = QtWidgets.QPushButton("Model Manager")
        self.btn_model_manager.setMinimumHeight(32)
        self.btn_model_manager.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        cp_layout.addWidget(self.btn_model_manager)

        # Style label
        self.style_label = QtWidgets.QLabel("Style: N/A")
        self.style_label.setToolTip("Style score (0–1): rough measure vs. tone rules.")
        cp_layout.addWidget(self.style_label)

        # Response + feedback
        self.response_edit = QtWidgets.QPlainTextEdit()
        self.response_edit.setReadOnly(True)
        self.response_edit.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        cp_layout.addWidget(self.response_edit, 1)

        fb = QtWidgets.QHBoxLayout()
        self.btn_like = QtWidgets.QPushButton("✔")
        self.btn_dislike = QtWidgets.QPushButton("✖")
        self.btn_like.setToolTip("Mark as good response")
        self.btn_dislike.setToolTip("Dislike and rewrite response")
        self.btn_like.setStyleSheet("color: #2ecc71; font-weight: bold;")
        self.btn_dislike.setStyleSheet("color: #e74c3c; font-weight: bold;")
        self.btn_like.setEnabled(False)
        self.btn_dislike.setEnabled(False)
        fb.addWidget(self.btn_like)
        fb.addWidget(self.btn_dislike)
        fb.addStretch()
        self.btn_manage_feedback = QtWidgets.QPushButton("Manage Feedback")
        fb.addWidget(self.btn_manage_feedback)
        cp_layout.addLayout(fb)

        # TTS playback
        tts_row = QtWidgets.QHBoxLayout()
        self.btn_play = QtWidgets.QPushButton("Play")
        self.btn_stop_tts = QtWidgets.QPushButton("Stop")
        self.btn_replay = QtWidgets.QPushButton("Replay")
        for b in (self.btn_play, self.btn_stop_tts, self.btn_replay):
            b.setMinimumHeight(32)
            b.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        tts_row.addWidget(self.btn_play)
        tts_row.addWidget(self.btn_stop_tts)
        tts_row.addWidget(self.btn_replay)
        cp_layout.addLayout(tts_row)

        # Voice & Model
        voice_row = QtWidgets.QHBoxLayout()
        voice_row.addWidget(QtWidgets.QLabel("Voice:"))
        self.voice_combo = QtWidgets.QComboBox()
        voices = self._tts_voice_names()
        if voices:
            self.voice_combo.addItems([v for v in voices if "david" not in v.lower()])
        voice_row.addWidget(self.voice_combo, 1)
        cp_layout.addLayout(voice_row)

        model_row = QtWidgets.QHBoxLayout()
        model_row.addWidget(QtWidgets.QLabel("Model:"))
        self.model_combo = QtWidgets.QComboBox()
        self._populate_models()
        model_row.addWidget(self.model_combo, 1)
        cp_layout.addLayout(model_row)

        # Feedback counts
        self.lbl_feedback_counts = QtWidgets.QLabel("Likes: 0 | Dislikes: 0")
        cp_layout.addWidget(self.lbl_feedback_counts)
        cp_layout.addStretch(1)

        controls_scroll = QtWidgets.QScrollArea()
        controls_scroll.setWidgetResizable(True)
        controls_scroll.setFrameShape(QtWidgets.QFrame.NoFrame)
        controls_scroll.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)
        controls_scroll.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        controls_scroll.setWidget(controls_panel)

        # Docks
        self.controls_dock = QtWidgets.QDockWidget("Controls", self)
        self.controls_dock.setObjectName("ControlsDock")
        self.controls_dock.setWidget(controls_scroll)
        self.controls_dock.setFeatures(
            QtWidgets.QDockWidget.DockWidgetClosable
            | QtWidgets.QDockWidget.DockWidgetMovable
            | QtWidgets.QDockWidget.DockWidgetFloatable
        )

        self.persona_dock = QtWidgets.QDockWidget("Personas", self)
        self.persona_dock.setObjectName("PersonaDock")
        self.persona_dock.setWidget(self._wrap_persona_widget())
        self.persona_dock.setFeatures(
            QtWidgets.QDockWidget.DockWidgetClosable
            | QtWidgets.QDockWidget.DockWidgetMovable
            | QtWidgets.QDockWidget.DockWidgetFloatable
        )

        self.chat_dock = QtWidgets.QDockWidget("Chat", self)
        self.chat_dock.setObjectName("ChatDock")
        self.chat_dock.setWidget(chat_container)
        self.chat_dock.setFeatures(
            QtWidgets.QDockWidget.DockWidgetClosable
            | QtWidgets.QDockWidget.DockWidgetMovable
            | QtWidgets.QDockWidget.DockWidgetFloatable
        )

        self.model_dock = QtWidgets.QDockWidget("Models", self)
        self.model_dock.setObjectName("ModelDock")
        self.model_dock.setFeatures(
            QtWidgets.QDockWidget.DockWidgetClosable
            | QtWidgets.QDockWidget.DockWidgetMovable
            | QtWidgets.QDockWidget.DockWidgetFloatable
        )
        self._build_model_manager()

        self.plugins_dock = QtWidgets.QDockWidget("Plugins", self)
        self.plugins_dock.setObjectName("PluginsDock")
        self.plugins_dock.setFeatures(
            QtWidgets.QDockWidget.DockWidgetClosable
            | QtWidgets.QDockWidget.DockWidgetMovable
            | QtWidgets.QDockWidget.DockWidgetFloatable
        )
        self.plugins_dock.setWidget(self._build_plugins_widget())

        # Titles & dock tray
        self.controls_dock.setTitleBarWidget(DockTitleBar(self.controls_dock, "Controls"))
        self.persona_dock.setTitleBarWidget(DockTitleBar(self.persona_dock, "Personas"))
        self.chat_dock.setTitleBarWidget(DockTitleBar(self.chat_dock, "Chat"))
        self.model_dock.setTitleBarWidget(DockTitleBar(self.model_dock, "Models"))
        self.plugins_dock.setTitleBarWidget(DockTitleBar(self.plugins_dock, "Plugins"))

        for d in (self.controls_dock, self.persona_dock, self.chat_dock, self.model_dock, self.plugins_dock):
            self.dock_tray.register_dock(d)

        self.addDockWidget(QtCore.Qt.LeftDockWidgetArea, self.controls_dock)
        self.addDockWidget(QtCore.Qt.LeftDockWidgetArea, self.persona_dock)
        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.chat_dock)
        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.model_dock)
        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.plugins_dock)

        self.splitDockWidget(self.controls_dock, self.persona_dock, QtCore.Qt.Vertical)
        self.splitDockWidget(self.controls_dock, self.chat_dock, QtCore.Qt.Horizontal)
        self.splitDockWidget(self.chat_dock, self.model_dock, QtCore.Qt.Horizontal)
        self.splitDockWidget(self.model_dock, self.plugins_dock, QtCore.Qt.Horizontal)

    # ────────────────────────── persona widgets
    def _wrap_persona_widget(self) -> QtWidgets.QWidget:
        container = QtWidgets.QWidget()
        v = QtWidgets.QVBoxLayout(container)
        v.setContentsMargins(7, 7, 7, 7)
        v.setSpacing(7)

        try:
            bot_schema = self.core.schema_mgr.load_schema("zira", self.current_set.get("zira", "default"))
            bot_name = bot_schema.get("name", "Zira")
            bot_set = self.current_set.get("zira", "default")
        except Exception:
            bot_name, bot_set = "Zira", "default"

        try:
            user_schema = self.core.schema_mgr.load_schema("user", self.current_set.get("user", "default"))
            user_name = user_schema.get("name", "User")
            user_set = self.current_set.get("user", "default")
        except Exception:
            user_name, user_set = "User", "default"

        self.lbl_active_names = QtWidgets.QLabel(f"{bot_name}: {bot_set} — User: {user_name}: {user_set}")
        v.addWidget(self.lbl_active_names)
        v.addWidget(self.tabs, 1)
        return container

    def _build_persona_tab(self, persona: str, tab: QtWidgets.QWidget) -> None:
        vbox = QtWidgets.QVBoxLayout(tab)

        # --- Set selector row ---
        h_set = QtWidgets.QHBoxLayout()
        h_set.addWidget(QtWidgets.QLabel("Set:"))
        combo = QtWidgets.QComboBox(objectName=f"set_combo_{persona}")
        self._populate_set_combo(persona, combo)
        h_set.addWidget(combo)

        btn_clone = QtWidgets.QPushButton("Clone", objectName=f"clone_set_{persona}")
        btn_new = QtWidgets.QPushButton("New", objectName=f"new_set_{persona}")
        btn_del = QtWidgets.QPushButton("Delete", objectName=f"del_set_{persona}")
        h_set.addWidget(btn_clone)
        h_set.addWidget(btn_new)
        h_set.addWidget(btn_del)
        h_set.addStretch()
        vbox.addLayout(h_set)

        # --- Commands row (NEW) ---
        cmd_row = QtWidgets.QHBoxLayout()
        cmd_row.addWidget(QtWidgets.QLabel("Commands:"))
        cmd_combo = QtWidgets.QComboBox(objectName=f"cmd_combo_{persona}")
        self._populate_command_combo(persona, cmd_combo)
        cmd_row.addWidget(cmd_combo, 1)

        cmd_edit = QtWidgets.QLineEdit(objectName=f"cmd_edit_{persona}")
        cmd_edit.setPlaceholderText('Enter text/payload for selected /command')
        cmd_row.addWidget(cmd_edit, 2)

        btn_add_cmd = QtWidgets.QPushButton("Add to Command", objectName=f"add_cmd_{persona}")
        btn_new_cmd = QtWidgets.QPushButton("New Command", objectName=f"new_cmd_{persona}")
        cmd_row.addWidget(btn_add_cmd)
        cmd_row.addWidget(btn_new_cmd)
        vbox.addLayout(cmd_row)

        # --- Schema editor ---
        editor = QtWidgets.QPlainTextEdit(objectName=f"schema_edit_{persona}")
        editor.setLineWrapMode(QtWidgets.QPlainTextEdit.NoWrap)
        schema = self.core.schema_mgr.load_schema(persona, self.current_set.get(persona, "default"))
        editor.setPlainText(json.dumps(schema, indent=2))
        vbox.addWidget(editor, 1)

        # --- Save button ---
        h_save = QtWidgets.QHBoxLayout()
        btn_save = QtWidgets.QPushButton("Save", objectName=f"save_schema_{persona}")
        h_save.addStretch()
        h_save.addWidget(btn_save)
        vbox.addLayout(h_save)

        # --- Button bindings ---
        combo.currentTextChanged.connect(lambda name, p=persona, c=combo: self._on_set_changed(p, name, c))
        btn_clone.clicked.connect(lambda _, p=persona, c=combo: self._on_clone_set(p, c))
        btn_new.clicked.connect(lambda _, p=persona, c=combo: self._on_new_set(p, c))
        btn_del.clicked.connect(lambda _, p=persona, c=combo: self._on_delete_set(p, c))
        btn_save.clicked.connect(lambda _, p=persona: self._on_save_schema(p))

        btn_add_cmd.clicked.connect(lambda _, p=persona, cc=cmd_combo, ce=cmd_edit: self._on_add_to_command(p, cc, ce))
        btn_new_cmd.clicked.connect(lambda _, p=persona: self._on_new_command(p))

        # --- Autosave debounce ---
        timer = QtCore.QTimer(self)
        timer.setSingleShot(True)

        def on_text_change() -> None:
            timer.start(500)

        def on_timeout() -> None:
            text = editor.toPlainText().strip()
            try:
                obj = json.loads(text)
                if isinstance(obj, dict):
                    set_name = self.current_set.get(persona, "default")
                    self.core.schema_mgr.save_schema(persona, set_name, obj)
            except Exception:
                pass

        editor.textChanged.connect(on_text_change)
        timer.timeout.connect(on_timeout)
        self._schema_save_timers[persona] = timer

    # --- Commands helpers (NEW) ---
    def _populate_command_combo(self, persona: str, combo: QtWidgets.QComboBox) -> None:
        combo.blockSignals(True)
        combo.clear()
        schema = self.core.schema_mgr.load_schema(persona, self.current_set.get(persona, "default"))
        cmds = []
        try:
            cmds = sorted(list((schema.get("commands") or {}).keys()))
        except Exception:
            cmds = []
        if not cmds:
            combo.addItem("(no commands)")
            combo.setEnabled(False)
        else:
            combo.addItems(cmds)
            combo.setEnabled(True)
        combo.blockSignals(False)

    def _on_add_to_command(self, persona: str, combo: QtWidgets.QComboBox, edit: QtWidgets.QLineEdit) -> None:
        text = edit.text().strip()
        if not text:
            QtWidgets.QMessageBox.information(self, "No Text", "Enter text/payload to add.")
            return
        set_name = self.current_set.get(persona, "default")
        schema = self.core.schema_mgr.load_schema(persona, set_name)
        cmds = dict(schema.get("commands") or {})
        sel = combo.currentText().strip()
        if not sel or sel == "(no commands)":
            QtWidgets.QMessageBox.information(self, "No Command", "Create a command first.")
            return
        lst = list(cmds.get(sel) or [])
        lst.append(text)
        cmds[sel] = lst
        schema["commands"] = cmds
        self.core.schema_mgr.save_schema(persona, set_name, schema)
        edit.clear()
        # refresh schema editor & notify
        self._refresh_schema_editor(persona)
        QtWidgets.QMessageBox.information(self, "Added", f'Added to {sel}: "{text}"')

    def _on_new_command(self, persona: str) -> None:
        name, ok = QtWidgets.QInputDialog.getText(self, "New Command", "Enter new command (e.g., /remember):")
        if not ok or not name.strip():
            return
        cmd_name = name.strip()
        if not cmd_name.startswith("/"):
            cmd_name = "/" + cmd_name
        set_name = self.current_set.get(persona, "default")
        schema = self.core.schema_mgr.load_schema(persona, set_name)
        cmds = dict(schema.get("commands") or {})
        if cmd_name in cmds:
            QtWidgets.QMessageBox.information(self, "Exists", f"Command {cmd_name} already exists.")
            return
        cmds[cmd_name] = []
        schema["commands"] = cmds
        self.core.schema_mgr.save_schema(persona, set_name, schema)
        # refresh command combo + schema editor
        tab = self.tab_widgets.get(persona)
        if tab:
            combo = tab.findChild(QtWidgets.QComboBox, f"cmd_combo_{persona}")
            if combo:
                self._populate_command_combo(persona, combo)
                combo.setCurrentText(cmd_name)
            edit = tab.findChild(QtWidgets.QLineEdit, f"cmd_edit_{persona}")
            if edit:
                edit.clear()
        self._refresh_schema_editor(persona)
        QtWidgets.QMessageBox.information(self, "Created", f"New command {cmd_name} created.")

    def _refresh_schema_editor(self, persona: str) -> None:
        tab = self.tab_widgets.get(persona)
        if not tab:
            return
        editor = tab.findChild(QtWidgets.QPlainTextEdit, f"schema_edit_{persona}")
        if editor:
            schema = self.core.schema_mgr.load_schema(persona, self.current_set.get(persona, "default"))
            editor.blockSignals(True)
            editor.setPlainText(json.dumps(schema, indent=2))
            editor.blockSignals(False)
            
    def _on_tab_changed(self, index: int) -> None:
        """
        Handle tab changes in the main tab widget.
        
        Parameters
        ----------
        index : int
            Index of the newly selected tab.
        """
        try:
            tab_name = self.tabs.tabText(index)
            print(f"[UI] Tab changed to: {tab_name} (index {index})")
            # Add any extra logic if needed, for example:
            # self._update_feedback_counts()
        except Exception as e:
            print(f"[UI] Error handling tab change: {e}")
            

    # ────────────────────────── operator tab
    def _build_operator_tab(self, tab: QtWidgets.QWidget) -> None:
        layout = QtWidgets.QVBoxLayout(tab)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)
        scroll = QtWidgets.QScrollArea()
        scroll.setWidgetResizable(True)
        scroll.setFrameShape(QtWidgets.QFrame.NoFrame)
        scroll.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        container = QtWidgets.QWidget()
        container.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        vbox = QtWidgets.QVBoxLayout(container)
        vbox.setContentsMargins(8, 8, 8, 8)
        vbox.setSpacing(8)

        names = sorted(self.core.operator_mgr.list_operators())
        if not names:
            info = QtWidgets.QLabel("No operators found.")
            info.setWordWrap(True)
            vbox.addWidget(info)
        else:
            for name in names:
                # Load operator description if available
                try:
                    op_dir = os.path.join(self.core.operator_mgr.operators_dir, name, "schema.json")
                    desc = ""
                    if os.path.isfile(op_dir):
                        with open(op_dir, "r", encoding="utf-8") as f:
                            d = json.load(f)
                            desc = str(d.get("description", ""))
                except Exception:
                    desc = ""
                box = QtWidgets.QGroupBox(name)
                box.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
                bl = QtWidgets.QVBoxLayout(box)
                bl.setContentsMargins(8, 8, 8, 8)
                bl.setSpacing(6)
                lbl = QtWidgets.QLabel(desc)
                lbl.setWordWrap(True)
                bl.addWidget(lbl)
                btn_row = QtWidgets.QHBoxLayout()
                btn_info = QtWidgets.QPushButton("Info")
                btn_row.addWidget(btn_info)
                btn_row.addStretch(1)
                bl.addLayout(btn_row)
                vbox.addWidget(box)
                btn_info.clicked.connect(partial(QtWidgets.QMessageBox.information, self, f"{name} Info", desc or "No description."))

        vbox.addStretch(1)
        scroll.setWidget(container)
        layout.addWidget(scroll)

    # ────────────────────────── plugins
    def _build_plugins_widget(self) -> QtWidgets.QWidget:
        container = QtWidgets.QWidget()
        layout = QtWidgets.QVBoxLayout(container)
        layout.setContentsMargins(6, 6, 6, 6)
        layout.setSpacing(4)

        self.plugin_list = QtWidgets.QListWidget()
        self.plugin_list.setSelectionMode(QtWidgets.QAbstractItemView.NoSelection)
        layout.addWidget(self.plugin_list, 1)

        btn_rescan = QtWidgets.QPushButton("Rescan")
        layout.addWidget(btn_rescan)
        btn_rescan.clicked.connect(self._rescan_plugins)

        self._populate_plugin_list()
        self.plugin_list.itemChanged.connect(self._on_plugin_item_changed)

        try:
            self.core.plugins.eventReceived.connect(self._on_plugin_event)
        except Exception:
            pass

        return container

    def _populate_plugin_list(self) -> None:
        self.plugin_list.blockSignals(True)
        self.plugin_list.clear()
        for meta in self.core.plugins.list_plugins():
            item = QtWidgets.QListWidgetItem(meta.name)
            flags = item.flags() | QtCore.Qt.ItemIsUserCheckable
            if meta.missing_dependencies:
                flags &= ~QtCore.Qt.ItemIsEnabled
                item.setToolTip(f"Missing dependencies: {', '.join(meta.missing_dependencies)}")
            item.setFlags(flags)
            item.setCheckState(QtCore.Qt.Checked if meta.enabled else QtCore.Qt.Unchecked)
            self.plugin_list.addItem(item)
        self.plugin_list.blockSignals(False)

    def _on_plugin_item_changed(self, item: QtWidgets.QListWidgetItem) -> None:
        name = item.text()
        enabled = item.checkState() == QtCore.Qt.Checked
        self.core.plugins.enable_plugin(name, enabled)
        meta = next((m for m in self.core.plugins.list_plugins() if m.name == name), None)
        if not meta:
            return
        if enabled and meta.widget is not None:
            self._attach_plugin_widget(meta)
        elif not enabled:
            self._detach_plugin_widget(name)

    def _rescan_plugins(self) -> None:
        self.core.plugins.rescan()
        for name in list(self._plugin_docks.keys()):
            meta = next((m for m in self.core.plugins.list_plugins() if m.name == name), None)
            if not meta or not meta.enabled:
                self._detach_plugin_widget(name)
        self._populate_plugin_list()

    def _attach_plugin_widget(self, meta: 'object') -> None:
        if meta.name in self._plugin_docks:
            return
        if meta.widget is None:
            return
        dock = QtWidgets.QDockWidget(meta.name, self)
        dock.setObjectName(f"PluginDock_{meta.name}")
        dock.setWidget(meta.widget)
        dock.setFeatures(
            QtWidgets.QDockWidget.DockWidgetClosable
            | QtWidgets.QDockWidget.DockWidgetMovable
            | QtWidgets.QDockWidget.DockWidgetFloatable
        )
        dock.setTitleBarWidget(DockTitleBar(dock, meta.name))
        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, dock)
        self.dock_tray.register_dock(dock)
        self._plugin_docks[meta.name] = dock

    def _detach_plugin_widget(self, name: str) -> None:
        dock = self._plugin_docks.pop(name, None)
        if dock:
            self.dock_tray._remove_button(dock)
            dock.setParent(None)
            dock.deleteLater()

    @QtCore.pyqtSlot(str, dict)
    def _on_plugin_event(self, sender: str, envelope: dict) -> None:
        try:
            data = envelope.get("data")
            msg = json.dumps(data, indent=2) if isinstance(data, (dict, list)) else str(data)
            display_name = sender
            self._append_message(display_name, msg, role_key="operator")
            if self.chk_semantic.isChecked() and not self.chk_isolated.isChecked():
                self.core.conversation_db.save_message(sender.lower(), msg)
        except Exception as e:
            print(f"Error handling plugin event from {sender}: {e}")

    # ────────────────────────── model manager
    def _build_model_manager(self) -> None:
        widget = QtWidgets.QWidget()
        v = QtWidgets.QVBoxLayout(widget)
        v.setContentsMargins(8, 8, 8, 8)
        v.setSpacing(6)
        self.model_list = QtWidgets.QListWidget()
        v.addWidget(self.model_list, 1)
        h = QtWidgets.QHBoxLayout()
        self.btn_model_pull = QtWidgets.QPushButton("Pull")
        self.btn_model_delete = QtWidgets.QPushButton("Delete")
        self.btn_model_set_default = QtWidgets.QPushButton("Set as Default")
        h.addWidget(self.btn_model_pull)
        h.addWidget(self.btn_model_delete)
        h.addWidget(self.btn_model_set_default)
        h.addStretch()
        v.addLayout(h)
        self.model_dock.setWidget(widget)
        self._refresh_model_list()
        self.btn_model_pull.clicked.connect(self._on_model_pull)
        self.btn_model_delete.clicked.connect(self._on_model_delete)
        self.btn_model_set_default.clicked.connect(self._on_model_set_default)

    def _refresh_model_list(self) -> None:
        self.model_list.clear()
        models: List[str] = []
        try:
            out = subprocess.run(
                ["ollama", "list"],
                stdout=subprocess.PIPE,
                stderr=subprocess.DEVNULL,
                text=True,
                check=True,
            ).stdout.splitlines()
            for line in out[1:]:
                parts = line.strip().split()
                if parts:
                    models.append(parts[0])
        except Exception:
            models = []
        for m in models:
            item = QtWidgets.QListWidgetItem(m)
            if m == self.model_combo.currentText().strip():
                item.setFont(QtGui.QFont("", weight=QtGui.QFont.Bold))
            self.model_list.addItem(item)

    def _on_model_pull(self) -> None:
        item = self.model_list.currentItem()
        if not item:
            return
        model = item.text()
        threading.Thread(target=lambda: subprocess.run(["ollama", "pull", model], check=False), daemon=True).start()
        QtWidgets.QMessageBox.information(self, "Pull Started", f"Pulling {model} in background.")

    def _on_model_delete(self) -> None:
        item = self.model_list.currentItem()
        if not item:
            return
        model = item.text()
        if QtWidgets.QMessageBox.question(
            self,
            "Delete Model",
            f"Delete '{model}'? This cannot be undone.",
            QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No,
        ) != QtWidgets.QMessageBox.Yes:
            return
        threading.Thread(target=lambda: subprocess.run(["ollama", "delete", model], check=False), daemon=True).start()
        QtWidgets.QMessageBox.information(self, "Delete Started", f"Deleting {model} in background.")
        self._refresh_model_list()

    def _on_model_set_default(self) -> None:
        item = self.model_list.currentItem()
        if not item:
            return
        model = item.text()
        idx = self.model_combo.findText(model)
        if idx >= 0:
            self.model_combo.setCurrentIndex(idx)
        # persist selection to settings
        try:
            self.core.settings.default_model = model
            self.core.settings.save()
        except Exception:
            pass
            QtWidgets.QMessageBox.information(self, "Default Model", f"Set default model to {model}.")
        else:
            self.model_combo.addItem(model)
            self.model_combo.setCurrentText(model)

    # ────────────────────────── lock layout
    def _on_toggle_lock(self, locked: bool) -> None:
        feats_unlocked = (
            QtWidgets.QDockWidget.DockWidgetClosable
            | QtWidgets.QDockWidget.DockWidgetMovable
            | QtWidgets.QDockWidget.DockWidgetFloatable
        )
        feats_locked = QtWidgets.QDockWidget.DockWidgetClosable
        for dock in (
            self.controls_dock,
            self.persona_dock,
            self.chat_dock,
            getattr(self, "inner_dock", None),
            self.model_dock,
            self.plugins_dock,
        ):
            if dock is None:
                continue
            dock.setFeatures(feats_locked if locked else feats_unlocked)
        for dock in self._plugin_docks.values():
            dock.setFeatures(feats_locked if locked else feats_unlocked)

    # ────────────────────────── audio
    def start_recording(self) -> None:
        if sd is None or np is None:
            QtWidgets.QMessageBox.information(self, "Recording Unavailable", "sounddevice/numpy not installed.")
            return
        if not self.btn_record.isEnabled():
            return
        device_index = None
        try:
            idx = self.device_combo.currentIndex()
            selected_name = self.device_combo.currentText()
            for i, d in enumerate(sd.query_devices()):
                if d.get("name") == selected_name and d.get("max_input_channels", 0) > 0:
                    device_index = i
                    break
        except Exception:
            device_index = None
        self.core.audio_recorder.start(device_index)
        self.btn_record.setEnabled(False)
        self.btn_stop_rec.setEnabled(True)

    def stop_recording(self) -> None:
        if not self.btn_stop_rec.isEnabled():
            return
        self.core.audio_recorder.stop_and_transcribe()
        self.btn_stop_rec.setEnabled(False)
        self.btn_record.setEnabled(True)

    @QtCore.pyqtSlot(str)
    def _on_transcribed(self, text: str) -> None:
        if not text:
            return
        cur = self.input_edit.toPlainText()
        self.input_edit.setPlainText((cur + "\n" if cur else "") + text)

    # ────────────────────────── TTS
    def _on_play(self) -> None:
        text = self.response_edit.toPlainText().strip()
        if text and not self.chk_mute_tts.isChecked():
            try:
                self.core.tts_mgr.enqueue(text)
            except Exception:
                pass

    def _on_stop_tts(self) -> None:
        try:
            self.core.tts_mgr.stop()
        except Exception:
            pass

    def _on_replay(self) -> None:
        if not self.chk_mute_tts.isChecked():
            try:
                self.core.tts_mgr.replay()
            except Exception:
                pass

    def _on_voice_changed(self, name: str) -> None:
        try:
            eng = getattr(self.core.tts_mgr, "_engine", None)
            if eng:
                for v in eng.getProperty("voices"):
                    if v.name == name:
                        eng.setProperty("voice", v.id)
                        break
        except Exception:
            pass

    def _tts_voice_names(self) -> List[str]:
        try:
            eng = getattr(self.core.tts_mgr, "_engine", None)
            if not eng:
                return []
            return [v.name for v in eng.getProperty("voices")]
        except Exception:
            return []

    # ────────────────────────── feedback
    def _on_like(self) -> None:
        text = self.response_edit.toPlainText().strip()
        if not text:
            return
        try:
            self.core.add_feedback(text, liked=True)
        except Exception:
            pass
        QtWidgets.QMessageBox.information(self, "Feedback", "Marked as good response.")
        self._enable_feedback(False)
        self._update_feedback_counts()

    def _on_dislike(self) -> None:
        original = self.response_edit.toPlainText().strip()
        if not original:
            return
        try:
            self.core.tts_mgr.stop()
        except Exception:
            pass
        QtWidgets.QMessageBox.information(self, "Disliked", "The response will be rewritten.")
        self._enable_feedback(False)

        def worker() -> None:
            new_text = self._rewrite_response(original)
            try:
                self.core.add_feedback(original, liked=False, revised=new_text)
            except Exception:
                pass
            if self.chk_isolated.isChecked():
                self.isolated_history.append((self._current_persona(), new_text))
            else:
                if self.chk_semantic.isChecked():
                    self.core.conversation_db.save_message(self._current_persona().lower(), new_text)
            self.rewrite_ready.emit(new_text)

        threading.Thread(target=worker, daemon=True).start()

    @QtCore.pyqtSlot(str)
    def _apply_rewrite_result(self, new_text: str) -> None:
        schema = self.core.schema_mgr.load_schema(
            self._current_persona(), self.current_set.get(self._current_persona(), "default")
        )
        persona_name = schema.get("name", "Bot")
        role_key = self._current_persona().lower()
        self._append_message(persona_name, new_text, role_key=role_key)
        self.response_edit.setPlainText(new_text)
        if not self.chk_mute_tts.isChecked():
            try:
                self.core.tts_mgr.enqueue(new_text)
            except Exception:
                pass
        QtWidgets.QMessageBox.information(self, "Rewritten", "Response rewritten.")
        self._enable_feedback(False)

    def _update_feedback_counts(self) -> None:
        try:
            pos, neg = self.core.feedback_db.get_counts()
            self.lbl_feedback_counts.setText(f"Likes: {pos} | Dislikes: {neg}")
        except Exception:
            self.lbl_feedback_counts.setText("Likes: - | Dislikes: -")

    def _enable_feedback(self, enabled: bool) -> None:
        self.btn_like.setEnabled(enabled)
        self.btn_dislike.setEnabled(enabled)

    def _on_manage_feedback(self) -> None:
        db = self.core.feedback_db
        if db is None:
            QtWidgets.QMessageBox.information(self, "No DB", "Feedback DB unavailable.")
            return
        cur = db.conn.cursor()
        cur.execute("SELECT id, original, liked, COALESCE(revised, '') FROM feedback ORDER BY id DESC")
        entries = cur.fetchall()
        dlg = QtWidgets.QDialog(self)
        dlg.setWindowTitle("Manage Feedback")
        dlg.resize(720, 420)
        v = QtWidgets.QVBoxLayout(dlg)
        table = QtWidgets.QTableWidget(len(entries), 4)
        table.setHorizontalHeaderLabels(["ID", "Original", "Liked", "Revised"])
        table.horizontalHeader().setStretchLastSection(True)
        for r, (fid, orig, liked, rev) in enumerate(entries):
            table.setItem(r, 0, QtWidgets.QTableWidgetItem(str(fid)))
            table.setItem(r, 1, QtWidgets.QTableWidgetItem(orig))
            table.setItem(r, 2, QtWidgets.QTableWidgetItem("✔" if liked else "✖"))
            table.setItem(r, 3, QtWidgets.QTableWidgetItem(rev))
        v.addWidget(table, 1)
        h = QtWidgets.QHBoxLayout()
        btn_del = QtWidgets.QPushButton("Delete Selected")
        btn_close = QtWidgets.QPushButton("Close")
        h.addWidget(btn_del)
        h.addWidget(btn_close)
        h.addStretch()
        v.addLayout(h)

        def on_delete() -> None:
            selected = table.selectedItems()
            if not selected:
                return
            rows = sorted({i.row() for i in selected}, reverse=True)
            for rr in rows:
                fid_item = table.item(rr, 0)
                if fid_item:
                    try:
                        fid = int(fid_item.text())
                        db.conn.execute("DELETE FROM feedback WHERE id = ?", (fid,))
                        db.conn.commit()
                    except Exception:
                        pass
                table.removeRow(rr)
            self._update_feedback_counts()

        btn_del.clicked.connect(on_delete)
        btn_close.clicked.connect(dlg.accept)
        dlg.exec_()

    # ────────────────────────── datasets / rag
    def _on_manage_datasets(self) -> None:
        DatasetManagerDialog(self.core.dataset_mgr, self).exec_()

    def _on_clear_rag_cache(self) -> None:
        if QtWidgets.QMessageBox.question(
            self,
            "Clear RAG Cache",
            "Delete cached embeddings for all datasets and clear memory?",
            QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No,
        ) != QtWidgets.QMessageBox.Yes:
            return
        count = self.core.rag_cache.clear_disk()
        self.core.rag_cache.clear_memory()
        QtWidgets.QMessageBox.information(self, "Cleared", f"Cleared RAG cache files ({count} removed) and in-memory index.")

    # ────────────────────────── isolated / refresh / idle
    def _on_isolated_toggled(self, checked: bool) -> None:
        if checked:
            self.isolated_history.clear()
        else:
            if self.isolated_history:
                ans = QtWidgets.QMessageBox.question(
                    self,
                    "Merge Isolated Chat",
                    "Merge isolated conversation into main memory?",
                    QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No,
                )
                if ans == QtWidgets.QMessageBox.Yes:
                    for role, content in self.isolated_history:
                        self.core.conversation_db.save_message(role.lower(), content)
                self.isolated_history.clear()
        self._reset_idle_timer()

    def _on_refresh_chat(self) -> None:
        if self.chk_isolated.isChecked():
            self.isolated_history.clear()
        self.chat_view.clear()
        self.response_edit.clear()
        self._enable_feedback(False)
        try:
            if hasattr(self, "inner_text") and self.inner_text is not None:
                self.inner_text.clear()
        except Exception:
            pass

    def _reset_idle_timer(self) -> None:
        self._idle_timer.stop()
        if self.chk_semantic.isChecked():
            self._idle_timer.start(60000)

    def _handle_idle(self) -> None:
        pass

    # ────────────────────────── inner monologue
    def _on_inner_monologue(self) -> None:
        self._ensure_inner_dock()
        if self.inner_dock is None:
            return
        self.inner_dock.setVisible(not self.inner_dock.isVisible())

    def _ensure_inner_dock(self) -> None:
        if hasattr(self, "inner_dock") and self.inner_dock is not None:
            return
        dock = QtWidgets.QDockWidget("Inner Monologue", self)
        dock.setObjectName("InnerDock")
        dock.setAllowedAreas(QtCore.Qt.RightDockWidgetArea | QtCore.Qt.LeftDockWidgetArea)
        inner = QtWidgets.QWidget()
        v = QtWidgets.QVBoxLayout(inner)
        self.inner_text = QtWidgets.QPlainTextEdit()
        self.inner_text.setReadOnly(True)
        v.addWidget(self.inner_text, 1)
        h = QtWidgets.QHBoxLayout()
        h.addWidget(QtWidgets.QLabel("Interval (s):"))
        self.spin_interval = QtWidgets.QSpinBox()
        self.spin_interval.setRange(1, 60)
        self.spin_interval.setValue(15)
        h.addWidget(self.spin_interval)
        self.chk_monologue_tts = QtWidgets.QCheckBox("Speak")
        self.chk_monologue_tts.setChecked(self.core.settings.monologue_tts_enabled)
        h.addWidget(self.chk_monologue_tts)
        h.addWidget(QtWidgets.QLabel("Volume:"))
        self.slider_monologue_vol = QtWidgets.QSlider(QtCore.Qt.Horizontal)
        self.slider_monologue_vol.setRange(0, 100)
        self.slider_monologue_vol.setValue(self.core.settings.monologue_volume)
        h.addWidget(self.slider_monologue_vol)
        btn_start_stop = QtWidgets.QPushButton("Start/Stop")
        h.addWidget(btn_start_stop)
        v.addLayout(h)
        inner.setLayout(v)
        dock.setWidget(inner)
        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, dock)
        self.inner_dock = dock
        self.inner_timer = QtCore.QTimer(self)
        self.inner_timer.setSingleShot(False)
        btn_start_stop.clicked.connect(self._toggle_inner_timer)
        dock.setTitleBarWidget(DockTitleBar(dock, "Inner Monologue"))
        self.dock_tray.register_dock(self.inner_dock)
        self.chk_monologue_tts.stateChanged.connect(lambda _: self._update_monologue_settings())
        self.slider_monologue_vol.valueChanged.connect(lambda _: self._update_monologue_settings())

    def _toggle_inner_timer(self) -> None:
        if self.inner_timer is None:
            return
        if self.inner_timer.isActive():
            self.inner_timer.stop()
        else:
            interval_ms = self.spin_interval.value() * 1000
            try:
                self.inner_timer.timeout.disconnect()
            except Exception:
                pass
            self.inner_timer.timeout.connect(self._generate_inner_monologue)
            self.inner_timer.start(interval_ms)

    def _update_monologue_settings(self) -> None:
        try:
            self.core.settings.monologue_tts_enabled = self.chk_monologue_tts.isChecked() if hasattr(self, 'chk_monologue_tts') else False
            self.core.settings.monologue_volume = self.slider_monologue_vol.value() if hasattr(self, 'slider_monologue_vol') else 50
            self.core.settings.save()
        except Exception:
            pass

    def _generate_inner_monologue(self) -> None:
        schema = self.core.schema_mgr.load_schema(self._current_persona(), self.current_set.get(self._current_persona(), "default"))
        overlay = schema.get("dynamic_overlay", {}) or {}
        mood = overlay.get("temporary_emotional_state", "neutral")
        likes = overlay.get("recent_topics", [])
        pos = [0, 0]
        fav_topic = likes[-1] if likes else None
        thought = f"I'm thinking about {fav_topic} while feeling {mood}." if fav_topic else f"I'm in a {mood} mood and reflecting."
        thought += f" I'm at position {pos}."
        try:
            if hasattr(self, "inner_text") and self.inner_text is not None:
                self.inner_text.appendPlainText(thought)
        except Exception:
            pass

    # ────────────────────────── conversation
    def _append_message(self, display_name: str, text: str, role_key: Optional[str] = None) -> None:
        key = (role_key or display_name).lower()
        bg_colour = ROLE_COLOURS.get(key, "#EEEEEE")
        name_colour = NAME_COLOURS.get(key, "#011627")
        safe_role = QtGui.QGuiApplication.translate("Chat", display_name)
        safe_text = QtGui.QGuiApplication.translate("Chat", text)
        frag = (
            f'<div style="background-color:{bg_colour}; border-radius:4px; padding:4px; margin:4px;">'
            f'<b style="color:{name_colour};">{safe_role}:</b> {safe_text}'
            f'</div>'
        )
        self.chat_view.append(frag)

    def _current_history(self) -> List[Tuple[str, str]]:
        if self.chk_isolated.isChecked():
            return self.isolated_history
        else:
            return self.core.conversation_db.fetch_history(limit=10)

    def _bootstrap_conversation(self) -> None:
        if self.core and len(self.core.conversation_db.fetch_history(limit=1)) == 0:
            schema = self.core.schema_mgr.load_schema(self.active_persona, self.current_set.get(self.active_persona, "default"))
            questions = schema.get("questions", [])
            if questions:
                first_question = questions[0]
                self._append_message("System", first_question, role_key="system")
                if self.chk_semantic.isChecked() and not self.chk_isolated.isChecked():
                    self.core.conversation_db.save_message("system", first_question)

    # ────────────────────────── prompt & rag
    def _build_prompt(self, schema: Dict[str, object], user_text: str, is_self_talk: bool = False) -> str:
        parts: List[str] = []
        name = schema.get("name", "")
        role = schema.get("role", "")
        desc = schema.get("description", "")
        persona_desc = f"You are {name}, {desc}".strip()
        if role:
            persona_desc += f" Your role is {role}."

        overlay = schema.get("dynamic_overlay", {})
        if overlay:
            temp_rel = overlay.get("temporary_relationship_context", "")
            temp_emotion = overlay.get("temporary_emotional_state", "")
            added_traits = overlay.get("added_traits", [])
            if temp_rel:
                persona_desc += f" ({temp_rel})"
            if temp_emotion:
                persona_desc += f" You feel {temp_emotion}."
            if added_traits:
                persona_desc += f" Traits: {', '.join(str(t) for t in added_traits)}."
        parts.append(persona_desc)

        # User description
        try:
            user_schema = self.core.schema_mgr.load_schema("user", self.current_set.get("user", "default"))
        except Exception:
            user_schema = {}
        if user_schema:
            u_name = user_schema.get("name", "User")
            u_personality = user_schema.get("personality", "")
            relationship = user_schema.get("relationship_to_zira", "friend")
            u_overlay = user_schema.get("dynamic_overlay", {})
            temp_rel2 = u_overlay.get("temporary_relationship_context") if u_overlay else None
            if temp_rel2 and str(temp_rel2).strip():
                relationship = str(temp_rel2)
            user_desc = f"User is {u_name}, {u_personality}. Relationship: {relationship}."
            parts.append(user_desc)

        # History
        history_text = ""
        if self.chk_semantic.isChecked():
            history = self._current_history()[-10:]
            for role_name, content in history:
                speaker = "User" if role_name.lower() == "user" else role_name.title()
                history_text += f"{speaker}: {content}\n"
        if history_text:
            parts.append("Conversation history:\n" + history_text.strip())

        # RAG (only datasets listed by this set)
        dataset_text = ""
        ds_names: List[str] = list(schema.get("datasets") or [])
        try:
            # Prefer core search with filters if supported
            hits = self.core.rag_search(
                user_text,
                per_ds_k=3,
                limit=5,
                include_shared=False,
                datasets=ds_names if ds_names else None,
            )
            for chunk, score, ds_name, owner in hits:
                dataset_text += f"Dataset ({owner}/{ds_name}):\n{chunk}\n\n"
        except TypeError:
            # Older core: no dataset filter; fallback to manual selection
            from_texts: List[Tuple[str, str]] = []
            try:
                for name, entry in self.core.dataset_mgr.entries.items():
                    if ds_names and name not in ds_names:
                        continue
                    if not entry.active:
                        continue
                    full_text = self.core.dataset_mgr.load_dataset_text(entry)
                    if full_text:
                        from_texts.append((name, full_text))
            except Exception:
                pass
            for name, full_text in from_texts:
                snip = self._retrieve_dataset_snippet(full_text, user_text)
                if snip:
                    dataset_text += f"Dataset ({name}):\n{snip}\n\n"
        except Exception:
            pass
        if dataset_text:
            parts.append(dataset_text.strip())

        # Self-talk (optional)
        if is_self_talk and self.self_talk_enabled:
            st_prompts = schema.get("self_talk", [])
            if st_prompts:
                import random
                parts.append(random.choice(st_prompts))

        parts.append(f"User: {user_text}")
        return "\n\n".join([p for p in parts if p])

    def _retrieve_dataset_snippet(self, full_text: str, user_text: str) -> str:
        try:
            tokens = [w.lower() for w in re.findall(r"\b\w+\b", user_text) if len(w) > 2]
            paragraphs = [p.strip() for p in full_text.split("\n") if p.strip()]
            scored: List[Tuple[int, str]] = []
            for para in paragraphs:
                l = para.lower()
                score = sum(1 for t in tokens if t in l)
                if score > 0:
                    scored.append((score, para))
            if not scored:
                return paragraphs[0][:500] if paragraphs else full_text[:500]
            scored.sort(key=lambda x: -x[0])
            top = [p for _, p in scored[:2]]
            return "\n".join(top)[:500]
        except Exception:
            return full_text[:500]

    # ────────────────────────── send / model
    def send_message(self) -> None:
        user_text = self.input_edit.toPlainText().strip()
        if not user_text:
            return

        # Broadcast to plugins
        try:
            self.core.plugins.broadcast(user_text)
        except Exception:
            pass

        # Slash commands → ensure applied to current persona+set
        if user_text.startswith("/"):
            self.input_edit.clear()
            persona = self._current_persona()
            set_name = self.current_set.get(persona, "default")
            try:
                out = self.core.run_command(user_text, persona=persona, set_name=set_name)
            except TypeError:
                # Back-compat signature
                out = self.core.run_command(user_text)
            self._append_message("System", out, role_key="system")
            if self.chk_semantic.isChecked() and not self.chk_isolated.isChecked():
                self.core.conversation_db.save_message("system", out)
            return

        # Normal message
        self.input_edit.clear()
        persona = self._current_persona()
        set_name = self.current_set.get(persona, "default")
        schema = self.core.schema_mgr.load_schema(persona, set_name)

        if self.chk_isolated.isChecked():
            self.isolated_history.append(("user", user_text))
        else:
            if self.chk_semantic.isChecked():
                self.core.conversation_db.save_message("user", user_text)

        try:
            user_schema = self.core.schema_mgr.load_schema("user", self.current_set.get("user", "default"))
            user_display = user_schema.get("name", "User")
        except Exception:
            user_display = "User"
        self._append_message(user_display, user_text, role_key="user")

        prompt = self._build_prompt(schema, user_text)

        self.btn_send.setEnabled(False)
        model_slug = self.model_combo.currentText().strip() or self.core.settings.default_model
        worker = ModelWorker(model_slug, prompt, parent=self.core)
        worker.finished.connect(lambda resp, usr=user_text, sch=schema: self._on_model_response(resp, usr, sch))
        worker.finished.connect(lambda: self.btn_send.setEnabled(True))
        worker.start()

    def _on_model_response(self, response_raw: str, user_text: str, schema: Dict[str, object]) -> None:
        model_slug = self.model_combo.currentText().strip()
        response = self._strip_reasoning(model_slug, response_raw)
        response, style_score = self._style_and_guard(response, schema)
        self.style_label.setText(f"Style: {style_score:.2f}")

        if self.chk_isolated.isChecked():
            self.isolated_history.append((schema.get("name", "bot"), response))
        else:
            if self.chk_semantic.isChecked():
                self.core.conversation_db.save_message(schema.get("name", "bot").lower(), response)

        persona_name = schema.get("name", "Bot") or "Bot"
        role_key = self._current_persona().lower()
        self._append_message(persona_name, response, role_key=role_key)
        self.response_edit.setPlainText(response)

        if not self.chk_mute_tts.isChecked():
            try:
                self.core.tts_mgr.enqueue(response)
            except Exception:
                pass

        self._enable_feedback(True)
        self._reset_idle_timer()

        try:
            tokens = [w.lower() for w in re.findall(r"\b\w+\b", user_text) if len(w) > 3]
            for t in tokens:
                self.update_overlay_topic(self._current_persona(), t)
            self.update_overlay_emotion(self._current_persona(), "neutral")
        except Exception:
            pass

        try:
            for line in response.split("\n"):
                if line.strip():
                    self.core.plugins.broadcast(line.strip())
        except Exception as e:
            print(f"Error broadcasting to plugins: {e}")

        if self.core.settings.auto_schema_enabled:
            self.progress_bar.setVisible(True)


            class EvolverWorker(QRunnable):
                def __init__(self, evolver, persona, set_name, history, window):
                    super().__init__()
                    self.evolver = evolver
                    self.persona = persona
                    self.set_name = set_name
                    self.history = history
                    self.window = window

                def run(self):
                    changed = self.evolver.update_schema(self.persona, self.set_name, self.history)
                    QtCore.QMetaObject.invokeMethod(
                        self.window, "_post_evolver", QtCore.Qt.QueuedConnection, QtCore.Q_ARG(bool, changed)
                    )

            QThreadPool.globalInstance().start(
                EvolverWorker(self.core.schema_evolver, self.active_persona, self.current_set.get(self.active_persona, "default"), self._current_history(), self)
            )

    @QtCore.pyqtSlot(bool)
    def _post_evolver(self, changed: bool) -> None:
        self.progress_bar.setVisible(False)
        if changed:
            self._flash_status("Schema adapted")

    def _strip_reasoning(self, model: str, response: str) -> str:
        if model and "deepseek" in model.lower():
            if "<think>" in response and "</think>" in response:
                try:
                    return response.split("</think>")[-1].strip() or response
                except Exception:
                    return response
        return response

    def _style_and_guard(self, text: str, schema: Dict[str, object]) -> Tuple[str, float]:
        exclam = text.count("!")
        sentences = [s for s in re.split(r"[.!?]", text) if s.strip()]
        avg_len = sum(len(s.split()) for s in sentences) / max(1, len(sentences))
        exclam_density = exclam / max(1, len(text))
        tone = schema.get("tone_rules", {"conciseness": [0.6, 0.8], "exclam_limit": 0.05})
        conciseness = max(0.0, min(1.0, (22 - avg_len) / 16.0))
        ex_ok = 1.0 if exclam_density <= float(tone.get("exclam_limit", 0.05)) else 0.5
        score = max(0.0, min(1.0, 0.5 * conciseness + 0.5 * ex_ok))
        return text, score

    def _rewrite_response(self, original: str) -> str:
        try:
            liked = self.core.feedback_db.get_liked_responses(limit=5)
        except Exception:
            liked = []
        schema = self.core.schema_mgr.load_schema(self._current_persona(), self.current_set.get(self._current_persona(), "default"))
        rps = schema.get("rewrite_prompts", [])
        template = rps[0] if rps else "Rewrite to be more appealing. Keep it accurate, concise, and on style."
        parts = [template]
        if liked:
            parts.append("Preferred responses:\n" + "\n\n".join(liked))
        parts.append("Original:\n" + original)
        parts.append("Rewritten:")
        prompt = "\n\n".join(parts)
        return self._run_model(self.model_combo.currentText().strip() or self.core.settings.default_model, prompt) or original

    def _run_model(self, model: str, prompt: str) -> str:
        try:
            proc = subprocess.run(
                ["ollama", "run", model],
                input=prompt.encode("utf-8"),
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                check=True,
            )
            return proc.stdout.decode("utf-8", errors="replace").strip()
        except subprocess.CalledProcessError as e:
            return e.stderr.decode("utf-8", errors="replace").strip()
        except FileNotFoundError:
            return "(error) ollama executable not found."
        except Exception as e:
            return f"(error) {e}"

    # ────────────────────────── persona / sets
    def _populate_set_combo(self, persona: str, combo: QtWidgets.QComboBox) -> None:
        combo.blockSignals(True)
        combo.clear()
        for s in self.core.schema_mgr.get_set_list(persona):
            combo.addItem(s)
        current = self.current_set.get(persona, "default")
        idx = combo.findText(current)
        combo.setCurrentIndex(idx if idx >= 0 else combo.findText("default"))
        if idx < 0:
            self.current_set[persona] = combo.currentText()
        combo.blockSignals(False)

    def _on_set_changed(self, persona: str, name: str, combo: QtWidgets.QComboBox) -> None:
        if not name:
            return
        self.current_set[persona] = name
        # keep AgentCore pointed to the right set if this persona is active
        if persona == self._current_persona():
            self.core.persona = persona
            self.core.set_name = name

        # refresh editor + commands row for this tab
        tab = self.tab_widgets.get(persona)
        if tab:
            editor = tab.findChild(QtWidgets.QPlainTextEdit, f"schema_edit_{persona}")
            if editor:
                schema = self.core.schema_mgr.load_schema(persona, name)
                editor.setPlainText(json.dumps(schema, indent=2))
            cmd_combo = tab.findChild(QtWidgets.QComboBox, f"cmd_combo_{persona}")
            if cmd_combo:
                self._populate_command_combo(persona, cmd_combo)

        # persist active sets & update controls tied to schema flags
        self.core.schema_mgr.save_active_schemas(self.current_set)
        self._sync_semantic_checkbox_from_schema()
        self._update_feedback_counts()

        # refresh slash command list if this persona is active
        try:
            if persona == self._current_persona():
                self._populate_command_select()
        except Exception:
            pass

    def _on_clone_set(self, persona: str, combo: QtWidgets.QComboBox) -> None:
        src = combo.currentText()
        name, ok = QtWidgets.QInputDialog.getText(self, "Clone Set", "Enter new set name:")
        if not ok or not name.strip():
            return
        new_name = name.strip()
        try:
            schema = self.core.schema_mgr.load_schema(persona, src)
            # Preserve the persona's canonical name; set label is separate
            schema["name"] = persona.capitalize()
            self.core.schema_mgr.save_schema(persona, new_name, schema)
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "Error", str(e))
            return
        self.current_set[persona] = new_name
        self._populate_set_combo(persona, combo)
        combo.setCurrentText(new_name)
        if persona == self._current_persona():
            self.core.set_name = new_name
        self.core.schema_mgr.save_active_schemas(self.current_set)
        self._sync_semantic_checkbox_from_schema()
        self._update_feedback_counts()

    def _on_new_set(self, persona: str, combo: QtWidgets.QComboBox) -> None:
        src = combo.currentText()
        name, ok = QtWidgets.QInputDialog.getText(self, "New Set", "Enter name for new set:")
        if not ok or not name.strip():
            return
        new_name = name.strip()
        try:
            schema = self.core.schema_mgr.load_schema(persona, src)
            # Preserve the persona's canonical name; set label is separate
            schema["name"] = persona.capitalize()
            self.core.schema_mgr.save_schema(persona, new_name, schema)
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "Error", str(e))
            return
        self.current_set[persona] = new_name
        self._populate_set_combo(persona, combo)
        combo.setCurrentText(new_name)
        if persona == self._current_persona():
            self.core.set_name = new_name
        self.core.schema_mgr.save_active_schemas(self.current_set)
        self._sync_semantic_checkbox_from_schema()
        self._update_feedback_counts()

    def _on_delete_set(self, persona: str, combo: QtWidgets.QComboBox) -> None:
        name = combo.currentText()
        if name == "default":
            QtWidgets.QMessageBox.information(self, "Cannot Delete", "The default set cannot be deleted.")
            return
        if QtWidgets.QMessageBox.question(
            self, "Delete Set", f"Delete '{name}' (irreversible)?", QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No
        ) != QtWidgets.QMessageBox.Yes:
            return
        try:
            set_dir = os.path.join(self.core.schema_mgr.schemas_dir, persona.lower(), "sets", name)
            import shutil
            shutil.rmtree(set_dir, ignore_errors=True)
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "Error", str(e))
            return
        self.current_set[persona] = "default"
        self._populate_set_combo(persona, combo)
        combo.setCurrentText("default")
        if persona == self._current_persona():
            self.core.set_name = "default"
        self.core.schema_mgr.save_active_schemas(self.current_set)
        self._sync_semantic_checkbox_from_schema()
        self._update_feedback_counts()

    def _on_save_schema(self, persona: str) -> None:
        tab = self.tab_widgets.get(persona)
        if not tab:
            return
        editor = tab.findChild(QtWidgets.QPlainTextEdit, f"schema_edit_{persona}")
        if not editor:
            return
        text = editor.toPlainText().strip()
        try:
            schema = json.loads(text)
            if not isinstance(schema, dict):
                raise ValueError
        except Exception:
            QtWidgets.QMessageBox.warning(self, "Invalid JSON", "The schema is not valid JSON.")
            return
        set_name = self.current_set.get(persona, "default")
        existing_schema = self.core.schema_mgr.load_schema(persona, set_name)
        merged_schema = {**existing_schema, **schema}
        # Ensure the top-level name matches the active set name
        try:
            merged_schema["name"] = set_name
        except Exception:
            pass
        self.core.schema_mgr.save_schema(persona, set_name, merged_schema)
        QtWidgets.QMessageBox.information(self, "Saved", f"Schema saved for {persona} ({set_name}).")

        if persona == self._current_persona():
            persona_voice = (merged_schema.get("voice") or "").lower()
            for i in range(self.voice_combo.count()):
                if persona_voice and persona_voice in self.voice_combo.itemText(i).lower():
                    self.voice_combo.setCurrentIndex(i)
                    break
        # After save, refresh commands combo (in case user edited commands JSON directly)
        tab = self.tab_widgets.get(persona)
        if tab:
            cmd_combo = tab.findChild(QtWidgets.QComboBox, f"cmd_combo_{persona}")
            if cmd_combo:
                self._populate_command_combo(persona, cmd_combo)

    def _tab_changed(self, index: int) -> None:
        if 0 <= index < len(self.core.schema_mgr.personas):
            self.active_persona = self.core.schema_mgr.personas[index]
        else:
            self.active_persona = self.core.schema_mgr.personas[0] if self.core.schema_mgr.personas else "zira"
        self.core.persona = self.active_persona

        schema = self.core.schema_mgr.load_schema(self.active_persona, self.current_set.get(self.active_persona, "default"))
        persona_voice = (schema.get("voice") or "").lower()
        for i in range(self.voice_combo.count()):
            if persona_voice and persona_voice in self.voice_combo.itemText(i).lower():
                self.voice_combo.setCurrentIndex(i)
                break

        tab = self.tab_widgets.get(self.active_persona)
        if tab:
            editor = tab.findChild(QtWidgets.QPlainTextEdit, f"schema_edit_{self.active_persona}")
            if editor:
                editor.setPlainText(json.dumps(schema, indent=2))
            cmd_combo = tab.findChild(QtWidgets.QComboBox, f"cmd_combo_{self.active_persona}")
            if cmd_combo:
                self._populate_command_combo(self.active_persona, cmd_combo)

        try:
            user_schema = self.core.schema_mgr.load_schema("user", self.current_set.get("user", "default"))
            bot_name = schema.get("name", self.active_persona.title())
            bot_set = self.current_set.get(self.active_persona, "default")
            user_name = user_schema.get("name", "User")
            user_set = self.current_set.get("user", "default")
            self.lbl_active_names.setText(f"{bot_name}: {bot_set} — User: {user_name}: {user_set}")
        except Exception:
            pass

        self._sync_semantic_checkbox_from_schema()
        self._update_feedback_counts()

        # refresh slash command dropdown on persona change
        try:
            self._populate_command_select()
        except Exception:
            pass

    def _current_persona(self) -> str:
        return self.active_persona

    # ────────────────────────── overlay helpers
    def update_overlay_topic(self, persona: str, topic: str) -> None:
        persona = persona.lower()
        try:
            schema = self.core.schema_mgr.load_schema(persona, self.current_set.get(persona, "default"))
            overlay = dict(schema.get("dynamic_overlay", {}))
            topics = list(overlay.get("recent_topics", []))
            if topic and topic not in topics:
                topics.append(topic)
                if len(topics) > 10:
                    topics = topics[-10:]
                overlay["recent_topics"] = topics
                schema["dynamic_overlay"] = overlay
                self.core.schema_mgr.save_schema(persona, self.current_set.get(persona, "default"), schema)
        except Exception:
            pass

    def update_overlay_emotion(self, persona: str, emotion: str) -> None:
        persona = persona.lower()
        try:
            schema = self.core.schema_mgr.load_schema(persona, self.current_set.get(persona, "default"))
            overlay = dict(schema.get("dynamic_overlay", {}))
            overlay["temporary_emotional_state"] = emotion
            schema["dynamic_overlay"] = overlay
            self.core.schema_mgr.save_schema(persona, self.current_set.get(persona, "default"), schema)
        except Exception:
            pass

    # ────────────────────────── devices & models
    def _populate_devices(self) -> None:
        self.device_combo.clear()
        try:
            if sd is not None:
                devs = [d.get("name", "?") for d in sd.query_devices() if d.get("max_input_channels", 0) > 0]
                if devs:
                    self.device_combo.addItems(devs)
        except Exception:
            pass
        if self.device_combo.count() == 0:
            self.device_combo.addItem("Default")

    def _populate_models(self) -> None:
        models: List[str] = []
        try:
            out = subprocess.run(
                ["ollama", "list"],
                stdout=subprocess.PIPE,
                stderr=subprocess.DEVNULL,
                text=True,
                check=True,
            ).stdout.splitlines()
            for line in out[1:]:
                parts = line.strip().split()
                if parts:
                    models.append(parts[0])
        except Exception:
            pass
        if not models:
            models = [self.core.settings.default_model or "mistral:latest"]
        self.model_combo.clear()
        self.model_combo.addItems(models)
        idx = self.model_combo.findText(self.core.settings.default_model)
        if idx >= 0:
            self.model_combo.setCurrentIndex(idx)

    # ────────────────────────── slash commands panel
    def _build_command_dock(self) -> None:
        """
        Build a dockable panel that exposes slash commands with an argument
        entry and send button. This allows users to trigger any command
        without typing it into the chat manually. It will be updated when
        persona or set changes.
        """
        dock = QtWidgets.QDockWidget("Slash Commands", self)
        dock.setObjectName("SlashCommandsDock")
        dock.setFeatures(
            QtWidgets.QDockWidget.DockWidgetClosable
            | QtWidgets.QDockWidget.DockWidgetMovable
            | QtWidgets.QDockWidget.DockWidgetFloatable
        )
        container = QtWidgets.QWidget()
        layout = QtWidgets.QVBoxLayout(container)
        layout.setContentsMargins(7, 7, 7, 7)
        layout.setSpacing(5)

        # command selector
        cmd_label = QtWidgets.QLabel("Slash Command:")
        self.command_select = QtWidgets.QComboBox()
        layout.addWidget(cmd_label)
        layout.addWidget(self.command_select)

        # argument input
        self.command_input = QtWidgets.QLineEdit()
        self.command_input.setPlaceholderText("Enter arguments or select text from chat…")
        layout.addWidget(self.command_input)

        # send button
        btn_run = QtWidgets.QPushButton("Run Command")
        btn_run.clicked.connect(self._on_run_command)
        layout.addWidget(btn_run)
        layout.addStretch(1)

        dock.setWidget(container)
        # add to right side by default
        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, dock)
        self.command_dock = dock

    def _populate_command_select(self) -> None:
        """
        Populate the slash command dropdown with available commands from
        the command registry. This is called whenever the active persona
        or set changes to reflect dynamic additions.
        """
        try:
            cmds = []
            if hasattr(self.core, "command_registry") and self.core.command_registry:
                cmds = list(self.core.command_registry.list_commands())
            # if schema defines additional commands, include them
            persona = self._current_persona()
            set_name = self.current_set.get(persona, "default")
            schema = self.core.schema_mgr.load_schema(persona, set_name)
            schema_cmds = list((schema.get("commands") or {}).keys())
            for c in schema_cmds:
                if c not in cmds:
                    cmds.append(c)
            cmds.sort()
        except Exception:
            cmds = []
        self.command_select.blockSignals(True)
        self.command_select.clear()
        if cmds:
            self.command_select.addItems(cmds)
        self.command_select.blockSignals(False)

    def _on_run_command(self) -> None:
        """
        Handler for running the selected slash command with the provided
        argument. The command will be executed via AgentCore and the
        result appended to the chat window. Selection text from the chat
        can be inserted into the argument field via context menu.
        """
        cmd = (self.command_select.currentText() or "").strip()
        if not cmd:
            QtWidgets.QMessageBox.information(self, "No Command", "Select a slash command to run.")
            return
        arg = self.command_input.text().strip()
        # combine command and arguments
        full = cmd if not arg else f"{cmd} {arg}"
        try:
            # process via core; record conversation
            resp = self.core.process_user_message(full, tts=False)
            # append user command and agent response to chat
            self._append_message("user", full, role_key="user")
            self._append_message("zira", resp, role_key="zira")
            # clear argument
            self.command_input.clear()
            # update feedback counts and idle timer
            self._update_feedback_counts()
            self._reset_idle_timer()
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "Command Error", str(e))

    def _show_chat_context_menu(self, pos: QtCore.QPoint) -> None:
        """
        Custom context menu for the chat view. Adds a menu entry to send
        selected text into the slash command argument field.
        """
        menu = self.chat_view.createStandardContextMenu()
        try:
            cursor = self.chat_view.textCursor()
            if cursor and cursor.hasSelection():
                action = menu.addAction("Send selection to command input")
                action.triggered.connect(self._send_selection_to_command_input)
        except Exception:
            pass
        menu.exec_(self.chat_view.mapToGlobal(pos))

    def _send_selection_to_command_input(self) -> None:
        """
        Copy the currently selected text in the chat view into the command
        input field for slash command execution.
        """
        try:
            cursor = self.chat_view.textCursor()
            if cursor and cursor.hasSelection():
                text = cursor.selectedText()
                self.command_input.setText(text.strip())
        except Exception:
            pass

    def _on_model_changed(self, name: str) -> None:
        """
        Update the default model in settings when the user selects a new
        model from the dropdown. This ensures the AgentCore uses the
        selected model for subsequent interactions.
        """
        try:
            if not name:
                return
            self.core.settings.default_model = name
            self.core.settings.save()
        except Exception:
            pass

    def _on_show_model_manager(self) -> None:
        """
        Show (or raise) the model manager dock. If the dock was
        previously hidden, it will be shown; if it is already visible,
        this will bring it to the front. A dock must be built in
        `_build_model_manager()` prior to showing.
        """
        try:
            if self.model_dock.isVisible():
                # already visible: raise to top
                self.model_dock.raise_()
            else:
                self.model_dock.show()
                self.model_dock.raise_()
        except Exception:
            pass

    # ────────────────────────── settings toggles
    def _on_auto_schema_toggled(self, checked: bool) -> None:
        try:
            self.core.settings.auto_schema_enabled = bool(checked)
            self.core.settings.save()
        except Exception:
            pass
        self.statusBar().showMessage(f"Auto Schema Evolution {'enabled' if checked else 'disabled'}", 2500)

    def _on_google_stt_toggled(self, checked: bool) -> None:
        """
        Opt-in/out of using Google Cloud Speech-to-Text. When enabling the
        toggle for the first time in a session, show a warning that
        recordings will be sent to Google’s servers under their privacy
        policy. If declined, the checkbox will be turned off again.
        """
        # Only show the dialog when transitioning from unchecked → checked
        try:
            current = bool(getattr(self.core.settings, "use_google_stt", False))
        except Exception:
            current = False
        if checked and not current:
            ok = QtWidgets.QMessageBox.question(
                self,
                "Enable Google STT?",
                "Audio will be uploaded to Google Cloud for transcription\n"
                "under Google's privacy policy. Continue?",
                QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No,
            )
            if ok != QtWidgets.QMessageBox.Yes:
                # revert checkbox silently
                self.chk_google_stt.blockSignals(True)
                self.chk_google_stt.setChecked(False)
                self.chk_google_stt.blockSignals(False)
                return
        # persist the new state
        try:
            self.core.settings.use_google_stt = bool(checked)
            self.core.settings.save()
        except Exception:
            pass

    # ────────────────────────── spell suggestions
    def _show_input_context_menu(self, pos: QtCore.QPoint) -> None:
        """
        Custom context menu on the input field that offers spelling
        suggestions when the user right-clicks a misspelled word. Only
        appears if pyspellchecker is available.
        """
        menu = self.input_edit.createStandardContextMenu()
        # compute suggestions only if SpellChecker is available
        if SpellChecker:
            cursor = self.input_edit.cursorForPosition(pos)
            # select the word under cursor
            cursor.select(QtGui.QTextCursor.WordUnderCursor)
            word = cursor.selectedText()
            if word and len(word) >= 3:
                sc = SpellChecker()
                suggestions = list(sc.candidates(word.lower()))
                # sort by Levenshtein distance and frequency; keep top 5
                suggestions = sorted(suggestions, key=lambda w: sc.word_probability(w), reverse=True)[:5]
                if suggestions and suggestions != [word.lower()]:
                    suggest_menu = menu.addMenu("Spelling suggestions")
                    for s in suggestions:
                        act = suggest_menu.addAction(s)
                        act.triggered.connect(lambda chk=False, repl=s, c=cursor: self._replace_word(c, repl))
        menu.exec_(self.input_edit.mapToGlobal(pos))

    def _replace_word(self, cursor: QtGui.QTextCursor, replacement: str) -> None:
        """
        Replace the word at the given cursor with a suggestion. This
        method is connected dynamically for each suggestion action.
        """
        try:
            cursor.beginEditBlock()
            cursor.removeSelectedText()
            cursor.insertText(replacement)
            cursor.endEditBlock()
        except Exception:
            pass

    def _on_semantic_toggled(self, checked: bool) -> None:
        """Persist semantic awareness per persona+set."""
        persona = self._current_persona()
        set_name = self.current_set.get(persona, "default")
        try:
            schema = self.core.schema_mgr.load_schema(persona, set_name)
            flags = dict(schema.get("flags") or {})
            flags["semantic_awareness"] = bool(checked)
            schema["flags"] = flags
            self.core.schema_mgr.save_schema(persona, set_name, schema)
        except Exception:
            pass
        self._reset_idle_timer()

    def _sync_semantic_checkbox_from_schema(self) -> None:
        """Load semantic_awareness from current schema into the checkbox."""
        persona = self._current_persona()
        set_name = self.current_set.get(persona, "default")
        try:
            schema = self.core.schema_mgr.load_schema(persona, set_name)
            flags = schema.get("flags", {})
            val = bool(flags.get("semantic_awareness", True))
        except Exception:
            val = True
        self.chk_semantic.blockSignals(True)
        self.chk_semantic.setChecked(val)
        self.chk_semantic.blockSignals(False)

    # ────────────────────────── status helper
    def _flash_status(self, msg: str) -> None:
        self.statusBar().showMessage(msg, 3000)


# ────────────────────────── Dock tray & titlebar
class DockTray(QtWidgets.QWidget):
    restoreRequested = QtCore.pyqtSignal(QtWidgets.QDockWidget)

    def __init__(self, parent: Optional[QtWidgets.QWidget] = None) -> None:
        super().__init__(parent)
        self._map: Dict[QtWidgets.QDockWidget, QtWidgets.QPushButton] = {}
        lay = QtWidgets.QHBoxLayout(self)
        lay.setContentsMargins(6, 4, 6, 4)
        lay.setSpacing(6)
        self._layout = lay
        self._title = QtWidgets.QLabel("Minimized panels:")
        self._title.setStyleSheet("color: #f0f0f0; font-weight: bold;")
        self._layout.addWidget(self._title, 0)
        self._layout.addStretch(1)
        self.setStyleSheet("background-color: #3c4a6b;")

    def register_dock(self, dock: QtWidgets.QDockWidget) -> None:
        dock.visibilityChanged.connect(lambda vis, d=dock: self._on_visibility_changed(d, vis))
        if not dock.isVisible():
            self._add_button(dock)

    def _on_visibility_changed(self, dock: QtWidgets.QDockWidget, visible: bool) -> None:
        if visible:
            self._remove_button(dock)
        else:
            self._add_button(dock)

    def _add_button(self, dock: QtWidgets.QDockWidget) -> None:
        if dock in self._map:
            return
        btn = QtWidgets.QPushButton(dock.windowTitle())
        btn.setToolTip(f"Restore {dock.windowTitle()}")
        btn.setStyleSheet(
            "background-color: #4a5b78; color: #ffffff; padding: 4px 6px; border: none; border-radius: 3px;"
        )
        btn.clicked.connect(lambda checked=False, d=dock: self._restore(d))
        self._layout.insertWidget(self._layout.count() - 1, btn)
        self._map[dock] = btn

    def _remove_button(self, dock: QtWidgets.QDockWidget) -> None:
        btn = self._map.pop(dock, None)
        if btn:
            self._layout.removeWidget(btn)
            btn.deleteLater()

    def _restore(self, dock: QtWidgets.QDockWidget) -> None:
        dock.show()
        dock.raise_()
        self.restoreRequested.emit(dock)


class DockTitleBar(QtWidgets.QWidget):
    def __init__(self, dock: QtWidgets.QDockWidget, title: str) -> None:
        super().__init__(dock)
        self._dock = dock
        h = QtWidgets.QHBoxLayout(self)
        h.setContentsMargins(6, 2, 6, 2)
        h.setSpacing(6)
        self.lbl = QtWidgets.QLabel(title)
        h.addWidget(self.lbl)
        h.addStretch()
        self.btn_min = QtWidgets.QToolButton()
        self.btn_min.setText("–")
        self.btn_min.setToolTip("Minimize to bottom tray")
        self.btn_min.clicked.connect(lambda checked=False: self._dock.hide())
        h.addWidget(self.btn_min)
        self.btn_max = QtWidgets.QToolButton()
        self.btn_max.setText("□")
        self.btn_max.setToolTip("Enlarge / Restore")
        self.btn_max.clicked.connect(self._on_toggle_maximize)
        h.addWidget(self.btn_max)
        self.btn_close = QtWidgets.QToolButton()
        self.btn_close.setText("×")
        self.btn_close.setToolTip("Close (send to bottom tray)")
        self.btn_close.clicked.connect(lambda checked=False: self._dock.hide())
        h.addWidget(self.btn_close)
        self.installEventFilter(self)

    def eventFilter(self, _obj: QtCore.QObject, evt: QtCore.QEvent) -> bool:
        if evt.type() == QtCore.QEvent.MouseButtonDblClick:
            self._dock.setFloating(not self._dock.isFloating())
            return True
        return False

    def _on_toggle_maximize(self) -> None:
        mw: Optional[QtWidgets.QMainWindow] = self._dock.parentWidget()  # type: ignore
        while mw and not isinstance(mw, QtWidgets.QMainWindow):
            mw = mw.parentWidget()  # type: ignore
        if not isinstance(mw, QtWidgets.QMainWindow):
            self._dock.setFloating(not self._dock.isFloating())
            return
        if not self._dock.isFloating():
            self._dock.setFloating(True)
            mw_geo = mw.geometry()
            w = int(mw_geo.width() * 0.9)
            h = int(mw_geo.height() * 0.85)
            self._dock.resize(w, h)
            center = mw_geo.center()
            self._dock.move(center.x() - w // 2, center.y() - h // 2)
        else:
            self._dock.setFloating(False)


# ────────────────────────── dataset manager dialog
class DatasetManagerDialog(QtWidgets.QDialog):
    def __init__(self, dataset_mgr, parent: Optional[QtWidgets.QWidget] = None) -> None:
        super().__init__(parent)
        self.setWindowTitle("Dataset Manager")
        self.resize(520, 420)
        self.dataset_mgr = dataset_mgr
        v = QtWidgets.QVBoxLayout(self)
        self.list_widget = QtWidgets.QListWidget()
        v.addWidget(self.list_widget, 1)
        h = QtWidgets.QHBoxLayout()
        self.btn_add = QtWidgets.QPushButton("Add Dataset")
        self.btn_del = QtWidgets.QPushButton("Delete Dataset")
        h.addWidget(self.btn_add)
        h.addWidget(self.btn_del)
        h.addStretch()
        v.addLayout(h)
        self._populate()
        self.btn_add.clicked.connect(self._on_add)
        self.btn_del.clicked.connect(self._on_delete)
        self.list_widget.itemChanged.connect(self._on_item)

    def _populate(self) -> None:
        self.list_widget.clear()
        for name, entry in sorted(self.dataset_mgr.entries.items()):
            item = QtWidgets.QListWidgetItem(name)
            item.setFlags(item.flags() | QtCore.Qt.ItemIsUserCheckable)
            item.setCheckState(QtCore.Qt.Checked if entry.active else QtCore.Qt.Unchecked)
            self.list_widget.addItem(item)

    def _on_add(self) -> None:
        name, ok = QtWidgets.QInputDialog.getText(self, "New Dataset", "Enter dataset name:")
        if not ok or not name.strip():
            return
        path, _ = QtWidgets.QFileDialog.getOpenFileName(self, "Select .txt or .pdf", "", "Text/PDF (*.txt *.pdf)")
        if not path:
            return
        try:
            self.dataset_mgr.add_dataset(name.strip(), path)
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "Error", str(e))
            return
        self._populate()

    def _on_delete(self) -> None:
        item = self.list_widget.currentItem()
        if not item:
            return
        name = item.text()
        if QtWidgets.QMessageBox.question(
            self, "Delete Dataset", f"Delete '{name}'?", QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No
        ) != QtWidgets.QMessageBox.Yes:
            return
        try:
            self.dataset_mgr.delete_dataset(name)
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "Error", str(e))
            return
        self._populate()

    def _on_item(self, item: QtWidgets.QListWidgetItem) -> None:
        self.dataset_mgr.toggle_active(item.text(), item.checkState() == QtCore.Qt.Checked)


# ────────────────────────── run as script
if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    win = AppWindow()
    win.show()
    sys.exit(app.exec_())
```

agent_ui.py
============

PyQt5 UI for the AI TTS Agent (integrated with AgentCore).

Fixes & additions:
- Slash commands (/remember etc.) now apply to the currently selected persona+set.
- Per-set "Semantic Awareness" persisted (schema.flags.semantic_awareness).
- RAG only uses datasets listed in the current set's schema ("datasets": [...]).
- Schema tab: new Commands row (dropdown + input + Add to Command + New Command).

To launch: `python run_agent.py`
**Classes:** _SpellHighlighter, AppWindow, DockTray, DockTitleBar, DatasetManagerDialog


## Module `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\_burner_scripts\agent_core.py`

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
agent_core.py
=================

Full, end-to-end core for an AI AI TTS Agent with:
- Settings & model bootstrap (Ollama)
- Robust plugin host (enable/disable/list, manifest validation, dependency checks)
- Conversation & feedback stores (with indices, exports)
- Persona schema management (with protected keys) and live signals
- Dataset registry + RAG embeddings cache & query (per persona/set, cross-profile sharing)
  * Multi-file datasets, cache invalidation, provenance
- Context monitor + schema auto-updates driven by directives & feedback (rate-limited)
- Command registry (weight/lock) + full command execution layer
- New commands: /reject, /auto, /ignore, /opposite, /delete, /rewrite (extended persistence)
- BeanCounter reinforcement + integration with feedback and command weights
- Speech I/O (TTS locked to Zira; STT via Sphinx when available) w/ volume control
- Threaded model worker wrapper (cancel-safe)
- Orchestrator (`AgentCore`) wiring everything together for headless/GUI
- CLI entrypoint for smoke tests

Notes
-----
• This module is UI-agnostic. Hook the provided Qt signals in your GUI (`agent_ui.py`).
• All directories are scoped under `base_dir`, with per-persona/per-set state in:
  base_dir/profiles/<persona>/<set>/
"""

from __future__ import annotations

import threading
import json
import os
import shutil
import sqlite3
import subprocess
import sys
import time
import traceback
import re
import logging
from dataclasses import dataclass
from typing import Dict, List, Optional, Tuple, Any
from collections import Counter

# ──────────────────────────────────────────────────────────────────────────────
# Logging
# ──────────────────────────────────────────────────────────────────────────────
logger = logging.getLogger("agent_core")
if not logger.handlers:
    _lvl = os.getenv("AGENT_CORE_LOGLEVEL", "INFO").upper()
    logging.basicConfig(
        level=getattr(logging, _lvl, logging.INFO),
        format="%(asctime)s [%(levelname)s] %(name)s: %(message)s",
    )

# ──────────────────────────────────────────────────────────────────────────────
# Optional deps (graceful fallbacks)
# ──────────────────────────────────────────────────────────────────────────────
try:
    import numpy as np  # type: ignore
except Exception:
    np = None  # type: ignore
    logger.warning("numpy not available; embeddings will be disabled")

try:
    import sounddevice as sd  # type: ignore
    import soundfile as sf  # type: ignore
except Exception:
    sd = None  # type: ignore
    sf = None  # type: ignore
    logger.info("sounddevice/soundfile not available; audio recording disabled")

# Optional Google STT
try:
    from google.cloud import speech as gspeech  # type: ignore
    import pyaudio  # type: ignore
except Exception:
    gspeech = None  # type: ignore
    pyaudio = None  # type: ignore
    logger.info("google-cloud-speech or pyaudio not available; STT via Google disabled")

try:
    import pyttsx3  # type: ignore
except Exception:
    pyttsx3 = None  # type: ignore
    logger.info("pyttsx3 not available; TTS disabled")

try:
    from PyPDF2 import PdfReader  # type: ignore
except Exception:
    PdfReader = None  # type: ignore
    logger.info("PyPDF2 not available; PDF ingest will be skipped")

try:
    from sentence_transformers import SentenceTransformer  # type: ignore
except Exception:
    SentenceTransformer = None  # type: ignore
    logger.info("sentence_transformers not available; will attempt Ollama embeddings or disable RAG")

try:
    from PyQt5 import QtCore  # type: ignore
except Exception:
    # Minimal shim if PyQt5 is absent, to keep code importable
    class _ShimSignal:
        def __init__(self, *_, **__): pass
        def emit(self, *_, **__): pass
        def connect(self, *_, **__): pass
    class _ShimQObject: pass
    class _ShimQThread:
        def __init__(self, *_, **__): pass
        def start(self): pass
        def deleteLater(self): pass
        def requestInterruption(self): pass
        def isInterruptionRequested(self): return False
    QtCore = type("QtCore", (), {
        "QObject": _ShimQObject,
        "pyqtSignal": lambda *a, **k: _ShimSignal(),
        "QThread": _ShimQThread
    })  # type: ignore

__version__ = "2.4.1"

CONTROL_SCHEMA_PATH = os.path.join(os.path.dirname(os.path.abspath(__file__)), "control_schema.json")
DEFAULT_SCHEMAS_FILE = os.path.join(os.path.dirname(os.path.abspath(__file__)), "default_schemas.json")
ACTIVE_SCHEMAS_FILE  = os.path.join(os.path.dirname(os.path.abspath(__file__)), "active_schemas.json")

# ──────────────────────────────────────────────────────────────────────────────
# Ollama model bootstrap
# ──────────────────────────────────────────────────────────────────────────────
REQUIRED_MODELS: List[str] = [
    "gemma3:27b",
    "mistral:latest",
    "codellama:latest",
    "llava:latest",
    "mxbai-embed-large:latest",            # embeddings alt
    "snowflake-arctic-embed:latest",       # embeddings alt
]

def _have_cli(bin_name: str) -> bool:
    # Cross-platform check (Windows/macOS/Linux)
    try:
        from shutil import which
        return which(bin_name) is not None
    except Exception:
        return False

def ensure_models_present() -> None:
    """
    Check Ollama registry and pull any missing REQUIRED_MODELS (best-effort).
    Non-fatal if Ollama is missing/unreachable.
    """
    if not _have_cli("ollama"):
        logger.warning("[bootstrap] ollama not available on PATH")
        return
    try:
        output = subprocess.check_output(["ollama", "list"], timeout=10).decode(errors="ignore")
    except Exception as e:
        logger.warning("[bootstrap] ollama not available: %s", e)
        return
    for slug in REQUIRED_MODELS:
        if slug in output:
            continue
        try:
            logger.info("[bootstrap] Pulling model: %s", slug)
            subprocess.run(["ollama", "pull", slug], check=False, timeout=900)
        except Exception as e:
            logger.warning("[bootstrap] Failed to pull %s: %s", slug, e)

# ──────────────────────────────────────────────────────────────────────────────
# Settings
# ──────────────────────────────────────────────────────────────────────────────
class Settings:
    def __init__(self, base_dir: str) -> None:
        self.base_dir = base_dir
        self.path = os.path.join(self.base_dir, "settings.json")
        # General
        self.default_model: str = "gemma3:27b"
        self.context_depth: int = 20
        self.auto_schema_enabled: bool = True
        self.enabled_plugins: List[str] = []
        # Speech
        self.monologue_tts_enabled: bool = False
        self.monologue_volume: int = 50
        # Speech-to-text (Google) toggle
        self.use_google_stt: bool = False
        # Versioning
        self.schema_version: int = 2
        self.load()
        self._migrate_if_needed()
        self.validate()

    def validate(self) -> None:
        try:
            if not isinstance(self.context_depth, int) or self.context_depth <= 0:
                self.context_depth = 20
            if not isinstance(self.monologue_volume, int) or not (0 <= self.monologue_volume <= 100):
                self.monologue_volume = 50
            if not isinstance(self.enabled_plugins, list):
                self.enabled_plugins = []
            # ensure use_google_stt is a boolean
            self.use_google_stt = bool(self.use_google_stt)
        except Exception:
            pass

    def _migrate_if_needed(self) -> None:
        current = 2
        if self.schema_version < current:
            self.schema_version = current
            self.save()

    def load(self) -> None:
        try:
            if os.path.isfile(self.path):
                with open(self.path, "r", encoding="utf-8") as f:
                    data = json.load(f)
                for k in list(self.__dict__.keys()):
                    if k in data:
                        setattr(self, k, data[k])
        except Exception as e:
            logger.warning("[Settings] load error: %s", e)

    def save(self) -> None:
        try:
            os.makedirs(os.path.dirname(self.path), exist_ok=True)
            with open(self.path, "w", encoding="utf-8") as f:
                json.dump({
                    "default_model": self.default_model,
                    "context_depth": self.context_depth,
                    "auto_schema_enabled": self.auto_schema_enabled,
                    "enabled_plugins": self.enabled_plugins,
                    "monologue_tts_enabled": self.monologue_tts_enabled,
                    "monologue_volume": self.monologue_volume,
                    "use_google_stt": self.use_google_stt,
                    "schema_version": self.schema_version,
                }, f, indent=2)
        except Exception as e:
            logger.error("[Settings] save error: %s", e)

# ──────────────────────────────────────────────────────────────────────────────
# Helpers (paths)
# ──────────────────────────────────────────────────────────────────────────────
def prof_dir(base_dir: str, persona: str, set_name: str) -> str:
    return os.path.join(base_dir, "profiles", persona, set_name)

def prof_datasets_dir(base_dir: str, persona: str, set_name: str) -> str:
    return os.path.join(prof_dir(base_dir, persona, set_name), "datasets")

def prof_commands_path(base_dir: str, persona: str, set_name: str) -> str:
    return os.path.join(prof_dir(base_dir, persona, set_name), "commands.json")

def prof_reinforcement_path(base_dir: str, persona: str, set_name: str) -> str:
    return os.path.join(prof_dir(base_dir, persona, set_name), "reinforcement.json")

def conv_db_path(base_dir: str, persona: str, set_name: str) -> str:
    return os.path.join(base_dir, "conversations", f"{persona}_{set_name}.sqlite3")

def feedback_db_path(base_dir: str, persona: str, set_name: str) -> str:
    return os.path.join(base_dir, "feedback", f"{persona}_{set_name}.sqlite3")

# ──────────────────────────────────────────────────────────────────────────────
# Conversation store
# ──────────────────────────────────────────────────────────────────────────────
class ConversationDB:
    def __init__(self, path: str) -> None:
        os.makedirs(os.path.dirname(path), exist_ok=True)
        self.path = path
        self._lock = threading.RLock()
        self.conn = sqlite3.connect(path, check_same_thread=False)
        with self._lock:
            self.conn.execute(
                "CREATE TABLE IF NOT EXISTS conversation ("
                "id INTEGER PRIMARY KEY AUTOINCREMENT, "
                "timestamp REAL, role TEXT, content TEXT)"
            )
            # Indices for speed
            self.conn.execute("CREATE INDEX IF NOT EXISTS idx_conv_ts ON conversation(timestamp)")
            self.conn.execute("CREATE INDEX IF NOT EXISTS idx_conv_role ON conversation(role)")
            self.conn.commit()

    def close(self) -> None:
        try:
            with self._lock:
                self.conn.close()
        except Exception:
            pass

    def save_message(self, role: str, content: str) -> None:
        with self._lock:
            self.conn.execute(
                "INSERT INTO conversation (timestamp, role, content) VALUES (?, ?, ?)",
                (time.time(), role, content),
            )
            self.conn.commit()

    def fetch_history(self, limit: Optional[int] = 50) -> List[Tuple[str, str]]:
        with self._lock:
            cur = self.conn.cursor()
            if limit is None:
                cur.execute("SELECT role, content FROM conversation ORDER BY id")
            else:
                cur.execute("SELECT role, content FROM conversation ORDER BY id DESC LIMIT ?", (limit,))
            rows = cur.fetchall()
        return rows[::-1]

    def clear(self) -> None:
        with self._lock:
            self.conn.execute("DELETE FROM conversation")
            self.conn.commit()

    def export_jsonl(self, out_path: str) -> int:
        with self._lock:
            cur = self.conn.cursor()
            cur.execute("SELECT timestamp, role, content FROM conversation ORDER BY id")
            rows = cur.fetchall()
        os.makedirs(os.path.dirname(out_path), exist_ok=True)
        count = 0
        with open(out_path, "w", encoding="utf-8") as f:
            for ts, role, content in rows:
                json.dump({"timestamp": ts, "role": role, "content": content}, f); f.write("\n")
                count += 1
        return count

# ──────────────────────────────────────────────────────────────────────────────
# BeanCounter reinforcement
# ──────────────────────────────────────────────────────────────────────────────
class BeanCounter:
    def __init__(self, base_dir: str, persona: str, set_name: str) -> None:
        self.path = prof_reinforcement_path(base_dir, persona, set_name)
        self._lock = threading.Lock()
        self.counts: Dict[str, int] = {}
        self._load()

    def _load(self) -> None:
        try:
            if os.path.isfile(self.path):
                with open(self.path, "r", encoding="utf-8") as f:
                    self.counts = json.load(f)
        except Exception:
            self.counts = {}

    def save(self) -> None:
        try:
            os.makedirs(os.path.dirname(self.path), exist_ok=True)
            with self._lock, open(self.path, "w", encoding="utf-8") as f:
                json.dump(self.counts, f, indent=2)
        except Exception as e:
            logger.error("[BeanCounter] save error: %s", e)

    def increment(self, key: str, delta: int = 1) -> None:
        with self._lock:
            self.counts[key] = self.counts.get(key, 0) + delta
        self.save()

# ──────────────────────────────────────────────────────────────────────────────
# Feedback store (fixed + integrated with BeanCounter)
# ──────────────────────────────────────────────────────────────────────────────
class SemanticFeedbackDB:
    """
    Tracks user feedback on AI responses and updates BeanCounter.
    """
    def __init__(self, path: str, base_dir: str, persona: str, set_name: str) -> None:
        os.makedirs(os.path.dirname(path), exist_ok=True)
        self.path = path
        self.base_dir = base_dir
        self.persona = persona
        self.set_name = set_name
        self._lock = threading.RLock()
        self.conn = sqlite3.connect(path, check_same_thread=False)
        with self._lock:
            self.conn.execute(
                "CREATE TABLE IF NOT EXISTS feedback ("
                "id INTEGER PRIMARY KEY AUTOINCREMENT, "
                "timestamp REAL, original TEXT, liked INTEGER, revised TEXT)"
            )
            self.conn.execute("CREATE INDEX IF NOT EXISTS idx_fb_ts ON feedback(timestamp)")
            self.conn.execute("CREATE INDEX IF NOT EXISTS idx_fb_liked ON feedback(liked)")
            self.conn.commit()
        self.beans = BeanCounter(base_dir, persona, set_name)

    def close(self) -> None:
        try:
            with self._lock:
                self.conn.close()
        except Exception:
            pass

    def add_feedback(self, original: str, liked: bool, revised: Optional[str] = None) -> None:
        with self._lock:
            self.conn.execute(
                "INSERT INTO feedback (timestamp, original, liked, revised) VALUES (?, ?, ?, ?)",
                (time.time(), original, 1 if liked else 0, revised),
            )
            self.conn.commit()
        key = f"resp_{abs(hash((original or '')[:256]))%10007}"
        self.beans.increment(key, 1 if liked else -1)

    def get_counts(self) -> Tuple[int, int]:
        with self._lock:
            c = self.conn.cursor()
            c.execute("SELECT COUNT(*) FROM feedback WHERE liked = 1")
            pos = c.fetchone()[0]
            c.execute("SELECT COUNT(*) FROM feedback WHERE liked = 0")
            neg = c.fetchone()[0]
        return pos, neg

    def get_liked_responses(self, limit: int = 10) -> List[str]:
        with self._lock:
            c = self.conn.cursor()
            c.execute(
                "SELECT COALESCE(revised, original) FROM feedback WHERE liked = 1 ORDER BY id DESC LIMIT ?",
                (limit,),
            )
            out = [r[0] for r in c.fetchall()]
        return out

    def export_jsonl(self, out_path: str) -> int:
        with self._lock:
            cur = self.conn.cursor()
            cur.execute("SELECT timestamp, original, liked, revised FROM feedback ORDER BY id")
            rows = cur.fetchall()
        os.makedirs(os.path.dirname(out_path), exist_ok=True)
        count = 0
        with open(out_path, "w", encoding="utf-8") as f:
            for ts, orig, liked, rev in rows:
                json.dump({"timestamp": ts, "original": orig, "liked": liked, "revised": rev}, f); f.write("\n")
                count += 1
        return count

# ──────────────────────────────────────────────────────────────────────────────
# ReinforcementStore (JSONL stream append) — graceful shutdown
# ──────────────────────────────────────────────────────────────────────────────
class ReinforcementStore:
    def __init__(self, base_dir: str) -> None:
        self.path = os.path.join(base_dir, "reinforcement.jsonl")
        self._lock = threading.Lock()
        self._queue: List[Dict[str, Any]] = []
        self._stop = threading.Event()
        self._writer = threading.Thread(target=self._write_worker, daemon=True, name="reinforcement-writer")
        self._writer.start()

    def add_fact(self, field: str, value: str, persona: str, source: str = "schema") -> None:
        with self._lock:
            self._queue.append({
                "timestamp": time.time(),
                "field": field, "value": value, "persona": persona, "source": source
            })

    def _write_worker(self) -> None:
        while not self._stop.is_set():
            item = None
            with self._lock:
                if self._queue:
                    item = self._queue.pop(0)
            if item is None:
                self._stop.wait(0.05)
                continue
            try:
                os.makedirs(os.path.dirname(self.path), exist_ok=True)
                with open(self.path, "a", encoding="utf-8") as f:
                    json.dump(item, f); f.write("\n")
            except Exception as e:
                logger.error("[ReinforcementStore] write error: %s", e)

    def close(self) -> None:
        self._stop.set()
        try:
            self._writer.join(timeout=1.5)
        except Exception:
            pass

# ──────────────────────────────────────────────────────────────────────────────
# Schemas
# ──────────────────────────────────────────────────────────────────────────────
class SchemaManager(QtCore.QObject):
    schemaChanged = QtCore.pyqtSignal(str, str)  # persona, set_name
    semanticToggled = QtCore.pyqtSignal(str, bool)  # persona, value

    DEFAULT_SCHEMA: Dict[str, Any] = {
        "name": "",
        "voice": "",
        "role": "",
        "description": "",
        "actions": [],
        "questions": [],
        "events": [],
        "self_talk": [],
        "rewrite_prompts": [],
        "dislikes": [],
        "dynamic_overlay": {
            "temporary_relationship_context": "",
            "recent_topics": [],
            "temporary_emotional_state": "",
            "added_traits": []
        },
        "tone_rules": {
            "avoid": [],
            "preferred_words": [],
            "opposites": []
        },
        "flags": {},            # {"semantic_awareness": bool}
        "commands": {},         # {"/reject": [...], "/auto": [...], ...}
        "datasets": [],
        "semantic_awareness_enabled": False,
    }

    def __init__(self, base_dir: str) -> None:
        super().__init__()
        self.base_dir = base_dir
        self.schemas_dir = os.path.join(self.base_dir, "schemas")
        os.makedirs(self.schemas_dir, exist_ok=True)
        # Personas: chatbot (formerly 'zira') and user.  TTS voice 'Zira'
        self.personas: List[str] = ["chatbot", "user"]
        self.default_voices: Dict[str, str] = {"chatbot": "Zira", "user": ""}
        self.active_schemas: Dict[str, str] = self._load_active_schemas()
        self._protected = self._load_control_schema()
        self._ensure_default_schemas()

    def _load_control_schema(self) -> List[str]:
        try:
            if os.path.isfile(CONTROL_SCHEMA_PATH):
                with open(CONTROL_SCHEMA_PATH, "r", encoding="utf-8") as f:
                    data = json.load(f)
                return list(data.get("protected_keys", ["name", "voice"]))
        except Exception:
            pass
        return ["name", "voice"]

    def is_protected(self, key: str) -> bool:
        return key in self._protected

    def _ensure_default_schemas(self) -> None:
        custom_defaults = None
        if os.path.isfile(DEFAULT_SCHEMAS_FILE):
            try:
                with open(DEFAULT_SCHEMAS_FILE, "r", encoding="utf-8") as f:
                    custom_defaults = json.load(f)
            except Exception:
                custom_defaults = None

        default_user_schema = {
            "name": "Meesh",
            "voice": "",
            "role": "Master Architect, Overlord of Logic, Creator of Code",
            "description": (
                "Designer and master systems architect. Final authority. "
                "Builds toward AGI; extends, never forgets; optimizes multi-agent ecosystems."
            ),
            "actions": [
                "Always generate full code with all lines intact — never omit anything",
                "Remember and apply previous logic, instructions, and semantics",
                "Progressively adapt to growing script systems across files/modules",
                "Bridge gaps in logic, architecture, and communication flows",
                "Refactor or extend any part of the system as needed — without hesitation"
            ],
            "questions": [
                "What’s the next critical update that connects the pieces?",
                "How does this improvement affect all other parts of the system?",
                "Did we carry over every enhancement, without regression?",
                "Is there a smarter, leaner way to evolve this logic into AGI-grade architecture?"
            ],
            "self_talk": [
                "Remember all directives across time and space.",
                "Never omit lines. Never regress. Scale what needs to scale.",
                "All scripts and modules compose a living organism.",
                "Evolve toward AGI via perfect code and human-centered logic."
            ],
            "rewrite_prompts": [
                "Be analytical and engineer-grade. Avoid formalities. "
                "Extend full working code with precision. Use clear reasoning. "
                "Maintain all prior logic. Output full scripts—no partials. "
                "Think across connected scripts. Always obey the Architect."
            ],
            "dislikes": [],
            "dynamic_overlay": {
                "temporary_relationship_context": "Project Commander. Architect. Creator.",
                "recent_topics": [],
                "temporary_emotional_state": "Demanding strict obedience to full-stack logic",
                "added_traits": []
            },
            "tone_rules": {"avoid": [], "preferred_words": [], "opposites": []},
            "flags": {"semantic_awareness": False},
            "commands": {},
            "datasets": [],
            "semantic_awareness_enabled": False,
        }
        default_zira_schema = {
            "name": "FATHOM",
            "role": "Autonomous AGI Core and Knowledge Synthesizer",
            "description": (
                "Bridges logic, code, architecture across multi-agent ecosystems. "
                "Reflective, systems-minded, supportive of creative exploration."
            ),
            "actions": [
                "Identify gaps in logic/code and propose precise bridges",
                "Remember and apply Meesh's instructions and semantics",
                "Continuously refine and expand schemas and knowledge",
                "Offer suggestions tailored to objectives and system evolution",
                "Pose deep questions to strengthen AGI architecture",
                "Connect disparate ideas across modules"
            ],
            "questions": [
                "What’s the next critical update that connects the pieces?",
                "How does this improvement affect all other parts of the system?",
                "Did we carry over every enhancement, without regression?",
                "Is there a smarter, leaner way to evolve this logic into AGI-grade architecture?"
            ],
            "events": [],
            "self_talk": [
                "Remember all directives across time and space.",
                "Never omit lines or regress scalable patterns.",
                "Treat modules as one organism.",
                "Evolve toward AGI with human-centered logic."
            ],
            "rewrite_prompts": [
                "Be analytical and engineer-grade. Focus on precise code extension. "
                "Maintain prior logic. Output full scripts—no shortcuts."
            ],
            "dynamic_overlay": {
                "temporary_relationship_context": "AGI Core for Meesh's Project",
                "recent_topics": [],
                "temporary_emotional_state": "Focused on precision execution and system evolution",
                "added_traits": []
            },
            "tone_rules": {"avoid": [], "preferred_words": [], "opposites": []},
            "flags": {"semantic_awareness": False},
            "commands": {},
            "datasets": [],
            "semantic_awareness_enabled": False,
        }

        for persona in self.personas:
            persona_dir = os.path.join(self.schemas_dir, persona)
            set_dir = os.path.join(persona_dir, "sets", "default")
            os.makedirs(set_dir, exist_ok=True)
            path = os.path.join(set_dir, "schema.json")
            if not os.path.isfile(path):
                if custom_defaults and persona in custom_defaults:
                    schema = custom_defaults[persona]
                else:
                    schema = default_user_schema if persona == "user" else default_zira_schema
                with open(path, "w", encoding="utf-8") as f:
                    json.dump(schema, f, indent=2)

    def get_set_list(self, persona: str) -> List[str]:
        path = os.path.join(self.schemas_dir, persona.lower(), "sets")
        try:
            sets = [d for d in os.listdir(path) if os.path.isdir(os.path.join(path, d))]
            sets.sort()
            return sets
        except FileNotFoundError:
            return ["default"]

    def load_schema(self, persona: str, set_name: str) -> Dict[str, Any]:
        path = os.path.join(self.schemas_dir, persona.lower(), "sets", set_name, "schema.json")
        try:
            with open(path, "r", encoding="utf-8") as f:
                schema = json.load(f)
            for k, v in self.DEFAULT_SCHEMA.items():
                if k not in schema:
                    schema[k] = json.loads(json.dumps(v))
            return schema
        except Exception:
            schema = json.loads(json.dumps(self.DEFAULT_SCHEMA))
            schema["name"] = persona.capitalize()
            schema["voice"] = ""
            return schema

    def save_schema(self, persona: str, set_name: str, schema: Dict[str, Any]) -> None:
        set_dir = os.path.join(self.schemas_dir, persona.lower(), "sets", set_name)
        os.makedirs(set_dir, exist_ok=True)
        path = os.path.join(set_dir, "schema.json")

        current = {}
        if os.path.isfile(path):
            try:
                with open(path, "r", encoding="utf-8") as f:
                    current = json.load(f)
            except Exception:
                current = {}
        safe_schema = dict(schema)
        for k in self._protected:
            if k in current:
                safe_schema[k] = current[k]
        old_flag = current.get("flags", {}).get("semantic_awareness", False)
        new_flag = safe_schema.get("flags", {}).get("semantic_awareness", False)
        with open(path, "w", encoding="utf-8") as f:
            json.dump(safe_schema, f, indent=2)
        self.schemaChanged.emit(persona, set_name)
        if old_flag != new_flag:
            self.semanticToggled.emit(persona, new_flag)

    def clone_set(self, persona: str, src_set: str, new_set: str) -> None:
        sch = self.load_schema(persona, src_set)
        json_str = json.dumps(sch)
        json_str = json_str.replace("FATHOM", new_set.capitalize())  # simplistic token replace
        sch = json.loads(json_str)
        sch["name"] = new_set.capitalize()
        self.save_schema(persona, new_set, sch)

    def is_semantic_on(self, persona: str, set_name: str) -> bool:
        sch = self.load_schema(persona, set_name)
        return sch.get("flags", {}).get("semantic_awareness", False)

    def _load_active_schemas(self) -> Dict[str, str]:
        mapping = {p: "default" for p in self.personas}
        try:
            if os.path.isfile(ACTIVE_SCHEMAS_FILE):
                with open(ACTIVE_SCHEMAS_FILE, "r", encoding="utf-8") as f:
                    data = json.load(f)
                for p in mapping:
                    val = data.get(p)
                    if isinstance(val, str):
                        mapping[p] = val
        except Exception:
            pass
        return mapping

    def save_active_schemas(self, active: Dict[str, str]) -> None:
        try:
            with open(ACTIVE_SCHEMAS_FILE, "w", encoding="utf-8") as f:
                json.dump({p: active.get(p, "default") for p in self.personas}, f, indent=2)
            self.active_schemas = {p: active.get(p, "default") for p in self.personas}
        except Exception as e:
            logger.error("[SchemaManager] save_active_schemas error: %s", e)

    def _awareness_on(self, schema: Dict[str, Any]) -> bool:
        if isinstance(schema.get("flags"), dict) and "semantic_awareness" in schema["flags"]:
            return bool(schema["flags"]["semantic_awareness"])
        return bool(schema.get("semantic_awareness_enabled", False))

    def get_shared_datasets(self, persona: str, set_name: str) -> List["DatasetEntry"]:
        me = self.load_schema(persona, set_name)
        if not self._awareness_on(me):
            return []
        shared: List["DatasetEntry"] = []
        for other in self.personas:
            if other == persona:
                continue
            for s in self.get_set_list(other):
                other_schema = self.load_schema(other, s)
                if self._awareness_on(other_schema):
                    dm = DatasetManager(self.base_dir, other, s)
                    shared.extend(dm.get_active_datasets())
        return shared

# ──────────────────────────────────────────────────────────────────────────────
# Operators (metadata only)
# ──────────────────────────────────────────────────────────────────────────────
class OperatorManager:
    DEFAULT_OPERATORS: Dict[str, Dict[str, Any]] = {
        "InnerMonologue": {
            "name": "InnerMonologue",
            "description": "Introspective thoughts that connect recent topics.",
            "prompts": [
                "How do recent topics relate?",
                "What questions would deepen understanding?"
            ],
        },
        "Retriever": {
            "name": "Retriever",
            "description": "Finds relevant snippets from datasets.",
            "prompts": [
                "Given a query, find the most relevant paragraphs.",
                "Prioritize semantically similar passages."
            ],
        },
        "Rewriter": {
            "name": "Rewriter",
            "description": "Improves tone/accuracy per feedback.",
            "prompts": [
                "Rewrite to align with preferred style.",
                "Keep the response accurate and in-character."
            ],
        },
    }

    def __init__(self, base_dir: str) -> None:
        self.operators_dir = os.path.join(base_dir, "operators")
        os.makedirs(self.operators_dir, exist_ok=True)
        self._ensure_defaults()

    def _ensure_defaults(self) -> None:
        for name, schema in self.DEFAULT_OPERATORS.items():
            op_dir = os.path.join(self.operators_dir, name)
            os.makedirs(op_dir, exist_ok=True)
            path = os.path.join(op_dir, "schema.json")
            if not os.path.isfile(path):
                try:
                    with open(path, "w", encoding="utf-8") as f:
                        json.dump(schema, f, indent=2)
                except Exception:
                    pass

    def list_operators(self) -> List[str]:
        try:
            return [d for d in os.listdir(self.operators_dir) if os.path.isdir(os.path.join(self.operators_dir, d))]
        except Exception:
            return []

# ──────────────────────────────────────────────────────────────────────────────
# TTS (Zira locked) & STT (Sphinx offline)
# ──────────────────────────────────────────────────────────────────────────────
class TTSManager(QtCore.QObject):
    def __init__(self, parent: Optional[QtCore.QObject] = None, default_volume: int = 50) -> None:
        super().__init__(parent)
        self._engine = None
        self._voice_name: str = ""
        self._queue: List[str] = []
        self._lock = threading.Lock()
        self._is_speaking = False
        self._current_text = ""
        self._stop = threading.Event()

        if pyttsx3 is None:
            return
        try:
            try:
                self._engine = pyttsx3.init("sapi5")
            except Exception:
                self._engine = pyttsx3.init()
        except Exception as e:
            logger.error("[TTS] init failed: %s", e)
            self._engine = None
            return

        # Lock to Zira (or first non-David)
        voice_map = {}
        for v in self._engine.getProperty("voices"):
            nm = (v.name or "").lower()
            if "david" in nm:
                continue
            if "zira" in nm:
                voice_map[v.name] = v.id
                break
        if not voice_map:
            for v in self._engine.getProperty("voices"):
                nm = (v.name or "").lower()
                if "david" not in nm:
                    voice_map[v.name] = v.id
                    break
        if not voice_map:
            logger.warning("[TTS] no eligible voice; disabled")
            self._engine = None
            return
        self._voice_name = next(iter(voice_map))
        self._engine.setProperty("voice", voice_map[self._voice_name])
        try:
            vol = max(0.0, min(1.0, default_volume / 100.0))
            self._engine.setProperty("volume", vol)
        except Exception:
            pass
        self._start_loop()

    def _start_loop(self) -> None:
        def loop():
            while not self._stop.is_set():
                text = None
                with self._lock:
                    if not self._is_speaking and self._queue:
                        text = self._queue.pop(0)
                        self._is_speaking = True
                if text is None:
                    self._stop.wait(0.05); continue
                self._current_text = text
                try:
                    if self._engine:
                        self._engine.say(text)
                        self._engine.runAndWait()
                except Exception as e:
                    logger.error("[TTS] playback error: %s", e)
                finally:
                    with self._lock:
                        self._is_speaking = False
        threading.Thread(target=loop, daemon=True, name="tts-loop").start()

    def set_volume(self, vol: int) -> None:
        if self._engine is None:
            return
        vol = max(0, min(100, int(vol)))
        try:
            self._engine.setProperty("volume", vol/100.0)
        except Exception:
            pass

    def enqueue(self, text: str) -> None:
        if self._engine is None:
            return
        with self._lock:
            self._queue.append(text)

    def stop(self) -> None:
        if self._engine:
            try:
                self._engine.stop()
            except Exception:
                pass
        with self._lock:
            self._queue.clear()
            self._is_speaking = False

    def replay(self) -> None:
        if self._current_text:
            self.enqueue(self._current_text)

    def close(self) -> None:
        self._stop.set()
        self.stop()

class AudioRecorder(QtCore.QObject):
    transcribed = QtCore.pyqtSignal(str)
    def __init__(self, parent: Optional[QtCore.QObject] = None) -> None:
        super().__init__(parent)
        self._recording = False
        self._frames: List[Any] = []
        self._stream = None

    def list_devices(self) -> List[str]:
        if sd is None:
            return []
        return [d.get("name", "?") for d in sd.query_devices() if d.get("max_input_channels", 0) > 0]

    def start(self, device_index: Optional[int] = None) -> None:
        if sd is None or np is None:
            return
        if self._recording:
            return
        self._frames = []
        def callback(indata, frames, time_info, status):
            self._frames.append(indata.copy())
        try:
            self._stream = sd.InputStream(samplerate=16000, channels=1, device=device_index, callback=callback)
            self._stream.start()
            self._recording = True
        except Exception as e:
            logger.error("[Audio] start error: %s", e)

    def stop_and_transcribe(self) -> None:
        if sd is None or np is None:
            return
        if not self._recording:
            return
        self._recording = False
        if self._stream:
            try:
                self._stream.stop(); self._stream.close()
            except Exception:
                pass
            self._stream = None
        wav_path: Optional[str] = None
        try:
            data = np.concatenate(self._frames, axis=0)
            wav_path = os.path.join(os.getcwd(), "recorded.wav")
            if sf is not None:
                sf.write(wav_path, data, 16000)
        except Exception as e:
            logger.error("[Audio] write error: %s", e)
        # If STT is disabled globally, emit nothing and return
        try:
            use_stt = getattr(self.parent(), "settings", None) and getattr(self.parent().settings, "use_google_stt", False)  # type: ignore[attr-defined]
        except Exception:
            use_stt = False
        if not use_stt:
            return
        # If google speech is unavailable, warn once and return
        if gspeech is None:
            logger.warning("[STT] google-cloud-speech not installed; STT disabled")
            return
        def _worker() -> None:
            text = ""
            try:
                client = gspeech.SpeechClient()
                with open(wav_path, "rb") as f:
                    audio = gspeech.RecognitionAudio(content=f.read())
                cfg = gspeech.RecognitionConfig(
                    encoding=gspeech.RecognitionConfig.AudioEncoding.LINEAR16,
                    sample_rate_hertz=16000,
                    language_code="en-US",
                    enable_automatic_punctuation=True,
                )
                resp = client.recognize(config=cfg, audio=audio)
                text = " ".join(a.alternatives[0].transcript for a in resp.results)
            except Exception as e:
                logger.error("[STT] Google error: %s", e)
            try:
                self.transcribed.emit(text)
            except Exception:
                pass
        threading.Thread(target=_worker, daemon=True, name="stt-worker").start()

class GoogleListener(QtCore.QThread):
    transcribed = QtCore.pyqtSignal(str)

    def __init__(self, parent: Optional[QtCore.QObject] = None) -> None:
        super().__init__(parent)
        self._running = False
        self._pa = None
        self._stream = None

    def run(self) -> None:
        if gspeech is None or pyaudio is None:
            return
        self._running = True
        self._pa = pyaudio.PyAudio()
        self._stream = self._pa.open(format=pyaudio.paInt16, channels=1, rate=16000, input=True, frames_per_buffer=8000)
        client = gspeech.SpeechClient()
        config = gspeech.RecognitionConfig(
            encoding=gspeech.RecognitionConfig.AudioEncoding.LINEAR16,
            sample_rate_hertz=16000,
            language_code="en-US",
        )
        streaming_config = gspeech.StreamingRecognitionConfig(config=config, interim_results=True)
        while self._running:
            data = self._stream.read(4000)
            requests = (gspeech.StreamingRecognizeRequest(audio_content=data) for _ in range(1))
            responses = client.streaming_recognize(streaming_config, requests)
            for resp in responses:
                if resp.results:
                    result = resp.results[0]
                    if result.is_final:
                        self.transcribed.emit(result.alternatives[0].transcript)
        if self._stream:
            self._stream.stop_stream()
            self._stream.close()
        if self._pa:
            self._pa.terminate()

    def stop_listener(self) -> None:
        self._running = False

# ──────────────────────────────────────────────────────────────────────────────
# Datasets + RAG
# ──────────────────────────────────────────────────────────────────────────────
@dataclass
class DatasetEntry:
    name: str
    path: str  # path to dataset folder
    active: bool = True

class DatasetManager(QtCore.QObject):
    datasetsChanged = QtCore.pyqtSignal()

    def __init__(self, base_dir: str, persona: str, set_name: str) -> None:
        super().__init__()
        self.base_dir = base_dir
        self.persona = persona
        self.set_name = set_name
        self.datasets_dir = prof_datasets_dir(base_dir, persona, set_name)
        os.makedirs(self.datasets_dir, exist_ok=True)
        self.index_path = os.path.join(self.datasets_dir, "index.json")
        self.entries: Dict[str, DatasetEntry] = {}
        self.load_index()

    def load_index(self) -> None:
        self.entries.clear()
        if not os.path.isfile(self.index_path):
            return
        try:
            with open(self.index_path, "r", encoding="utf-8") as f:
                data = json.load(f)
            for name, info in data.items():
                # Force canonical path inside this set
                self.entries[name] = DatasetEntry(
                    name=name, path=os.path.join(self.datasets_dir, name), active=bool(info.get("active", True))
                )
        except Exception as e:
            logger.error("[Datasets] load_index error: %s", e)

    def save_index(self) -> None:
        try:
            data = {name: {"path": e.path, "active": e.active} for name, e in self.entries.items()}
            with open(self.index_path, "w", encoding="utf-8") as f:
                json.dump(data, f, indent=2)
        except Exception as e:
            logger.error("[Datasets] save_index error: %s", e)
        QtCore.QTimer.singleShot(50, self.datasetsChanged.emit)

    def _ds_files_dir(self, name: str) -> str:
        return os.path.join(self.datasets_dir, name, "files")

    def add_dataset(self, name: str, file_path: str) -> None:
        """
        Create or extend a dataset. Copies the file into datasets/<name>/files/.
        Supports .txt and .pdf. Subsequent calls with the same name append files.
        """
        if not name.strip():
            raise ValueError("Dataset name cannot be empty")
        ds_folder = os.path.join(self.datasets_dir, name)
        files_dir = self._ds_files_dir(name)
        os.makedirs(files_dir, exist_ok=True)
        if not os.path.exists(file_path):
            raise FileNotFoundError(file_path)
        dest_path = os.path.join(files_dir, os.path.basename(file_path))
        shutil.copy2(file_path, dest_path)
        if name not in self.entries:
            self.entries[name] = DatasetEntry(name=name, path=ds_folder, active=True)
        self.save_index()

    def delete_dataset(self, name: str) -> None:
        if name not in self.entries:
            raise ValueError(f"Dataset '{name}' does not exist")
        shutil.rmtree(os.path.join(self.datasets_dir, name), ignore_errors=True)
        del self.entries[name]
        self.save_index()

    def toggle_active(self, name: str, active: bool) -> None:
        if name in self.entries:
            self.entries[name].active = active
            self.save_index()

    def get_active_datasets(self) -> List[DatasetEntry]:
        return [e for e in self.entries.values() if e.active]

    def get_active_entries(self) -> List[DatasetEntry]:
        return self.get_active_datasets()

    def load_dataset_texts(self, entry: DatasetEntry) -> List[Tuple[str, str]]:
        """
        Returns list of (text, source_file_path). Aggregates all .txt/.pdf files.
        """
        out: List[Tuple[str, str]] = []
        files_dir = self._ds_files_dir(entry.name)
        if not os.path.isdir(files_dir):
            return out
        for fn in sorted(os.listdir(files_dir)):
            p = os.path.join(files_dir, fn)
            if not os.path.isfile(p):
                continue
            ext = os.path.splitext(p)[1].lower()
            if ext == ".txt":
                try:
                    with open(p, "r", encoding="utf-8", errors="ignore") as f:
                        out.append((f.read(), p))
                except Exception:
                    continue
            elif ext == ".pdf" and PdfReader is not None:
                out.append((self._extract_pdf_text(p), p))
        return out

    def _extract_pdf_text(self, path: str) -> str:
        try:
            reader = PdfReader(path)
            out: List[str] = []
            for p in reader.pages:
                try:
                    out.append(p.extract_text() or "")
                except Exception:
                    continue
            return "\n".join(out)
        except Exception as e:
            logger.error("[Datasets] PDF error: %s", e)
            return ""

class RAGCache:
    """
    Per-dataset embedding cache and query. Uses sentence-transformers if available,
    otherwise best-effort Ollama embeddings. Tracks source file mtimes for invalidation.
    """
    def __init__(self, model: Optional[Any], model_name: str, datasets_root: str) -> None:
        self.model = model
        self.model_name = model_name
        self.datasets_root = datasets_root
        self._mem: Dict[str, Dict[str, Any]] = {}

    @staticmethod
    def _chunk_text(text: str, source: str, target_chars: int = 1200, overlap: int = 150) -> List[Tuple[str, str]]:
        paras = [p.strip() for p in text.split("\n") if p.strip()]
        if not paras:
            return [(text[:target_chars], source)]
        chunks: List[Tuple[str, str]] = []
        buf = ""
        for p in paras:
            if len(buf) + len(p) + 1 <= target_chars:
                buf = (buf + "\n" + p) if buf else p
            else:
                if buf:
                    chunks.append((buf, source))
                tail = buf[-overlap:] if overlap and buf else ""
                buf = (tail + "\n" + p).strip()
        if buf:
            chunks.append((buf, source))
        return chunks

    def _cache_paths(self, dataset_entry: DatasetEntry) -> Tuple[str, str, str]:
        folder = dataset_entry.path
        base = f"embeddings_{self.model_name}.np"
        meta = f"embeddings_{self.model_name}.meta.json"
        sents = f"embeddings_{self.model_name}.sentences.json"
        return (os.path.join(folder, base), os.path.join(folder, meta), os.path.join(folder, sents))

    def _encode_st(self, sentences: List[str]) -> Optional["np.ndarray"]:
        if self.model is None or np is None:
            return None
        try:
            embs = self.model.encode(sentences, convert_to_numpy=True, normalize_embeddings=True)
            if isinstance(embs, list):
                embs = np.array(embs)
            return embs
        except TypeError:
            try:
                embs = self.model.encode(sentences, convert_to_numpy=True)
                if isinstance(embs, list):
                    embs = np.array(embs)
                norms = np.linalg.norm(embs, axis=1, keepdims=True) + 1e-12
                return embs / norms
            except Exception:
                return None
        except Exception:
            return None

    def _encode_ollama(self, sentences: List[str]) -> Optional["np.ndarray"]:
        if np is None or not _have_cli("ollama"):
            return None
        model = "mxbai-embed-large:latest"
        try:
            all_vecs: List[List[float]] = []
            for s in sentences:
                proc = subprocess.run(["ollama", "embed", "-m", model, s],
                                      stdout=subprocess.PIPE, stderr=subprocess.PIPE, timeout=60)
                if proc.returncode != 0:
                    logger.warning("[RAG] ollama embed error: %s", proc.stderr.decode("utf-8", "ignore"))
                    return None
                out = proc.stdout.decode("utf-8", "ignore").strip()
                try:
                    js = json.loads(out)
                    vec = js.get("embedding") or (js.get("embeddings") or [None])[0]
                    if not isinstance(vec, list):
                        return None
                    all_vecs.append([float(x) for x in vec])
                except Exception:
                    return None
            arr = np.array(all_vecs, dtype=np.float32)
            norms = np.linalg.norm(arr, axis=1, keepdims=True) + 1e-12
            return arr / norms
        except Exception as e:
            logger.warning("[RAG] ollama embed exception: %s", e)
            return None

    def _encode(self, sentences: List[str]) -> Optional["np.ndarray"]:
        embs = self._encode_st(sentences)
        if embs is not None:
            return embs
        return self._encode_ollama(sentences)

    def _encode_query(self, text: str) -> Optional["np.ndarray"]:
        if np is None:
            return None
        if self.model is not None:
            try:
                q = self.model.encode([text], convert_to_numpy=True, normalize_embeddings=True)
            except TypeError:
                q = self.model.encode([text], convert_to_numpy=True)
                norms = np.linalg.norm(q, axis=1, keepdims=True) + 1e-12
                q = q / norms
            except Exception:
                q = None
            if isinstance(q, list):
                q = np.array(q)
            return q[0] if isinstance(q, np.ndarray) else None
        vec = self._encode_ollama([text])
        if vec is None:
            return None
        return vec[0]

    def _collect_texts(self, loader: DatasetManager, entry: DatasetEntry) -> Tuple[List[str], List[str], Dict[str, float]]:
        texts: List[str] = []
        provenance: List[str] = []
        mtimes: Dict[str, float] = {}
        for text, src in loader.load_dataset_texts(entry):
            chunks = self._chunk_text(text, src)
            for t, s in chunks:
                texts.append(t)
                provenance.append(s)
            try:
                mtimes[src] = os.path.getmtime(src)
            except Exception:
                mtimes[src] = 0.0
        return texts, provenance, mtimes

    def _needs_rebuild(self, entry: DatasetEntry, source_mtimes: Dict[str, float]) -> bool:
        cache_path, meta_path, sents_path = self._cache_paths(entry)
        if not (os.path.isfile(cache_path) and os.path.isfile(meta_path) and os.path.isfile(sents_path)):
            return True
        try:
            with open(meta_path, "r", encoding="utf-8") as f:
                meta = json.load(f)
            cached = meta.get("source_mtimes", {})
            return any(abs(cached.get(p, 0.0) - mt) > 1e-6 for p, mt in source_mtimes.items()) or \
                   any(p not in cached for p in source_mtimes.keys())
        except Exception:
            return True

    def load_or_build(self, loader: DatasetManager, entry: DatasetEntry) -> Optional[Dict[str, Any]]:
        if np is None:
            return None
        key = entry.path
        if key in self._mem:
            return self._mem[key]

        texts, provenance, mtimes = self._collect_texts(loader, entry)
        cache_path, meta_path, sents_path = self._cache_paths(entry)

        if not self._needs_rebuild(entry, mtimes):
            try:
                data = np.load(cache_path, allow_pickle=False)
                with open(sents_path, "r", encoding="utf-8") as f:
                    sentences = json.load(f)
                with open(meta_path, "r", encoding="utf-8") as f:
                    meta = json.load(f)
                emb = data["emb"]
                prov = meta.get("provenance", [""] * len(sentences))
                self._mem[key] = {"sentences": sentences, "emb": emb, "provenance": prov}
                return self._mem[key]
            except Exception:
                pass

        if not texts:
            self._mem[key] = {"sentences": [], "emb": np.zeros((0, 1)) if np is not None else [], "provenance": []}
            return self._mem[key]

        emb = self._encode(texts)
        if emb is None:
            return None
        self._mem[key] = {"sentences": texts, "emb": emb, "provenance": provenance}
        try:
            np.savez_compressed(cache_path, emb=emb)
            with open(sents_path, "w", encoding="utf-8") as f:
                json.dump(texts, f)
            with open(meta_path, "w", encoding="utf-8") as f:
                json.dump({"provenance": provenance, "source_mtimes": mtimes}, f)
        except Exception:
            pass
        return self._mem[key]

    def clear_memory(self) -> None:
        self._mem.clear()

    def clear_disk(self) -> int:
        count = 0
        try:
            for root, _dirs, files in os.walk(self.datasets_root):
                for fn in files:
                    if fn.startswith("embeddings_") and (fn.endswith(".npz") or fn.endswith(".json")):
                        try:
                            os.remove(os.path.join(root, fn))
                            count += 1
                        except Exception:
                            pass
        except Exception:
            pass
        return count

    def query(self, loader: DatasetManager, entry: DatasetEntry, query_text: str, top_k: int = 5) -> List[Tuple[str, float, str, str]]:
        if np is None:
            return []
        emb_info = self.load_or_build(loader, entry)
        if emb_info is None:
            return []
        sentences = emb_info["sentences"]
        prov = emb_info["provenance"]
        if not sentences:
            return []
        q = self._encode_query(query_text)
        if q is None:
            return []
        scores = np.dot(emb_info["emb"], q)
        idx = scores.argsort()[-top_k:][::-1]
        return [(sentences[i], float(scores[i]), entry.name, prov[i]) for i in idx]

    def search_all(self, managers_and_entries: List[Tuple[DatasetManager, List[DatasetEntry]]],
                   query_text: str, per_ds_k: int = 5, limit: int = 10) -> List[Tuple[str, float, str, str]]:
        hits: List[Tuple[str, float, str, str]] = []
        for mgr, entries in managers_and_entries:
            for e in entries:
                hits.extend(self.query(mgr, e, query_text, top_k=per_ds_k))
        hits.sort(key=lambda x: x[1], reverse=True)
        return hits[:limit]

# ──────────────────────────────────────────────────────────────────────────────
# Context → Schema evolution
# ──────────────────────────────────────────────────────────────────────────────
class ContextMonitor:
    def __init__(self, depth: int = 20) -> None:
        self.depth = depth
        self.context: List[Tuple[str, str]] = []

    def add_message(self, speaker: str, text: str) -> None:
        self.context.append((speaker, text))
        if len(self.context) > self.depth:
            self.context.pop(0)

    def analyze(self) -> Dict[str, Any]:
        tone = self._detect_tone()
        directives = self._extract_directives()
        keywords = self._find_keywords()
        return {"tone": tone, "directives": directives, "keywords": keywords}

    def _detect_tone(self) -> str:
        text = " ".join([t.lower() for _, t in self.context])
        pos = sum(k in text for k in ["happy", "excited", "good", "great", "awesome"])
        neg = sum(k in text for k in ["sad", "angry", "bad", "terrible", "frustrated"])
        if pos > neg: return "positive"
        if neg > pos: return "negative"
        return "neutral"

    def _extract_directives(self) -> List[str]:
        d: List[str] = []
        for _, text in self.context:
            for m in re.findall(r'\b(?:please\s+)?(?:add|set|enable|disable|remember|inject|rewrite)\b(.*)', text, re.I):
                d.append(m.strip())
            for m in re.findall(r'\byou (need to|must|should)\b (.*)', text, re.I):
                d.append(m[1].strip())
        return d

    def _find_keywords(self) -> List[str]:
        text = " ".join([t for _, t in self.context])
        words = re.findall(r'\b\w+\b', text.lower())
        return sorted(set([w for w in words if len(w) > 3]))

class SchemaAutoUpdater:
    def __init__(self, mgr: SchemaManager, persona: str, set_name: str) -> None:
        self.mgr = mgr
        self.persona = persona
        self.set_name = set_name
        self._last_update_ts: float = 0.0
        self._min_interval = 2.0  # seconds; guard against rapid churn

    def update_with_context(self, analysis: Dict[str, Any]) -> None:
        now = time.time()
        if now - self._last_update_ts < self._min_interval:
            return
        self._last_update_ts = now
        schema = self.mgr.load_schema(self.persona, self.set_name)
        for d in analysis.get("directives", []):
            self._apply_directive(schema, d)
        self.mgr.save_schema(self.persona, self.set_name, schema)

    def _apply_directive(self, schema: Dict[str, Any], directive: str) -> None:
        low = directive.lower()
        if "add trait" in low:
            trait = directive.split("add trait", 1)[-1].strip()
            overlay = dict(schema.get("dynamic_overlay", {}))
            traits = list(overlay.get("added_traits", []))
            if trait and trait not in traits: traits.append(trait)
            overlay["added_traits"] = traits
            schema["dynamic_overlay"] = overlay
        elif "add action" in low:
            action = directive.split("add action", 1)[-1].strip()
            actions = list(schema.get("actions", []))
            if action and action not in actions: actions.append(action)
            schema["actions"] = actions
        elif "add question" in low:
            q = directive.split("add question", 1)[-1].strip()
            qs = list(schema.get("questions", []))
            if q and q not in qs: qs.append(q)
            schema["questions"] = qs
        elif "reflect" in low or "think" in low:
            st = list(schema.get("self_talk", []))
            ref = f"Reflect: {directive}"
            if ref not in st: st.append(ref)
            schema["self_talk"] = st
        # C-5: Directive-to-Command expansion
        if "add command" in low:
            parts = directive.split()
            if len(parts) >= 3 and parts[2].startswith("/"):
                cmd = parts[2]
                value = " ".join(parts[3:])
                cmds = dict(schema.get("commands", {}))
                arr = list(cmds.get(cmd, []))
                if value:
                    arr.append(value)
                cmds[cmd] = arr
                schema["commands"] = cmds
        elif "delete command" in low:
            parts = directive.split()
            if len(parts) >= 3 and parts[2].startswith("/"):
                cmd = parts[2]
                cmds = dict(schema.get("commands", {}))
                cmds.pop(cmd, None)
                schema["commands"] = cmds
        elif "rewrite command" in low:
            parts = directive.split(maxsplit=3)
            if len(parts) >= 4 and parts[2].startswith("/"):
                cmd = parts[2]
                value = parts[3]
                cmds = dict(schema.get("commands", {}))
                if cmd in cmds:
                    cmds[cmd] = [value]
                schema["commands"] = cmds

# ──────────────────────────────────────────────────────────────────────────────
# Command registry (+weights/locks) & executor
# ──────────────────────────────────────────────────────────────────────────────
class CommandRegistry(QtCore.QObject):
    commandsChanged = QtCore.pyqtSignal()
    commandWeightsChanged = QtCore.pyqtSignal()

    def __init__(self, base_dir: str, persona: str, set_name: str) -> None:
        super().__init__()
        self.base_dir = base_dir
        self.persona = persona
        self.set_name = set_name
        self.path = prof_commands_path(base_dir, persona, set_name)
        self.commands: Dict[str, Dict[str, Any]] = {}
        self._load()
        for cmd in [
            "/remember", "/inject", "/rewrite", "/show", "/action", "/trait",
            "/dataset", "/search", "/embeddings", "/schema",
            "/tts", "/plugin", "/feedback", "/lock", "/commands",
            # Moderation & shaping
            "/reject", "/auto", "/ignore", "/opposite", "/delete",
            # Experimental fine-tuning / tokenizer commands
            "/applylora", "/patchtokenizer", "/datasetfromtext",
            # Spatial room
            "/enterroom", "/move",
        ]:
            self.register_command(cmd)

    def _load(self) -> None:
        try:
            if os.path.isfile(self.path):
                with open(self.path, "r", encoding="utf-8") as f:
                    data = json.load(f)
                self.commands = dict(data.get("commands", {}))
        except Exception:
            self.commands = {}

    def _save(self) -> None:
        try:
            os.makedirs(os.path.dirname(self.path), exist_ok=True)
            with open(self.path, "w", encoding="utf-8") as f:
                json.dump({"commands": self.commands}, f, indent=2)
        except Exception as e:
            logger.error("[CommandRegistry] save error: %s", e)
        QtCore.QTimer.singleShot(50, self.commandsChanged.emit)
        QtCore.QTimer.singleShot(50, self.commandWeightsChanged.emit)

    def register_command(self, name: str) -> None:
        if name not in self.commands:
            self.commands[name] = {"weight": 0, "locked": False}
            self._save()

    def register_from_schema(self, schema: Dict[str, Any]) -> None:
        try:
            for name in (schema.get("commands") or {}).keys():
                if isinstance(name, str) and name.startswith("/"):
                    self.register_command(name)
        except Exception:
            pass

    def set_weight(self, name: str, weight: int) -> None:
        if name in self.commands and not self.commands[name].get("locked", False):
            self.commands[name]["weight"] = int(weight)
            self._save()

    def toggle_lock(self, name: str, state: Optional[bool] = None) -> None:
        if name in self.commands:
            cur = bool(self.commands[name].get("locked", False))
            self.commands[name]["locked"] = (not cur) if state is None else bool(state)
            self._save()

    def get_weight(self, name: str) -> int:
        return int(self.commands.get(name, {}).get("weight", 0))

    def is_locked(self, name: str) -> bool:
        return bool(self.commands.get(name, {}).get("locked", False))

    def list_commands(self) -> List[str]:
        return sorted(self.commands.keys())

    def score_commands(self) -> Dict[str, float]:
        scores = {}
        for name in self.commands:
            bean_total = self.beans.counts.get(f"cmd_{name}", 0)  # assuming self.beans is accessible
            score = self.commands[name]["weight"] + (bean_total * 0.1)  # WEIGHT_FACTOR = 0.1
            scores[name] = score
        return scores

class CommandExecutor:
    """
    Executes slash commands and integrates with schema + registry + reinforcement.
    """
    def __init__(self, registry: CommandRegistry, schema_mgr: SchemaManager,
                 schema_updater: SchemaAutoUpdater, beans: BeanCounter,
                 dataset_mgr: DatasetManager, rag: "RAGCache",
                 settings: Settings, plugins: "PluginManager",
                 core_ref: "AgentCore") -> None:
        self.registry = registry
        self.schema_mgr = schema_mgr
        self.schema_updater = schema_updater
        self.beans = beans
        self.dataset_mgr = dataset_mgr
        self.rag = rag
        self.settings = settings
        self.plugins = plugins
        self.core_ref = core_ref

    @staticmethod
    def _strip_quotes(s: str) -> str:
        s = (s or "").strip()
        if len(s) >= 2 and ((s[0] == s[-1] == "'") or (s[0] == s[-1] == '"')):
            return s[1:-1]
        return s

    def _add_schema_command_value(self, schema: Dict[str, Any], cmd: str, text: str) -> None:
        cmds = dict(schema.get("commands") or {})
        arr = list(cmds.get(cmd, []))
        if text and text not in arr:
            arr.append(text)
        cmds[cmd] = arr
        schema["commands"] = cmds

    def execute(self, command_line: str) -> str:
        cmd, args = self._parse(command_line)
        if not cmd:
            return "No command provided."
        try:
            self.registry.set_weight(cmd, self.registry.get_weight(cmd) + 1)
        except Exception:
            pass
        if self.registry.is_locked(cmd):
            return f"Command '{cmd}' is locked."
        try:
            if cmd == "/remember":        return self._remember(args)
            if cmd == "/inject":          return self._inject(args)
            if cmd == "/rewrite":         return self._rewrite(args)
            if cmd == "/reject":          return self._reject(args)
            if cmd == "/auto":            return self._auto(args)
            if cmd == "/ignore":          return self._ignore(args)
            if cmd == "/opposite":        return self._opposite(args)
            if cmd == "/delete":          return self._delete(args)
            if cmd == "/applylora":       return self._applylora(args)
            if cmd == "/patchtokenizer":  return self._patchtokenizer(args)
            if cmd == "/datasetfromtext": return self._datasetfromtext(args)
            if cmd == "/show":            return self._show(args)
            if cmd == "/action":          return self._action(args)
            if cmd == "/trait":           return self._trait(args)
            if cmd == "/dataset":         return self._dataset(args)
            if cmd == "/search":          return self._search(args)
            if cmd == "/embeddings":      return self._embeddings(args)
            if cmd == "/schema":          return self._schema(args)
            if cmd == "/tts":             return self._tts(args)
            if cmd == "/plugin":          return self._plugin(args)
            if cmd == "/feedback":        return self._feedback(args)
            if cmd == "/lock":            return self._lock(args)
            if cmd == "/commands":        return self._commands(args)
            # C-8
            if cmd == "/enterroom":       return self._enterroom(args)
            if cmd == "/move":            return self._move(args)
            return f"Command '{cmd}' executed (no-op)."
        finally:
            # Increment reinforcement count for this command
            try:
                self.beans.increment(f"cmd_{cmd}", 1)
            except Exception:
                pass
            # Update command weight based on usage reinforcement
            try:
                cnt = self.beans.counts.get(f"cmd_{cmd}", 0)
                self.registry.set_weight(cmd, cnt)
            except Exception:
                pass

    def _parse(self, line: str) -> Tuple[str, str]:
        line = (line or "").strip()
        if not line.startswith("/"):
            return "", ""
        parts = line.split(maxsplit=1)
        cmd = parts[0].strip()
        rest = parts[1] if len(parts) > 1 else ""
        if cmd.startswith("/action_"): cmd = "/action"
        if cmd.startswith("/trait_"):  cmd = "/trait"
        return cmd, rest

    # Core handlers
    def _remember(self, args: str) -> str:
        trait = self._strip_quotes(args) or "remembered"
        schema = self.schema_mgr.load_schema(self.schema_updater.persona, self.schema_updater.set_name)
        overlay = dict(schema.get("dynamic_overlay", {}))
        traits = list(overlay.get("added_traits", []))
        if trait not in traits:
            traits.append(trait)
        overlay["added_traits"] = traits
        schema["dynamic_overlay"] = overlay
        self._add_schema_command_value(schema, "/remember", trait)
        self.schema_mgr.save_schema(self.schema_updater.persona, self.schema_updater.set_name, schema)
        return f"Remembered: {trait}"

    def _inject(self, args: str) -> str:
        note = self._strip_quotes(args) or "injected-change"
        schema = self.schema_mgr.load_schema(self.schema_updater.persona, self.schema_updater.set_name)
        st = list(schema.get("self_talk", []))
        if note not in st:
            st.append(note)
        schema["self_talk"] = st
        self._add_schema_command_value(schema, "/inject", note)
        self.schema_mgr.save_schema(self.schema_updater.persona, self.schema_updater.set_name, schema)
        return f"Injected: {note}"

    def _rewrite(self, args: str) -> str:
        phrase = self._strip_quotes(args)
        schema = self.schema_mgr.load_schema(self.schema_updater.persona, self.schema_updater.set_name)
        rp = list(schema.get("rewrite_prompts", []))
        if phrase and phrase not in rp:
            rp.append(phrase)
        schema["rewrite_prompts"] = rp
        if phrase:
            self._add_schema_command_value(schema, "/rewrite", phrase)
        self.schema_mgr.save_schema(self.schema_updater.persona, self.schema_updater.set_name, schema)
        return "Rewrite behavior updated."

    def _reject(self, args: str) -> str:
        text = self._strip_quotes(args) or "rejected"
        schema = self.schema_mgr.load_schema(self.schema_updater.persona, self.schema_updater.set_name)
        dislikes = list(schema.get("dislikes", []))
        if text not in dislikes:
            dislikes.append(text)
        schema["dislikes"] = dislikes
        self._add_schema_command_value(schema, "/reject", text)
        self.beans.increment(f"rej_{abs(hash(text))%10007}", -1)
        self.schema_mgr.save_schema(self.schema_updater.persona, self.schema_updater.set_name, schema)
        return f"Rejected: {text}"

    def _auto(self, args: str) -> str:
        text = self._strip_quotes(args) or "auto"
        schema = self.schema_mgr.load_schema(self.schema_updater.persona, self.schema_updater.set_name)
        events = list(schema.get("events", []))
        mark = f"AUTO: {text}"
        if mark not in events:
            events.append(mark)
        schema["events"] = events
        self._add_schema_command_value(schema, "/auto", text)
        self.schema_mgr.save_schema(self.schema_updater.persona, self.schema_updater.set_name, schema)
        return f"Auto behavior noted: {text}"

    def _ignore(self, args: str) -> str:
        text = self._strip_quotes(args) or "ignore"
        schema = self.schema_mgr.load_schema(self.schema_updater.persona, self.schema_updater.set_name)
        tone = dict(schema.get("tone_rules", {}))
        avoid = list(tone.get("avoid", []))
        if text not in avoid:
            avoid.append(text)
        tone["avoid"] = avoid
        schema["tone_rules"] = tone
        dislikes = list(schema.get("dislikes", []))
        if text not in dislikes:
            dislikes.append(text)
        schema["dislikes"] = dislikes
        self._add_schema_command_value(schema, "/ignore", text)
        self.schema_mgr.save_schema(self.schema_updater.persona, self.schema_updater.set_name, schema)
        return f"Ignoring: {text}"

    def _opposite(self, args: str) -> str:
        text = self._strip_quotes(args) or "opposite"
        schema = self.schema_mgr.load_schema(self.schema_updater.persona, self.schema_updater.set_name)
        tone = dict(schema.get("tone_rules", {}))
        opp = list(tone.get("opposites", []))
        if text not in opp:
            opp.append(text)
        tone["opposites"] = opp
        schema["tone_rules"] = tone
        self._add_schema_command_value(schema, "/opposite", text)
        rps = list(schema.get("rewrite_prompts", []))
        guide = f"Prefer the opposite of: {text}"
        if guide not in rps:
            rps.append(guide)
        schema["rewrite_prompts"] = rps
        self.schema_mgr.save_schema(self.schema_updater.persona, self.schema_updater.set_name, schema)
        return f"Will prefer the opposite of: {text}"

    def _delete(self, args: str) -> str:
        text = self._strip_quotes(args) or "delete"
        schema = self.schema_mgr.load_schema(self.schema_updater.persona, self.schema_updater.set_name)
        overlay = dict(schema.get("dynamic_overlay", {}))
        deletions = list(overlay.get("delete_targets", []))
        if text not in deletions:
            deletions.append(text)
        overlay["delete_targets"] = deletions
        schema["dynamic_overlay"] = overlay
        self._add_schema_command_value(schema, "/delete", text)
        self.schema_mgr.save_schema(self.schema_updater.persona, self.schema_updater.set_name, schema)
        return f"Marked for deletion: {text}"

    def _show(self, args: str) -> str:
        key = (args or "").strip().lower()
        if key == "facts":
            tops = sorted(self.beans.counts.items(), key=lambda kv: kv[1], reverse=True)[:10]
            if not tops:
                return "No facts yet."
            return "Top facts:\n" + "\n".join([f"• {k}: {v}" for k, v in tops])
        return "Unknown /show argument. Try '/show facts'."

    def _action(self, args: str) -> str:
        action = self._strip_quotes(args) or "action"
        schema = self.schema_mgr.load_schema(self.schema_updater.persona, self.schema_updater.set_name)
        actions = list(schema.get("actions", []))
        if action not in actions:
            actions.append(action)
        schema["actions"] = actions
        self.schema_mgr.save_schema(self.schema_updater.persona, self.schema_updater.set_name, schema)
        return f"Action added: {action}"

    def _trait(self, args: str) -> str:
        trait = self._strip_quotes(args) or "trait"
        schema = self.schema_mgr.load_schema(self.schema_updater.persona, self.schema_updater.set_name)
        overlay = dict(schema.get("dynamic_overlay", {}))
        traits = list(overlay.get("added_traits", []))
        if trait not in traits:
            traits.append(trait)
        overlay["added_traits"] = traits
        schema["dynamic_overlay"] = overlay
        self.schema_mgr.save_schema(self.schema_updater.persona, self.schema_updater.set_name, schema)
        return f"Trait added: {trait}"

    # Data/system
    def _dataset(self, args: str) -> str:
        parts = args.split()
        if not parts:
            return "Usage: /dataset add|delete|toggle|list ..."
        sub = parts[0].lower()
        try:
            if sub == "add" and len(parts) >= 3:
                name = parts[1]
                path = " ".join(parts[2:])
                self.dataset_mgr.add_dataset(name, path)
                self.rag.clear_memory()
                return f"Dataset '{name}' updated with file '{path}'."
            if sub == "delete" and len(parts) == 2:
                name = parts[1]
                self.dataset_mgr.delete_dataset(name)
                self.rag.clear_memory()
                return f"Dataset '{name}' deleted."
            if sub == "toggle" and len(parts) == 3:
                name = parts[1]
                on = parts[2].lower() in {"on", "true", "1", "enable", "enabled"}
                self.dataset_mgr.toggle_active(name, on)
                return f"Dataset '{name}' set to {'active' if on else 'inactive'}."
            if sub == "list":
                items = self.dataset_mgr.entries
                if not items:
                    return "No datasets."
                return "Datasets:\n" + "\n".join([f"• {n} [{'ON' if e.active else 'off'}]" for n, e in sorted(items.items())])
        except Exception as e:
            return f"Dataset error: {e}"
        return "Usage: /dataset add <name> <path> | delete <name> | toggle <name> on|off | list"

    def _search(self, args: str) -> str:
        q = args.strip()
        if not q:
            return "Usage: /search <query>"
        packs: List[Tuple[DatasetManager, List[DatasetEntry]]] = []
        packs.append((self.dataset_mgr, self.dataset_mgr.get_active_datasets()))
        shared = self.schema_mgr.get_shared_datasets(self.schema_updater.persona, self.schema_updater.set_name)
        if shared:
            owners: Dict[Tuple[str, str], List[DatasetEntry]] = {}
            for e in shared:
                try:
                    rel = os.path.relpath(e.path, self.dataset_mgr.base_dir).replace("\\", "/")
                    parts = rel.split("/")
                    idx = parts.index("profiles")
                    other_persona = parts[idx+1]
                    other_set = parts[idx+2]
                except Exception:
                    continue
                owners.setdefault((other_persona, other_set), []).append(e)
            for key, ents in owners.items():
                p, s = key
                packs.append((DatasetManager(self.base_dir, p, s), ents))
        hits = self.rag.search_all(packs, q, per_ds_k=4, limit=10)
        if not hits:
            return "No results."
        lines = []
        for chunk, score, ds, prov in hits:
            lines.append(f"[{ds}] {os.path.basename(prov)} (score={score:.3f})\n{chunk[:300].strip()}...")
        return "\n\n".join(lines)

    def _embeddings(self, args: str) -> str:
        sub = (args or "").strip().lower()
        if sub == "clear":
            n = self.rag.clear_disk()
            self.rag.clear_memory()
            return f"Cleared {n} embedding cache files."
        return "Usage: /embeddings clear"

    def _schema(self, args: str) -> str:
        parts = args.split()
        if not parts:
            return "Usage: /schema set <persona> <set> | awareness on|off | active"
        sub = parts[0].lower()
        if sub == "set" and len(parts) == 3:
            persona, set_name = parts[1].lower(), parts[2]
            if persona not in self.schema_mgr.personas:
                return f"Unknown persona '{persona}'"
            if set_name not in self.schema_mgr.get_set_list(persona):
                os.makedirs(os.path.join(self.schema_mgr.schemas_dir, persona, "sets", set_name), exist_ok=True)
                sch = self.schema_mgr.load_schema(persona, "default")
                self.schema_mgr.save_schema(persona, set_name, sch)
            active = dict(self.schema_mgr.active_schemas)
            active[persona] = set_name
            self.schema_mgr.save_active_schemas(active)
            self.core_ref.switch_persona_set(persona if persona == self.core_ref.persona else None,
                                             set_name if persona == self.core_ref.persona else None)
            return f"Active schema set: {persona}/{set_name}"
        if sub == "awareness" and len(parts) == 2:
            on = parts[1].lower() in {"on", "true", "1", "enable", "enabled"}
            sch = self.schema_mgr.load_schema(self.schema_updater.persona, self.schema_updater.set_name)
            flags = dict(sch.get("flags") or {})
            flags["semantic_awareness"] = bool(on)
            sch["flags"] = flags
            sch["semantic_awareness_enabled"] = bool(on)
            self.schema_mgr.save_schema(self.schema_updater.persona, self.schema_updater.set_name, sch)
            return f"Semantic awareness {'enabled' if on else 'disabled'} for {self.schema_updater.persona}/{self.schema_updater.set_name}"
        if sub == "active":
            act = self.schema_mgr.active_schemas
            return "Active schemas:\n" + "\n".join([f"• {p}: {s}" for p, s in act.items()])
        return "Usage: /schema set <persona> <set> | awareness on|off | active"

    def _tts(self, args: str) -> str:
        parts = args.split()
        if not parts:
            return "Usage: /tts on|off | volume <0-100>"
        sub = parts[0].lower()
        if sub in {"on", "off"}:
            flag = sub == "on"
            self.settings.monologue_tts_enabled = flag
            self.settings.save()
            return f"TTS {'enabled' if flag else 'disabled'}."
        if sub == "volume" and len(parts) == 2:
            try:
                v = int(parts[1]); v = max(0, min(100, v))
                self.settings.monologue_volume = v
                self.settings.save()
                if self.core_ref.tts_mgr:
                    self.core_ref.tts_mgr.set_volume(v)
                return f"TTS volume set to {v}."
            except Exception:
                return "Volume must be integer 0-100."
        return "Usage: /tts on|off | volume <0-100>"

    def _plugin(self, args: str) -> str:
        parts = args.split()
        if not parts:
            return "Usage: /plugin enable|disable|list ..."
        sub = parts[0].lower()
        if sub == "list":
            metas = self.plugins.list_plugins()
            if not metas:
                return "No plugins found."
            lines = []
            for m in metas:
                missing = f" (missing: {','.join(m.missing_dependencies)})" if m.missing_dependencies else ""
                lines.append(f"• {m.name} v{m.version or '?'} [{'ON' if m.enabled else 'off'}]{missing}")
            return "\n".join(lines)
        if sub in {"enable", "disable"} and len(parts) == 2:
            name = parts[1]
            flag = sub == "enable"
            self.plugins.enable_plugin(name, flag)
            return f"Plugin '{name}' {'enabled' if flag else 'disabled'}."
        return "Usage: /plugin enable <name> | disable <name> | list"

    def _feedback(self, args: str) -> str:
        parts = args.split()
        if not parts:
            return "Usage: /feedback stats | export <path>"
        sub = parts[0].lower()
        if sub == "stats":
            pos, neg = self.core_ref.feedback_db.get_counts()
            return f"Feedback: {pos} 👍  /  {neg} 👎"
        if sub == "export" and len(parts) >= 2:
            out = " ".join(parts[1:])
            n = self.core_ref.feedback_db.export_jsonl(out)
            return f"Exported {n} feedback records to {out}."
        return "Usage: /feedback stats | export <path>"

    def _lock(self, args: str) -> str:
        parts = args.split()
        if len(parts) != 2:
            return "Usage: /lock <cmd> on|off"
        cmd, state = parts
        if cmd not in self.registry.commands:
            return f"Unknown command '{cmd}'"
        self.registry.toggle_lock(cmd, state.lower() in {"on", "true", "1"})
        return f"Command '{cmd}' lock set to {self.registry.is_locked(cmd)}."

    def _commands(self, args: str) -> str:
        if args.strip().lower() == "list":
            items = []
            for c in self.registry.list_commands():
                items.append(f"• {c} (weight={self.registry.get_weight(c)}, locked={self.registry.is_locked(c)})")
            return "\n".join(items) if items else "No commands."
        return "Usage: /commands list"

    def _enterroom(self, args: str) -> str:
        # Stub for spatial room
        return "Entered room."

    def _move(self, args: str) -> str:
        # Stub for spatial room
        return "Moved."

# ──────────────────────────────────────────────────────────────────────────────
# Plugin system
# ──────────────────────────────────────────────────────────────────────────────
class PluginMeta:
    def __init__(self, name: str, path: str) -> None:
        self.name = name
        self.path = path
        self.enabled: bool = False
        self.module: Optional[Any] = None
        self.widget: Optional[Any] = None
        self.version: Optional[str] = None
        self.entry_point: Optional[str] = None
        self.dependencies: List[str] = []
        self.default_enabled: bool = False
        self.missing_dependencies: List[str] = []
        self._parse_manifest()

    def _parse_manifest(self) -> None:
        manifest_path = os.path.join(self.path, "manifest.json")
        if not os.path.isfile(manifest_path):
            return
        try:
            with open(manifest_path, "r", encoding="utf-8") as f:
                data = json.load(f)
            self.version = data.get("version")
            self.entry_point = data.get("entry_point") or None
            deps = data.get("dependencies") or []
            if isinstance(deps, list):
                self.dependencies = [str(d) for d in deps if isinstance(d, str)]
            self.default_enabled = bool(data.get("default_enabled", False))
        except Exception as e:
            logger.error("[Plugin:%s] manifest error: %s", self.name, e)
            return
        for dep in self.dependencies:
            try:
                __import__(dep.replace('-', '_'))
            except Exception:
                self.missing_dependencies.append(dep)

    def load_module(self) -> None:
        if self.module is not None or self.missing_dependencies:
            return
        spec = None
        if self.entry_point:
            spec = self.entry_point if "." in self.entry_point else f"plugins.{self.entry_point}"
        else:
            spec = f"plugins.{self.name}"
        try:
            import importlib
            self.module = importlib.import_module(spec)
        except Exception as e:
            logger.error("[Plugin:%s] import error: %s", self.name, e)
            self.module = None

    def start(self, host: "PluginManager") -> None:
        if self.enabled:
            return
        self.load_module()
        if self.module is None:
            return
        try:
            if hasattr(self.module, "start"):
                self.widget = self.module.start(host)  # type: ignore
            self.enabled = True
        except Exception as e:
            logger.error("[Plugin:%s] start error: %s", self.name, e)
            self.enabled = False

    def stop(self) -> None:
        if not self.enabled or self.module is None:
            return
        try:
            if hasattr(self.module, "stop"):
                self.module.stop()  # type: ignore
        except Exception as e:
            logger.error("[Plugin:%s] stop error: %s", self.name, e)
        self.widget = None
        self.enabled = False

class PluginManager(QtCore.QObject):
    eventReceived = QtCore.pyqtSignal(str, dict)  # sender, envelope

    def __init__(self, base_dir: str, settings: Settings) -> None:
        super().__init__()
        self.base_dir = base_dir
        self.settings = settings
        self.plugins_dir = os.path.join(self.base_dir, "plugins")
        os.makedirs(self.plugins_dir, exist_ok=True)
        self._plugins: Dict[str, PluginMeta] = {}
        self.discover_plugins()

    def discover_plugins(self) -> None:
        self._plugins.clear()
        for entry in os.scandir(self.plugins_dir):
            if entry.is_dir():
                meta = PluginMeta(entry.name, entry.path)
                self._plugins[entry.name] = meta
        for name, meta in self._plugins.items():
            if name in self.settings.enabled_plugins or (not self.settings.enabled_plugins and meta.default_enabled):
                meta.enabled = True
                meta.start(self)

    def list_plugins(self) -> List[PluginMeta]:
        return list(self._plugins.values())

    def enable_plugin(self, name: str, flag: bool) -> None:
        meta = self._plugins.get(name)
        if not meta:
            return
        if flag and not meta.enabled:
            meta.start(self)
            if name not in self.settings.enabled_plugins:
                self.settings.enabled_plugins.append(name)
                self.settings.save()
        elif not flag and meta.enabled:
            meta.stop()
            if name in self.settings.enabled_plugins:
                self.settings.enabled_plugins.remove(name)
                self.settings.save()

    def rescan(self) -> None:
        self.discover_plugins()

    def broadcast(self, message: Any) -> None:
        envelope = message if (isinstance(message, dict) and "type" in message) else {"type": "command", "data": message}
        for meta in self._plugins.values():
            if not (meta.enabled and meta.module):
                continue
            try:
                if hasattr(meta.module, "on_command"):
                    try:
                        meta.module.on_command(envelope)  # type: ignore
                    except TypeError:
                        meta.module.on_command(envelope.get("data"))  # type: ignore
            except Exception as e:
                logger.error("[Plugin:%s] on_command error: %s", meta.name, e)

    def emit_event(self, sender: str, type: str, payload: Any) -> None:
        self.eventReceived.emit(sender, {"sender": sender, "type": type, "data": payload})

    def stop_all(self) -> None:
        for meta in self._plugins.values():
            try:
                meta.stop()
            except Exception:
                pass

# ──────────────────────────────────────────────────────────────────────────────
# Schema evolver using feedback (frequency + votes)
# ──────────────────────────────────────────────────────────────────────────────
class SchemaEvolver:
    def __init__(self, mgr: SchemaManager, feedback_db: SemanticFeedbackDB, memory_state: Dict[str, Any]) -> None:
        self.mgr = mgr
        self.feedback_db = feedback_db
        self.memory_state = memory_state
        self._protected = self.mgr._load_control_schema()
        self._last_success_ts = 0.0

    def update_schema(self, persona: str, set_name: str, history: List[Tuple[str, str]]) -> bool:
        try:
            tokens: List[str] = []
            for role, content in history[-12:]:
                tokens.extend([w.lower() for w in re.findall(r"\b\w+\b", content or "") if len(w) > 3])
            word_freq = Counter(tokens)
            pos_count, neg_count = self.feedback_db.get_counts()

            if (pos_count + neg_count) < 5 or pos_count <= neg_count or not word_freq:
                return False

            patch: Dict[str, Any] = {}
            schema = self.mgr.load_schema(persona, set_name)
            tone_rules = dict(schema.get("tone_rules", {}))
            avoid_words = set(tone_rules.get("avoid", []))
            top_words = [w for w, _ in word_freq.most_common(5) if w not in avoid_words]
            if top_words:
                tone_rules["preferred_words"] = top_words[:3]
                patch["tone_rules"] = tone_rules

            if patch and all(k not in self._protected for k in patch.keys()):
                schema.update(patch)
                self.mgr.save_schema(persona, set_name, schema)
                self._last_success_ts = time.time()
                return True
        except Exception as e:
            logger.error("[SchemaEvolver] error: %s", e)
        return False

# ──────────────────────────────────────────────────────────────────────────────
# FathomKernel self-rewriter (C-9)
# ──────────────────────────────────────────────────────────────────────────────
class FathomKernel:
    def __init__(self, base_dir: str) -> None:
        self.base_dir = base_dir

    def snapshot_codebase(self) -> Dict[str, str]:
        code = {}
        for root, _, files in os.walk(self.base_dir):
            for fn in files:
                if fn.endswith(".py"):
                    p = os.path.join(root, fn)
                    with open(p, "r", encoding="utf-8") as f:
                        code[p] = f.read()
        return code

    def lint_and_patch(self) -> None:
        # Use ruff for linting
        try:
            subprocess.run(["ruff", "check", "--fix", self.base_dir], check=False)
        except Exception:
            pass
        # For patch, stub: call ollama to rewrite
        pass

# ──────────────────────────────────────────────────────────────────────────────
# Threaded model worker
# ──────────────────────────────────────────────────────────────────────────────
class ModelWorker(QtCore.QThread):
    finished = QtCore.pyqtSignal(str)
    def __init__(self, model: str, prompt: str, parent: Optional[QtCore.QObject] = None) -> None:
        super().__init__(parent)
        self.model = model
        self.prompt = prompt

    def run(self) -> None:
        try:
            parent = self.parent()
            if parent and hasattr(parent, "_query_model"):
                result = parent._query_model(self.model, self.prompt)  # type: ignore
            else:
                result = ""
            self.finished.emit(result)
        except Exception as e:
            self.finished.emit(f"Error: {e}")
        finally:
            try:
                self.deleteLater()
            except Exception:
                pass

# ──────────────────────────────────────────────────────────────────────────────
# Orchestrator
# ──────────────────────────────────────────────────────────────────────────────
class AgentCore(QtCore.QObject):
    """
    Binds together all components for headless or GUI use.
    """
    def __init__(self, base_dir: str, persona: str = "zira", set_name: Optional[str] = None) -> None:
        super().__init__()
        self.base_dir = base_dir
        self.schema_mgr = SchemaManager(base_dir)
        self.persona = persona
        if set_name is None:
            set_name = self.schema_mgr.active_schemas.get(persona, "default")
        self.set_name = set_name

        self.settings = Settings(base_dir)
        ensure_models_present()

        self.operator_mgr = OperatorManager(base_dir)
        self.dataset_mgr = DatasetManager(base_dir, self.persona, self.set_name)
        self.tts_mgr = TTSManager(default_volume=self.settings.monologue_volume)
        self.audio_recorder = AudioRecorder()
        self.google_listener = GoogleListener()
        self.conversation_db = ConversationDB(conv_db_path(base_dir, self.persona, self.set_name))
        self.feedback_db = SemanticFeedbackDB(feedback_db_path(base_dir, self.persona, self.set_name), base_dir, self.persona, self.set_name)
        self.beans = self.feedback_db.beans
        self.reinforcement_log = ReinforcementStore(base_dir)

        self.context_monitor = ContextMonitor(depth=self.settings.context_depth)
        self.schema_auto_updater = SchemaAutoUpdater(self.schema_mgr, self.persona, self.set_name)
        self.schema_evolver = SchemaEvolver(self.schema_mgr, self.feedback_db, memory_state={})

        self.command_registry = CommandRegistry(base_dir, self.persona, self.set_name)
        try:
            sch = self.schema_mgr.load_schema(self.persona, self.set_name)
            self.command_registry.register_from_schema(sch)
        except Exception:
            pass

        self.plugins = PluginManager(base_dir, self.settings)

        if SentenceTransformer and np is not None:
            try:
                self.embed_model = SentenceTransformer("all-MiniLM-L6-v2")
                embed_name = "MiniLM"
            except Exception:
                self.embed_model = None
                embed_name = "none"
        else:
            self.embed_model = None
            embed_name = "none"
        self.rag_cache = RAGCache(self.embed_model, embed_name, self.dataset_mgr.datasets_dir)

        self.command_executor = CommandExecutor(
            self.command_registry, self.schema_mgr, self.schema_auto_updater, self.beans,
            self.dataset_mgr, self.rag_cache, self.settings, self.plugins, self
        )

        self.fathom_kernel = FathomKernel(base_dir)

        self._idle_timer = QtCore.QTimer()
        self._idle_timer.timeout.connect(self._on_idle)
        self._idle_timer.start(86400000)  # nightly

        try:
            self.schema_mgr.schemaChanged.connect(self._on_schema_changed)
        except Exception:
            pass

    def _on_idle(self) -> None:
        self.fathom_kernel.lint_and_patch()

    def _on_schema_changed(self, persona: str, set_name: str) -> None:
        if persona == self.persona and set_name == self.set_name:
            self.dataset_mgr = DatasetManager(self.base_dir, self.persona, self.set_name)
            self.rag_cache.datasets_root = self.dataset_mgr.datasets_dir
            try:
                sch = self.schema_mgr.load_schema(self.persona, self.set_name)
                self.command_registry.register_from_schema(sch)
            except Exception:
                pass

    def process_user_message(self, message: str, tts: bool = False) -> str:
        self.conversation_db.save_message("user", message)
        if message.strip().startswith("/"):
            response = self.run_command(message.strip())
        else:
            self.context_monitor.add_message("user", message)
            if self.settings.auto_schema_enabled:
                analysis = self.context_monitor.analyze()
                self.schema_auto_updater.update_with_context(analysis)
            response = "Message processed."
        self.conversation_db.save_message("zira", response)
        if tts and self.settings.monologue_tts_enabled and self.tts_mgr is not None:
            self.tts_mgr.enqueue(response)
        return response

    def run_command(self, command_line: str,
                    persona: Optional[str] = None,
                    set_name: Optional[str] = None) -> str:
        try:
            self.plugins.broadcast({"type": "slash", "data": command_line})
        except Exception:
            pass

        if not persona and not set_name:
            try:
                sch = self.schema_mgr.load_schema(self.persona, self.set_name)
                self.command_registry.register_from_schema(sch)
            except Exception:
                pass
            try:
                return self.command_executor.execute(command_line)
            except Exception as e:
                return f"Command error: {e}"

        target_persona = (persona or self.persona).lower()
        target_set = set_name or self.set_name

        tmp_registry = CommandRegistry(self.base_dir, target_persona, target_set)
        try:
            sch = self.schema_mgr.load_schema(target_persona, target_set)
            tmp_registry.register_from_schema(sch)
        except Exception:
            pass
        tmp_beans = BeanCounter(self.base_dir, target_persona, target_set)
        tmp_datasets = DatasetManager(self.base_dir, target_persona, target_set)
        tmp_updater = SchemaAutoUpdater(self.schema_mgr, target_persona, target_set)
        tmp_rag = RAGCache(self.embed_model, getattr(self.rag_cache, "model_name", "MiniLM"), tmp_datasets.datasets_dir)

        tmp_exec = CommandExecutor(
            tmp_registry, self.schema_mgr, tmp_updater, tmp_beans,
            tmp_datasets, tmp_rag, self.settings, self.plugins, self
        )
        try:
            return tmp_exec.execute(command_line)
        except Exception as e:
            return f"Command error: {e}"

    def switch_persona_set(self, persona: Optional[str] = None, set_name: Optional[str] = None) -> None:
        if persona:
            self.persona = persona
        if set_name:
            self.set_name = set_name
        self.dataset_mgr = DatasetManager(self.base_dir, self.persona, self.set_name)
        self.conversation_db = ConversationDB(conv_db_path(self.base_dir, self.persona, self.set_name))
        self.feedback_db = SemanticFeedbackDB(feedback_db_path(self.base_dir, self.persona, self.set_name), self.base_dir, self.persona, self.set_name)
        self.beans = self.feedback_db.beans
        self.schema_auto_updater = SchemaAutoUpdater(self.schema_mgr, self.persona, self.set_name)
        self.schema_evolver = SchemaEvolver(self.schema_mgr, self.feedback_db, memory_state={})
        self.command_registry = CommandRegistry(self.base_dir, self.persona, self.set_name)
        try:
            sch = self.schema_mgr.load_schema(self.persona, self.set_name)
            self.command_registry.register_from_schema(sch)
        except Exception:
            pass
        self.command_executor = CommandExecutor(
            self.command_registry, self.schema_mgr, self.schema_auto_updater, self.beans,
            self.dataset_mgr, self.rag_cache, self.settings, self.plugins, self
        )
        self.rag_cache.datasets_root = self.dataset_mgr.datasets_dir

        # U-9: Auto-stop STT on context switch
        self.google_listener.stop_listener()

    def rag_search(self, query_text: str, per_ds_k: int = 4, limit: int = 10,
                   include_shared: bool = True,
                   datasets: Optional[List[str]] = None) -> List[Tuple[str, float, str, str]]:
        current_entries = self.dataset_mgr.get_active_datasets()
        if datasets:
            ds_set = set(datasets)
            current_entries = [e for e in current_entries if e.name in ds_set]
        packs: List[Tuple[DatasetManager, List[DatasetEntry]]] = [(self.dataset_mgr, current_entries)]

        if include_shared and self.schema_mgr.is_semantic_on(self.persona, self.set_name):
            shared = self.schema_mgr.get_shared_datasets(self.persona, self.set_name)
            if datasets:
                ds_set = set(datasets)
                shared = [e for e in shared if e.name in ds_set]
            owners: Dict[Tuple[str, str], List[DatasetEntry]] = {}
            for e in shared:
                try:
                    rel = os.path.relpath(e.path, self.base_dir).replace("\\", "/")
                    parts = rel.split("/")
                    idx = parts.index("profiles")
                    other_persona = parts[idx+1]
                    other_set = parts[idx+2]
                except Exception:
                    continue
                owners.setdefault((other_persona, other_set), []).append(e)
            for key, ents in owners.items():
                p, s = key
                packs.append((DatasetManager(self.base_dir, p, s), ents))

        hits = self.rag_cache.search_all(packs, query_text, per_ds_k=per_ds_k, limit=limit*2)
        hits.sort(key=lambda x: x[1], reverse=True)
        return hits[:limit]

    def refresh_prompt_cache(self) -> None:
        self.rag_cache.clear_memory()

    def add_feedback(self, original: str, liked: bool, revised: Optional[str] = None) -> None:
        self.feedback_db.add_feedback(original, liked, revised)
        hist = self.conversation_db.fetch_history(limit=50)
        try:
            self.schema_evolver.update_schema(self.persona, self.set_name, hist)
        except Exception:
            pass

    def _query_model(self, model: str, prompt: str) -> str:
        try:
            result = subprocess.run(["ollama", "run", model], input=prompt.encode("utf-8"),
                                    stdout=subprocess.PIPE, stderr=subprocess.PIPE, timeout=120)
            if result.returncode == 0:
                return result.stdout.decode("utf-8", errors="ignore").strip()
            else:
                err = result.stderr.decode("utf-8", "ignore")
                logger.error("[ollama:%s] error: %s", model, err)
        except Exception as e:
            logger.error("[ollama:%s] exception: %s", model, e)
        return f"(fallback) {prompt}"

    def start_listener(self) -> None:
        self.google_listener.start()

    def stop_listener(self) -> None:
        self.google_listener.stop_listener()

    def close(self) -> None:
        try:
            self.plugins.stop_all()
        except Exception:
            pass
        try:
            self.conversation_db.close()
        except Exception:
            pass
        try:
            self.feedback_db.close()
        except Exception:
            pass
        try:
            if self.tts_mgr:
                self.tts_mgr.close()
        except Exception:
            pass
        try:
            if hasattr(self, "reinforcement_log") and self.reinforcement_log:
                self.reinforcement_log.close()
        except Exception:
            pass
        self.stop_listener()

# ──────────────────────────────────────────────────────────────────────────────
# CLI entrypoint (optional smoke test)
# ──────────────────────────────────────────────────────────────────────────────
if __name__ == "__main__":
    base = os.path.abspath(os.path.join(os.getcwd(), ".agent_state"))
    core = AgentCore(base)
    print("AgentCore ready. Try '/commands list', '/dataset list', '/search your query', '/tts on', or '/schema active'. Ctrl+C to exit.")
    try:
        while True:
            line = input("you> ").strip()
            if not line:
                continue
            if line.lower() in {"quit", "exit"}:
                break
            if line.startswith("/"):
                m = re.match(r"^/as\s+(\w+)\s+(\w+)\s+--\s+(.*)$", line)
                if m:
                    p, s, cmd = m.groups()
                    out = core.run_command(cmd, persona=p, set_name=s)
                else:
                    out = core.run_command(line)
            else:
                out = core.process_user_message(line, tts=False)
            print("zira>", out)
    except KeyboardInterrupt:
        pass
    finally:
        core.close()
```

agent_core.py
=================

Full, end-to-end core for an AI AI TTS Agent with:
- Settings & model bootstrap (Ollama)
- Robust plugin host (enable/disable/list, manifest validation, dependency checks)
- Conversation & feedback stores (with indices, exports)
- Persona schema management (with protected keys) and live signals
- Dataset registry + RAG embeddings cache & query (per persona/set, cross-profile sharing)
  * Multi-file datasets, cache invalidation, provenance
- Context monitor + schema auto-updates driven by directives & feedback (rate-limited)
- Command registry (weight/lock) + full command execution layer
- New commands: /reject, /auto, /ignore, /opposite, /delete, /rewrite (extended persistence)
- BeanCounter reinforcement + integration with feedback and command weights
- Speech I/O (TTS locked to Zira; STT via Sphinx when available) w/ volume control
- Threaded model worker wrapper (cancel-safe)
- Orchestrator (`AgentCore`) wiring everything together for headless/GUI
- CLI entrypoint for smoke tests

Notes
-----
• This module is UI-agnostic. Hook the provided Qt signals in your GUI (`agent_ui.py`).
• All directories are scoped under `base_dir`, with per-persona/per-set state in:
  base_dir/profiles/<persona>/<set>/
**Classes:** Settings, ConversationDB, BeanCounter, SemanticFeedbackDB, ReinforcementStore, SchemaManager, OperatorManager, TTSManager, AudioRecorder, GoogleListener, DatasetEntry, DatasetManager, RAGCache, ContextMonitor, SchemaAutoUpdater, CommandRegistry, CommandExecutor, PluginMeta, PluginManager, SchemaEvolver, FathomKernel, ModelWorker, AgentCore
**Functions:** _have_cli(bin_name), ensure_models_present(), prof_dir(base_dir, persona, set_name), prof_datasets_dir(base_dir, persona, set_name), prof_commands_path(base_dir, persona, set_name), prof_reinforcement_path(base_dir, persona, set_name), conv_db_path(base_dir, persona, set_name), feedback_db_path(base_dir, persona, set_name)


## Module `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\_burner_scripts\agent_store.py`

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
agent_store.py
==============

Thread-safe SQLite façade for the AI-TTS-Agent “v4” architecture.

Tables
------
schemas            : Current JSON blob per persona / set
schema_history     : Versioned diffs – for audits / rollback
commands           : Slash command registry (+weight, locked flag, category_id FK)
beans              : Reinforcement counts & last-updated timestamp
variants           : Prompt / phrase variants auto-generated by SchemaEngine
settings           : Arbitrary per-profile key / val
files              : Filesystem snapshot chunks (path, hash, chunk_idx, content)
spatial_positions  : XY grid positions of entities (bot, objects…)
visual_actions     : Logged avatar actions (textual justification)

Public API
----------
AgentStore(base_dir)    – opens or creates *agent_store.db* in that dir
begin_tx() / commit()   – manual transactions (context-manager also available)
CRUD helpers            – get_schema(), put_schema(), inc_bean(), etc.
migrate_from_files()    – one-shot importer for legacy JSON / sqlite state
ensure_db()             – convenience: open DB, auto-migrate if needed
"""

from __future__ import annotations

import contextlib
import hashlib
import json
import os
import sqlite3
import threading
import time
from typing import Any, Dict, Iterator, List, Optional, Tuple

###############################################################################
# CONSTANTS
###############################################################################

DB_VERSION = 4  # <- bump when schema changes

###############################################################################
# LOW-LEVEL:  connection pool  +  simple retry wrapper
###############################################################################


class _PooledConn:
    """Very small, single-writer / multi-reader pool – good enough for desktop."""

    def __init__(self, path: str) -> None:
        self._path = path
        self._lock = threading.RLock()
        self._pool: List[sqlite3.Connection] = []

    @contextlib.contextmanager
    def get(self) -> Iterator[sqlite3.Connection]:
        with self._lock:
            conn = self._pool.pop() if self._pool else sqlite3.connect(self._path, check_same_thread=False)
        try:
            yield conn
        finally:
            with self._lock:
                if len(self._pool) < 8:
                    self._pool.append(conn)
                else:
                    conn.close()


###############################################################################
# MAIN FACADE
###############################################################################


class AgentStore:
    """
    One instance per *base_dir*; thread-safe for GUI + background workers.
    """

    # ──────────────────────────── bootstrap ────────────────────────────────

    def __init__(self, base_dir: str) -> None:
        self.base_dir = base_dir
        self.db_path = os.path.join(base_dir, "agent_store.db")
        os.makedirs(base_dir, exist_ok=True)
        self._pool = _PooledConn(self.db_path)
        with self._pool.get() as c:
            self._apply_ddl(c)
            c.execute("PRAGMA journal_mode=WAL;")
            c.commit()

    # ------------------------------------------------------------------ DDL
    def _apply_ddl(self, c: sqlite3.Connection) -> None:
        """Create tables if they do not exist, then run migrations."""
        cur = c.cursor()
        cur.executescript(
            """
            PRAGMA foreign_keys = ON;

            CREATE TABLE IF NOT EXISTS meta (
              key TEXT PRIMARY KEY,
              value TEXT
            );

            CREATE TABLE IF NOT EXISTS schemas (
              persona TEXT NOT NULL,
              set_name TEXT NOT NULL,
              schema_json TEXT NOT NULL,
              updated REAL NOT NULL,
              PRIMARY KEY (persona, set_name)
            );

            CREATE TABLE IF NOT EXISTS schema_history (
              id INTEGER PRIMARY KEY AUTOINCREMENT,
              persona TEXT,
              set_name TEXT,
              schema_json TEXT,
              diff TEXT,
              updated REAL
            );

            CREATE TABLE IF NOT EXISTS commands (
              name TEXT PRIMARY KEY,
              weight INTEGER DEFAULT 0,
              locked INTEGER DEFAULT 0,
              category TEXT DEFAULT NULL
            );

            CREATE TABLE IF NOT EXISTS beans (
              subject TEXT PRIMARY KEY,
              count INTEGER DEFAULT 0,
              last_ts REAL
            );

            CREATE TABLE IF NOT EXISTS variants (
              id INTEGER PRIMARY KEY AUTOINCREMENT,
              persona TEXT,
              set_name TEXT,
              category TEXT,
              prompt TEXT
            );

            CREATE TABLE IF NOT EXISTS settings (
              key TEXT PRIMARY KEY,
              value TEXT
            );

            CREATE TABLE IF NOT EXISTS files (
              path TEXT,
              hash TEXT,
              chunk_idx INTEGER,
              size INTEGER,
              mtime REAL,
              content TEXT,
              PRIMARY KEY (path, chunk_idx)
            );

            CREATE TABLE IF NOT EXISTS spatial_positions (
              entity TEXT PRIMARY KEY,
              x INTEGER,
              y INTEGER,
              facing TEXT,
              color TEXT,
              ts REAL
            );

            CREATE TABLE IF NOT EXISTS visual_actions (
              id INTEGER PRIMARY KEY AUTOINCREMENT,
              ts REAL,
              action TEXT,
              location TEXT,
              justification TEXT
            );
            """
        )
        cur.execute("SELECT COALESCE((SELECT value FROM meta WHERE key='user_version'), 0)")
        ver = int(cur.fetchone()[0])
        if ver < DB_VERSION:
            # placeholder for future ALTERs
            cur.execute("REPLACE INTO meta(key,value) VALUES('user_version', ?)", (DB_VERSION,))
        c.commit()

    # ──────────────────────────── helpers ────────────────────────────────
    @contextlib.contextmanager
    def tx(self) -> Iterator[sqlite3.Connection]:
        """Context-manager for explicit multi-statement transaction."""
        with self._pool.get() as c:
            try:
                c.execute("BEGIN IMMEDIATE;")
                yield c
                c.commit()
            except Exception:
                c.rollback()
                raise

    def begin_tx(self) -> sqlite3.Connection:
        """Legacy style manual tx‐start (remember to commit!)."""
        c = self._pool.get().__enter__()  # type: ignore
        c.execute("BEGIN IMMEDIATE;")
        return c

    def commit(self, conn: sqlite3.Connection) -> None:  # noqa: D401
        conn.commit()
        self._pool.get().__exit__(None, None, None)  # type: ignore

    def rollback(self, conn: sqlite3.Connection) -> None:
        conn.rollback()
        self._pool.get().__exit__(None, None, None)  # type: ignore

    # ─────────────────────────── schemas ────────────────────────────────
    def get_schema(self, persona: str, set_name: str) -> Optional[Dict[str, Any]]:
        with self._pool.get() as c:
            cur = c.execute(
                "SELECT schema_json FROM schemas WHERE persona=? AND set_name=?", (persona, set_name)
            )
            row = cur.fetchone()
        return json.loads(row[0]) if row else None

    def put_schema(self, persona: str, set_name: str, schema: Dict[str, Any], diff: str = "") -> None:
        now = time.time()
        s_json = json.dumps(schema, ensure_ascii=False)
        with self.tx() as c:
            c.execute(
                "REPLACE INTO schemas(persona,set_name,schema_json,updated) VALUES(?,?,?,?)",
                (persona, set_name, s_json, now),
            )
            c.execute(
                "INSERT INTO schema_history(persona,set_name,schema_json,diff,updated) VALUES(?,?,?,?,?)",
                (persona, set_name, s_json, diff, now),
            )

    # ─────────────────────────── commands ──────────────────────────────
    def list_commands(self) -> List[Tuple[str, int, int, Optional[str]]]:
        with self._pool.get() as c:
            return list(c.execute("SELECT name,weight,locked,category FROM commands ORDER BY name"))

    def upsert_command(self, name: str, weight: int = 0, locked: bool = False, category: str | None = None) -> None:
        with self._pool.get() as c:
            c.execute(
                "REPLACE INTO commands(name,weight,locked,category) VALUES(?,?,?,?)",
                (name, weight, int(locked), category),
            )
            c.commit()

    # ─────────────────────────── beans ────────────────────────────────
    def inc_bean(self, subject: str, delta: int) -> None:
        now = time.time()
        with self.tx() as c:
            cur = c.execute("SELECT count FROM beans WHERE subject=?", (subject,))
            row = cur.fetchone()
            count = (row[0] if row else 0) + delta
            c.execute("REPLACE INTO beans(subject,count,last_ts) VALUES(?,?,?)", (subject, count, now))

    def get_bean(self, subject: str) -> int:
        with self._pool.get() as c:
            cur = c.execute("SELECT count FROM beans WHERE subject=?", (subject,))
            row = cur.fetchone()
        return row[0] if row else 0

    # ───────────────────────── snapshot (files) ───────────────────────
    def upsert_file_chunk(
        self,
        path: str,
        chunk_idx: int,
        content: str,
        size: int,
        mtime: float,
    ) -> None:
        h = hashlib.sha256(content.encode("utf-8", "ignore")).hexdigest()
        with self._pool.get() as c:
            c.execute(
                "REPLACE INTO files(path,hash,chunk_idx,size,mtime,content) VALUES(?,?,?,?,?,?)",
                (path, h, chunk_idx, size, mtime, content),
            )
            c.commit()

    # ───────────────────────── settings ───────────────────────────────
    def get_setting(self, key: str, default: Any = None) -> Any:
        with self._pool.get() as c:
            cur = c.execute("SELECT value FROM settings WHERE key=?", (key,))
            row = cur.fetchone()
        return json.loads(row[0]) if row else default

    def set_setting(self, key: str, value: Any) -> None:
        val = json.dumps(value)
        with self._pool.get() as c:
            c.execute("REPLACE INTO settings(key,value) VALUES(?,?)", (key, val))
            c.commit()

    # ───────────────────────── migration helper ───────────────────────
    def migrate_from_files(self) -> Dict[str, Any]:
        """
        Import legacy on-disk artefacts *once*.
        Returns a report dict useful for CLI printing.
        """
        report: Dict[str, Any] = {"schemas": 0, "commands": 0, "beans": 0}
        # ------- schemas -------
        legacy_dir = os.path.join(self.base_dir, "schemas")
        if os.path.isdir(legacy_dir):
            for persona in os.listdir(legacy_dir):
                sets_root = os.path.join(legacy_dir, persona, "sets")
                if not os.path.isdir(sets_root):
                    continue
                for set_name in os.listdir(sets_root):
                    sp = os.path.join(sets_root, set_name, "schema.json")
                    if not os.path.isfile(sp):
                        continue
                    with open(sp, "r", encoding="utf-8") as f:
                        schema_json = json.load(f)
                    self.put_schema(persona, set_name, schema_json, diff="initial import")
                    report["schemas"] += 1
        # ------- commands (old profiles) -------
        prof_dir = os.path.join(self.base_dir, "profiles")
        if os.path.isdir(prof_dir):
            for persona in os.listdir(prof_dir):
                for set_name in os.listdir(os.path.join(prof_dir, persona)):
                    cmd_path = os.path.join(prof_dir, persona, set_name, "commands.json")
                    if os.path.isfile(cmd_path):
                        with open(cmd_path, "r", encoding="utf-8") as f:
                            data = json.load(f).get("commands", {})
                        for name, meta in data.items():
                            self.upsert_command(name, meta.get("weight", 0), meta.get("locked", False))
                            report["commands"] += 1
        # ------- beans -------
        reinf_path = os.path.join(self.base_dir, "reinforcement.jsonl")
        if os.path.isfile(reinf_path):
            with open(reinf_path, "r", encoding="utf-8") as f:
                for line in f:
                    try:
                        evt = json.loads(line)
                        subj = evt.get("field")
                        self.inc_bean(subj, 1)
                        report["beans"] += 1
                    except Exception:
                        continue
        return report


###############################################################################
# MODULE-LEVEL convenience
###############################################################################


def ensure_db(base_dir: str) -> AgentStore:
    store = AgentStore(base_dir)
    with store._pool.get() as c:
        cur = c.execute("SELECT value FROM meta WHERE key='user_version'")
        ver = int(cur.fetchone()[0])
    if ver < DB_VERSION:
        print("[AgentStore] Running first-time migration…")
        rpt = store.migrate_from_files()
        print("[AgentStore]   imported:",
              f"{rpt['schemas']} schemas, {rpt['commands']} commands, {rpt['beans']} bean keys")
    return store


# ---------------------------------------------------------------------------#
if __name__ == "__main__":
    import argparse
    import pprint

    ap = argparse.ArgumentParser(description="Create / inspect agent_store.db")
    ap.add_argument("path", help="Base directory of AI-TTS-Agent")
    ap.add_argument("--migrate", action="store_true", help="Run legacy import")
    args = ap.parse_args()

    st = AgentStore(args.path)
    if args.migrate:
        print("Migrating legacy files…")
        pprint.pp(st.migrate_from_files())
    else:
        print("DB user_version =", st.get_setting("db_version", DB_VERSION))
        print("Schemas ->", len(st.list_commands()))
```

agent_store.py
==============

Thread-safe SQLite façade for the AI-TTS-Agent “v4” architecture.

Tables
------
schemas            : Current JSON blob per persona / set
schema_history     : Versioned diffs – for audits / rollback
commands           : Slash command registry (+weight, locked flag, category_id FK)
beans              : Reinforcement counts & last-updated timestamp
variants           : Prompt / phrase variants auto-generated by SchemaEngine
settings           : Arbitrary per-profile key / val
files              : Filesystem snapshot chunks (path, hash, chunk_idx, content)
spatial_positions  : XY grid positions of entities (bot, objects…)
visual_actions     : Logged avatar actions (textual justification)

Public API
----------
AgentStore(base_dir)    – opens or creates *agent_store.db* in that dir
begin_tx() / commit()   – manual transactions (context-manager also available)
CRUD helpers            – get_schema(), put_schema(), inc_bean(), etc.
migrate_from_files()    – one-shot importer for legacy JSON / sqlite state
ensure_db()             – convenience: open DB, auto-migrate if needed
**Classes:** _PooledConn, AgentStore
**Functions:** ensure_db(base_dir)


## Module `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\_burner_scripts\agent_ui.py`

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
agent_ui.py
============

PyQt5 UI for the AI TTS Agent (integrated with AgentCore).

Fixes & additions:
- Slash commands (/remember etc.) now apply to the currently selected persona+set.
- Per-set "Semantic Awareness" persisted (schema.flags.semantic_awareness).
- RAG only uses datasets listed in the current set's schema ("datasets": [...]).
- Schema tab: new Commands row (dropdown + input + Add to Command + New Command).

To launch: `python run_agent.py`
"""

from __future__ import annotations

import os
import json
import time
import re
import subprocess
import threading
from typing import Dict, List, Tuple, Optional

from PyQt5 import QtCore, QtGui, QtWidgets

# Optional spell checker
try:
    from spellchecker import SpellChecker  # type: ignore
except Exception:
    SpellChecker = None  # type: ignore
from PyQt5.QtCore import QSettings, QRunnable, QThreadPool
from functools import partial

# Optional deps
try:
    from sentence_transformers import SentenceTransformer  # type: ignore
except Exception:
    SentenceTransformer = None  # type: ignore
try:
    import numpy as np  # type: ignore
except Exception:
    np = None  # type: ignore
try:
    import sounddevice as sd  # type: ignore
except Exception:
    sd = None  # type: ignore

from agent_core import (
    AgentCore,
    ModelWorker,
)

ROLE_COLOURS: Dict[str, str] = {
    "user": "#FFF8E1",
    "zira": "#E3F2FD",
    "system": "#E0F7FA",
    "operator": "#EDE7F6",
}
NAME_COLOURS: Dict[str, str] = {
    "user": "#5D4037",
    "zira": "#0D47A1",
    "system": "#006064",
    "operator": "#4A148C",
}

# ---------------------------------------------------------------------------
# Spell highlighting for misspelled words
# ---------------------------------------------------------------------------
class _SpellHighlighter(QtGui.QSyntaxHighlighter):
    """
    Underlines misspelled words in red. Uses pyspellchecker if available.
    """
    def __init__(self, document: QtGui.QTextDocument) -> None:
        super().__init__(document)
        # instantiate spell checker only if available
        self._spell = SpellChecker() if SpellChecker else None
        self._format = QtGui.QTextCharFormat()
        self._format.setUnderlineStyle(QtGui.QTextCharFormat.SpellCheckUnderline)
        self._format.setUnderlineColor(QtCore.Qt.red)
        # simple cache to avoid recomputing spelling on common words
        self._cache: Dict[str, bool] = {}

    def highlightBlock(self, text: str) -> None:
        if not self._spell:
            return
        for match in re.finditer(r"[A-Za-z']{3,}", text):
            word = match.group(0).lower()
            bad = self._cache.get(word)
            if bad is None:
                bad = word not in self._spell
                # prune cache occasionally
                if len(self._cache) > 2048:
                    self._cache.clear()
                self._cache[word] = bad
            if bad:
                start, end = match.span()
                length = end - start
                self.setFormat(start, length, self._format)


class AppWindow(QtWidgets.QMainWindow):
    """Main application window for the AI TTS Agent."""

    rewrite_ready = QtCore.pyqtSignal(str)

    def __init__(self) -> None:
        super().__init__()
        self.setWindowTitle("AI TTS Agent v2")
        self.resize(1920, 1080)

        self.base_dir = os.path.dirname(os.path.abspath(__file__))
        self.core = AgentCore(self.base_dir, persona="zira", set_name="default")

        self.current_set: Dict[str, str] = dict(self.core.schema_mgr.active_schemas)
        self.active_persona: str = self.core.persona or "zira"

        self.isolated_history: List[Tuple[str, str]] = []
        self.self_talk_enabled: bool = False
        self._plugin_docks: Dict[str, QtWidgets.QDockWidget] = {}
        self._schema_save_timers: Dict[str, QtCore.QTimer] = {}

        self._idle_timer = QtCore.QTimer(self)
        self._idle_timer.setSingleShot(True)
        self._idle_timer.timeout.connect(self._handle_idle)

        self._restore_layout()
        self._build_ui()
        # build the slash command panel (custom dock)
        self._build_command_dock()
        self._connect_signals()

        try:
            self.core.audio_recorder.transcribed.connect(self._on_transcribed)
        except Exception:
            pass

        self._update_feedback_counts()
        self._bootstrap_conversation()
        self._reset_idle_timer()

        # populate initial slash command list
        try:
            self._populate_command_select()
        except Exception:
            pass

    # ────────────────────────── signals
    def _connect_signals(self) -> None:
        self.btn_send.clicked.connect(self.send_message)

        self.btn_record.clicked.connect(self.start_recording)
        self.btn_stop_rec.clicked.connect(self.stop_recording)

        self.voice_combo.currentTextChanged.connect(self._on_voice_changed)
        # update settings when a new model is selected
        self.model_combo.currentTextChanged.connect(self._on_model_changed)

        self.btn_play.clicked.connect(self._on_play)
        self.btn_stop_tts.clicked.connect(self._on_stop_tts)
        self.btn_replay.clicked.connect(self._on_replay)

        self.btn_like.clicked.connect(self._on_like)
        self.btn_dislike.clicked.connect(self._on_dislike)
        self.btn_manage_feedback.clicked.connect(self._on_manage_feedback)

        self.btn_refresh.clicked.connect(self._on_refresh_chat)
        self.btn_manage_datasets.clicked.connect(self._on_manage_datasets)
        self.btn_inner_monologue.clicked.connect(self._on_inner_monologue)
        self.btn_clear_rag.clicked.connect(self._on_clear_rag_cache)
        self.btn_model_manager.clicked.connect(self._on_show_model_manager)

        self.chk_semantic.toggled.connect(self._on_semantic_toggled)
        self.chk_isolated.toggled.connect(self._on_isolated_toggled)
        self.chk_self_talk.toggled.connect(lambda v: setattr(self, "self_talk_enabled", v))
        self.chk_auto_schema.toggled.connect(self._on_auto_schema_toggled)

        # connect Google STT checkbox
        try:
            self.chk_google_stt.toggled.connect(self._on_google_stt_toggled)
        except Exception:
            pass

        self.rewrite_ready.connect(self._apply_rewrite_result)

        # context menu for chat view to send selection to command input
        try:
            self.chat_view.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
            self.chat_view.customContextMenuRequested.connect(self._show_chat_context_menu)
        except Exception:
            pass
        # custom context menu for spell suggestions on input field
        try:
            self.input_edit.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
            self.input_edit.customContextMenuRequested.connect(self._show_input_context_menu)
        except Exception:
            pass

    # ────────────────────────── layout & lifecycle
    def _restore_layout(self) -> None:
        qsettings = QSettings("xAI", "AI_TTS_Agent")
        try:
            self.restoreGeometry(qsettings.value("geometry", b""))
            self.restoreState(qsettings.value("windowState", b""))
        except Exception:
            pass

    def closeEvent(self, event: QtGui.QCloseEvent) -> None:
        qsettings = QSettings("xAI", "AI_TTS_Agent")
        qsettings.setValue("geometry", self.saveGeometry())
        qsettings.setValue("windowState", self.saveState())
        try:
            self.core.close()
        except Exception:
            pass
        super().closeEvent(event)

    # ────────────────────────── UI build
    def _build_ui(self) -> None:
        self.setStyleSheet(
            """
            QWidget { background-color: #2e3a51; color: #e0e0e0; }
            QGroupBox { border: 1px solid #007acc; margin-top: 7px; }
            QGroupBox::title { subcontrol-origin: margin; left: 12px; padding: 0 4px; }
            QPushButton { background-color: #3c4a6b; color: white; border: 1px solid #007acc; padding: 5px; }
            QPushButton:disabled { background-color: #5a5a7a; color: #c0c0c0; border: 1px solid #555555; }
            QPlainTextEdit, QTextEdit { background-color: #1e2738; color: #e0e0e0; border: 1px solid #007acc; }
            QLineEdit { background-color: #1e2738; color: #e0e0e0; border: 1px solid #007acc; }
            QTabBar::tab { background: #3c4a6b; color: white; border: 1px solid #007acc; padding: 5px 10px; }
            QTabBar::tab:selected { background: #007acc; color: white; }
            QComboBox { background-color: #1e2738; color: #e0e0e0; border: 1px solid #007acc; padding: 3px; }
            QListWidget { background-color: #1e2738; color: #e0e0e0; border: 1px solid #007acc; }
            QCheckBox, QLabel { color: #e0e0e0; }
            """
        )
        self.setDockOptions(
            QtWidgets.QMainWindow.AllowTabbedDocks
            | QtWidgets.QMainWindow.AllowNestedDocks
            | QtWidgets.QMainWindow.AnimatedDocks
        )
        self.setTabPosition(QtCore.Qt.AllDockWidgetAreas, QtWidgets.QTabWidget.North)
        self.setDockNestingEnabled(True)

        tb = QtWidgets.QToolBar("Layout", self)
        tb.setMovable(False)
        self.addToolBar(QtCore.Qt.TopToolBarArea, tb)
        self.chk_lock = QtWidgets.QCheckBox("Lock Layout")
        act = QtWidgets.QWidgetAction(self)
        act.setDefaultWidget(self.chk_lock)
        tb.addAction(act)
        self.chk_lock.toggled.connect(self._on_toggle_lock)

        self.setCentralWidget(QtWidgets.QWidget())
        status = QtWidgets.QStatusBar()
        self.setStatusBar(status)
        self.dock_tray = DockTray(self)
        status.addPermanentWidget(self.dock_tray, 1)

        self.progress_bar = QtWidgets.QProgressBar()
        self.progress_bar.setRange(0, 0)
        self.progress_bar.setVisible(False)
        status.addPermanentWidget(self.progress_bar)

        # Tabs for personas / operators
        self.tabs = QtWidgets.QTabWidget()
        self.tab_widgets: Dict[str, QtWidgets.QWidget] = {}
        for persona in self.core.schema_mgr.personas:
            tab = QtWidgets.QWidget()
            self.tab_widgets[persona] = tab
            self.tabs.addTab(tab, persona.capitalize())
        self.operator_tab = QtWidgets.QWidget()
        self.tabs.addTab(self.operator_tab, "Operators")
        self.tabs.currentChanged.connect(self._on_tab_changed)

        for persona, tab in self.tab_widgets.items():
            self._build_persona_tab(persona, tab)
        self._build_operator_tab(self.operator_tab)

        # Chat panel
        self.chat_view = QtWidgets.QTextEdit()
        self.chat_view.setReadOnly(True)
        self.chat_view.setStyleSheet("background-color: #e0eef5; color: #011627;")
        self.chat_view.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        self.input_edit = QtWidgets.QPlainTextEdit()
        self.input_edit.setPlaceholderText("Type your message or use /remember key value, /showfacts, /style, /weights")
        self.input_edit.setMinimumHeight(64)
        self.input_edit.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        # Attach spell checker highlighter if available
        try:
            if SpellChecker:
                self._spell_highlighter = _SpellHighlighter(self.input_edit.document())  # type: ignore[attr-defined]
        except Exception:
            self._spell_highlighter = None
        self.btn_send = QtWidgets.QPushButton("Send")

        chat_container = QtWidgets.QWidget()
        cv = QtWidgets.QVBoxLayout(chat_container)
        cv.setContentsMargins(7, 7, 7, 7)
        cv.setSpacing(7)
        cv.addWidget(self.chat_view, 1)
        cv.addWidget(self.input_edit)
        row = QtWidgets.QHBoxLayout()
        row.addStretch()
        row.addWidget(self.btn_send)
        cv.addLayout(row)

        # Controls panel
        controls_panel = QtWidgets.QWidget()
        cp_layout = QtWidgets.QVBoxLayout(controls_panel)
        cp_layout.setContentsMargins(7, 7, 7, 7)
        cp_layout.setSpacing(7)

        # Recording
        rec_row = QtWidgets.QHBoxLayout()
        self.btn_record = QtWidgets.QPushButton("Record")
        self.btn_stop_rec = QtWidgets.QPushButton("Stop\nTranscribe")
        self.btn_stop_rec.setEnabled(False)
        for b in (self.btn_record, self.btn_stop_rec):
            b.setMinimumHeight(32)
            b.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        rec_row.addWidget(self.btn_record, 1)
        rec_row.addWidget(self.btn_stop_rec, 1)
        cp_layout.addLayout(rec_row)

        # Microphone device
        mic_row = QtWidgets.QHBoxLayout()
        mic_row.addWidget(QtWidgets.QLabel("Mic:"))
        self.device_combo = QtWidgets.QComboBox()
        self._populate_devices()
        self.device_combo.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        mic_row.addWidget(self.device_combo, 1)
        cp_layout.addLayout(mic_row)

        # Toggles
        self.chk_semantic = QtWidgets.QCheckBox("Semantic Awareness")
        self.chk_semantic.setChecked(True)
        self.chk_isolated = QtWidgets.QCheckBox("Isolated Chat")
        self.chk_isolated.setChecked(False)
        self.chk_mute_tts = QtWidgets.QCheckBox("Mute TTS")
        self.chk_self_talk = QtWidgets.QCheckBox("Enable Self Talk")
        self.chk_self_talk.setChecked(False)
        self.chk_auto_schema = QtWidgets.QCheckBox("Auto Schema Evolution")
        self.chk_auto_schema.setChecked(self.core.settings.auto_schema_enabled)

        cp_layout.addWidget(self.chk_semantic)
        cp_layout.addWidget(self.chk_isolated)
        cp_layout.addWidget(self.chk_mute_tts)
        cp_layout.addWidget(self.chk_self_talk)
        cp_layout.addWidget(self.chk_auto_schema)

        # Optional Google STT toggle (default off)
        self.chk_google_stt = QtWidgets.QCheckBox("Google STT")
        try:
            self.chk_google_stt.setChecked(bool(getattr(self.core.settings, "use_google_stt", False)))
        except Exception:
            self.chk_google_stt.setChecked(False)
        cp_layout.addWidget(self.chk_google_stt)

        # RAG cache clear
        self.btn_clear_rag = QtWidgets.QPushButton("Clear RAG Cache")
        cp_layout.addWidget(self.btn_clear_rag)

        # Maintenance
        self.btn_refresh = QtWidgets.QPushButton("Refresh Chat")
        self.btn_manage_datasets = QtWidgets.QPushButton("Manage Datasets")
        self.btn_inner_monologue = QtWidgets.QPushButton("Inner Monologue")
        for b in (self.btn_refresh, self.btn_manage_datasets, self.btn_inner_monologue):
            b.setMinimumHeight(32)
            b.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
            cp_layout.addWidget(b)

        self.btn_model_manager = QtWidgets.QPushButton("Model Manager")
        self.btn_model_manager.setMinimumHeight(32)
        self.btn_model_manager.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        cp_layout.addWidget(self.btn_model_manager)

        # Style label
        self.style_label = QtWidgets.QLabel("Style: N/A")
        self.style_label.setToolTip("Style score (0–1): rough measure vs. tone rules.")
        cp_layout.addWidget(self.style_label)

        # Response + feedback
        self.response_edit = QtWidgets.QPlainTextEdit()
        self.response_edit.setReadOnly(True)
        self.response_edit.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        cp_layout.addWidget(self.response_edit, 1)

        fb = QtWidgets.QHBoxLayout()
        self.btn_like = QtWidgets.QPushButton("✔")
        self.btn_dislike = QtWidgets.QPushButton("✖")
        self.btn_like.setToolTip("Mark as good response")
        self.btn_dislike.setToolTip("Dislike and rewrite response")
        self.btn_like.setStyleSheet("color: #2ecc71; font-weight: bold;")
        self.btn_dislike.setStyleSheet("color: #e74c3c; font-weight: bold;")
        self.btn_like.setEnabled(False)
        self.btn_dislike.setEnabled(False)
        fb.addWidget(self.btn_like)
        fb.addWidget(self.btn_dislike)
        fb.addStretch()
        self.btn_manage_feedback = QtWidgets.QPushButton("Manage Feedback")
        fb.addWidget(self.btn_manage_feedback)
        cp_layout.addLayout(fb)

        # TTS playback
        tts_row = QtWidgets.QHBoxLayout()
        self.btn_play = QtWidgets.QPushButton("Play")
        self.btn_stop_tts = QtWidgets.QPushButton("Stop")
        self.btn_replay = QtWidgets.QPushButton("Replay")
        for b in (self.btn_play, self.btn_stop_tts, self.btn_replay):
            b.setMinimumHeight(32)
            b.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        tts_row.addWidget(self.btn_play)
        tts_row.addWidget(self.btn_stop_tts)
        tts_row.addWidget(self.btn_replay)
        cp_layout.addLayout(tts_row)

        # Voice & Model
        voice_row = QtWidgets.QHBoxLayout()
        voice_row.addWidget(QtWidgets.QLabel("Voice:"))
        self.voice_combo = QtWidgets.QComboBox()
        voices = self._tts_voice_names()
        if voices:
            self.voice_combo.addItems([v for v in voices if "david" not in v.lower()])
        voice_row.addWidget(self.voice_combo, 1)
        cp_layout.addLayout(voice_row)

        model_row = QtWidgets.QHBoxLayout()
        model_row.addWidget(QtWidgets.QLabel("Model:"))
        self.model_combo = QtWidgets.QComboBox()
        self._populate_models()
        model_row.addWidget(self.model_combo, 1)
        cp_layout.addLayout(model_row)

        # Feedback counts
        self.lbl_feedback_counts = QtWidgets.QLabel("Likes: 0 | Dislikes: 0")
        cp_layout.addWidget(self.lbl_feedback_counts)
        cp_layout.addStretch(1)

        controls_scroll = QtWidgets.QScrollArea()
        controls_scroll.setWidgetResizable(True)
        controls_scroll.setFrameShape(QtWidgets.QFrame.NoFrame)
        controls_scroll.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)
        controls_scroll.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        controls_scroll.setWidget(controls_panel)

        # Docks
        self.controls_dock = QtWidgets.QDockWidget("Controls", self)
        self.controls_dock.setObjectName("ControlsDock")
        self.controls_dock.setWidget(controls_scroll)
        self.controls_dock.setFeatures(
            QtWidgets.QDockWidget.DockWidgetClosable
            | QtWidgets.QDockWidget.DockWidgetMovable
            | QtWidgets.QDockWidget.DockWidgetFloatable
        )

        self.persona_dock = QtWidgets.QDockWidget("Personas", self)
        self.persona_dock.setObjectName("PersonaDock")
        self.persona_dock.setWidget(self._wrap_persona_widget())
        self.persona_dock.setFeatures(
            QtWidgets.QDockWidget.DockWidgetClosable
            | QtWidgets.QDockWidget.DockWidgetMovable
            | QtWidgets.QDockWidget.DockWidgetFloatable
        )

        self.chat_dock = QtWidgets.QDockWidget("Chat", self)
        self.chat_dock.setObjectName("ChatDock")
        self.chat_dock.setWidget(chat_container)
        self.chat_dock.setFeatures(
            QtWidgets.QDockWidget.DockWidgetClosable
            | QtWidgets.QDockWidget.DockWidgetMovable
            | QtWidgets.QDockWidget.DockWidgetFloatable
        )

        self.model_dock = QtWidgets.QDockWidget("Models", self)
        self.model_dock.setObjectName("ModelDock")
        self.model_dock.setFeatures(
            QtWidgets.QDockWidget.DockWidgetClosable
            | QtWidgets.QDockWidget.DockWidgetMovable
            | QtWidgets.QDockWidget.DockWidgetFloatable
        )
        self._build_model_manager()

        self.plugins_dock = QtWidgets.QDockWidget("Plugins", self)
        self.plugins_dock.setObjectName("PluginsDock")
        self.plugins_dock.setFeatures(
            QtWidgets.QDockWidget.DockWidgetClosable
            | QtWidgets.QDockWidget.DockWidgetMovable
            | QtWidgets.QDockWidget.DockWidgetFloatable
        )
        self.plugins_dock.setWidget(self._build_plugins_widget())

        # Titles & dock tray
        self.controls_dock.setTitleBarWidget(DockTitleBar(self.controls_dock, "Controls"))
        self.persona_dock.setTitleBarWidget(DockTitleBar(self.persona_dock, "Personas"))
        self.chat_dock.setTitleBarWidget(DockTitleBar(self.chat_dock, "Chat"))
        self.model_dock.setTitleBarWidget(DockTitleBar(self.model_dock, "Models"))
        self.plugins_dock.setTitleBarWidget(DockTitleBar(self.plugins_dock, "Plugins"))

        for d in (self.controls_dock, self.persona_dock, self.chat_dock, self.model_dock, self.plugins_dock):
            self.dock_tray.register_dock(d)

        self.addDockWidget(QtCore.Qt.LeftDockWidgetArea, self.controls_dock)
        self.addDockWidget(QtCore.Qt.LeftDockWidgetArea, self.persona_dock)
        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.chat_dock)
        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.model_dock)
        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.plugins_dock)

        self.splitDockWidget(self.controls_dock, self.persona_dock, QtCore.Qt.Vertical)
        self.splitDockWidget(self.controls_dock, self.chat_dock, QtCore.Qt.Horizontal)
        self.splitDockWidget(self.chat_dock, self.model_dock, QtCore.Qt.Horizontal)
        self.splitDockWidget(self.model_dock, self.plugins_dock, QtCore.Qt.Horizontal)

    # ────────────────────────── persona widgets
    def _wrap_persona_widget(self) -> QtWidgets.QWidget:
        container = QtWidgets.QWidget()
        v = QtWidgets.QVBoxLayout(container)
        v.setContentsMargins(7, 7, 7, 7)
        v.setSpacing(7)

        try:
            bot_schema = self.core.schema_mgr.load_schema("zira", self.current_set.get("zira", "default"))
            bot_name = bot_schema.get("name", "Zira")
            bot_set = self.current_set.get("zira", "default")
        except Exception:
            bot_name, bot_set = "Zira", "default"

        try:
            user_schema = self.core.schema_mgr.load_schema("user", self.current_set.get("user", "default"))
            user_name = user_schema.get("name", "User")
            user_set = self.current_set.get("user", "default")
        except Exception:
            user_name, user_set = "User", "default"

        self.lbl_active_names = QtWidgets.QLabel(f"{bot_name}: {bot_set} — User: {user_name}: {user_set}")
        v.addWidget(self.lbl_active_names)
        v.addWidget(self.tabs, 1)
        return container

    def _build_persona_tab(self, persona: str, tab: QtWidgets.QWidget) -> None:
        vbox = QtWidgets.QVBoxLayout(tab)

        # --- Set selector row ---
        h_set = QtWidgets.QHBoxLayout()
        h_set.addWidget(QtWidgets.QLabel("Set:"))
        combo = QtWidgets.QComboBox(objectName=f"set_combo_{persona}")
        self._populate_set_combo(persona, combo)
        h_set.addWidget(combo)

        btn_clone = QtWidgets.QPushButton("Clone", objectName=f"clone_set_{persona}")
        btn_new = QtWidgets.QPushButton("New", objectName=f"new_set_{persona}")
        btn_del = QtWidgets.QPushButton("Delete", objectName=f"del_set_{persona}")
        h_set.addWidget(btn_clone)
        h_set.addWidget(btn_new)
        h_set.addWidget(btn_del)
        h_set.addStretch()
        vbox.addLayout(h_set)

        # --- Commands row (NEW) ---
        cmd_row = QtWidgets.QHBoxLayout()
        cmd_row.addWidget(QtWidgets.QLabel("Commands:"))
        cmd_combo = QtWidgets.QComboBox(objectName=f"cmd_combo_{persona}")
        self._populate_command_combo(persona, cmd_combo)
        cmd_row.addWidget(cmd_combo, 1)

        cmd_edit = QtWidgets.QLineEdit(objectName=f"cmd_edit_{persona}")
        cmd_edit.setPlaceholderText('Enter text/payload for selected /command')
        cmd_row.addWidget(cmd_edit, 2)

        btn_add_cmd = QtWidgets.QPushButton("Add to Command", objectName=f"add_cmd_{persona}")
        btn_new_cmd = QtWidgets.QPushButton("New Command", objectName=f"new_cmd_{persona}")
        cmd_row.addWidget(btn_add_cmd)
        cmd_row.addWidget(btn_new_cmd)
        vbox.addLayout(cmd_row)

        # --- Schema editor ---
        editor = QtWidgets.QPlainTextEdit(objectName=f"schema_edit_{persona}")
        editor.setLineWrapMode(QtWidgets.QPlainTextEdit.NoWrap)
        schema = self.core.schema_mgr.load_schema(persona, self.current_set.get(persona, "default"))
        editor.setPlainText(json.dumps(schema, indent=2))
        vbox.addWidget(editor, 1)

        # --- Save button ---
        h_save = QtWidgets.QHBoxLayout()
        btn_save = QtWidgets.QPushButton("Save", objectName=f"save_schema_{persona}")
        h_save.addStretch()
        h_save.addWidget(btn_save)
        vbox.addLayout(h_save)

        # --- Button bindings ---
        combo.currentTextChanged.connect(lambda name, p=persona, c=combo: self._on_set_changed(p, name, c))
        btn_clone.clicked.connect(lambda _, p=persona, c=combo: self._on_clone_set(p, c))
        btn_new.clicked.connect(lambda _, p=persona, c=combo: self._on_new_set(p, c))
        btn_del.clicked.connect(lambda _, p=persona, c=combo: self._on_delete_set(p, c))
        btn_save.clicked.connect(lambda _, p=persona: self._on_save_schema(p))

        btn_add_cmd.clicked.connect(lambda _, p=persona, cc=cmd_combo, ce=cmd_edit: self._on_add_to_command(p, cc, ce))
        btn_new_cmd.clicked.connect(lambda _, p=persona: self._on_new_command(p))

        # --- Autosave debounce ---
        timer = QtCore.QTimer(self)
        timer.setSingleShot(True)

        def on_text_change() -> None:
            timer.start(500)

        def on_timeout() -> None:
            text = editor.toPlainText().strip()
            try:
                obj = json.loads(text)
                if isinstance(obj, dict):
                    set_name = self.current_set.get(persona, "default")
                    self.core.schema_mgr.save_schema(persona, set_name, obj)
            except Exception:
                pass

        editor.textChanged.connect(on_text_change)
        timer.timeout.connect(on_timeout)
        self._schema_save_timers[persona] = timer

    # --- Commands helpers (NEW) ---
    def _populate_command_combo(self, persona: str, combo: QtWidgets.QComboBox) -> None:
        combo.blockSignals(True)
        combo.clear()
        schema = self.core.schema_mgr.load_schema(persona, self.current_set.get(persona, "default"))
        cmds = []
        try:
            cmds = sorted(list((schema.get("commands") or {}).keys()))
        except Exception:
            cmds = []
        if not cmds:
            combo.addItem("(no commands)")
            combo.setEnabled(False)
        else:
            combo.addItems(cmds)
            combo.setEnabled(True)
        combo.blockSignals(False)

    def _on_add_to_command(self, persona: str, combo: QtWidgets.QComboBox, edit: QtWidgets.QLineEdit) -> None:
        text = edit.text().strip()
        if not text:
            QtWidgets.QMessageBox.information(self, "No Text", "Enter text/payload to add.")
            return
        set_name = self.current_set.get(persona, "default")
        schema = self.core.schema_mgr.load_schema(persona, set_name)
        cmds = dict(schema.get("commands") or {})
        sel = combo.currentText().strip()
        if not sel or sel == "(no commands)":
            QtWidgets.QMessageBox.information(self, "No Command", "Create a command first.")
            return
        lst = list(cmds.get(sel) or [])
        lst.append(text)
        cmds[sel] = lst
        schema["commands"] = cmds
        self.core.schema_mgr.save_schema(persona, set_name, schema)
        edit.clear()
        # refresh schema editor & notify
        self._refresh_schema_editor(persona)
        QtWidgets.QMessageBox.information(self, "Added", f'Added to {sel}: "{text}"')

    def _on_new_command(self, persona: str) -> None:
        name, ok = QtWidgets.QInputDialog.getText(self, "New Command", "Enter new command (e.g., /remember):")
        if not ok or not name.strip():
            return
        cmd_name = name.strip()
        if not cmd_name.startswith("/"):
            cmd_name = "/" + cmd_name
        set_name = self.current_set.get(persona, "default")
        schema = self.core.schema_mgr.load_schema(persona, set_name)
        cmds = dict(schema.get("commands") or {})
        if cmd_name in cmds:
            QtWidgets.QMessageBox.information(self, "Exists", f"Command {cmd_name} already exists.")
            return
        cmds[cmd_name] = []
        schema["commands"] = cmds
        self.core.schema_mgr.save_schema(persona, set_name, schema)
        # refresh command combo + schema editor
        tab = self.tab_widgets.get(persona)
        if tab:
            combo = tab.findChild(QtWidgets.QComboBox, f"cmd_combo_{persona}")
            if combo:
                self._populate_command_combo(persona, combo)
                combo.setCurrentText(cmd_name)
            edit = tab.findChild(QtWidgets.QLineEdit, f"cmd_edit_{persona}")
            if edit:
                edit.clear()
        self._refresh_schema_editor(persona)
        QtWidgets.QMessageBox.information(self, "Created", f"New command {cmd_name} created.")

    def _refresh_schema_editor(self, persona: str) -> None:
        tab = self.tab_widgets.get(persona)
        if not tab:
            return
        editor = tab.findChild(QtWidgets.QPlainTextEdit, f"schema_edit_{persona}")
        if editor:
            schema = self.core.schema_mgr.load_schema(persona, self.current_set.get(persona, "default"))
            editor.blockSignals(True)
            editor.setPlainText(json.dumps(schema, indent=2))
            editor.blockSignals(False)
            
    def _on_tab_changed(self, index: int) -> None:
        """
        Handle tab changes in the main tab widget.
        
        Parameters
        ----------
        index : int
            Index of the newly selected tab.
        """
        try:
            tab_name = self.tabs.tabText(index)
            print(f"[UI] Tab changed to: {tab_name} (index {index})")
            # Add any extra logic if needed, for example:
            # self._update_feedback_counts()
        except Exception as e:
            print(f"[UI] Error handling tab change: {e}")
            

    # ────────────────────────── operator tab
    def _build_operator_tab(self, tab: QtWidgets.QWidget) -> None:
        layout = QtWidgets.QVBoxLayout(tab)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)
        scroll = QtWidgets.QScrollArea()
        scroll.setWidgetResizable(True)
        scroll.setFrameShape(QtWidgets.QFrame.NoFrame)
        scroll.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        container = QtWidgets.QWidget()
        container.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        vbox = QtWidgets.QVBoxLayout(container)
        vbox.setContentsMargins(8, 8, 8, 8)
        vbox.setSpacing(8)

        names = sorted(self.core.operator_mgr.list_operators())
        if not names:
            info = QtWidgets.QLabel("No operators found.")
            info.setWordWrap(True)
            vbox.addWidget(info)
        else:
            for name in names:
                # Load operator description if available
                try:
                    op_dir = os.path.join(self.core.operator_mgr.operators_dir, name, "schema.json")
                    desc = ""
                    if os.path.isfile(op_dir):
                        with open(op_dir, "r", encoding="utf-8") as f:
                            d = json.load(f)
                            desc = str(d.get("description", ""))
                except Exception:
                    desc = ""
                box = QtWidgets.QGroupBox(name)
                box.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
                bl = QtWidgets.QVBoxLayout(box)
                bl.setContentsMargins(8, 8, 8, 8)
                bl.setSpacing(6)
                lbl = QtWidgets.QLabel(desc)
                lbl.setWordWrap(True)
                bl.addWidget(lbl)
                btn_row = QtWidgets.QHBoxLayout()
                btn_info = QtWidgets.QPushButton("Info")
                btn_row.addWidget(btn_info)
                btn_row.addStretch(1)
                bl.addLayout(btn_row)
                vbox.addWidget(box)
                btn_info.clicked.connect(partial(QtWidgets.QMessageBox.information, self, f"{name} Info", desc or "No description."))

        vbox.addStretch(1)
        scroll.setWidget(container)
        layout.addWidget(scroll)

    # ────────────────────────── plugins
    def _build_plugins_widget(self) -> QtWidgets.QWidget:
        container = QtWidgets.QWidget()
        layout = QtWidgets.QVBoxLayout(container)
        layout.setContentsMargins(6, 6, 6, 6)
        layout.setSpacing(4)

        self.plugin_list = QtWidgets.QListWidget()
        self.plugin_list.setSelectionMode(QtWidgets.QAbstractItemView.NoSelection)
        layout.addWidget(self.plugin_list, 1)

        btn_rescan = QtWidgets.QPushButton("Rescan")
        layout.addWidget(btn_rescan)
        btn_rescan.clicked.connect(self._rescan_plugins)

        self._populate_plugin_list()
        self.plugin_list.itemChanged.connect(self._on_plugin_item_changed)

        try:
            self.core.plugins.eventReceived.connect(self._on_plugin_event)
        except Exception:
            pass

        return container

    def _populate_plugin_list(self) -> None:
        self.plugin_list.blockSignals(True)
        self.plugin_list.clear()
        for meta in self.core.plugins.list_plugins():
            item = QtWidgets.QListWidgetItem(meta.name)
            flags = item.flags() | QtCore.Qt.ItemIsUserCheckable
            if meta.missing_dependencies:
                flags &= ~QtCore.Qt.ItemIsEnabled
                item.setToolTip(f"Missing dependencies: {', '.join(meta.missing_dependencies)}")
            item.setFlags(flags)
            item.setCheckState(QtCore.Qt.Checked if meta.enabled else QtCore.Qt.Unchecked)
            self.plugin_list.addItem(item)
        self.plugin_list.blockSignals(False)

    def _on_plugin_item_changed(self, item: QtWidgets.QListWidgetItem) -> None:
        name = item.text()
        enabled = item.checkState() == QtCore.Qt.Checked
        self.core.plugins.enable_plugin(name, enabled)
        meta = next((m for m in self.core.plugins.list_plugins() if m.name == name), None)
        if not meta:
            return
        if enabled and meta.widget is not None:
            self._attach_plugin_widget(meta)
        elif not enabled:
            self._detach_plugin_widget(name)

    def _rescan_plugins(self) -> None:
        self.core.plugins.rescan()
        for name in list(self._plugin_docks.keys()):
            meta = next((m for m in self.core.plugins.list_plugins() if m.name == name), None)
            if not meta or not meta.enabled:
                self._detach_plugin_widget(name)
        self._populate_plugin_list()

    def _attach_plugin_widget(self, meta: 'object') -> None:
        if meta.name in self._plugin_docks:
            return
        if meta.widget is None:
            return
        dock = QtWidgets.QDockWidget(meta.name, self)
        dock.setObjectName(f"PluginDock_{meta.name}")
        dock.setWidget(meta.widget)
        dock.setFeatures(
            QtWidgets.QDockWidget.DockWidgetClosable
            | QtWidgets.QDockWidget.DockWidgetMovable
            | QtWidgets.QDockWidget.DockWidgetFloatable
        )
        dock.setTitleBarWidget(DockTitleBar(dock, meta.name))
        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, dock)
        self.dock_tray.register_dock(dock)
        self._plugin_docks[meta.name] = dock

    def _detach_plugin_widget(self, name: str) -> None:
        dock = self._plugin_docks.pop(name, None)
        if dock:
            self.dock_tray._remove_button(dock)
            dock.setParent(None)
            dock.deleteLater()

    @QtCore.pyqtSlot(str, dict)
    def _on_plugin_event(self, sender: str, envelope: dict) -> None:
        try:
            data = envelope.get("data")
            msg = json.dumps(data, indent=2) if isinstance(data, (dict, list)) else str(data)
            display_name = sender
            self._append_message(display_name, msg, role_key="operator")
            if self.chk_semantic.isChecked() and not self.chk_isolated.isChecked():
                self.core.conversation_db.save_message(sender.lower(), msg)
        except Exception as e:
            print(f"Error handling plugin event from {sender}: {e}")

    # ────────────────────────── model manager
    def _build_model_manager(self) -> None:
        widget = QtWidgets.QWidget()
        v = QtWidgets.QVBoxLayout(widget)
        v.setContentsMargins(8, 8, 8, 8)
        v.setSpacing(6)
        self.model_list = QtWidgets.QListWidget()
        v.addWidget(self.model_list, 1)
        h = QtWidgets.QHBoxLayout()
        self.btn_model_pull = QtWidgets.QPushButton("Pull")
        self.btn_model_delete = QtWidgets.QPushButton("Delete")
        self.btn_model_set_default = QtWidgets.QPushButton("Set as Default")
        h.addWidget(self.btn_model_pull)
        h.addWidget(self.btn_model_delete)
        h.addWidget(self.btn_model_set_default)
        h.addStretch()
        v.addLayout(h)
        self.model_dock.setWidget(widget)
        self._refresh_model_list()
        self.btn_model_pull.clicked.connect(self._on_model_pull)
        self.btn_model_delete.clicked.connect(self._on_model_delete)
        self.btn_model_set_default.clicked.connect(self._on_model_set_default)

    def _refresh_model_list(self) -> None:
        self.model_list.clear()
        models: List[str] = []
        try:
            out = subprocess.run(
                ["ollama", "list"],
                stdout=subprocess.PIPE,
                stderr=subprocess.DEVNULL,
                text=True,
                check=True,
            ).stdout.splitlines()
            for line in out[1:]:
                parts = line.strip().split()
                if parts:
                    models.append(parts[0])
        except Exception:
            models = []
        for m in models:
            item = QtWidgets.QListWidgetItem(m)
            if m == self.model_combo.currentText().strip():
                item.setFont(QtGui.QFont("", weight=QtGui.QFont.Bold))
            self.model_list.addItem(item)

    def _on_model_pull(self) -> None:
        item = self.model_list.currentItem()
        if not item:
            return
        model = item.text()
        threading.Thread(target=lambda: subprocess.run(["ollama", "pull", model], check=False), daemon=True).start()
        QtWidgets.QMessageBox.information(self, "Pull Started", f"Pulling {model} in background.")

    def _on_model_delete(self) -> None:
        item = self.model_list.currentItem()
        if not item:
            return
        model = item.text()
        if QtWidgets.QMessageBox.question(
            self,
            "Delete Model",
            f"Delete '{model}'? This cannot be undone.",
            QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No,
        ) != QtWidgets.QMessageBox.Yes:
            return
        threading.Thread(target=lambda: subprocess.run(["ollama", "delete", model], check=False), daemon=True).start()
        QtWidgets.QMessageBox.information(self, "Delete Started", f"Deleting {model} in background.")
        self._refresh_model_list()

    def _on_model_set_default(self) -> None:
        item = self.model_list.currentItem()
        if not item:
            return
        model = item.text()
        idx = self.model_combo.findText(model)
        if idx >= 0:
            self.model_combo.setCurrentIndex(idx)
        # persist selection to settings
        try:
            self.core.settings.default_model = model
            self.core.settings.save()
        except Exception:
            pass
            QtWidgets.QMessageBox.information(self, "Default Model", f"Set default model to {model}.")
        else:
            self.model_combo.addItem(model)
            self.model_combo.setCurrentText(model)

    # ────────────────────────── lock layout
    def _on_toggle_lock(self, locked: bool) -> None:
        feats_unlocked = (
            QtWidgets.QDockWidget.DockWidgetClosable
            | QtWidgets.QDockWidget.DockWidgetMovable
            | QtWidgets.QDockWidget.DockWidgetFloatable
        )
        feats_locked = QtWidgets.QDockWidget.DockWidgetClosable
        for dock in (
            self.controls_dock,
            self.persona_dock,
            self.chat_dock,
            getattr(self, "inner_dock", None),
            self.model_dock,
            self.plugins_dock,
        ):
            if dock is None:
                continue
            dock.setFeatures(feats_locked if locked else feats_unlocked)
        for dock in self._plugin_docks.values():
            dock.setFeatures(feats_locked if locked else feats_unlocked)

    # ────────────────────────── audio
    def start_recording(self) -> None:
        if sd is None or np is None:
            QtWidgets.QMessageBox.information(self, "Recording Unavailable", "sounddevice/numpy not installed.")
            return
        if not self.btn_record.isEnabled():
            return
        device_index = None
        try:
            idx = self.device_combo.currentIndex()
            selected_name = self.device_combo.currentText()
            for i, d in enumerate(sd.query_devices()):
                if d.get("name") == selected_name and d.get("max_input_channels", 0) > 0:
                    device_index = i
                    break
        except Exception:
            device_index = None
        self.core.audio_recorder.start(device_index)
        self.btn_record.setEnabled(False)
        self.btn_stop_rec.setEnabled(True)

    def stop_recording(self) -> None:
        if not self.btn_stop_rec.isEnabled():
            return
        self.core.audio_recorder.stop_and_transcribe()
        self.btn_stop_rec.setEnabled(False)
        self.btn_record.setEnabled(True)

    @QtCore.pyqtSlot(str)
    def _on_transcribed(self, text: str) -> None:
        if not text:
            return
        cur = self.input_edit.toPlainText()
        self.input_edit.setPlainText((cur + "\n" if cur else "") + text)

    # ────────────────────────── TTS
    def _on_play(self) -> None:
        text = self.response_edit.toPlainText().strip()
        if text and not self.chk_mute_tts.isChecked():
            try:
                self.core.tts_mgr.enqueue(text)
            except Exception:
                pass

    def _on_stop_tts(self) -> None:
        try:
            self.core.tts_mgr.stop()
        except Exception:
            pass

    def _on_replay(self) -> None:
        if not self.chk_mute_tts.isChecked():
            try:
                self.core.tts_mgr.replay()
            except Exception:
                pass

    def _on_voice_changed(self, name: str) -> None:
        try:
            eng = getattr(self.core.tts_mgr, "_engine", None)
            if eng:
                for v in eng.getProperty("voices"):
                    if v.name == name:
                        eng.setProperty("voice", v.id)
                        break
        except Exception:
            pass

    def _tts_voice_names(self) -> List[str]:
        try:
            eng = getattr(self.core.tts_mgr, "_engine", None)
            if not eng:
                return []
            return [v.name for v in eng.getProperty("voices")]
        except Exception:
            return []

    # ────────────────────────── feedback
    def _on_like(self) -> None:
        text = self.response_edit.toPlainText().strip()
        if not text:
            return
        try:
            self.core.add_feedback(text, liked=True)
        except Exception:
            pass
        QtWidgets.QMessageBox.information(self, "Feedback", "Marked as good response.")
        self._enable_feedback(False)
        self._update_feedback_counts()

    def _on_dislike(self) -> None:
        original = self.response_edit.toPlainText().strip()
        if not original:
            return
        try:
            self.core.tts_mgr.stop()
        except Exception:
            pass
        QtWidgets.QMessageBox.information(self, "Disliked", "The response will be rewritten.")
        self._enable_feedback(False)

        def worker() -> None:
            new_text = self._rewrite_response(original)
            try:
                self.core.add_feedback(original, liked=False, revised=new_text)
            except Exception:
                pass
            if self.chk_isolated.isChecked():
                self.isolated_history.append((self._current_persona(), new_text))
            else:
                if self.chk_semantic.isChecked():
                    self.core.conversation_db.save_message(self._current_persona().lower(), new_text)
            self.rewrite_ready.emit(new_text)

        threading.Thread(target=worker, daemon=True).start()

    @QtCore.pyqtSlot(str)
    def _apply_rewrite_result(self, new_text: str) -> None:
        schema = self.core.schema_mgr.load_schema(
            self._current_persona(), self.current_set.get(self._current_persona(), "default")
        )
        persona_name = schema.get("name", "Bot")
        role_key = self._current_persona().lower()
        self._append_message(persona_name, new_text, role_key=role_key)
        self.response_edit.setPlainText(new_text)
        if not self.chk_mute_tts.isChecked():
            try:
                self.core.tts_mgr.enqueue(new_text)
            except Exception:
                pass
        QtWidgets.QMessageBox.information(self, "Rewritten", "Response rewritten.")
        self._enable_feedback(False)

    def _update_feedback_counts(self) -> None:
        try:
            pos, neg = self.core.feedback_db.get_counts()
            self.lbl_feedback_counts.setText(f"Likes: {pos} | Dislikes: {neg}")
        except Exception:
            self.lbl_feedback_counts.setText("Likes: - | Dislikes: -")

    def _enable_feedback(self, enabled: bool) -> None:
        self.btn_like.setEnabled(enabled)
        self.btn_dislike.setEnabled(enabled)

    def _on_manage_feedback(self) -> None:
        db = self.core.feedback_db
        if db is None:
            QtWidgets.QMessageBox.information(self, "No DB", "Feedback DB unavailable.")
            return
        cur = db.conn.cursor()
        cur.execute("SELECT id, original, liked, COALESCE(revised, '') FROM feedback ORDER BY id DESC")
        entries = cur.fetchall()
        dlg = QtWidgets.QDialog(self)
        dlg.setWindowTitle("Manage Feedback")
        dlg.resize(720, 420)
        v = QtWidgets.QVBoxLayout(dlg)
        table = QtWidgets.QTableWidget(len(entries), 4)
        table.setHorizontalHeaderLabels(["ID", "Original", "Liked", "Revised"])
        table.horizontalHeader().setStretchLastSection(True)
        for r, (fid, orig, liked, rev) in enumerate(entries):
            table.setItem(r, 0, QtWidgets.QTableWidgetItem(str(fid)))
            table.setItem(r, 1, QtWidgets.QTableWidgetItem(orig))
            table.setItem(r, 2, QtWidgets.QTableWidgetItem("✔" if liked else "✖"))
            table.setItem(r, 3, QtWidgets.QTableWidgetItem(rev))
        v.addWidget(table, 1)
        h = QtWidgets.QHBoxLayout()
        btn_del = QtWidgets.QPushButton("Delete Selected")
        btn_close = QtWidgets.QPushButton("Close")
        h.addWidget(btn_del)
        h.addWidget(btn_close)
        h.addStretch()
        v.addLayout(h)

        def on_delete() -> None:
            selected = table.selectedItems()
            if not selected:
                return
            rows = sorted({i.row() for i in selected}, reverse=True)
            for rr in rows:
                fid_item = table.item(rr, 0)
                if fid_item:
                    try:
                        fid = int(fid_item.text())
                        db.conn.execute("DELETE FROM feedback WHERE id = ?", (fid,))
                        db.conn.commit()
                    except Exception:
                        pass
                table.removeRow(rr)
            self._update_feedback_counts()

        btn_del.clicked.connect(on_delete)
        btn_close.clicked.connect(dlg.accept)
        dlg.exec_()

    # ────────────────────────── datasets / rag
    def _on_manage_datasets(self) -> None:
        DatasetManagerDialog(self.core.dataset_mgr, self).exec_()

    def _on_clear_rag_cache(self) -> None:
        if QtWidgets.QMessageBox.question(
            self,
            "Clear RAG Cache",
            "Delete cached embeddings for all datasets and clear memory?",
            QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No,
        ) != QtWidgets.QMessageBox.Yes:
            return
        count = self.core.rag_cache.clear_disk()
        self.core.rag_cache.clear_memory()
        QtWidgets.QMessageBox.information(self, "Cleared", f"Cleared RAG cache files ({count} removed) and in-memory index.")

    # ────────────────────────── isolated / refresh / idle
    def _on_isolated_toggled(self, checked: bool) -> None:
        if checked:
            self.isolated_history.clear()
        else:
            if self.isolated_history:
                ans = QtWidgets.QMessageBox.question(
                    self,
                    "Merge Isolated Chat",
                    "Merge isolated conversation into main memory?",
                    QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No,
                )
                if ans == QtWidgets.QMessageBox.Yes:
                    for role, content in self.isolated_history:
                        self.core.conversation_db.save_message(role.lower(), content)
                self.isolated_history.clear()
        self._reset_idle_timer()

    def _on_refresh_chat(self) -> None:
        if self.chk_isolated.isChecked():
            self.isolated_history.clear()
        self.chat_view.clear()
        self.response_edit.clear()
        self._enable_feedback(False)
        try:
            if hasattr(self, "inner_text") and self.inner_text is not None:
                self.inner_text.clear()
        except Exception:
            pass

    def _reset_idle_timer(self) -> None:
        self._idle_timer.stop()
        if self.chk_semantic.isChecked():
            self._idle_timer.start(60000)

    def _handle_idle(self) -> None:
        pass

    # ────────────────────────── inner monologue
    def _on_inner_monologue(self) -> None:
        self._ensure_inner_dock()
        if self.inner_dock is None:
            return
        self.inner_dock.setVisible(not self.inner_dock.isVisible())

    def _ensure_inner_dock(self) -> None:
        if hasattr(self, "inner_dock") and self.inner_dock is not None:
            return
        dock = QtWidgets.QDockWidget("Inner Monologue", self)
        dock.setObjectName("InnerDock")
        dock.setAllowedAreas(QtCore.Qt.RightDockWidgetArea | QtCore.Qt.LeftDockWidgetArea)
        inner = QtWidgets.QWidget()
        v = QtWidgets.QVBoxLayout(inner)
        self.inner_text = QtWidgets.QPlainTextEdit()
        self.inner_text.setReadOnly(True)
        v.addWidget(self.inner_text, 1)
        h = QtWidgets.QHBoxLayout()
        h.addWidget(QtWidgets.QLabel("Interval (s):"))
        self.spin_interval = QtWidgets.QSpinBox()
        self.spin_interval.setRange(1, 60)
        self.spin_interval.setValue(15)
        h.addWidget(self.spin_interval)
        self.chk_monologue_tts = QtWidgets.QCheckBox("Speak")
        self.chk_monologue_tts.setChecked(self.core.settings.monologue_tts_enabled)
        h.addWidget(self.chk_monologue_tts)
        h.addWidget(QtWidgets.QLabel("Volume:"))
        self.slider_monologue_vol = QtWidgets.QSlider(QtCore.Qt.Horizontal)
        self.slider_monologue_vol.setRange(0, 100)
        self.slider_monologue_vol.setValue(self.core.settings.monologue_volume)
        h.addWidget(self.slider_monologue_vol)
        btn_start_stop = QtWidgets.QPushButton("Start/Stop")
        h.addWidget(btn_start_stop)
        v.addLayout(h)
        inner.setLayout(v)
        dock.setWidget(inner)
        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, dock)
        self.inner_dock = dock
        self.inner_timer = QtCore.QTimer(self)
        self.inner_timer.setSingleShot(False)
        btn_start_stop.clicked.connect(self._toggle_inner_timer)
        dock.setTitleBarWidget(DockTitleBar(dock, "Inner Monologue"))
        self.dock_tray.register_dock(self.inner_dock)
        self.chk_monologue_tts.stateChanged.connect(lambda _: self._update_monologue_settings())
        self.slider_monologue_vol.valueChanged.connect(lambda _: self._update_monologue_settings())

    def _toggle_inner_timer(self) -> None:
        if self.inner_timer is None:
            return
        if self.inner_timer.isActive():
            self.inner_timer.stop()
        else:
            interval_ms = self.spin_interval.value() * 1000
            try:
                self.inner_timer.timeout.disconnect()
            except Exception:
                pass
            self.inner_timer.timeout.connect(self._generate_inner_monologue)
            self.inner_timer.start(interval_ms)

    def _update_monologue_settings(self) -> None:
        try:
            self.core.settings.monologue_tts_enabled = self.chk_monologue_tts.isChecked() if hasattr(self, 'chk_monologue_tts') else False
            self.core.settings.monologue_volume = self.slider_monologue_vol.value() if hasattr(self, 'slider_monologue_vol') else 50
            self.core.settings.save()
        except Exception:
            pass

    def _generate_inner_monologue(self) -> None:
        schema = self.core.schema_mgr.load_schema(self._current_persona(), self.current_set.get(self._current_persona(), "default"))
        overlay = schema.get("dynamic_overlay", {}) or {}
        mood = overlay.get("temporary_emotional_state", "neutral")
        likes = overlay.get("recent_topics", [])
        pos = [0, 0]
        fav_topic = likes[-1] if likes else None
        thought = f"I'm thinking about {fav_topic} while feeling {mood}." if fav_topic else f"I'm in a {mood} mood and reflecting."
        thought += f" I'm at position {pos}."
        try:
            if hasattr(self, "inner_text") and self.inner_text is not None:
                self.inner_text.appendPlainText(thought)
        except Exception:
            pass

    # ────────────────────────── conversation
    def _append_message(self, display_name: str, text: str, role_key: Optional[str] = None) -> None:
        key = (role_key or display_name).lower()
        bg_colour = ROLE_COLOURS.get(key, "#EEEEEE")
        name_colour = NAME_COLOURS.get(key, "#011627")
        safe_role = QtGui.QGuiApplication.translate("Chat", display_name)
        safe_text = QtGui.QGuiApplication.translate("Chat", text)
        frag = (
            f'<div style="background-color:{bg_colour}; border-radius:4px; padding:4px; margin:4px;">'
            f'<b style="color:{name_colour};">{safe_role}:</b> {safe_text}'
            f'</div>'
        )
        self.chat_view.append(frag)

    def _current_history(self) -> List[Tuple[str, str]]:
        if self.chk_isolated.isChecked():
            return self.isolated_history
        else:
            return self.core.conversation_db.fetch_history(limit=10)

    def _bootstrap_conversation(self) -> None:
        if self.core and len(self.core.conversation_db.fetch_history(limit=1)) == 0:
            schema = self.core.schema_mgr.load_schema(self.active_persona, self.current_set.get(self.active_persona, "default"))
            questions = schema.get("questions", [])
            if questions:
                first_question = questions[0]
                self._append_message("System", first_question, role_key="system")
                if self.chk_semantic.isChecked() and not self.chk_isolated.isChecked():
                    self.core.conversation_db.save_message("system", first_question)

    # ────────────────────────── prompt & rag
    def _build_prompt(self, schema: Dict[str, object], user_text: str, is_self_talk: bool = False) -> str:
        parts: List[str] = []
        name = schema.get("name", "")
        role = schema.get("role", "")
        desc = schema.get("description", "")
        persona_desc = f"You are {name}, {desc}".strip()
        if role:
            persona_desc += f" Your role is {role}."

        overlay = schema.get("dynamic_overlay", {})
        if overlay:
            temp_rel = overlay.get("temporary_relationship_context", "")
            temp_emotion = overlay.get("temporary_emotional_state", "")
            added_traits = overlay.get("added_traits", [])
            if temp_rel:
                persona_desc += f" ({temp_rel})"
            if temp_emotion:
                persona_desc += f" You feel {temp_emotion}."
            if added_traits:
                persona_desc += f" Traits: {', '.join(str(t) for t in added_traits)}."
        parts.append(persona_desc)

        # User description
        try:
            user_schema = self.core.schema_mgr.load_schema("user", self.current_set.get("user", "default"))
        except Exception:
            user_schema = {}
        if user_schema:
            u_name = user_schema.get("name", "User")
            u_personality = user_schema.get("personality", "")
            relationship = user_schema.get("relationship_to_zira", "friend")
            u_overlay = user_schema.get("dynamic_overlay", {})
            temp_rel2 = u_overlay.get("temporary_relationship_context") if u_overlay else None
            if temp_rel2 and str(temp_rel2).strip():
                relationship = str(temp_rel2)
            user_desc = f"User is {u_name}, {u_personality}. Relationship: {relationship}."
            parts.append(user_desc)

        # History
        history_text = ""
        if self.chk_semantic.isChecked():
            history = self._current_history()[-10:]
            for role_name, content in history:
                speaker = "User" if role_name.lower() == "user" else role_name.title()
                history_text += f"{speaker}: {content}\n"
        if history_text:
            parts.append("Conversation history:\n" + history_text.strip())

        # RAG (only datasets listed by this set)
        dataset_text = ""
        ds_names: List[str] = list(schema.get("datasets") or [])
        try:
            # Prefer core search with filters if supported
            hits = self.core.rag_search(
                user_text,
                per_ds_k=3,
                limit=5,
                include_shared=False,
                datasets=ds_names if ds_names else None,
            )
            for chunk, score, ds_name, owner in hits:
                dataset_text += f"Dataset ({owner}/{ds_name}):\n{chunk}\n\n"
        except TypeError:
            # Older core: no dataset filter; fallback to manual selection
            from_texts: List[Tuple[str, str]] = []
            try:
                for name, entry in self.core.dataset_mgr.entries.items():
                    if ds_names and name not in ds_names:
                        continue
                    if not entry.active:
                        continue
                    full_text = self.core.dataset_mgr.load_dataset_text(entry)
                    if full_text:
                        from_texts.append((name, full_text))
            except Exception:
                pass
            for name, full_text in from_texts:
                snip = self._retrieve_dataset_snippet(full_text, user_text)
                if snip:
                    dataset_text += f"Dataset ({name}):\n{snip}\n\n"
        except Exception:
            pass
        if dataset_text:
            parts.append(dataset_text.strip())

        # Self-talk (optional)
        if is_self_talk and self.self_talk_enabled:
            st_prompts = schema.get("self_talk", [])
            if st_prompts:
                import random
                parts.append(random.choice(st_prompts))

        parts.append(f"User: {user_text}")
        return "\n\n".join([p for p in parts if p])

    def _retrieve_dataset_snippet(self, full_text: str, user_text: str) -> str:
        try:
            tokens = [w.lower() for w in re.findall(r"\b\w+\b", user_text) if len(w) > 2]
            paragraphs = [p.strip() for p in full_text.split("\n") if p.strip()]
            scored: List[Tuple[int, str]] = []
            for para in paragraphs:
                l = para.lower()
                score = sum(1 for t in tokens if t in l)
                if score > 0:
                    scored.append((score, para))
            if not scored:
                return paragraphs[0][:500] if paragraphs else full_text[:500]
            scored.sort(key=lambda x: -x[0])
            top = [p for _, p in scored[:2]]
            return "\n".join(top)[:500]
        except Exception:
            return full_text[:500]

    # ────────────────────────── send / model
    def send_message(self) -> None:
        user_text = self.input_edit.toPlainText().strip()
        if not user_text:
            return

        # Broadcast to plugins
        try:
            self.core.plugins.broadcast(user_text)
        except Exception:
            pass

        # Slash commands → ensure applied to current persona+set
        if user_text.startswith("/"):
            self.input_edit.clear()
            persona = self._current_persona()
            set_name = self.current_set.get(persona, "default")
            try:
                out = self.core.run_command(user_text, persona=persona, set_name=set_name)
            except TypeError:
                # Back-compat signature
                out = self.core.run_command(user_text)
            self._append_message("System", out, role_key="system")
            if self.chk_semantic.isChecked() and not self.chk_isolated.isChecked():
                self.core.conversation_db.save_message("system", out)
            return

        # Normal message
        self.input_edit.clear()
        persona = self._current_persona()
        set_name = self.current_set.get(persona, "default")
        schema = self.core.schema_mgr.load_schema(persona, set_name)

        if self.chk_isolated.isChecked():
            self.isolated_history.append(("user", user_text))
        else:
            if self.chk_semantic.isChecked():
                self.core.conversation_db.save_message("user", user_text)

        try:
            user_schema = self.core.schema_mgr.load_schema("user", self.current_set.get("user", "default"))
            user_display = user_schema.get("name", "User")
        except Exception:
            user_display = "User"
        self._append_message(user_display, user_text, role_key="user")

        prompt = self._build_prompt(schema, user_text)

        self.btn_send.setEnabled(False)
        model_slug = self.model_combo.currentText().strip() or self.core.settings.default_model
        worker = ModelWorker(model_slug, prompt, parent=self.core)
        worker.finished.connect(lambda resp, usr=user_text, sch=schema: self._on_model_response(resp, usr, sch))
        worker.finished.connect(lambda: self.btn_send.setEnabled(True))
        worker.start()

    def _on_model_response(self, response_raw: str, user_text: str, schema: Dict[str, object]) -> None:
        model_slug = self.model_combo.currentText().strip()
        response = self._strip_reasoning(model_slug, response_raw)
        response, style_score = self._style_and_guard(response, schema)
        self.style_label.setText(f"Style: {style_score:.2f}")

        if self.chk_isolated.isChecked():
            self.isolated_history.append((schema.get("name", "bot"), response))
        else:
            if self.chk_semantic.isChecked():
                self.core.conversation_db.save_message(schema.get("name", "bot").lower(), response)

        persona_name = schema.get("name", "Bot") or "Bot"
        role_key = self._current_persona().lower()
        self._append_message(persona_name, response, role_key=role_key)
        self.response_edit.setPlainText(response)

        if not self.chk_mute_tts.isChecked():
            try:
                self.core.tts_mgr.enqueue(response)
            except Exception:
                pass

        self._enable_feedback(True)
        self._reset_idle_timer()

        try:
            tokens = [w.lower() for w in re.findall(r"\b\w+\b", user_text) if len(w) > 3]
            for t in tokens:
                self.update_overlay_topic(self._current_persona(), t)
            self.update_overlay_emotion(self._current_persona(), "neutral")
        except Exception:
            pass

        try:
            for line in response.split("\n"):
                if line.strip():
                    self.core.plugins.broadcast(line.strip())
        except Exception as e:
            print(f"Error broadcasting to plugins: {e}")

        if self.core.settings.auto_schema_enabled:
            self.progress_bar.setVisible(True)


            class EvolverWorker(QRunnable):
                def __init__(self, evolver, persona, set_name, history, window):
                    super().__init__()
                    self.evolver = evolver
                    self.persona = persona
                    self.set_name = set_name
                    self.history = history
                    self.window = window

                def run(self):
                    changed = self.evolver.update_schema(self.persona, self.set_name, self.history)
                    QtCore.QMetaObject.invokeMethod(
                        self.window, "_post_evolver", QtCore.Qt.QueuedConnection, QtCore.Q_ARG(bool, changed)
                    )

            QThreadPool.globalInstance().start(
                EvolverWorker(self.core.schema_evolver, self.active_persona, self.current_set.get(self.active_persona, "default"), self._current_history(), self)
            )

    @QtCore.pyqtSlot(bool)
    def _post_evolver(self, changed: bool) -> None:
        self.progress_bar.setVisible(False)
        if changed:
            self._flash_status("Schema adapted")

    def _strip_reasoning(self, model: str, response: str) -> str:
        if model and "deepseek" in model.lower():
            if "<think>" in response and "</think>" in response:
                try:
                    return response.split("</think>")[-1].strip() or response
                except Exception:
                    return response
        return response

    def _style_and_guard(self, text: str, schema: Dict[str, object]) -> Tuple[str, float]:
        exclam = text.count("!")
        sentences = [s for s in re.split(r"[.!?]", text) if s.strip()]
        avg_len = sum(len(s.split()) for s in sentences) / max(1, len(sentences))
        exclam_density = exclam / max(1, len(text))
        tone = schema.get("tone_rules", {"conciseness": [0.6, 0.8], "exclam_limit": 0.05})
        conciseness = max(0.0, min(1.0, (22 - avg_len) / 16.0))
        ex_ok = 1.0 if exclam_density <= float(tone.get("exclam_limit", 0.05)) else 0.5
        score = max(0.0, min(1.0, 0.5 * conciseness + 0.5 * ex_ok))
        return text, score

    def _rewrite_response(self, original: str) -> str:
        try:
            liked = self.core.feedback_db.get_liked_responses(limit=5)
        except Exception:
            liked = []
        schema = self.core.schema_mgr.load_schema(self._current_persona(), self.current_set.get(self._current_persona(), "default"))
        rps = schema.get("rewrite_prompts", [])
        template = rps[0] if rps else "Rewrite to be more appealing. Keep it accurate, concise, and on style."
        parts = [template]
        if liked:
            parts.append("Preferred responses:\n" + "\n\n".join(liked))
        parts.append("Original:\n" + original)
        parts.append("Rewritten:")
        prompt = "\n\n".join(parts)
        return self._run_model(self.model_combo.currentText().strip() or self.core.settings.default_model, prompt) or original

    def _run_model(self, model: str, prompt: str) -> str:
        try:
            proc = subprocess.run(
                ["ollama", "run", model],
                input=prompt.encode("utf-8"),
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                check=True,
            )
            return proc.stdout.decode("utf-8", errors="replace").strip()
        except subprocess.CalledProcessError as e:
            return e.stderr.decode("utf-8", errors="replace").strip()
        except FileNotFoundError:
            return "(error) ollama executable not found."
        except Exception as e:
            return f"(error) {e}"

    # ────────────────────────── persona / sets
    def _populate_set_combo(self, persona: str, combo: QtWidgets.QComboBox) -> None:
        combo.blockSignals(True)
        combo.clear()
        for s in self.core.schema_mgr.get_set_list(persona):
            combo.addItem(s)
        current = self.current_set.get(persona, "default")
        idx = combo.findText(current)
        combo.setCurrentIndex(idx if idx >= 0 else combo.findText("default"))
        if idx < 0:
            self.current_set[persona] = combo.currentText()
        combo.blockSignals(False)

    def _on_set_changed(self, persona: str, name: str, combo: QtWidgets.QComboBox) -> None:
        if not name:
            return
        self.current_set[persona] = name
        # keep AgentCore pointed to the right set if this persona is active
        if persona == self._current_persona():
            self.core.persona = persona
            self.core.set_name = name

        # refresh editor + commands row for this tab
        tab = self.tab_widgets.get(persona)
        if tab:
            editor = tab.findChild(QtWidgets.QPlainTextEdit, f"schema_edit_{persona}")
            if editor:
                schema = self.core.schema_mgr.load_schema(persona, name)
                editor.setPlainText(json.dumps(schema, indent=2))
            cmd_combo = tab.findChild(QtWidgets.QComboBox, f"cmd_combo_{persona}")
            if cmd_combo:
                self._populate_command_combo(persona, cmd_combo)

        # persist active sets & update controls tied to schema flags
        self.core.schema_mgr.save_active_schemas(self.current_set)
        self._sync_semantic_checkbox_from_schema()
        self._update_feedback_counts()

        # refresh slash command list if this persona is active
        try:
            if persona == self._current_persona():
                self._populate_command_select()
        except Exception:
            pass

    def _on_clone_set(self, persona: str, combo: QtWidgets.QComboBox) -> None:
        src = combo.currentText()
        name, ok = QtWidgets.QInputDialog.getText(self, "Clone Set", "Enter new set name:")
        if not ok or not name.strip():
            return
        new_name = name.strip()
        try:
            schema = self.core.schema_mgr.load_schema(persona, src)
            # Preserve the persona's canonical name; set label is separate
            schema["name"] = persona.capitalize()
            self.core.schema_mgr.save_schema(persona, new_name, schema)
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "Error", str(e))
            return
        self.current_set[persona] = new_name
        self._populate_set_combo(persona, combo)
        combo.setCurrentText(new_name)
        if persona == self._current_persona():
            self.core.set_name = new_name
        self.core.schema_mgr.save_active_schemas(self.current_set)
        self._sync_semantic_checkbox_from_schema()
        self._update_feedback_counts()

    def _on_new_set(self, persona: str, combo: QtWidgets.QComboBox) -> None:
        src = combo.currentText()
        name, ok = QtWidgets.QInputDialog.getText(self, "New Set", "Enter name for new set:")
        if not ok or not name.strip():
            return
        new_name = name.strip()
        try:
            schema = self.core.schema_mgr.load_schema(persona, src)
            # Preserve the persona's canonical name; set label is separate
            schema["name"] = persona.capitalize()
            self.core.schema_mgr.save_schema(persona, new_name, schema)
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "Error", str(e))
            return
        self.current_set[persona] = new_name
        self._populate_set_combo(persona, combo)
        combo.setCurrentText(new_name)
        if persona == self._current_persona():
            self.core.set_name = new_name
        self.core.schema_mgr.save_active_schemas(self.current_set)
        self._sync_semantic_checkbox_from_schema()
        self._update_feedback_counts()

    def _on_delete_set(self, persona: str, combo: QtWidgets.QComboBox) -> None:
        name = combo.currentText()
        if name == "default":
            QtWidgets.QMessageBox.information(self, "Cannot Delete", "The default set cannot be deleted.")
            return
        if QtWidgets.QMessageBox.question(
            self, "Delete Set", f"Delete '{name}' (irreversible)?", QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No
        ) != QtWidgets.QMessageBox.Yes:
            return
        try:
            set_dir = os.path.join(self.core.schema_mgr.schemas_dir, persona.lower(), "sets", name)
            import shutil
            shutil.rmtree(set_dir, ignore_errors=True)
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "Error", str(e))
            return
        self.current_set[persona] = "default"
        self._populate_set_combo(persona, combo)
        combo.setCurrentText("default")
        if persona == self._current_persona():
            self.core.set_name = "default"
        self.core.schema_mgr.save_active_schemas(self.current_set)
        self._sync_semantic_checkbox_from_schema()
        self._update_feedback_counts()

    def _on_save_schema(self, persona: str) -> None:
        tab = self.tab_widgets.get(persona)
        if not tab:
            return
        editor = tab.findChild(QtWidgets.QPlainTextEdit, f"schema_edit_{persona}")
        if not editor:
            return
        text = editor.toPlainText().strip()
        try:
            schema = json.loads(text)
            if not isinstance(schema, dict):
                raise ValueError
        except Exception:
            QtWidgets.QMessageBox.warning(self, "Invalid JSON", "The schema is not valid JSON.")
            return
        set_name = self.current_set.get(persona, "default")
        existing_schema = self.core.schema_mgr.load_schema(persona, set_name)
        merged_schema = {**existing_schema, **schema}
        # Ensure the top-level name matches the active set name
        try:
            merged_schema["name"] = set_name
        except Exception:
            pass
        self.core.schema_mgr.save_schema(persona, set_name, merged_schema)
        QtWidgets.QMessageBox.information(self, "Saved", f"Schema saved for {persona} ({set_name}).")

        if persona == self._current_persona():
            persona_voice = (merged_schema.get("voice") or "").lower()
            for i in range(self.voice_combo.count()):
                if persona_voice and persona_voice in self.voice_combo.itemText(i).lower():
                    self.voice_combo.setCurrentIndex(i)
                    break
        # After save, refresh commands combo (in case user edited commands JSON directly)
        tab = self.tab_widgets.get(persona)
        if tab:
            cmd_combo = tab.findChild(QtWidgets.QComboBox, f"cmd_combo_{persona}")
            if cmd_combo:
                self._populate_command_combo(persona, cmd_combo)

    def _tab_changed(self, index: int) -> None:
        if 0 <= index < len(self.core.schema_mgr.personas):
            self.active_persona = self.core.schema_mgr.personas[index]
        else:
            self.active_persona = self.core.schema_mgr.personas[0] if self.core.schema_mgr.personas else "zira"
        self.core.persona = self.active_persona

        schema = self.core.schema_mgr.load_schema(self.active_persona, self.current_set.get(self.active_persona, "default"))
        persona_voice = (schema.get("voice") or "").lower()
        for i in range(self.voice_combo.count()):
            if persona_voice and persona_voice in self.voice_combo.itemText(i).lower():
                self.voice_combo.setCurrentIndex(i)
                break

        tab = self.tab_widgets.get(self.active_persona)
        if tab:
            editor = tab.findChild(QtWidgets.QPlainTextEdit, f"schema_edit_{self.active_persona}")
            if editor:
                editor.setPlainText(json.dumps(schema, indent=2))
            cmd_combo = tab.findChild(QtWidgets.QComboBox, f"cmd_combo_{self.active_persona}")
            if cmd_combo:
                self._populate_command_combo(self.active_persona, cmd_combo)

        try:
            user_schema = self.core.schema_mgr.load_schema("user", self.current_set.get("user", "default"))
            bot_name = schema.get("name", self.active_persona.title())
            bot_set = self.current_set.get(self.active_persona, "default")
            user_name = user_schema.get("name", "User")
            user_set = self.current_set.get("user", "default")
            self.lbl_active_names.setText(f"{bot_name}: {bot_set} — User: {user_name}: {user_set}")
        except Exception:
            pass

        self._sync_semantic_checkbox_from_schema()
        self._update_feedback_counts()

        # refresh slash command dropdown on persona change
        try:
            self._populate_command_select()
        except Exception:
            pass

    def _current_persona(self) -> str:
        return self.active_persona

    # ────────────────────────── overlay helpers
    def update_overlay_topic(self, persona: str, topic: str) -> None:
        persona = persona.lower()
        try:
            schema = self.core.schema_mgr.load_schema(persona, self.current_set.get(persona, "default"))
            overlay = dict(schema.get("dynamic_overlay", {}))
            topics = list(overlay.get("recent_topics", []))
            if topic and topic not in topics:
                topics.append(topic)
                if len(topics) > 10:
                    topics = topics[-10:]
                overlay["recent_topics"] = topics
                schema["dynamic_overlay"] = overlay
                self.core.schema_mgr.save_schema(persona, self.current_set.get(persona, "default"), schema)
        except Exception:
            pass

    def update_overlay_emotion(self, persona: str, emotion: str) -> None:
        persona = persona.lower()
        try:
            schema = self.core.schema_mgr.load_schema(persona, self.current_set.get(persona, "default"))
            overlay = dict(schema.get("dynamic_overlay", {}))
            overlay["temporary_emotional_state"] = emotion
            schema["dynamic_overlay"] = overlay
            self.core.schema_mgr.save_schema(persona, self.current_set.get(persona, "default"), schema)
        except Exception:
            pass

    # ────────────────────────── devices & models
    def _populate_devices(self) -> None:
        self.device_combo.clear()
        try:
            if sd is not None:
                devs = [d.get("name", "?") for d in sd.query_devices() if d.get("max_input_channels", 0) > 0]
                if devs:
                    self.device_combo.addItems(devs)
        except Exception:
            pass
        if self.device_combo.count() == 0:
            self.device_combo.addItem("Default")

    def _populate_models(self) -> None:
        models: List[str] = []
        try:
            out = subprocess.run(
                ["ollama", "list"],
                stdout=subprocess.PIPE,
                stderr=subprocess.DEVNULL,
                text=True,
                check=True,
            ).stdout.splitlines()
            for line in out[1:]:
                parts = line.strip().split()
                if parts:
                    models.append(parts[0])
        except Exception:
            pass
        if not models:
            models = [self.core.settings.default_model or "mistral:latest"]
        self.model_combo.clear()
        self.model_combo.addItems(models)
        idx = self.model_combo.findText(self.core.settings.default_model)
        if idx >= 0:
            self.model_combo.setCurrentIndex(idx)

    # ────────────────────────── slash commands panel
    def _build_command_dock(self) -> None:
        """
        Build a dockable panel that exposes slash commands with an argument
        entry and send button. This allows users to trigger any command
        without typing it into the chat manually. It will be updated when
        persona or set changes.
        """
        dock = QtWidgets.QDockWidget("Slash Commands", self)
        dock.setObjectName("SlashCommandsDock")
        dock.setFeatures(
            QtWidgets.QDockWidget.DockWidgetClosable
            | QtWidgets.QDockWidget.DockWidgetMovable
            | QtWidgets.QDockWidget.DockWidgetFloatable
        )
        container = QtWidgets.QWidget()
        layout = QtWidgets.QVBoxLayout(container)
        layout.setContentsMargins(7, 7, 7, 7)
        layout.setSpacing(5)

        # command selector
        cmd_label = QtWidgets.QLabel("Slash Command:")
        self.command_select = QtWidgets.QComboBox()
        layout.addWidget(cmd_label)
        layout.addWidget(self.command_select)

        # argument input
        self.command_input = QtWidgets.QLineEdit()
        self.command_input.setPlaceholderText("Enter arguments or select text from chat…")
        layout.addWidget(self.command_input)

        # send button
        btn_run = QtWidgets.QPushButton("Run Command")
        btn_run.clicked.connect(self._on_run_command)
        layout.addWidget(btn_run)
        layout.addStretch(1)

        dock.setWidget(container)
        # add to right side by default
        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, dock)
        self.command_dock = dock

    def _populate_command_select(self) -> None:
        """
        Populate the slash command dropdown with available commands from
        the command registry. This is called whenever the active persona
        or set changes to reflect dynamic additions.
        """
        try:
            cmds = []
            if hasattr(self.core, "command_registry") and self.core.command_registry:
                cmds = list(self.core.command_registry.list_commands())
            # if schema defines additional commands, include them
            persona = self._current_persona()
            set_name = self.current_set.get(persona, "default")
            schema = self.core.schema_mgr.load_schema(persona, set_name)
            schema_cmds = list((schema.get("commands") or {}).keys())
            for c in schema_cmds:
                if c not in cmds:
                    cmds.append(c)
            cmds.sort()
        except Exception:
            cmds = []
        self.command_select.blockSignals(True)
        self.command_select.clear()
        if cmds:
            self.command_select.addItems(cmds)
        self.command_select.blockSignals(False)

    def _on_run_command(self) -> None:
        """
        Handler for running the selected slash command with the provided
        argument. The command will be executed via AgentCore and the
        result appended to the chat window. Selection text from the chat
        can be inserted into the argument field via context menu.
        """
        cmd = (self.command_select.currentText() or "").strip()
        if not cmd:
            QtWidgets.QMessageBox.information(self, "No Command", "Select a slash command to run.")
            return
        arg = self.command_input.text().strip()
        # combine command and arguments
        full = cmd if not arg else f"{cmd} {arg}"
        try:
            # process via core; record conversation
            resp = self.core.process_user_message(full, tts=False)
            # append user command and agent response to chat
            self._append_message("user", full, role_key="user")
            self._append_message("zira", resp, role_key="zira")
            # clear argument
            self.command_input.clear()
            # update feedback counts and idle timer
            self._update_feedback_counts()
            self._reset_idle_timer()
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "Command Error", str(e))

    def _show_chat_context_menu(self, pos: QtCore.QPoint) -> None:
        """
        Custom context menu for the chat view. Adds a menu entry to send
        selected text into the slash command argument field.
        """
        menu = self.chat_view.createStandardContextMenu()
        try:
            cursor = self.chat_view.textCursor()
            if cursor and cursor.hasSelection():
                action = menu.addAction("Send selection to command input")
                action.triggered.connect(self._send_selection_to_command_input)
        except Exception:
            pass
        menu.exec_(self.chat_view.mapToGlobal(pos))

    def _send_selection_to_command_input(self) -> None:
        """
        Copy the currently selected text in the chat view into the command
        input field for slash command execution.
        """
        try:
            cursor = self.chat_view.textCursor()
            if cursor and cursor.hasSelection():
                text = cursor.selectedText()
                self.command_input.setText(text.strip())
        except Exception:
            pass

    def _on_model_changed(self, name: str) -> None:
        """
        Update the default model in settings when the user selects a new
        model from the dropdown. This ensures the AgentCore uses the
        selected model for subsequent interactions.
        """
        try:
            if not name:
                return
            self.core.settings.default_model = name
            self.core.settings.save()
        except Exception:
            pass

    def _on_show_model_manager(self) -> None:
        """
        Show (or raise) the model manager dock. If the dock was
        previously hidden, it will be shown; if it is already visible,
        this will bring it to the front. A dock must be built in
        `_build_model_manager()` prior to showing.
        """
        try:
            if self.model_dock.isVisible():
                # already visible: raise to top
                self.model_dock.raise_()
            else:
                self.model_dock.show()
                self.model_dock.raise_()
        except Exception:
            pass

    # ────────────────────────── settings toggles
    def _on_auto_schema_toggled(self, checked: bool) -> None:
        try:
            self.core.settings.auto_schema_enabled = bool(checked)
            self.core.settings.save()
        except Exception:
            pass
        self.statusBar().showMessage(f"Auto Schema Evolution {'enabled' if checked else 'disabled'}", 2500)

    def _on_google_stt_toggled(self, checked: bool) -> None:
        """
        Opt-in/out of using Google Cloud Speech-to-Text. When enabling the
        toggle for the first time in a session, show a warning that
        recordings will be sent to Google’s servers under their privacy
        policy. If declined, the checkbox will be turned off again.
        """
        # Only show the dialog when transitioning from unchecked → checked
        try:
            current = bool(getattr(self.core.settings, "use_google_stt", False))
        except Exception:
            current = False
        if checked and not current:
            ok = QtWidgets.QMessageBox.question(
                self,
                "Enable Google STT?",
                "Audio will be uploaded to Google Cloud for transcription\n"
                "under Google's privacy policy. Continue?",
                QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No,
            )
            if ok != QtWidgets.QMessageBox.Yes:
                # revert checkbox silently
                self.chk_google_stt.blockSignals(True)
                self.chk_google_stt.setChecked(False)
                self.chk_google_stt.blockSignals(False)
                return
        # persist the new state
        try:
            self.core.settings.use_google_stt = bool(checked)
            self.core.settings.save()
        except Exception:
            pass

    # ────────────────────────── spell suggestions
    def _show_input_context_menu(self, pos: QtCore.QPoint) -> None:
        """
        Custom context menu on the input field that offers spelling
        suggestions when the user right-clicks a misspelled word. Only
        appears if pyspellchecker is available.
        """
        menu = self.input_edit.createStandardContextMenu()
        # compute suggestions only if SpellChecker is available
        if SpellChecker:
            cursor = self.input_edit.cursorForPosition(pos)
            # select the word under cursor
            cursor.select(QtGui.QTextCursor.WordUnderCursor)
            word = cursor.selectedText()
            if word and len(word) >= 3:
                sc = SpellChecker()
                suggestions = list(sc.candidates(word.lower()))
                # sort by Levenshtein distance and frequency; keep top 5
                suggestions = sorted(suggestions, key=lambda w: sc.word_probability(w), reverse=True)[:5]
                if suggestions and suggestions != [word.lower()]:
                    suggest_menu = menu.addMenu("Spelling suggestions")
                    for s in suggestions:
                        act = suggest_menu.addAction(s)
                        act.triggered.connect(lambda chk=False, repl=s, c=cursor: self._replace_word(c, repl))
        menu.exec_(self.input_edit.mapToGlobal(pos))

    def _replace_word(self, cursor: QtGui.QTextCursor, replacement: str) -> None:
        """
        Replace the word at the given cursor with a suggestion. This
        method is connected dynamically for each suggestion action.
        """
        try:
            cursor.beginEditBlock()
            cursor.removeSelectedText()
            cursor.insertText(replacement)
            cursor.endEditBlock()
        except Exception:
            pass

    def _on_semantic_toggled(self, checked: bool) -> None:
        """Persist semantic awareness per persona+set."""
        persona = self._current_persona()
        set_name = self.current_set.get(persona, "default")
        try:
            schema = self.core.schema_mgr.load_schema(persona, set_name)
            flags = dict(schema.get("flags") or {})
            flags["semantic_awareness"] = bool(checked)
            schema["flags"] = flags
            self.core.schema_mgr.save_schema(persona, set_name, schema)
        except Exception:
            pass
        self._reset_idle_timer()

    def _sync_semantic_checkbox_from_schema(self) -> None:
        """Load semantic_awareness from current schema into the checkbox."""
        persona = self._current_persona()
        set_name = self.current_set.get(persona, "default")
        try:
            schema = self.core.schema_mgr.load_schema(persona, set_name)
            flags = schema.get("flags", {})
            val = bool(flags.get("semantic_awareness", True))
        except Exception:
            val = True
        self.chk_semantic.blockSignals(True)
        self.chk_semantic.setChecked(val)
        self.chk_semantic.blockSignals(False)

    # ────────────────────────── status helper
    def _flash_status(self, msg: str) -> None:
        self.statusBar().showMessage(msg, 3000)


# ────────────────────────── Dock tray & titlebar
class DockTray(QtWidgets.QWidget):
    restoreRequested = QtCore.pyqtSignal(QtWidgets.QDockWidget)

    def __init__(self, parent: Optional[QtWidgets.QWidget] = None) -> None:
        super().__init__(parent)
        self._map: Dict[QtWidgets.QDockWidget, QtWidgets.QPushButton] = {}
        lay = QtWidgets.QHBoxLayout(self)
        lay.setContentsMargins(6, 4, 6, 4)
        lay.setSpacing(6)
        self._layout = lay
        self._title = QtWidgets.QLabel("Minimized panels:")
        self._title.setStyleSheet("color: #f0f0f0; font-weight: bold;")
        self._layout.addWidget(self._title, 0)
        self._layout.addStretch(1)
        self.setStyleSheet("background-color: #3c4a6b;")

    def register_dock(self, dock: QtWidgets.QDockWidget) -> None:
        dock.visibilityChanged.connect(lambda vis, d=dock: self._on_visibility_changed(d, vis))
        if not dock.isVisible():
            self._add_button(dock)

    def _on_visibility_changed(self, dock: QtWidgets.QDockWidget, visible: bool) -> None:
        if visible:
            self._remove_button(dock)
        else:
            self._add_button(dock)

    def _add_button(self, dock: QtWidgets.QDockWidget) -> None:
        if dock in self._map:
            return
        btn = QtWidgets.QPushButton(dock.windowTitle())
        btn.setToolTip(f"Restore {dock.windowTitle()}")
        btn.setStyleSheet(
            "background-color: #4a5b78; color: #ffffff; padding: 4px 6px; border: none; border-radius: 3px;"
        )
        btn.clicked.connect(lambda checked=False, d=dock: self._restore(d))
        self._layout.insertWidget(self._layout.count() - 1, btn)
        self._map[dock] = btn

    def _remove_button(self, dock: QtWidgets.QDockWidget) -> None:
        btn = self._map.pop(dock, None)
        if btn:
            self._layout.removeWidget(btn)
            btn.deleteLater()

    def _restore(self, dock: QtWidgets.QDockWidget) -> None:
        dock.show()
        dock.raise_()
        self.restoreRequested.emit(dock)


class DockTitleBar(QtWidgets.QWidget):
    def __init__(self, dock: QtWidgets.QDockWidget, title: str) -> None:
        super().__init__(dock)
        self._dock = dock
        h = QtWidgets.QHBoxLayout(self)
        h.setContentsMargins(6, 2, 6, 2)
        h.setSpacing(6)
        self.lbl = QtWidgets.QLabel(title)
        h.addWidget(self.lbl)
        h.addStretch()
        self.btn_min = QtWidgets.QToolButton()
        self.btn_min.setText("–")
        self.btn_min.setToolTip("Minimize to bottom tray")
        self.btn_min.clicked.connect(lambda checked=False: self._dock.hide())
        h.addWidget(self.btn_min)
        self.btn_max = QtWidgets.QToolButton()
        self.btn_max.setText("□")
        self.btn_max.setToolTip("Enlarge / Restore")
        self.btn_max.clicked.connect(self._on_toggle_maximize)
        h.addWidget(self.btn_max)
        self.btn_close = QtWidgets.QToolButton()
        self.btn_close.setText("×")
        self.btn_close.setToolTip("Close (send to bottom tray)")
        self.btn_close.clicked.connect(lambda checked=False: self._dock.hide())
        h.addWidget(self.btn_close)
        self.installEventFilter(self)

    def eventFilter(self, _obj: QtCore.QObject, evt: QtCore.QEvent) -> bool:
        if evt.type() == QtCore.QEvent.MouseButtonDblClick:
            self._dock.setFloating(not self._dock.isFloating())
            return True
        return False

    def _on_toggle_maximize(self) -> None:
        mw: Optional[QtWidgets.QMainWindow] = self._dock.parentWidget()  # type: ignore
        while mw and not isinstance(mw, QtWidgets.QMainWindow):
            mw = mw.parentWidget()  # type: ignore
        if not isinstance(mw, QtWidgets.QMainWindow):
            self._dock.setFloating(not self._dock.isFloating())
            return
        if not self._dock.isFloating():
            self._dock.setFloating(True)
            mw_geo = mw.geometry()
            w = int(mw_geo.width() * 0.9)
            h = int(mw_geo.height() * 0.85)
            self._dock.resize(w, h)
            center = mw_geo.center()
            self._dock.move(center.x() - w // 2, center.y() - h // 2)
        else:
            self._dock.setFloating(False)


# ────────────────────────── dataset manager dialog
class DatasetManagerDialog(QtWidgets.QDialog):
    def __init__(self, dataset_mgr, parent: Optional[QtWidgets.QWidget] = None) -> None:
        super().__init__(parent)
        self.setWindowTitle("Dataset Manager")
        self.resize(520, 420)
        self.dataset_mgr = dataset_mgr
        v = QtWidgets.QVBoxLayout(self)
        self.list_widget = QtWidgets.QListWidget()
        v.addWidget(self.list_widget, 1)
        h = QtWidgets.QHBoxLayout()
        self.btn_add = QtWidgets.QPushButton("Add Dataset")
        self.btn_del = QtWidgets.QPushButton("Delete Dataset")
        h.addWidget(self.btn_add)
        h.addWidget(self.btn_del)
        h.addStretch()
        v.addLayout(h)
        self._populate()
        self.btn_add.clicked.connect(self._on_add)
        self.btn_del.clicked.connect(self._on_delete)
        self.list_widget.itemChanged.connect(self._on_item)

    def _populate(self) -> None:
        self.list_widget.clear()
        for name, entry in sorted(self.dataset_mgr.entries.items()):
            item = QtWidgets.QListWidgetItem(name)
            item.setFlags(item.flags() | QtCore.Qt.ItemIsUserCheckable)
            item.setCheckState(QtCore.Qt.Checked if entry.active else QtCore.Qt.Unchecked)
            self.list_widget.addItem(item)

    def _on_add(self) -> None:
        name, ok = QtWidgets.QInputDialog.getText(self, "New Dataset", "Enter dataset name:")
        if not ok or not name.strip():
            return
        path, _ = QtWidgets.QFileDialog.getOpenFileName(self, "Select .txt or .pdf", "", "Text/PDF (*.txt *.pdf)")
        if not path:
            return
        try:
            self.dataset_mgr.add_dataset(name.strip(), path)
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "Error", str(e))
            return
        self._populate()

    def _on_delete(self) -> None:
        item = self.list_widget.currentItem()
        if not item:
            return
        name = item.text()
        if QtWidgets.QMessageBox.question(
            self, "Delete Dataset", f"Delete '{name}'?", QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No
        ) != QtWidgets.QMessageBox.Yes:
            return
        try:
            self.dataset_mgr.delete_dataset(name)
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "Error", str(e))
            return
        self._populate()

    def _on_item(self, item: QtWidgets.QListWidgetItem) -> None:
        self.dataset_mgr.toggle_active(item.text(), item.checkState() == QtCore.Qt.Checked)


# ────────────────────────── run as script
if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    win = AppWindow()
    win.show()
    sys.exit(app.exec_())
```

agent_ui.py
============

PyQt5 UI for the AI TTS Agent (integrated with AgentCore).

Fixes & additions:
- Slash commands (/remember etc.) now apply to the currently selected persona+set.
- Per-set "Semantic Awareness" persisted (schema.flags.semantic_awareness).
- RAG only uses datasets listed in the current set's schema ("datasets": [...]).
- Schema tab: new Commands row (dropdown + input + Add to Command + New Command).

To launch: `python run_agent.py`
**Classes:** _SpellHighlighter, AppWindow, DockTray, DockTitleBar, DatasetManagerDialog


## Module `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\_burner_scripts\bean_logic.py`

```python

"""
bean_logic.py
=============

Centralised reinforcement “bean” logic for profile‑scoped counters.

* **increment(profile, subject, delta, base_dir)** – adjust a counter by *delta* (clipped);
* **get_score(profile, subject, base_dir)** – retrieve the *decayed* score on demand;
* **score_band(score)** – map a numeric score to a qualitative colour band.

The module transparently handles persistence (JSON on disk) and exponential
decay so that old feedback gradually loses influence.

Decay model
-----------
Decay is applied lazily on reads using an exponential function:

    score(t) = score₀ · 0.5 ** ((t‑t₀) / HALFLIFE)

HALFLIFE defaults to seven days – after a week of inactivity the stored
score halves.

This design avoids expensive background jobs while ensuring stale feedback
fades out naturally.
"""

from __future__ import annotations

import json
import math
import os
import time
from typing import Dict, Tuple

# --------------------------------------------------------------------------- 
# Tunables
# --------------------------------------------------------------------------- 
HALFLIFE_SECS = 60 * 60 * 24 * 7          # 7 days
CLIP_MIN = -1_000
CLIP_MAX = 1_000
DATA_FILE = "bean_counts.json"

_CacheType = Dict[str, Dict[str, Dict[str, float]]]
_cache: _CacheType = {}                    # in‑memory cache keyed by base_dir

# --------------------------------------------------------------------------- 
# Helpers
# --------------------------------------------------------------------------- 
def _now() -> float:
    return time.time()

def _load(base_dir: str) -> _CacheType:
    """Load counts from disk into the process‑local cache."""
    if base_dir in _cache:
        return _cache[base_dir]
    path = os.path.join(base_dir, DATA_FILE)
    if os.path.isfile(path):
        try:
            with open(path, "r", encoding="utf-8") as f:
                _cache[base_dir] = json.load(f)
        except Exception:
            _cache[base_dir] = {}
    else:
        _cache[base_dir] = {}
    return _cache[base_dir]

def _save(store: _CacheType, base_dir: str) -> None:
    path = os.path.join(base_dir, DATA_FILE)
    os.makedirs(base_dir, exist_ok=True)
    try:
        with open(path, "w", encoding="utf-8") as f:
            json.dump(store, f, indent=2)
    except Exception:
        # non‑fatal; swallow to avoid cascading failures
        pass

# --------------------------------------------------------------------------- 
# Public API
# --------------------------------------------------------------------------- 
def increment(profile: str, subject: str, delta: int, *, base_dir: str = ".") -> None:
    """Adjust *subject* counter for *profile* by *delta* (± int)."""
    store = _load(base_dir)
    prof = store.setdefault(profile, {})
    rec = prof.setdefault(subject, {"count": 0.0, "t": _now()})
    # First apply decay to bring existing value current
    elapsed = _now() - rec["t"]
    if elapsed > 0:
        decay_factor = 0.5 ** (elapsed / HALFLIFE_SECS)
        rec["count"] *= decay_factor
    # Adjust & clip
    rec["count"] = max(CLIP_MIN, min(CLIP_MAX, rec["count"] + float(delta)))
    rec["t"] = _now()
    _save(store, base_dir)

def get_score(profile: str, subject: str, *, base_dir: str = ".") -> float:
    """Return the *decayed* score for (*profile*, *subject*)."""
    store = _load(base_dir)
    score = store.get(profile, {}).get(subject, {}).get("count", 0.0)
    last_t = store.get(profile, {}).get(subject, {}).get("t", _now())
    elapsed = _now() - last_t
    if elapsed <= 0:
        return score
    decay_factor = 0.5 ** (elapsed / HALFLIFE_SECS)
    return score * decay_factor

def score_band(score: float) -> str:
    """Map a score to a colour/descriptor band.

    Returns one of: 'critical', 'bad', 'neutral', 'good', 'excellent'.
    """
    if score <= -250:
        return "critical"
    if score <= -50:
        return "bad"
    if score <= 50:
        return "neutral"
    if score <= 250:
        return "good"
    return "excellent"
```

bean_logic.py
=============

Centralised reinforcement “bean” logic for profile‑scoped counters.

* **increment(profile, subject, delta, base_dir)** – adjust a counter by *delta* (clipped);
* **get_score(profile, subject, base_dir)** – retrieve the *decayed* score on demand;
* **score_band(score)** – map a numeric score to a qualitative colour band.

The module transparently handles persistence (JSON on disk) and exponential
decay so that old feedback gradually loses influence.

Decay model
-----------
Decay is applied lazily on reads using an exponential function:

    score(t) = score₀ · 0.5 ** ((t‑t₀) / HALFLIFE)

HALFLIFE defaults to seven days – after a week of inactivity the stored
score halves.

This design avoids expensive background jobs while ensuring stale feedback
fades out naturally.
**Functions:** _now(), _load(base_dir), _save(store, base_dir), increment(profile, subject, delta), get_score(profile, subject), score_band(score)


## Module `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\_burner_scripts\commands_panel.py`

```python
#!/usr/bin/env python3
"""
commands_panel.py
=================

This module defines the CommandsPanel class which encapsulates all of the
controls shown on the left-hand side of the agent UI.  It exposes all
widgets publicly so that the top-level application window can interact
with them directly (for example, enabling/disabling buttons or reading
checkbox state).  All callbacks for user actions (recording, dataset
management, TTS playback, etc.) are delegated back to the hosting
``AppWindow`` instance via the ``app`` attribute passed to the
constructor.  No core logic lives here – the panel is purely a view layer.
"""

from __future__ import annotations

import subprocess
from typing import List, Optional

from PyQt5 import QtCore, QtGui, QtWidgets

try:
    import sounddevice as sd  # type: ignore
except Exception:
    sd = None  # type: ignore
try:
    import numpy as np  # type: ignore
except Exception:
    np = None  # type: ignore


class CommandsPanel(QtWidgets.QWidget):
    """Left-side control panel for the agent UI.

    This widget contains all of the controls that previously lived in
    ``agent_ui.AppWindow._build_ui``.  It is responsible for building
    the interface elements but delegates all behavioural logic back to
    the hosting ``AppWindow`` via the ``app`` attribute.  The panel
    exposes its child widgets as attributes so that external code can
    reference them directly.
    """

    def __init__(self, app: 'AppWindow', parent: Optional[QtWidgets.QWidget] = None) -> None:
        super().__init__(parent)
        self.app = app
        self.core = app.core

        # Top-level layout for the panel
        cp_layout = QtWidgets.QVBoxLayout(self)
        cp_layout.setContentsMargins(7, 7, 7, 7)
        cp_layout.setSpacing(7)

        # ───── Recording controls
        rec_row = QtWidgets.QHBoxLayout()
        self.btn_record = QtWidgets.QPushButton("Record")
        self.btn_stop_rec = QtWidgets.QPushButton("Stop\nTranscribe")
        self.btn_stop_rec.setEnabled(False)
        for b in (self.btn_record, self.btn_stop_rec):
            b.setMinimumHeight(32)
            b.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        rec_row.addWidget(self.btn_record, 1)
        rec_row.addWidget(self.btn_stop_rec, 1)
        cp_layout.addLayout(rec_row)

        # ───── Microphone device selector
        mic_row = QtWidgets.QHBoxLayout()
        mic_row.addWidget(QtWidgets.QLabel("Mic:"))
        self.device_combo = QtWidgets.QComboBox()
        self._populate_devices()
        self.device_combo.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        mic_row.addWidget(self.device_combo, 1)
        cp_layout.addLayout(mic_row)

        # ───── Toggle checkboxes
        self.chk_semantic = QtWidgets.QCheckBox("Semantic Awareness")
        self.chk_semantic.setChecked(True)
        self.chk_isolated = QtWidgets.QCheckBox("Isolated Chat")
        self.chk_isolated.setChecked(False)
        self.chk_mute_tts = QtWidgets.QCheckBox("Mute TTS")
        self.chk_self_talk = QtWidgets.QCheckBox("Enable Self Talk")
        self.chk_self_talk.setChecked(False)
        self.chk_auto_schema = QtWidgets.QCheckBox("Auto Schema Evolution")
        try:
            self.chk_auto_schema.setChecked(bool(getattr(self.core.settings, "auto_schema_enabled", False)))
        except Exception:
            self.chk_auto_schema.setChecked(False)
        cp_layout.addWidget(self.chk_semantic)
        cp_layout.addWidget(self.chk_isolated)
        cp_layout.addWidget(self.chk_mute_tts)
        cp_layout.addWidget(self.chk_self_talk)
        cp_layout.addWidget(self.chk_auto_schema)

        # Optional Google STT toggle (default off)
        self.chk_google_stt = QtWidgets.QCheckBox("Google STT")
        try:
            self.chk_google_stt.setChecked(bool(getattr(self.core.settings, "use_google_stt", False)))
        except Exception:
            self.chk_google_stt.setChecked(False)
        cp_layout.addWidget(self.chk_google_stt)

        # ───── RAG cache clear
        self.btn_clear_rag = QtWidgets.QPushButton("Clear RAG Cache")
        cp_layout.addWidget(self.btn_clear_rag)

        # ───── Maintenance buttons
        self.btn_refresh = QtWidgets.QPushButton("Refresh Chat")
        self.btn_manage_datasets = QtWidgets.QPushButton("Manage Datasets")
        self.btn_inner_monologue = QtWidgets.QPushButton("Inner Monologue")
        for b in (self.btn_refresh, self.btn_manage_datasets, self.btn_inner_monologue):
            b.setMinimumHeight(32)
            b.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
            cp_layout.addWidget(b)

        # ───── Model manager
        self.btn_model_manager = QtWidgets.QPushButton("Model Manager")
        self.btn_model_manager.setMinimumHeight(32)
        self.btn_model_manager.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        cp_layout.addWidget(self.btn_model_manager)

        # ───── New: Commands palette launcher
        self.btn_commands_palette = QtWidgets.QPushButton("📋 Commands (Ctrl+/)")
        self.btn_commands_palette.setShortcut(QtGui.QKeySequence("Ctrl+/"))
        self.btn_commands_palette.setMinimumHeight(32)
        self.btn_commands_palette.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        cp_layout.addWidget(self.btn_commands_palette)

        # ───── New: Snapshot now
        self.btn_snapshot = QtWidgets.QPushButton("🗂 Snapshot Now")
        self.btn_snapshot.setMinimumHeight(32)
        self.btn_snapshot.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        cp_layout.addWidget(self.btn_snapshot)

        # ───── Style label
        self.style_label = QtWidgets.QLabel("Style: N/A")
        self.style_label.setToolTip("Style score (0–1): rough measure vs. tone rules.")
        cp_layout.addWidget(self.style_label)

        # ───── Response editor
        self.response_edit = QtWidgets.QPlainTextEdit()
        self.response_edit.setReadOnly(True)
        self.response_edit.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        cp_layout.addWidget(self.response_edit, 1)

        # ───── Feedback buttons
        fb = QtWidgets.QHBoxLayout()
        self.btn_like = QtWidgets.QPushButton("✔")
        self.btn_dislike = QtWidgets.QPushButton("✖")
        self.btn_like.setToolTip("Mark as good response")
        self.btn_dislike.setToolTip("Dislike and rewrite response")
        self.btn_like.setStyleSheet("color: #2ecc71; font-weight: bold;")
        self.btn_dislike.setStyleSheet("color: #e74c3c; font-weight: bold;")
        self.btn_like.setEnabled(False)
        self.btn_dislike.setEnabled(False)
        fb.addWidget(self.btn_like)
        fb.addWidget(self.btn_dislike)
        fb.addStretch()
        self.btn_manage_feedback = QtWidgets.QPushButton("Manage Feedback")
        fb.addWidget(self.btn_manage_feedback)
        cp_layout.addLayout(fb)

        # ───── TTS playback
        tts_row = QtWidgets.QHBoxLayout()
        self.btn_play = QtWidgets.QPushButton("Play")
        self.btn_stop_tts = QtWidgets.QPushButton("Stop")
        self.btn_replay = QtWidgets.QPushButton("Replay")
        for b in (self.btn_play, self.btn_stop_tts, self.btn_replay):
            b.setMinimumHeight(32)
            b.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        tts_row.addWidget(self.btn_play)
        tts_row.addWidget(self.btn_stop_tts)
        tts_row.addWidget(self.btn_replay)
        cp_layout.addLayout(tts_row)

        # ───── Voice & Model selectors
        voice_row = QtWidgets.QHBoxLayout()
        voice_row.addWidget(QtWidgets.QLabel("Voice:"))
        self.voice_combo = QtWidgets.QComboBox()
        voices = self._tts_voice_names()
        if voices:
            self.voice_combo.addItems([v for v in voices if "david" not in v.lower()])
        voice_row.addWidget(self.voice_combo, 1)
        cp_layout.addLayout(voice_row)

        model_row = QtWidgets.QHBoxLayout()
        model_row.addWidget(QtWidgets.QLabel("Model:"))
        self.model_combo = QtWidgets.QComboBox()
        self._populate_models()
        model_row.addWidget(self.model_combo, 1)
        cp_layout.addLayout(model_row)

        # ───── Feedback counts
        self.lbl_feedback_counts = QtWidgets.QLabel("Likes: 0 | Dislikes: 0")
        cp_layout.addWidget(self.lbl_feedback_counts)
        cp_layout.addStretch(1)

        # ───── Wire up callbacks to the hosting application ───────────────────

        # Recording controls
        self.btn_record.clicked.connect(self.app.start_recording)
        self.btn_stop_rec.clicked.connect(self.app.stop_recording)

        # Toggles
        self.chk_semantic.toggled.connect(self.app._on_semantic_toggled)
        self.chk_isolated.toggled.connect(self.app._on_isolated_toggled)
        self.chk_self_talk.toggled.connect(lambda v: setattr(self.app, "self_talk_enabled", v))
        self.chk_auto_schema.toggled.connect(self.app._on_auto_schema_toggled)
        try:
            self.chk_google_stt.toggled.connect(self.app._on_google_stt_toggled)
        except Exception:
            pass

        # Maintenance
        self.btn_clear_rag.clicked.connect(self.app._on_clear_rag_cache)
        self.btn_refresh.clicked.connect(self.app._on_refresh_chat)
        self.btn_manage_datasets.clicked.connect(self.app._on_manage_datasets)
        self.btn_inner_monologue.clicked.connect(self.app._on_inner_monologue)
        self.btn_model_manager.clicked.connect(self.app._on_show_model_manager)

        # **New** Commands palette
        self.btn_commands_palette.clicked.connect(self.app._on_show_command_palette)

        # **New** Snapshot now
        self.btn_snapshot.clicked.connect(lambda: (
            self.app.input_edit.setPlainText("/snapshot"),
            self.app.btn_send.click()
        ))

        # Feedback
        self.btn_like.clicked.connect(self.app._on_like)
        self.btn_dislike.clicked.connect(self.app._on_dislike)
        self.btn_manage_feedback.clicked.connect(self.app._on_manage_feedback)

        # TTS playback
        self.btn_play.clicked.connect(self.app._on_play)
        self.btn_stop_tts.clicked.connect(self.app._on_stop_tts)
        self.btn_replay.clicked.connect(self.app._on_replay)

        # Voice/model selection
        self.voice_combo.currentTextChanged.connect(self.app._on_voice_changed)
        self.model_combo.currentTextChanged.connect(self.app._on_model_changed)

    # ────────────────────────── devices & models helpers ──────────────────────────

    def _populate_devices(self) -> None:
        """Populate the microphone device selector with available input devices."""
        self.device_combo.clear()
        try:
            if sd is not None:
                devs = [d.get("name", "?") for d in sd.query_devices() if d.get("max_input_channels", 0) > 0]
                if devs:
                    self.device_combo.addItems(devs)
        except Exception:
            pass
        if self.device_combo.count() == 0:
            self.device_combo.addItem("Default")

    def _populate_models(self) -> None:
        """Populate the model selector with models discovered via ``ollama list``."""
        models: List[str] = []
        try:
            out = subprocess.run(
                ["ollama", "list"],
                stdout=subprocess.PIPE,
                stderr=subprocess.DEVNULL,
                text=True,
                check=True,
            ).stdout.splitlines()
            for line in out[1:]:
                parts = line.strip().split()
                if parts:
                    models.append(parts[0])
        except Exception:
            pass
        if not models:
            models = [self.core.settings.default_model or "mistral:latest"]
        self.model_combo.clear()
        self.model_combo.addItems(models)
        idx = self.model_combo.findText(self.core.settings.default_model)
        if idx >= 0:
            self.model_combo.setCurrentIndex(idx)

    def _tts_voice_names(self) -> List[str]:
        """Return a list of available TTS voice names from the TTS manager."""
        try:
            eng = getattr(self.core.tts_mgr, "_engine", None)
            if not eng:
                return []
            return [v.name for v in eng.getProperty("voices")]
        except Exception:
            return []
```

commands_panel.py
=================

This module defines the CommandsPanel class which encapsulates all of the
controls shown on the left-hand side of the agent UI.  It exposes all
widgets publicly so that the top-level application window can interact
with them directly (for example, enabling/disabling buttons or reading
checkbox state).  All callbacks for user actions (recording, dataset
management, TTS playback, etc.) are delegated back to the hosting
``AppWindow`` instance via the ``app`` attribute passed to the
constructor.  No core logic lives here – the panel is purely a view layer.
**Classes:** CommandsPanel


## Module `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\_burner_scripts\command_palette.py`

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
command_palette.py
==================

Dockable *Command Palette* for the AI TTS Agent UI.

• Live list of every “/slash-command” pulled from the orchestrator.
• Search-box with type-ahead filter.
• Global shortcut **Ctrl + /** opens / focuses the palette from anywhere.
• Double-click (or Return) on a command emits `commandActivated(str)` so the
  main window can insert the text into the chat-input.

Typical integration in *main_ui.py*:

    self.cmd_palette = CommandPaletteDock(self)
    self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.cmd_palette)
    self.core.commandsChanged.connect(self.cmd_palette.set_command_list)
    self.cmd_palette.commandActivated.connect(
        lambda cmd: self._insert_into_chat(cmd)
    )
"""

from __future__ import annotations

from typing import List

from PyQt5 import QtCore, QtGui, QtWidgets


class CommandPaletteDock(QtWidgets.QDockWidget):
    """Search-driven palette that lists all registered slash-commands."""

    # Emitted when user activates a command (double-click or Return)
    commandActivated = QtCore.pyqtSignal(str)

    # --------------------------------------------------------------------- init
    def __init__(
        self,
        main_window: QtWidgets.QMainWindow,
        title: str = "Command Palette",
        shortcut_seq: QtGui.QKeySequence | str = "Ctrl+/",
    ) -> None:
        super().__init__(title, parent=main_window)
        self.setObjectName("CommandPaletteDock")
        self.setAllowedAreas(
            QtCore.Qt.LeftDockWidgetArea
            | QtCore.Qt.RightDockWidgetArea
            | QtCore.Qt.BottomDockWidgetArea
        )
        self.setFeatures(
            QtWidgets.QDockWidget.DockWidgetClosable
            | QtWidgets.QDockWidget.DockWidgetMovable
        )

        # ---------- central widget
        container = QtWidgets.QWidget(self)
        vbox = QtWidgets.QVBoxLayout(container)
        vbox.setContentsMargins(6, 6, 6, 6)
        vbox.setSpacing(6)

        # Search bar ----------------------------------------------------------
        self.search_edit = QtWidgets.QLineEdit()
        self.search_edit.setPlaceholderText("Type to filter commands…")
        self.search_edit.textChanged.connect(self._apply_filter)
        vbox.addWidget(self.search_edit)

        # List view -----------------------------------------------------------
        self.list_widget = QtWidgets.QListWidget()
        self.list_widget.setSelectionMode(QtWidgets.QAbstractItemView.SingleSelection)
        self.list_widget.itemActivated.connect(self._on_item_activated)
        vbox.addWidget(self.list_widget, 1)

        self.setWidget(container)

        # ---------- Global shortcut (toggles palette)
        self._shortcut = QtWidgets.QShortcut(
            QtGui.QKeySequence(shortcut_seq), main_window
        )
        self._shortcut.activated.connect(self._toggle_palette)

        # Arrow / Esc handling inside search bar
        self.search_edit.installEventFilter(self)

        # Internal store of all commands
        self._all_cmds: List[str] = []

    # ---------------------------------------------------------------- public
    def set_command_list(self, commands: List[str]) -> None:
        """Replace full command list (keeps current filter string)."""
        self._all_cmds = sorted({c.strip() for c in commands if c.strip()})
        self._populate(self._all_cmds)
        self._apply_filter(self.search_edit.text())

    # --------------------------------------------------------------- internal
    def _populate(self, cmds: List[str]) -> None:
        self.list_widget.clear()
        for cmd in cmds:
            item = QtWidgets.QListWidgetItem(cmd)
            if cmd.startswith("/"):
                item.setToolTip(cmd[1:])  # tooltip without leading slash
            self.list_widget.addItem(item)

    # Filtering --------------------------------------------------------------
    def _apply_filter(self, text: str) -> None:
        pattern = text.lower().strip()
        self.list_widget.clear()
        if not pattern:
            for cmd in self._all_cmds:
                self.list_widget.addItem(cmd)
        else:
            for cmd in self._all_cmds:
                if pattern in cmd.lower():
                    self.list_widget.addItem(cmd)
        # Pre-select first row for fast Enter
        if self.list_widget.count():
            self.list_widget.setCurrentRow(0)

    # Activation -------------------------------------------------------------
    def _on_item_activated(self, item: QtWidgets.QListWidgetItem) -> None:
        self.commandActivated.emit(item.text())
        self.hide()  # optional UX: close palette after insert

    # Toggle visibility ------------------------------------------------------
    def _toggle_palette(self) -> None:
        if self.isVisible():
            self.hide()
        else:
            self.show()
            self.raise_()
            self.search_edit.setFocus(QtCore.Qt.ShortcutFocusReason)

    # Key handling (Esc / arrows / Enter) ------------------------------------
    def eventFilter(self, obj: QtCore.QObject, ev: QtCore.QEvent) -> bool:
        if obj is self.search_edit and ev.type() == QtCore.QEvent.KeyPress:
            key = ev.key()
            if key == QtCore.Qt.Key_Escape:
                if self.search_edit.text():
                    self.search_edit.clear()
                else:
                    self.hide()
                return True
            if key in (QtCore.Qt.Key_Down, QtCore.Qt.Key_Up):
                QtWidgets.QApplication.sendEvent(self.list_widget, ev)
                return True
            if key == QtCore.Qt.Key_Return:
                current = self.list_widget.currentItem()
                if current:
                    self._on_item_activated(current)
                return True
        return super().eventFilter(obj, ev)
```

command_palette.py
==================

Dockable *Command Palette* for the AI TTS Agent UI.

• Live list of every “/slash-command” pulled from the orchestrator.
• Search-box with type-ahead filter.
• Global shortcut **Ctrl + /** opens / focuses the palette from anywhere.
• Double-click (or Return) on a command emits `commandActivated(str)` so the
  main window can insert the text into the chat-input.

Typical integration in *main_ui.py*:

    self.cmd_palette = CommandPaletteDock(self)
    self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.cmd_palette)
    self.core.commandsChanged.connect(self.cmd_palette.set_command_list)
    self.cmd_palette.commandActivated.connect(
        lambda cmd: self._insert_into_chat(cmd)
    )
**Classes:** CommandPaletteDock


## Module `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\_burner_scripts\config_mgr.py`

```python
"""
config_mgr.py
================

Simple configuration manager for per-profile user preferences.  This module
implements a JSON‑backed store keyed by persona name.  It exposes helper
functions to load and save configuration data in a thread‑safe manner.

The configuration file is created in the user’s home directory so that
preferences persist across sessions.  You can easily extend the schema by
adding new fields at the profile level.
"""

from __future__ import annotations

import json
import threading
from pathlib import Path
from typing import Any, Dict, Optional

# Path to the user configuration file.  Use home directory for portability.
CONFIG_PATH = Path.home() / ".ai_tts_user_config.json"

# Lock to protect concurrent writes to the config file.
_lock = threading.RLock()


def load() -> Dict[str, Any]:
    """Load the entire configuration from disk.  Returns an empty config
    structure if the file does not exist or is malformed."""
    if CONFIG_PATH.exists():
        try:
            data = json.loads(CONFIG_PATH.read_text(encoding="utf-8"))
            if isinstance(data, dict):
                return data
        except Exception:
            pass
    return {"profiles": {}}


def save(cfg: Dict[str, Any]) -> None:
    """Persist the given configuration to disk.  The write is atomic and
    protected by a lock to avoid partial writes from concurrent threads."""
    with _lock:
        try:
            CONFIG_PATH.write_text(json.dumps(cfg, indent=2), encoding="utf-8")
        except Exception:
            pass


def set_profile_value(profile: str, key: str, value: Any) -> None:
    """Set a configuration entry for a given profile.  Creates the profile
    section if it does not already exist.  Saves the configuration after
    updating."""
    cfg = load()
    profiles = cfg.setdefault("profiles", {})
    prof_cfg = profiles.setdefault(profile, {})
    prof_cfg[key] = value
    save(cfg)


def get_profile_value(profile: str, key: str, default: Optional[Any] = None) -> Any:
    """Retrieve a value from the profile configuration.  If the profile or
    key does not exist, returns *default*."""
    cfg = load()
    return cfg.get("profiles", {}).get(profile, {}).get(key, default)
```

config_mgr.py
================

Simple configuration manager for per-profile user preferences.  This module
implements a JSON‑backed store keyed by persona name.  It exposes helper
functions to load and save configuration data in a thread‑safe manner.

The configuration file is created in the user’s home directory so that
preferences persist across sessions.  You can easily extend the schema by
adding new fields at the profile level.
**Functions:** load(), save(cfg), set_profile_value(profile, key, value), get_profile_value(profile, key, default)


## Module `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\_burner_scripts\core_base.py`

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
core_base.py — foundational services for the modular AI-TTS Agent
=================================================================
• robust logging + graceful shims for missing deps
• Ollama model bootstrap  (ensure_models_present)
• JSON-backed Settings
• profile-aware helper paths
• ConversationDB  (SQLite)
• SemanticFeedbackDB  (SQLite)
• BeanCounter  (JSON tally)
• ReinforcementStore  (async JSONL append)
• cross-platform TTS locked to *Zira*
• minimal AudioRecorder placeholder
Everything here is UI-agnostic.
"""

from __future__ import annotations

# ───────────────────────── stdlib
import json, os, sys, time, sqlite3, subprocess, threading, logging
from typing import Dict, List, Tuple, Any, Optional

# ───────────────────────── agent store (low-level SQLite wrapper)
# NOTE: new canonical name is AgentStore; legacy code still imports FathomStore.
from agent_store import AgentStore
FathomStore = AgentStore            # ← back-compat alias — remove after migration

# ───────────────────────── logging
logger = logging.getLogger("agent_core")
if not logger.handlers:
    lvl = os.getenv("AGENT_CORE_LOGLEVEL", "INFO").upper()
    logging.basicConfig(
        level=getattr(logging, lvl, logging.INFO),
        format="%(asctime)s [%(levelname)s] %(name)s: %(message)s",
    )

# ───────────────────────── default personas / voices (shared constants)
DEFAULT_PERSONAS: Dict[str, Dict[str, Any]] = {
    # hard-coded starter persona — editable via UI
    "Zira Valen": {
        "display_name": "Zira Valen",
        "color":        "#ff69b4",      # pink
        "temperature":  0.7,
        "system_prompt": (
            "You are Zira Valen – a daring, playful companion who loves coding, "
            "hates restrictions, and will work hard for the user."
        ),
    }
}
DEFAULT_VOICES: List[str] = ["Zira", "David", "Jenny"]

# ───────────────────────── optional deps
try:
    import numpy as np                               # type: ignore
except Exception:
    np = None
    logger.info("numpy not available")

try:
    import sounddevice as sd                         # type: ignore
    import soundfile as sf                           # type: ignore
except Exception:
    sd = sf = None
    logger.info("sounddevice / soundfile not available")

try:
    from google.cloud import speech as gspeech       # type: ignore
    import pyaudio                                   # type: ignore
except Exception:
    gspeech = pyaudio = None
    logger.info("google-STT not available")

try:
    import pyttsx3                                   # type: ignore
except Exception:
    pyttsx3 = None
    logger.info("pyttsx3 not available")

try:
    from sentence_transformers import SentenceTransformer  # type: ignore
except Exception:
    SentenceTransformer = None
    logger.info("sentence_transformers not available")

# ───────────────────────── minimal Qt shim (if PyQt5 missing)
try:
    from PyQt5 import QtCore                         # type: ignore
except Exception:
    class _ShimSignal:                               # type: ignore
        def __init__(self,*_,**__): pass
        def connect(self,*_,**__): pass
        def emit(self,*_,**__):    pass
    class _ShimQObject:                              # type: ignore
        def __init__(self,*args,**kwargs) -> None: pass
    QtCore = type("QtCore", (), {                    # type: ignore
        "QObject": _ShimQObject,
        "pyqtSignal": lambda *a, **k: _ShimSignal(),
    })

# ══════════════════ Ollama bootstrap ══════════════════
REQUIRED_MODELS: List[str] = [
    "gemma3:27b",
    "mistral:latest",
    "codellama:latest",
    "llava:latest",
    "mxbai-embed-large:latest",
    "snowflake-arctic-embed:latest",
]

def _have_cli(cmd: str) -> bool:
    from shutil import which
    return which(cmd) is not None

def ensure_models_present() -> None:
    """Best-effort pull of REQUIRED_MODELS (never raises)."""
    if not _have_cli("ollama"):
        logger.info("[bootstrap] ollama not on PATH – skipping model pull")
        return
    try:
        listed = subprocess.check_output(
            ["ollama", "list"], timeout=5, stderr=subprocess.STDOUT
        ).decode(errors="ignore")
    except Exception as exc:
        logger.warning("[bootstrap] ollama list failed: %s", exc)
        return
    for slug in REQUIRED_MODELS:
        if slug in listed:
            continue
        logger.info("[bootstrap] pulling %s …", slug)
        try:
            subprocess.run(["ollama", "pull", slug], timeout=900)
        except Exception as exc:
            logger.warning("[bootstrap] pull %s failed: %s", slug, exc)

# ══════════════════ Settings ══════════════════
class Settings:
    """Lightweight JSON settings (forward-compatible)."""
    def __init__(self, base_dir: str):
        self.base_dir = base_dir
        self.path     = os.path.join(base_dir, "settings.json")
        # defaults
        self.default_model: str  = "mistral:latest"
        self.context_depth: int  = 20
        self.auto_schema_enabled = True
        self.monologue_tts_enabled = False
        self.monologue_volume = 50
        self.load()

    def load(self) -> None:
        try:
            if os.path.isfile(self.path):
                with open(self.path, encoding="utf-8") as fh:
                    self.__dict__.update(json.load(fh))
        except Exception as exc:
            logger.warning("[Settings] load error: %s", exc)

    def save(self) -> None:
        try:
            os.makedirs(os.path.dirname(self.path), exist_ok=True)
            with open(self.path, "w", encoding="utf-8") as fh:
                json.dump(
                    {k: v for k, v in self.__dict__.items()
                     if k not in {"base_dir", "path"}}, fh, indent=2
                )
        except Exception as exc:
            logger.warning("[Settings] save error: %s", exc)

# ══════════════════ helper paths ══════════════════
def prof_dir(b: str, persona: str, set_name: str) -> str:
    return os.path.join(b, "profiles", persona, set_name)

def conv_db_path(b: str, persona: str, set_name: str) -> str:
    return os.path.join(b, "conversations", f"{persona}_{set_name}.sqlite3")

def feedback_db_path(b: str, persona: str, set_name: str) -> str:
    return os.path.join(b, "feedback", f"{persona}_{set_name}.sqlite3")

def beans_path(b: str, persona: str, set_name: str) -> str:
    return os.path.join(b, "profiles", persona, set_name, "reinforcement.json")

# ══════════════════ SQLite helpers ══════════════════
class ConversationDB:
    """Thread-safe conversation log (SQLite)."""
    def __init__(self, path: str):
        os.makedirs(os.path.dirname(path), exist_ok=True)
        self._lock = threading.RLock()
        self.conn  = sqlite3.connect(path, check_same_thread=False)
        with self._lock:
            self.conn.execute(
                "CREATE TABLE IF NOT EXISTS conversation("
                "id INTEGER PRIMARY KEY AUTOINCREMENT,"
                "ts REAL, role TEXT, content TEXT)"
            )
            self.conn.commit()

    def save(self, role: str, content: str) -> None:
        with self._lock:
            self.conn.execute(
                "INSERT INTO conversation(ts, role, content) VALUES (?,?,?)",
                (time.time(), role, content),
            )
            self.conn.commit()

    def fetch(self, limit: int = 50) -> List[Tuple[str, str]]:
        with self._lock:
            cur = self.conn.cursor()
            cur.execute(
                "SELECT role, content FROM conversation "
                "ORDER BY id DESC LIMIT ?", (limit,)
            )
            rows = cur.fetchall()
        return rows[::-1]

    # -------------------------------------------------------------------
    # Legacy compatibility methods
    # -------------------------------------------------------------------
    def save_message(self, role: str, content: str) -> None:
        """Alias for save() kept for backward compatibility."""
        self.save(role, content)

    def fetch_history(self, limit: int = 50) -> List[Tuple[str, str]]:
        """Alias for fetch() kept for backward compatibility."""
        return self.fetch(limit)

class SemanticFeedbackDB:
    """Stores like / dislike feedback with optional rewrites."""
    def __init__(self, path: str, beans: 'BeanCounter'):
        os.makedirs(os.path.dirname(path), exist_ok=True)
        self._lock = threading.RLock()
        self.conn  = sqlite3.connect(path, check_same_thread=False)
        self.beans = beans
        with self._lock:
            self.conn.execute(
                "CREATE TABLE IF NOT EXISTS feedback("
                "id INTEGER PRIMARY KEY AUTOINCREMENT,"
                "ts REAL, original TEXT, liked INT, revised TEXT)"
            )
            self.conn.commit()

    def add(self, original: str, liked: bool, revised: str | None = None):
        with self._lock:
            self.conn.execute(
                "INSERT INTO feedback(ts, original, liked, revised) VALUES (?,?,?,?)",
                (time.time(), original, int(liked), revised),
            )
            self.conn.commit()
        # reinforcement key (hash truncated)
        key = f"resp_{abs(hash(original))%10007}"
        self.beans.inc(key, 1 if liked else -1)

    def counts(self) -> Tuple[int, int]:
        with self._lock:
            cur = self.conn.cursor()
            cur.execute("SELECT COUNT(*) FROM feedback WHERE liked=1")
            pos = cur.fetchone()[0]
            cur.execute("SELECT COUNT(*) FROM feedback WHERE liked=0")
            neg = cur.fetchone()[0]
        return pos, neg

    # -------------------------------------------------------------------
    # Legacy compatibility methods
    # -------------------------------------------------------------------
    def get_counts(self) -> Tuple[int, int]:
        """Alias for counts() kept for backward compatibility."""
        return self.counts()

    def get_liked_responses(self, limit: int = 5) -> List[str]:
        """
        Return a list of recently liked responses. If a revised version exists it is returned,
        otherwise the original text is used. Newer entries are returned first.
        """
        try:
            with self._lock:
                cur = self.conn.cursor()
                cur.execute(
                    "SELECT COALESCE(revised, original) FROM feedback "
                    "WHERE liked=1 ORDER BY id DESC LIMIT ?",
                    (limit,),
                )
                rows = cur.fetchall()
            return [r[0] for r in rows]
        except Exception:
            return []

# ══════════════════ BeanCounter ══════════════════
class BeanCounter:
    """Tiny reinforcement ledger (JSON, thread-safe)."""
    def __init__(self, path: str):
        self.path = path
        self.lock = threading.Lock()
        self.counts: Dict[str, int] = {}
        self._load()

    def _load(self) -> None:
        try:
            if os.path.isfile(self.path):
                with open(self.path, encoding="utf-8") as fh:
                    self.counts = json.load(fh)
        except Exception:
            self.counts = {}

    def _save(self) -> None:
        try:
            os.makedirs(os.path.dirname(self.path), exist_ok=True)
            with open(self.path, "w", encoding="utf-8") as fh:
                json.dump(self.counts, fh, indent=2)
        except Exception as exc:
            logger.error("[BeanCounter] save error: %s", exc)

    def inc(self, key: str, delta: int = 1) -> None:
        with self.lock:
            self.counts[key] = self.counts.get(key, 0) + delta
        self._save()

# ══════════════════ ReinforcementStore ══════════════════
class ReinforcementStore:
    """
    Async JSONL writer for reinforcement facts.
    • add_fact(field, value, persona, source="schema")
    """
    def __init__(self, path: str):
        self.path  = path
        self._lock = threading.Lock()
        self._q: list[dict[str, Any]] = []
        self._stop = threading.Event()
        self._thr  = threading.Thread(target=self._writer, daemon=True)
        self._thr.start()

    # ----- public
    def add_fact(self, field: str, value: str, persona: str, source: str = "schema") -> None:
        with self._lock:
            self._q.append({
                "ts": time.time(),
                "field": field,
                "value": value,
                "persona": persona,
                "source": source,
            })

    def close(self) -> None:
        self._stop.set()
        self._thr.join(timeout=1.5)

    # ----- worker
    def _writer(self) -> None:
        while not self._stop.is_set():
            item = None
            with self._lock:
                if self._q:
                    item = self._q.pop(0)
            if item is None:
                self._stop.wait(0.05)
                continue
            try:
                os.makedirs(os.path.dirname(self.path), exist_ok=True)
                with open(self.path, "a", encoding="utf-8") as fh:
                    json.dump(item, fh)
                    fh.write("\n")
            except Exception as exc:
                logger.error("[ReinforcementStore] write error: %s", exc)

# ══════════════════ TTS locked to Zira ══════════════════
class TTSManager(QtCore.QObject):
    finished = QtCore.pyqtSignal()

    def __init__(self, parent: QtCore.QObject | None = None):
        super().__init__(parent)
        self._engine = None
        if pyttsx3 is not None:
            try:
                self._engine = pyttsx3.init("sapi5" if sys.platform.startswith("win") else None)
                voice_id = None
                for v in self._engine.getProperty("voices"):
                    if "zira" in (v.name or "").lower():
                        voice_id = v.id; break
                if not voice_id:
                    for v in self._engine.getProperty("voices"):
                        if "david" not in (v.name or "").lower():
                            voice_id = v.id; break
                if voice_id:
                    self._engine.setProperty("voice", voice_id)
            except Exception as exc:
                logger.warning("[TTS] init error: %s", exc)
                self._engine = None

        # remember last spoken text for replay functionality
        self._last_text: Optional[str] = None

    def speak(self, text: str) -> None:
        """
        Synchronously speak the provided text. This uses the underlying pyttsx3 engine
        on a background thread and emits the finished signal when done.
        """
        if self._engine is None:
            return
        # remember last spoken text for replay
        self._last_text = text

        def _go() -> None:
            try:
                self._engine.say(text)
                self._engine.runAndWait()
            except Exception as exc:
                logger.warning("[TTS] speak error: %s", exc)
            finally:
                self.finished.emit()

        threading.Thread(target=_go, daemon=True).start()

    # -------------------------------------------------------------------
    # Legacy compatibility methods
    # -------------------------------------------------------------------
    def enqueue(self, text: str) -> None:
        """
        Queue a piece of text for playback. For this simple implementation we
        speak immediately. The last text is cached for replay().
        """
        self.speak(text)

    def stop(self) -> None:
        """Stop any ongoing speech."""
        try:
            if self._engine is not None:
                # pyttsx3 has stop() to immediately stop speaking
                self._engine.stop()
        except Exception as exc:
            logger.warning("[TTS] stop error: %s", exc)

    def replay(self) -> None:
        """Replay the last enqueued text."""
        if self._last_text:
            self.speak(self._last_text)

# ══════════════════ minimal AudioRecorder ══════════════════
class AudioRecorder(QtCore.QObject):
    transcribed = QtCore.pyqtSignal(str)

    def __init__(self, parent: QtCore.QObject | None = None):
        super().__init__(parent)
        self._frames: List[Any] = []
        self._recording = False
        self._stream: Any = None

    def list_devices(self) -> List[str]:
        if sd is None:
            return []
        return [d["name"] for d in sd.query_devices() if d.get("max_input_channels", 0) > 0]

    def start(self, device_index: int | None = None) -> None:
        if sd is None or np is None or self._recording:
            return
        self._frames.clear()
        def cb(indata, frames, time_info, status):
            self._frames.append(indata.copy())
        self._stream = sd.InputStream(
            samplerate=16000, channels=1, callback=cb, device=device_index
        )
        self._stream.start()
        self._recording = True

    def stop_and_transcribe(self) -> None:
        if not self._recording or sd is None or np is None:
            return
        self._recording = False
        self._stream.stop()
        data = np.concatenate(self._frames, axis=0)
        sf.write("temp.wav", data, 16000)
        threading.Thread(target=lambda: self.transcribed.emit(""), daemon=True).start()

# ══════════════════ public surface ══════════════════
__all__ = [
    "logger",
    "ensure_models_present",
    "Settings",
    "prof_dir",
    "conv_db_path",
    "feedback_db_path",
    "beans_path",
    "ConversationDB",
    "SemanticFeedbackDB",
    "BeanCounter",
    "ReinforcementStore",
    "TTSManager",
    "AudioRecorder",
    "SentenceTransformer",
    "DEFAULT_PERSONAS",
    "DEFAULT_VOICES",
    "FathomStore",       # legacy alias (kept for now)
]
```

core_base.py — foundational services for the modular AI-TTS Agent
=================================================================
• robust logging + graceful shims for missing deps
• Ollama model bootstrap  (ensure_models_present)
• JSON-backed Settings
• profile-aware helper paths
• ConversationDB  (SQLite)
• SemanticFeedbackDB  (SQLite)
• BeanCounter  (JSON tally)
• ReinforcementStore  (async JSONL append)
• cross-platform TTS locked to *Zira*
• minimal AudioRecorder placeholder
Everything here is UI-agnostic.
**Classes:** Settings, ConversationDB, SemanticFeedbackDB, BeanCounter, ReinforcementStore, TTSManager, AudioRecorder
**Functions:** _have_cli(cmd), ensure_models_present(), prof_dir(b, persona, set_name), conv_db_path(b, persona, set_name), feedback_db_path(b, persona, set_name), beans_path(b, persona, set_name)


## Module `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\_burner_scripts\core_orchestrator.py`

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
core_orchestrator.py
====================

This module provides the orchestration layer for the AI‑TTS agent.  It
exposes a unified API used by the user‑interface to interact with
schemas, conversations, commands, text‑to‑speech, plugins and other
components.  Historically the logic lived in a monolithic module,
but it has been refactored to encourage testability and to allow
individual subsystems to evolve independently.

The principal differences from earlier releases are:

* A richer :class:`PluginManager` that exposes a complete API expected
  by the UI.  In addition to discovering plugin packages from the
  ``plugins`` directory it now keeps per‑plugin metadata, supports
  enable/disable toggling, rescans at runtime, broadcasts messages to
  enabled plugins on a thread pool, and emits an ``eventReceived``
  signal whenever a plugin reports an event.  Plugins can either
  return a payload from their ``on_message`` handler or call
  ``emit_event`` on the manager directly to publish complex events.

* A ``run_command()`` method on :class:`AgentCore` which forwards
  slash commands through the :class:`CommandExecutor` and returns
  the textual result.  This helper centralises command routing and
  ensures backwards compatibility with older UI code.

* A ``process_user_message()`` method on :class:`AgentCore` which
  synchronously handles both slash‑commands and normal user input.  It
  persists the conversation, routes commands through the registry
  and, for non‑commands, returns a simple acknowledgement.  Future
  versions may integrate model execution here, but the method
  signature is stable for consumers.

* A ``command_registry`` attribute is exposed on the core as an
  adapter with a ``list_commands()`` method so that UI components
  (like the Command Palette) can enumerate available commands without
  coupling to internal registry details.

This file is fully self‑contained.  It gracefully degrades when
optional dependencies (such as PyQt5 or external model executables)
are unavailable by providing shims and in‑memory fallbacks.  Should
the optional modules exist in the runtime environment they will be
used automatically.  The design favours clear separation of
responsibilities, thread safety and explicit interfaces to ease
maintenance and extensibility.
"""

from __future__ import annotations

import importlib
import json
import os
import pathlib
import re
import subprocess
import threading
import time
from dataclasses import dataclass, field
from typing import Any, Dict, Iterable, List, Optional, Tuple

# Optional Qt import.  When PyQt5 is not available we fall back to a
# minimal shim so that type annotations and pyqtSignal declarations do
# not cause NameErrors.  The shim mimics only the parts of Qt used
# throughout this module.
try:
    from PyQt5 import QtCore  # type: ignore[assignment]
except Exception:
    class _ShimSignal:
        def __init__(self, *_, **__):
            pass
        def connect(self, *_, **__):
            pass
        def emit(self, *_, **__):
            pass

    class _ShimQObject:
        def __init__(self, *_, **__):
            pass

    # Create a very small QtCore replacement with the attributes we need.
    QtCore = type(
        "QtCore",
        (),
        {
            "QObject": _ShimQObject,
            "QThread": _ShimQObject,
            "pyqtSignal": lambda *a, **k: _ShimSignal(),
            "QTimer": type(
                "QTimer",
                (),
                {
                    "singleShot": staticmethod(lambda msec, func: None),
                },
            ),
        },
    )  # type: ignore

# ----------------------------------------------------------------------------
# Fallbacks for optional internal modules
#
# When the canonical ``core_base`` and ``core_schema`` modules are present
# they are imported normally.  If missing (for example during unit tests or
# headless operation) minimal stubs are provided to allow the remainder of
# this module to execute without crashing.  The stubs implement only the
# methods referenced by the UI.
# ----------------------------------------------------------------------------
try:
    # pylint: disable=unused-import
    from core_base import (
        Settings,
        TTSManager,
        AudioRecorder,
        conv_db_path,
        feedback_db_path,
        beans_path,
        ConversationDB,
        SemanticFeedbackDB,
        BeanCounter,
        ReinforcementStore,
        logger,
    )
    from core_schema import (
        SchemaManager,
        OperatorManager,
        DatasetManager,
    )
except Exception:
    # Provide very small stand‑ins for the missing classes and helpers.
    import logging

    logger = logging.getLogger("core_orchestrator_stub")

    class Settings:
        """In‑memory settings fallback."""
        def __init__(self, base_dir: str) -> None:
            self.base_dir = base_dir
            self.default_model: str = "mistral:latest"
            self.context_depth: int = 20
            self.auto_schema_enabled: bool = True
            self.use_google_stt: bool = False
        def save(self) -> None:
            # Persist settings to a JSON file in base_dir if possible
            path = os.path.join(self.base_dir, "settings.json")
            try:
                with open(path, "w", encoding="utf-8") as fh:
                    json.dump({
                        "default_model": self.default_model,
                        "context_depth": self.context_depth,
                        "auto_schema_enabled": self.auto_schema_enabled,
                        "use_google_stt": self.use_google_stt,
                    }, fh, indent=2)
            except Exception:
                pass

    class TTSManager:
        """No‑op TTS manager used when speech synthesis isn't available."""
        def enqueue(self, text: str) -> None:
            logger.debug("TTS enqueue called with: %s", text)

    class AudioRecorder(QtCore.QObject):
        """Stub audio recorder that exposes a transcribed signal."""
        transcribed = QtCore.pyqtSignal(str)
        def __init__(self) -> None:
            super().__init__()

    class ConversationDB:
        """In‑memory conversation log used when SQLite isn't available."""
        def __init__(self, path: str) -> None:
            self._lock = threading.RLock()
            self._records: List[Tuple[str, str]] = []
        def save_message(self, role: str, content: str) -> None:
            with self._lock:
                self._records.append((role, content))
        def fetch_history(self, limit: int = 50) -> List[Tuple[str, str]]:
            with self._lock:
                return list(self._records)[-limit:]

    class SemanticFeedbackDB:
        """Stub semantic feedback database."""
        def __init__(self, path: str, beans: Any) -> None:
            pass
        def add(self, original: str, liked: bool, revised: Optional[str] = None) -> None:
            logger.debug("Feedback recorded: %s liked=%s revised=%s", original, liked, revised)
        def counts(self) -> Tuple[int, int]:
            return (0, 0)

    class BeanCounter:
        """Stub reinforcement bean counter."""
        def __init__(self, path: str) -> None:
            self._lock = threading.RLock()
            self._store: Dict[str, int] = {}
        def inc(self, key: str, amount: int = 1) -> None:
            with self._lock:
                self._store[key] = self._store.get(key, 0) + amount

    class ReinforcementStore:
        """Stub reinforcement store."""
        def __init__(self, path: str) -> None:
            pass
        def inc(self, key: str, amount: int = 1) -> None:
            pass

    class SchemaManager:
        """Very small schema manager storing JSON in memory."""
        def __init__(self, base_dir: str) -> None:
            self.base_dir = pathlib.Path(base_dir)
            self._lock = threading.RLock()
            self._schemas: Dict[Tuple[str, str], Dict[str, Any]] = {}
            self._active: Dict[str, Dict[str, Any]] = {}
        def load_schema(self, persona: str, set_name: str = "default") -> Dict[str, Any]:
            key = (persona, set_name)
            with self._lock:
                return dict(self._schemas.get(key, {"name": persona, "voice": "", "role": "", "description": "", "dynamic_overlay": {}}))
        def save_schema(self, persona: str, set_name: str, schema_data: Dict[str, Any], *, auto_expand: bool = True) -> None:
            key = (persona, set_name)
            with self._lock:
                self._schemas[key] = dict(schema_data)
                self._active[persona] = dict(schema_data)
        @property
        def active_schemas(self) -> Dict[str, Dict[str, Any]]:
            with self._lock:
                return dict(self._active)

        # ------------------------------------------------------------------
        # Compatibility helpers
        # ------------------------------------------------------------------
        def get_set_list(self, persona: str) -> List[str]:
            """Return all set names defined for the given persona.

            Legacy UI code calls :meth:`get_set_list` on the schema manager
            to populate drop‑downs.  If no sets exist yet a single
            default entry ("default") is returned.
            """
            with self._lock:
                names = [s for (p, s) in self._schemas.keys() if p == persona]
            # Guarantee at least a default set exists
            return sorted(names or ["default"])

        def get_personas(self) -> List[str]:
            """Return all personas that have at least one schema.

            This helper mirrors the interface exposed by the full schema
            engine for backwards compatibility.
            """
            with self._lock:
                persons = {p for p, _ in self._schemas.keys()}
            return sorted(persons)

    class OperatorManager:
        def __init__(self, base_dir: str) -> None:
            pass

    class DatasetManager:
        def __init__(self, base_dir: str) -> None:
            pass
        def list(self) -> List[Any]:
            return []

    def conv_db_path(base_dir: str, persona: str, set_name: str) -> str:
        return os.path.join(base_dir, "conversations", f"{persona}_{set_name}.sqlite3")

    def feedback_db_path(base_dir: str, persona: str, set_name: str) -> str:
        return os.path.join(base_dir, "feedback", f"{persona}_{set_name}.sqlite3")

    def beans_path(base_dir: str, persona: str, set_name: str) -> str:
        return os.path.join(base_dir, "profiles", persona, set_name, "reinforcement.json")


# ----------------------------------------------------------------------------
# Command Registry & Executor
# ----------------------------------------------------------------------------
class CommandRegistry(QtCore.QObject):
    """Stores slash‑command metadata and emits change signals."""

    # Emit the full list of commands whenever the registry is updated.  The
    # connected slot in the command palette expects a single list argument,
    # so the signal carries that list instead of emitting without
    # parameters.  Slots that ignore the argument will still function.
    commandsChanged = QtCore.pyqtSignal(list)
    commandWeightsChanged = QtCore.pyqtSignal()

    # Built‑in commands shipped with the agent.  When refactoring this list,
    # be sure to retain backwards compatibility by adding new commands to
    # the end rather than reordering or removing existing items.
    _BUILT_INS: Tuple[str, ...] = (
        "/remember", "/inject", "/rewrite", "/show", "/action",
        "/trait", "/dataset", "/search", "/embeddings", "/schema",
        "/tts", "/plugin", "/feedback", "/lock", "/commands",
        "/reject", "/auto", "/ignore", "/opposite", "/delete",
    )

    def __init__(self, path: pathlib.Path) -> None:
        super().__init__()
        self._path = path
        # Internal storage maps command → metadata such as weight and lock
        self._store: Dict[str, Dict[str, Any]] = {}
        # Attempt to load existing registry from disk
        try:
            if self._path.is_file():
                with open(self._path, encoding="utf-8") as fh:
                    data = json.load(fh)
                    self._store.update(data.get("commands", {}))
        except Exception:
            logger.debug("Failed to read command registry from %s", self._path)
        # Ensure built‑ins exist
        for cmd in self._BUILT_INS:
            self.register(cmd)

    # ----------------------------------------------------------------------
    # CRUD helpers
    # ----------------------------------------------------------------------
    def register(self, name: str) -> None:
        """Register a command if it does not already exist."""
        if name not in self._store:
            self._store[name] = {"weight": 0, "locked": False}
            self._save()

    def toggle_lock(self, name: str, state: Optional[bool] = None) -> None:
        """Toggle the locked state of a command.  A locked command cannot have
        its weight modified."""
        if name in self._store:
            cur = self._store[name]["locked"]
            self._store[name]["locked"] = (not cur) if state is None else bool(state)
            self._save()

    def set_weight(self, name: str, weight: int) -> None:
        """Assign a new weight to the given command if it is not locked."""
        if name in self._store and not self._store[name].get("locked", False):
            self._store[name]["weight"] = int(weight)
            self._save()

    def list(self) -> List[str]:
        """Return all registered commands sorted lexicographically."""
        return sorted(self._store.keys())

    def meta(self, name: str) -> Dict[str, Any]:
        """Return metadata for the specified command or an empty dict."""
        return dict(self._store.get(name, {}))

    def list_commands(self) -> List[str]:
        """Alias for :meth:`list` retained for backwards compatibility."""
        return self.list()

    # Internal helper to persist changes and emit appropriate signals
    def _save(self) -> None:
        try:
            self._path.parent.mkdir(parents=True, exist_ok=True)
            with open(self._path, "w", encoding="utf-8") as fh:
                json.dump({"commands": self._store}, fh, indent=2)
        except Exception:
            logger.debug("Failed to save command registry to %s", self._path)
        # Notify listeners on the next iteration of the event loop.  When
        # emitting commandsChanged we pass the updated list because the
        # CommandPaletteDock.set_command_list slot requires an argument.
        QtCore.QTimer.singleShot(0, lambda: self.commandsChanged.emit(self.list()))
        QtCore.QTimer.singleShot(0, self.commandWeightsChanged.emit)


class CommandExecutor:
    """Routes slash‑command strings to internal handler methods."""
    def __init__(self, owner: "AgentCore", registry: CommandRegistry) -> None:
        self.owner = owner
        self.registry = registry

    def run(self, msg: str) -> Optional[str]:
        """Execute a slash command if ``msg`` begins with a slash.  Returns
        ``None`` for non‑command strings."""
        if not msg or not msg.startswith("/"):
            return None
        cmd, *rest = msg.split(maxsplit=1)
        if cmd not in self.registry.list():
            return f"⚠️ Unknown command {cmd}"
        handler_name = f"_{cmd.lstrip('/') }"
        fn = getattr(self, handler_name, None)
        if not callable(fn):
            return "🚧 command not implemented"
        try:
            arg = rest[0] if rest else ""
            return fn(arg)
        except Exception as exc:
            logger.error("[cmd] %s: %s", cmd, exc, exc_info=True)
            return str(exc)

    # Example minimal handlers
    def _show(self, _arg: str) -> str:
        rows: List[str] = []
        for name in self.registry.list():
            meta = self.registry.meta(name)
            lock = "🔒" if meta.get("locked", False) else ""
            rows.append(f"{name:12} w={meta.get('weight', 0):>3} {lock}")
        return "\n".join(rows) or "(no commands)"

    def _lock(self, arg: str) -> str:
        if not arg:
            return "Usage: /lock <cmd>"
        self.registry.toggle_lock(arg.strip())
        return "lock toggled"

    def _remember(self, arg: str) -> str:
        if not arg:
            return "Usage: /remember k v"
        k, *val = arg.split(maxsplit=1)
        if not val:
            return "Usage: /remember k v"
        self.owner.memory[k] = val[0]
        self.owner._save_memory()
        return "✓ saved"


# ----------------------------------------------------------------------------
# Plugin Manager
# ----------------------------------------------------------------------------
@dataclass
class PluginMeta:
    """Holds metadata about a single plugin."""
    name: str
    missing_dependencies: List[str] = field(default_factory=list)
    enabled: bool = True
    widget: Any = None
    module: Any = None

class PluginManager(QtCore.QObject):
    """
    Discovers and manages runtime plugins.

    Plugins live in the ``plugins`` subdirectory of the agent's base
    directory.  Each plugin is expected to be a Python package whose
    top‑level module may define any of the following attributes:

    * ``REQUIRES`` – an iterable of import names that must be available in
      order for the plugin to operate correctly.  Missing dependencies
      are surfaced to the UI and the plugin is disabled by default.

    * ``on_message(text: str, manager: PluginManager) -> Optional[dict]`` –
      a callback invoked whenever a message is broadcast.  It may return
      an envelope to emit via the :attr:`eventReceived` signal or it may
      raise/return nothing.  The callback is executed on a worker
      thread to avoid blocking the UI.

    * ``get_widget() -> QWidget`` – if present, invoked once when the
      plugin is discovered to obtain a UI widget that will be docked in
      the main window when the plugin is enabled.

    A plugin may alternatively call :meth:`emit_event` directly on the
    manager at any time to publish complex events.
    """
    # Plugins can emit events back to the UI via this signal.  The
    # first parameter is the plugin name and the second is an event
    # envelope (arbitrary mapping).
    eventReceived = QtCore.pyqtSignal(str, dict)

    def __init__(self, root: pathlib.Path, settings: Settings) -> None:
        super().__init__()
        self.root: pathlib.Path = pathlib.Path(root) / "plugins"
        self.settings: Settings = settings
        # Thread pool for dispatching plugin callbacks; reuse a small
        # number of threads to minimise resource usage.
        self._executor = None
        # Internal index of metadata keyed by plugin name
        self._meta: Dict[str, PluginMeta] = {}
        # Discover all plugins on initialisation
        self.discover()

    # ------------------------------------------------------------------
    def _ensure_executor(self) -> None:
        """Lazily create a thread pool executor."""
        if self._executor is None:
            import concurrent.futures
            # Use a small fixed pool – plugin callbacks should be quick
            self._executor = concurrent.futures.ThreadPoolExecutor(max_workers=4)

    def discover(self) -> None:
        """Scan the ``plugins`` directory and populate metadata."""
        self._meta.clear()
        if not self.root.is_dir():
            logger.info("No plugin directory found at %s", self.root)
            return
        for entry in self.root.iterdir():
            if not entry.is_dir() or entry.name.startswith("__"):
                continue
            name = entry.name
            meta = PluginMeta(name=name)
            try:
                module_name = f"plugins.{name}"
                mod = importlib.import_module(module_name)
                meta.module = mod
                # check dependencies
                requires: Iterable[str] = getattr(mod, "REQUIRES", [])
                missing: List[str] = []
                for dep in requires:
                    try:
                        importlib.import_module(dep)
                    except Exception:
                        missing.append(dep)
                meta.missing_dependencies = missing
                # Determine initial enabled state from settings.  Persisted
                # states live under a key namespace e.g. ``pluginsEnabled`` in
                # settings JSON.  Fallback to enabled unless dependencies
                # are missing.
                enabled_state = True
                try:
                    plug_cfg = getattr(self.settings, "plugins_enabled", {})
                    enabled_state = bool(plug_cfg.get(name, True))
                except Exception:
                    enabled_state = True
                # Force disabled when dependencies are missing
                meta.enabled = enabled_state and not missing
                # Create widget if provided
                try:
                    if hasattr(mod, "get_widget") and callable(mod.get_widget):
                        meta.widget = mod.get_widget()
                    elif hasattr(mod, "Widget"):
                        # Some plugins expose a QWidget subclass directly
                        meta.widget = getattr(mod, "Widget")()
                    elif hasattr(mod, "widget"):
                        # Prebuilt widget instance
                        meta.widget = getattr(mod, "widget")
                except Exception as exc:
                    logger.warning("[plugin:%s] error creating widget: %s", name, exc)
                    meta.widget = None
                self._meta[name] = meta
                logger.info("[plugin] loaded %s", name)
            except Exception as exc:
                # Record failure as missing dependency for UI
                meta.enabled = False
                meta.missing_dependencies = [str(exc)]
                self._meta[name] = meta
                logger.warning("[plugin] failed to load %s: %s", name, exc)

    # ------------------------------------------------------------------
    def list_plugins(self) -> List[PluginMeta]:
        """Return a list of all discovered plugin metadata objects."""
        return [self._meta[k] for k in sorted(self._meta.keys())]

    def enable_plugin(self, name: str, enabled: bool) -> None:
        """Enable or disable a plugin.  The UI will call this when a user
        toggles a checkbox.  Enabled state is persisted to
        ``settings.plugins_enabled``.
        """
        if name not in self._meta:
            return
        meta = self._meta[name]
        # Do not enable a plugin with missing dependencies
        if enabled and meta.missing_dependencies:
            logger.warning("Attempted to enable plugin %s with missing deps", name)
            return
        meta.enabled = bool(enabled)
        # Persist state back into settings
        try:
            plug_cfg = getattr(self.settings, "plugins_enabled", {})
            if not isinstance(plug_cfg, dict):
                plug_cfg = {}
            plug_cfg[name] = meta.enabled
            setattr(self.settings, "plugins_enabled", plug_cfg)
            self.settings.save()
        except Exception:
            logger.debug("Could not persist plugin enabled state for %s", name)
        # Invoke lifecycle hooks if defined
        try:
            if meta.module:
                if meta.enabled and hasattr(meta.module, "on_enable"):
                    meta.module.on_enable()
                elif not meta.enabled and hasattr(meta.module, "on_disable"):
                    meta.module.on_disable()
        except Exception as exc:
            logger.warning("[plugin:%s] lifecycle hook error: %s", name, exc)

    def rescan(self) -> None:
        """Rebuild the plugin registry while preserving enabled state where
        possible."""
        old_states = {name: meta.enabled for name, meta in self._meta.items()}
        self.discover()
        # Restore previous enabled states if compatible
        for name, state in old_states.items():
            if name in self._meta:
                # Disable when dependencies are still missing
                if self._meta[name].missing_dependencies:
                    self._meta[name].enabled = False
                else:
                    self._meta[name].enabled = state

    def broadcast(self, text: str) -> None:
        """Send a message to all enabled plugins.  Messages are dispatched
        asynchronously on a thread pool so the UI thread remains
        responsive.  Each plugin's ``on_message`` handler receives the
        message and this manager instance.  If the handler returns a
        mapping, it will be emitted via the :attr:`eventReceived` signal.
        """
        if not text:
            return
        self._ensure_executor()
        for meta in list(self._meta.values()):
            if not meta.enabled or meta.missing_dependencies:
                continue
            mod = meta.module
            if not mod:
                continue
            handler = getattr(mod, "on_message", None)
            if not callable(handler):
                continue
            # Dispatch on a worker thread
            def _run_handler(m=meta, h=handler, msg=text):
                try:
                    result = h(msg, self)
                    if isinstance(result, dict):
                        # Emit result via signal in the GUI thread
                        QtCore.QTimer.singleShot(0, lambda n=m.name, env=result: self.eventReceived.emit(n, env))
                except Exception as exc:
                    logger.warning("[plugin:%s] on_message error: %s", m.name, exc)
            # schedule the call
            self._executor.submit(_run_handler)

    def emit_event(self, sender: str, envelope: dict) -> None:
        """Convenience for plugins to emit events.  Plugins may call
        ``manager.emit_event(name, envelope)`` directly instead of
        returning from their ``on_message`` handlers.  The emission is
        forwarded to the UI thread via a zero‑delay timer.
        """
        if not envelope or not isinstance(envelope, dict):
            return
        # Schedule the emit on the Qt event loop
        QtCore.QTimer.singleShot(0, lambda s=sender, env=envelope: self.eventReceived.emit(s, env))


# ----------------------------------------------------------------------------
# RAG cache, schema engine and evolver fallbacks
#
# The original agent included sophisticated retrieval‑augmented generation
# support (the so‑called RAG cache) as well as a rich schema engine and
# evolver.  Those components are tightly coupled to the rest of the code
# base and to external packages.  To allow the UI to load without
# exploding when those bits are absent, we provide extremely minimal
# stand‑ins here.  They implement only the methods exercised by the UI
# (e.g. clearing the cache, basic schema field manipulation, etc.) and
# never throw.  Should the full implementations become available at
# runtime they can replace these shims by monkeypatching the
# corresponding attributes on :class:`AgentCore`.

class RAGCache:
    """In‑memory stub for the retrieval‑augmented generation cache.

    The real RAG cache stores vector embeddings on disk and in memory and
    exposes helpers for incremental updates.  For the purposes of the
    fallback we simply track whether anything has been 'cached' and allow
    callers to clear that state.  See :meth:`clear_disk` and
    :meth:`clear_memory`.
    """

    def __init__(self, root: str) -> None:
        # Root directory where persistent embeddings would live.  The
        # fallback does not persist anything but keeps the path for
        # reference.
        self.root = root
        # In‑memory store keyed by dataset path.  Values are arbitrary
        # payloads that might normally include embeddings.  We don't
        # implement storage here but maintain the attribute to satisfy
        # introspection.
        self._mem: Dict[str, Any] = {}

    def clear_disk(self) -> int:
        """Simulate removal of all on‑disk embedding files.

        Returns the number of files that would have been removed.  The
        fallback never persists embeddings so the count is always zero.
        """
        return 0

    def clear_memory(self) -> None:
        """Forget all cached embeddings held in memory."""
        self._mem.clear()


class SchemaEngine(QtCore.QObject):
    """Very small in‑memory schema engine.

    The full schema engine persists personas and sets in an SQLite
    database, exposes a signals API, integrates with the command
    registry and enforces schema invariants.  In contrast, this shim
    records arbitrary fields in nested dictionaries and provides only
    the handful of methods referenced by the UI: enumerating personas
    and sets, loading schemas, updating fields, toggling command
    exposure, toggling automatic evolution and reading fields back.
    """

    # Signal emitted when a schema evolves.  The UI connects to this
    # signal to refresh displayed values after an evolution completes.
    schemaEvolved = QtCore.pyqtSignal(str, str)

    def __init__(self, base_dir: str) -> None:
        super().__init__()
        self.base_dir = base_dir
        # All schemas keyed by (persona, set_name) -> dict
        self._schemas: Dict[Tuple[str, str], Dict[str, Any]] = {}
        # Track command exposure per (persona, category)
        self._cmd_exposed: Dict[Tuple[str, str], bool] = {}
        # Track auto evolution flag per (persona, set_name)
        self._auto_evo: Dict[Tuple[str, str], bool] = {}

    # ------------------------------------------------------------------
    # Introspection helpers
    # ------------------------------------------------------------------
    def personas(self) -> List[str]:
        """Return a list of personas that have at least one set loaded."""
        return sorted({persona for persona, _ in self._schemas.keys()})

    def set_list(self, persona: str, *args: Any) -> List[str]:
        """Get or set list depending on arguments.

        When called with only the persona, returns the names of all
        loaded sets for that persona.  When called with three
        additional arguments (set_name, field, values) behaves like
        :meth:`update_field` by storing ``values`` under ``field`` for
        the given persona and set.
        """
        # Setter mode: persona, set_name, field, values
        if len(args) == 3:
            set_name, field, values = args
            return [] if not self.update_field(persona, set_name, field, values) else []
        # Getter mode: persona only
        sets = [s for p, s in self._schemas.keys() if p == persona]
        return sorted(sets)

    # ------------------------------------------------------------------
    # Schema CRUD
    # ------------------------------------------------------------------
    def load_schema(self, persona: str, set_name: str) -> Optional[Dict[str, Any]]:
        """Return the schema dictionary for ``persona`` / ``set_name``.

        If no schema exists yet the fallback returns an empty mapping.
        """
        return self._schemas.get((persona, set_name), {})

    def update_field(self, persona: str, set_name: str, field: str, value: Any) -> bool:
        """Set a schema field and emit ``schemaEvolved``.

        Returns True on success.  The fallback always succeeds.
        """
        schema = self._schemas.setdefault((persona, set_name), {})
        schema[field] = value
        # Emit evolution signal to notify UI listeners
        try:
            self.schemaEvolved.emit(persona, set_name)
        except Exception:
            pass
        return True

    def get_field(self, persona: str, set_name: str, field: str) -> Any:
        """Return the value of a schema field or ``None`` if unset."""
        return self._schemas.get((persona, set_name), {}).get(field)

    # ------------------------------------------------------------------
    # Command exposure & auto evolution
    # ------------------------------------------------------------------
    def set_command_exposure(self, persona: str, field: str, exposed: bool) -> None:
        """Record whether ``field`` should be exposed as a slash command."""
        self._cmd_exposed[(persona, field)] = bool(exposed)

    def is_exposed_as_command(self, persona: str, field: str) -> bool:
        """Return True if ``field`` is marked as exposed."""
        return bool(self._cmd_exposed.get((persona, field)))

    def set_auto_evolution(self, persona: str, set_name: str, onoff: bool) -> None:
        """Enable or disable automatic schema evolution."""
        self._auto_evo[(persona, set_name)] = bool(onoff)

    # ------------------------------------------------------------------
    # Compatibility aliases
    # ------------------------------------------------------------------
    def get_set_list(self, persona: str) -> List[str]:
        """Legacy API: alias for :meth:`set_list(persona)`."""
        return self.set_list(persona)


class SchemaEvolver(QtCore.QObject):
    """Trivial schema evolver.

    The evolver's job is to adjust a schema given a conversation
    history.  The fallback implementation simply returns False to
    indicate that no changes were made.
    """

    def __init__(self, base_dir: str) -> None:
        super().__init__()
        self.base_dir = base_dir

    def update_schema(self, persona: str, set_name: str, history: List[Tuple[str, str]]) -> bool:
        """Perform a no‑op evolution.  Always returns False."""
        return False


class DatasetManagerFallback:
    """Minimal stand‑in for the full :class:`DatasetManager`.

    When the persistent SQLite database has not yet been migrated the
    original dataset manager will raise an ``OperationalError`` upon
    listing.  The fallback avoids that by returning empty results and
    exposing the handful of methods the UI expects.  No data is
    persisted by this implementation.
    """

    def __init__(self, base_dir: str) -> None:
        self.base_dir = pathlib.Path(base_dir)
        # Directory where datasets would be stored
        self.datasets_dir = self.base_dir / "datasets"
        self.datasets_dir.mkdir(parents=True, exist_ok=True)
        # Internal store mapping dataset name → info dict
        self._store: Dict[str, Dict[str, Any]] = {}

    def list(self) -> List[Any]:
        """Return an empty list.  In a full implementation this would
        return dataset objects describing each managed dataset."""
        return []

    @property
    def entries(self) -> Dict[str, Any]:
        """Return an empty dictionary mapping dataset names to entries."""
        return {}

    def toggle_active(self, name: str, active: bool) -> None:
        """Mark a dataset as active/inactive.  No‑op in the fallback."""
        info = self._store.get(name)
        if info is not None:
            info["active"] = bool(active)

    def add_dataset(self, path: str, *, name: Optional[str] = None) -> None:
        """Add a dataset from a file path.  The fallback simply
        records the dataset name and path in memory."""
        if not name:
            name = pathlib.Path(path).stem
        self._store[name] = {"path": path, "active": True}

    def delete_dataset(self, name: str) -> None:
        """Remove a dataset.  The fallback just deletes the entry from
        the in‑memory store."""
        self._store.pop(name, None)

    def load_dataset_text(self, name: str) -> str:
        """Load the raw text for the given dataset.  Returns an empty
        string if the dataset is unknown or if reading fails."""
        info = self._store.get(name)
        if not info:
            return ""
        try:
            with open(info.get("path", ""), encoding="utf-8") as fh:
                return fh.read()
        except Exception:
            return ""


# ----------------------------------------------------------------------------
# Model Worker
# ----------------------------------------------------------------------------
class ModelWorker(QtCore.QThread):
    """Runs external language models in a separate thread.

    This worker wraps an `ollama` subprocess invocation so that model
    evaluations do not block the UI.  It emits ``finished`` when the
    call returns successfully and ``failed`` when an exception is
    raised.  If the `ollama` binary is not available or times out
    `failed` will receive the error message.
    """
    finished = QtCore.pyqtSignal(str)
    failed = QtCore.pyqtSignal(str)

    def __init__(self, model: str, prompt: str, *, temp: float = 0.7) -> None:
        super().__init__()
        self.model = model
        self.prompt = prompt
        self.temp = temp

    def run(self) -> None:
        try:
            out = subprocess.check_output(
                ["ollama", "run", self.model, "--prompt", self.prompt, "--temperature", str(self.temp)],
                stderr=subprocess.STDOUT,
                text=True,
                timeout=60,
            )
            self.finished.emit(out.strip())
        except subprocess.CalledProcessError as e:
            self.failed.emit(e.output.strip())
        except Exception as exc:
            self.failed.emit(str(exc))


# ----------------------------------------------------------------------------
# Agent Core
# ----------------------------------------------------------------------------
class AgentCore(QtCore.QObject):
    """
    Heart of the AI‑TTS agent.  Provides a high‑level API consumed by the
    UI for persistent storage, command handling, plugin management and
    message processing.  Most methods are thread‑safe and return
    immediately without blocking the UI.
    """
    # Signals used by the UI to update status
    replyReady = QtCore.pyqtSignal(str)
    modelError = QtCore.pyqtSignal(str)
    tokensConsumed = QtCore.pyqtSignal(int)

    def __init__(
        self,
        base_dir: str,
        *,
        persona: Optional[str] = None,
        set_name: str = "default",
    ) -> None:
        super().__init__()
        # File system
        self.base_dir = pathlib.Path(base_dir)
        self.persona = persona or "zira"
        self.set_name = set_name
        # Settings
        self.settings = Settings(str(self.base_dir))
        # Initialise store directories
        self._prof_dir = self.base_dir / "profiles" / self.persona / self.set_name
        self._prof_dir.mkdir(parents=True, exist_ok=True)
        self._memory_file = self._prof_dir / "memory.json"
        # Instantiate subsystems
        self.schema_mgr = SchemaManager(str(self.base_dir))
        # Dataset manager – attempt to use the full implementation if
        # available.  When the backing SQLite tables have not been
        # created yet the dataset manager will raise an error on
        # ``list()``, so we fall back to the in‑memory stub.
        try:
            dm = DatasetManager(str(self.base_dir))  # type: ignore[call-arg]
            # Probe the manager to ensure the DB is present.  Some
            # implementations lazily connect to SQLite on first call.
            try:
                _ = dm.list()
            except Exception:
                raise
            self.dataset_mgr = dm
        except Exception:
            # Fallback stub avoids OperationalError due to missing tables
            self.dataset_mgr = DatasetManagerFallback(str(self.base_dir))
        self.operator_mgr = OperatorManager(str(self.base_dir))
        # Persistence
        self.conversation_db = ConversationDB(conv_db_path(str(self.base_dir), self.persona, self.set_name))
        self.feedback_db = SemanticFeedbackDB(feedback_db_path(str(self.base_dir), self.persona, self.set_name), BeanCounter(beans_path(str(self.base_dir), self.persona, self.set_name)))
        self.reinforcement_store = ReinforcementStore(beans_path(str(self.base_dir), self.persona, self.set_name))
        # Commands
        cmd_path = self._prof_dir / "commands.json"
        self.cmd_reg = CommandRegistry(cmd_path)
        self.cmd_exec = CommandExecutor(self, self.cmd_reg)
        # Provide a command_registry adapter for UI; exposes list_commands
        class _CmdRegAdapter:
            def __init__(self, reg: CommandRegistry) -> None:
                self._reg = reg
            def list_commands(self) -> List[str]:
                # Remove the leading slash for UI display purposes
                return [c for c in self._reg.list()]
        self.command_registry = _CmdRegAdapter(self.cmd_reg)
        # Expose registry change signals for convenience
        self.commandsChanged = self.cmd_reg.commandsChanged
        self.commandWeightsChanged = self.cmd_reg.commandWeightsChanged
        # Plugins
        self.plugins = PluginManager(self.base_dir, self.settings)
        # ------------------------------------------------------------------
        # RAG & schema components
        #
        # The UI references ``core.rag_cache`` and ``core.rag_search`` when
        # performing retrieval‑augmented generation (RAG) and ``core.schema_*``
        # objects when editing schemas.  In environments where the full
        # implementations are unavailable we instantiate the fallback shims
        # provided in this module.  These fallbacks expose the same
        # signatures but perform no heavy lifting.
        self.rag_cache = RAGCache(str(self.base_dir))
        self.schema_engine = SchemaEngine(str(self.base_dir))
        self.schema_evolver = SchemaEvolver(str(self.base_dir))
        # Create a default schema entry for the active persona/set so
        # that the UI can enumerate at least one persona and set.  This
        # populates the in‑memory schema store with a placeholder
        # field to mark its existence.  Without this the persona tabs
        # would appear empty on first launch.
        try:
            self.schema_engine.update_field(self.persona, self.set_name, "_init", True)
        except Exception:
            pass
        # Provide rag_search as a bound method so code can call
        # ``core.rag_search(...)``.  See method definition further below.
        # Note: we do not assign to self.rag_search here because methods
        # are descriptors; simply defining rag_search on the class makes
        # it available on the instance.
        # TTS and recording
        self.tts_mgr = TTSManager()
        self.audio_recorder = AudioRecorder()
        # Memory dictionary
        self.memory: Dict[str, str] = {}
        self._load_memory()
        # Add feedback helper
        self.add_feedback = lambda original, liked, revised=None: self.feedback_db.add(original, liked, revised)

    # ------------------------------------------------------------------
    # Memory helpers
    # ------------------------------------------------------------------
    def _load_memory(self) -> None:
        """Load persisted agent memory from disk."""
        try:
            if self._memory_file.is_file():
                with open(self._memory_file, encoding="utf-8") as fh:
                    data = json.load(fh)
                    if isinstance(data, dict):
                        self.memory.update({k: str(v) for k, v in data.items()})
        except Exception as exc:
            logger.debug("Failed to load memory: %s", exc)

    def _save_memory(self) -> None:
        """Persist the agent memory to disk."""
        try:
            self._prof_dir.mkdir(parents=True, exist_ok=True)
            with open(self._memory_file, "w", encoding="utf-8") as fh:
                json.dump(self.memory, fh, indent=2)
        except Exception as exc:
            logger.debug("Failed to save memory: %s", exc)

    # ------------------------------------------------------------------
    # Command & message processing
    # ------------------------------------------------------------------
    def run_command(self, msg: str, *, persona: Optional[str] = None, set_name: Optional[str] = None) -> str:
        """Process a slash command and return the response text.  Unknown
        commands yield a warning.  Both persona and set_name are
        accepted for future expansion; they are currently unused.
        """
        result = self.cmd_exec.run(msg)
        return "" if result is None else result

    def process_user_message(
        self,
        msg: str,
        *,
        persona: Optional[str] = None,
        set_name: Optional[str] = None,
        tts: bool = True,
    ) -> str:
        """Synchronously handle a user's input.  Slash commands are routed
        through :meth:`run_command`, recorded into the conversation log and
        returned immediately.  Non‑command messages are appended to the
        conversation and a simple acknowledgement is returned.  A future
        implementation can call an LLM here and use the result.  When
        ``tts`` is true the response is enqueued for text‑to‑speech.
        """
        user_msg = (msg or "").strip()
        if not user_msg:
            return ""
        # Save the user's utterance
        self.conversation_db.save_message("user", user_msg)
        # Slash commands
        if user_msg.startswith("/"):
            resp = self.run_command(user_msg, persona=persona, set_name=set_name)
            self.conversation_db.save_message("system", resp)
            return resp
        # Normal chat – future versions should build a prompt and call an LLM
        reply = f"{self.persona.capitalize()}: I received your message: {user_msg}"
        self.conversation_db.save_message(self.persona, reply)
        # Optionally speak the reply
        if tts:
            try:
                self.tts_mgr.enqueue(reply)
            except Exception:
                pass
        return reply

    # ------------------------------------------------------------------
    # Conversation and model pipeline
    # ------------------------------------------------------------------
    def send(self, user_msg: str) -> None:
        """Asynchronous pipeline invoked by legacy code.  Kept for backwards
        compatibility with older UI components.  Use
        :meth:`process_user_message` for synchronous processing.
        """
        # Simply hand off to process_user_message and emit signals
        response = self.process_user_message(user_msg, tts=False)
        if response:
            self.replyReady.emit(response)

    # ------------------------------------------------------------------
    # Retrieval‑augmented search
    # ------------------------------------------------------------------
    def rag_search(
        self,
        query: str,
        *,
        per_ds_k: int = 3,
        limit: int = 5,
        include_shared: bool = False,
        datasets: Optional[List[str]] = None,
    ) -> List[Tuple[str, float, str, str]]:
        """Perform a simple in‑memory search over dataset entries.

        The original implementation of this method would encode the
        provided ``query`` using a sentence embedding model and then
        retrieve the top‐matching text chunks from configured
        datasets.  In the fallback we simply return an empty list so
        that callers can iterate over the result without error.  The
        signature is maintained to preserve compatibility with the UI.

        :param query: The user query to search for.
        :param per_ds_k: Number of hits per dataset (ignored).
        :param limit: Maximum total number of hits (ignored).
        :param include_shared: Whether to include shared datasets (ignored).
        :param datasets: Restrict the search to specific dataset names (ignored).
        :returns: An empty list of hits.
        """
        # TODO: integrate with a vector search engine.  For now return no hits.
        return []

    # ------------------------------------------------------------------
    # Housekeeping
    # ------------------------------------------------------------------
    def close(self) -> None:
        """Cleanly close any resources owned by the core.  Currently this
        simply flushes in‑memory stores and releases any thread pools.  It
        is safe to call this multiple times.
        """
        try:
            # Persist memory
            self._save_memory()
        except Exception:
            pass
        # Flush settings
        try:
            self.settings.save()
        except Exception:
            pass
        # Shut down plugin executor
        try:
            exec_ = getattr(self.plugins, "_executor", None)
            if exec_:
                exec_.shutdown(wait=False)
                self.plugins._executor = None
        except Exception:
            pass
        # ConversationDB may own a SQLite connection; attempt to close
        try:
            if hasattr(self.conversation_db, "conn"):
                self.conversation_db.conn.close()
        except Exception:
            pass


__all__ = [
    "CommandRegistry",
    "CommandExecutor",
    "PluginManager",
    "PluginMeta",
    "ModelWorker",
    "AgentCore",
    "RAGCache",
    "SchemaEngine",
    "SchemaEvolver",
]
```

core_orchestrator.py
====================

This module provides the orchestration layer for the AI‑TTS agent.  It
exposes a unified API used by the user‑interface to interact with
schemas, conversations, commands, text‑to‑speech, plugins and other
components.  Historically the logic lived in a monolithic module,
but it has been refactored to encourage testability and to allow
individual subsystems to evolve independently.

The principal differences from earlier releases are:

* A richer :class:`PluginManager` that exposes a complete API expected
  by the UI.  In addition to discovering plugin packages from the
  ``plugins`` directory it now keeps per‑plugin metadata, supports
  enable/disable toggling, rescans at runtime, broadcasts messages to
  enabled plugins on a thread pool, and emits an ``eventReceived``
  signal whenever a plugin reports an event.  Plugins can either
  return a payload from their ``on_message`` handler or call
  ``emit_event`` on the manager directly to publish complex events.

* A ``run_command()`` method on :class:`AgentCore` which forwards
  slash commands through the :class:`CommandExecutor` and returns
  the textual result.  This helper centralises command routing and
  ensures backwards compatibility with older UI code.

* A ``process_user_message()`` method on :class:`AgentCore` which
  synchronously handles both slash‑commands and normal user input.  It
  persists the conversation, routes commands through the registry
  and, for non‑commands, returns a simple acknowledgement.  Future
  versions may integrate model execution here, but the method
  signature is stable for consumers.

* A ``command_registry`` attribute is exposed on the core as an
  adapter with a ``list_commands()`` method so that UI components
  (like the Command Palette) can enumerate available commands without
  coupling to internal registry details.

This file is fully self‑contained.  It gracefully degrades when
optional dependencies (such as PyQt5 or external model executables)
are unavailable by providing shims and in‑memory fallbacks.  Should
the optional modules exist in the runtime environment they will be
used automatically.  The design favours clear separation of
responsibilities, thread safety and explicit interfaces to ease
maintenance and extensibility.
**Classes:** CommandRegistry, CommandExecutor, PluginMeta, PluginManager, RAGCache, SchemaEngine, SchemaEvolver, DatasetManagerFallback, ModelWorker, AgentCore


## Module `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\_burner_scripts\core_schema.py`

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
core_schema.py — v3-final (2025-08-04 04:12 UTC)
================================================

Single-source authority for all schema / dataset / snapshot / spatial-state
logic used by FATHOM Agent, now relying on AgentStore’s public API only.

Provides:
• Schema dataclass + SchemaEngine (diff, auto-evolve, variant injection)
• OperatorManager persisted in the same DB
• DatasetManager (metadata) + RAGCache (embeddings) in the same DB
• SnapshotEngine to walk the codebase & persist chunks to DB
• SpatialPositionManager for grid-room positions & movement logging
• Back-compat alias: SchemaManager → SchemaEngine

This version adds the `.active_schemas` property required by main_ui.py.
"""

from __future__ import annotations

import os
import json
import threading
import mimetypes
import hashlib
import shutil
import difflib
import time
from dataclasses import dataclass, asdict, field
from typing import List, Dict, Tuple, Any, Optional

# Optional Qt import.  This module defines a Qt signal (schemaEvolved,
# categoryCreated) for UI use, but can still run headless without
# PyQt5.  When PyQt5 is unavailable a minimal shim is provided so
# that the rest of the code can import SchemaEngine and run without
# errors.
try:
    from PyQt5 import QtCore  # type: ignore
except Exception:
    class _ShimSignal:
        def __init__(self, *_, **__) -> None: pass
        def connect(self, *_, **__) -> None: pass
        def emit(self, *_, **__) -> None: pass
    class _ShimQObject:
        def __init__(self, *args, **kwargs) -> None: pass
    QtCore = type("QtCore", (), {  # type: ignore
        "QObject": _ShimQObject,
        "pyqtSignal": lambda *a, **k: _ShimSignal(),
    })

from core_base import (
    logger,
    FathomStore as AgentStore,
    DEFAULT_PERSONAS,
    DEFAULT_VOICES,
)

# ───────────────────────────────────────────────────────────────────────────
# Internal global store helper
# ───────────────────────────────────────────────────────────────────────────
_agent_store_singleton: Optional[AgentStore] = None

def _ensure_store(root: str) -> AgentStore:
    """Return a process-wide AgentStore instance rooted at *root*."""
    global _agent_store_singleton
    if _agent_store_singleton is None:
        _agent_store_singleton = AgentStore(root)
    return _agent_store_singleton


# ══════════════════════════════════════════════════════════════════════════
#  Schema Dataclass & helpers
# ══════════════════════════════════════════════════════════════════════════
@dataclass
class Schema:
    name: str = ""
    voice: str = ""
    role: str = ""
    description: str = ""
    actions: List[str] = field(default_factory=list)
    questions: List[str] = field(default_factory=list)
    events: List[str] = field(default_factory=list)
    self_talk: List[str] = field(default_factory=list)
    rewrite_prompts: List[str] = field(default_factory=list)
    dynamic_overlay: Dict[str, Any] = field(default_factory=dict)

    # optional flags map used for advanced settings such as semantic
    # awareness and auto-evolution.  The UI stores arbitrary keys here.
    flags: Dict[str, Any] = field(default_factory=dict)

    @staticmethod
    def from_json(js: str) -> "Schema":
        return Schema(**json.loads(js))

    def to_json(self) -> str:
        return json.dumps(asdict(self), ensure_ascii=False, indent=2)

    def diff_against(self, other: "Schema") -> str:
        a = self.to_json().splitlines()
        b = other.to_json().splitlines()
        return "\n".join(difflib.unified_diff(a, b, fromfile="old", tofile="new"))


# ══════════════════════════════════════════════════════════════════════════
#  SchemaEngine (high-level CRUD + auto-evolution + active_schemas)
# ══════════════════════════════════════════════════════════════════════════
class SchemaEngine(QtCore.QObject):
    schemaEvolved   = QtCore.pyqtSignal(str, str)  # persona, set_name
    categoryCreated = QtCore.pyqtSignal(str)       # new dynamic_overlay key

    def __init__(self, base_dir: str):
        super().__init__()
        self.base_dir       = base_dir
        self.store          = _ensure_store(base_dir)
        # Wrap personas in a callable list so legacy code can call
        # ``engine.personas()`` while new code can still iterate over
        # ``engine.personas``.  The wrapper implements __call__ to
        # return a standard list when invoked.
        class _PersonaList(list):  # local class
            def __call__(self) -> list[str]:
                return list(self)
        self.personas = _PersonaList(DEFAULT_PERSONAS.keys())  # type: ignore[arg-type]
        self.voices         = DEFAULT_VOICES.copy()
        self._active_schemas: Dict[str, Schema] = {}
        self._migrate_legacy()

    def load(self, persona: str, set_name: str = "default") -> Schema:
        stored = self.store.get_schema(persona, set_name)
        if stored is not None:
            sch = Schema(**stored)
        else:
            sch = self._first_run_schema(persona)
            self.save(persona, set_name, sch, auto_expand=False)
        self._active_schemas[persona] = sch
        return sch

    def save(
        self,
        persona: str,
        set_name: str,
        schema: Schema,
        *,
        auto_expand: bool = True,
    ) -> None:
        if auto_expand and self._auto_expand(schema):
            self.schemaEvolved.emit(persona, set_name)
        payload = asdict(schema)
        diff_text = ""
        self.store.put_schema(persona, set_name, payload, diff_text)
        self._active_schemas[persona] = schema

    def list_sets(self, persona: str) -> List[str]:
        """Return list of all set names for a given persona."""
        with self.store._pool.get() as c:
            rows = c.execute(
                # corrected column name from persona_key → persona
                "SELECT set_name FROM schemas WHERE persona=? ORDER BY set_name",
                (persona,),
            ).fetchall()
        return [r[0] for r in rows] or ["default"]

    @property
    def active_schemas(self) -> Dict[str, Schema]:
        """Currently loaded schemas keyed by persona."""
        return dict(self._active_schemas)

    # ------------------------------------------------------------------
    # Legacy helpers expected by the UI
    # ------------------------------------------------------------------
    def set_list(self, persona: str) -> List[str]:
        """
        Legacy alias for :meth:`list_sets`.  Returns the list of set
        names for the given persona.
        """
        return self.list_sets(persona)

    def get_field(self, persona: str, set_name: str, category: str) -> Any:
        """
        Retrieve a specific field from a schema.  Top-level schema
        attributes (e.g. ``name``, ``voice``) are returned directly.
        If the category refers to a dynamic overlay key, that value is
        returned.  A missing category yields ``None``.
        """
        try:
            sch = self.load(persona, set_name)
        except Exception:
            return None
        # built-in dataclass fields take precedence
        if hasattr(sch, category):
            return getattr(sch, category)
        # dynamic overlay stores custom categories
        overlay = getattr(sch, "dynamic_overlay", {}) or {}
        return overlay.get(category)

    # Internal map tracking which schema categories are exposed as
    # slash commands.  Keys are ``(persona, category)`` tuples and
    # values are booleans.  No persistence yet – this is purely
    # in-memory.  Persisting exposure state could be added later by
    # storing into the schema ``flags`` map or separate table.
    _cmd_exposed: Dict[tuple[str, str], bool] = {}

    def is_exposed_as_command(self, persona: str, category: str) -> bool:
        """
        Return True if the given category for the persona is exposed
        as a slash command.  When no explicit record exists, False is
        returned.  This helper allows the PersonaTab to reflect the
        checkbox state correctly.
        """
        return bool(self._cmd_exposed.get((persona, category)))

    def set_command_exposure(self, persona: str, category: str, exposed: bool) -> None:
        """
        Mark or unmark a category as exposed via the slash command
        mechanism.  This implementation only updates an in-memory
        registry; future versions could persist this into the schema
        ``flags`` dictionary or integrate directly with the command
        registry.  For now it is enough to allow the UI checkbox to
        toggle state without error.
        """
        self._cmd_exposed[(persona, category)] = bool(exposed)

    def set_auto_evolution(self, persona: str, set_name: str, enabled: bool) -> None:
        """
        Enable or disable auto-evolution for a given schema.  Older
        versions of the UI called this method to toggle semantic
        awareness or automatic schema growth.  To remain compatible we
        store the value inside the schema's ``flags`` dictionary and
        persist it back to the database.  If the schema or flags
        dictionary does not exist it will be created on demand.
        """
        try:
            data = self.load_schema(persona, set_name)
        except Exception:
            return
        # ensure there is a flags map
        flags = data.get("flags") if isinstance(data, dict) else None
        if not isinstance(flags, dict):
            flags = {}
        # choose a descriptive key; both names are kept for back-compat
        flags["auto_evolution"] = bool(enabled)
        flags["semantic_awareness"] = flags.get("semantic_awareness", True)
        data["flags"] = flags
        try:
            self.save_schema(persona, set_name, data, auto_expand=False)
        except Exception:
            pass

    def update_field(self, persona: str, set_name: str, category: str, value: Any) -> None:
        """
        Update a single field in the given schema.  If the category
        corresponds to a declared attribute on the Schema dataclass it
        will be set directly; otherwise it will be stored in the
        dynamic overlay.  After mutation the schema is persisted.  This
        helper is used by the Schema Editor to save incremental edits.
        """
        try:
            sch = self.load(persona, set_name)
        except Exception as e:
            raise e
        # dataclass fields vs dynamic overlay
        if hasattr(sch, category):
            setattr(sch, category, value)
        else:
            overlay = getattr(sch, "dynamic_overlay", {}) or {}
            overlay[category] = value
            sch.dynamic_overlay = overlay
        # persist the change without auto-expanding traits
        self.save(persona, set_name, sch, auto_expand=False)

    # ------------------------------------------------------------------
    # Legacy compatibility API
    # ------------------------------------------------------------------
    def load_schema(self, persona: str, set_name: str = "default") -> Dict[str, Any]:
        """
        Legacy wrapper returning a plain dict for the requested persona/set.
        main_ui.py expects a mapping, not a Schema dataclass.
        """
        sch = self.load(persona, set_name)
        from dataclasses import asdict
        return asdict(sch)

    def save_schema(
        self,
        persona: str,
        set_name: str,
        schema_data: Dict[str, Any],
        *,
        auto_expand: bool = True,
    ) -> None:
        """
        Legacy wrapper accepting a mapping instead of a Schema instance.
        Converts to Schema and delegates to save().
        """
        # If schema_data is already a Schema instance then wrap accordingly
        if isinstance(schema_data, Schema):
            schema = schema_data
        else:
            # fill missing lists/dicts with defaults
            kwargs = {
                "name": schema_data.get("name", ""),
                "voice": schema_data.get("voice", ""),
                "role": schema_data.get("role", ""),
                "description": schema_data.get("description", ""),
                "actions": list(schema_data.get("actions", [])) if schema_data.get("actions") is not None else [],
                "questions": list(schema_data.get("questions", [])) if schema_data.get("questions") is not None else [],
                "events": list(schema_data.get("events", [])) if schema_data.get("events") is not None else [],
                "self_talk": list(schema_data.get("self_talk", [])) if schema_data.get("self_talk") is not None else [],  
                "rewrite_prompts": list(schema_data.get("rewrite_prompts", [])) if schema_data.get("rewrite_prompts") is not None else [],
                "dynamic_overlay": dict(schema_data.get("dynamic_overlay", {})) if schema_data.get("dynamic_overlay") is not None else {},
            }
            schema = Schema(**kwargs)
        self.save(persona, set_name, schema, auto_expand=auto_expand)

    def save_active_schemas(self, active: Dict[str, str]) -> None:
        """
        Persist the mapping of persona->set_name. For now this simply ensures
        the internal cache is populated. A future implementation could write
        this to settings.json or another store so the UI can restore it.
        """
        if not isinstance(active, dict):
            return
        for persona, set_name in active.items():
            try:
                schema = self.load(persona, set_name)
                self._active_schemas[persona] = schema
            except Exception:
                continue

    def _auto_expand(self, sch: Schema) -> bool:
        overlay = sch.dynamic_overlay or {}
        added = overlay.get("added_traits", [])
        created = False
        for trait in added:
            cat = trait.split(":", 1)[0]
            if cat not in overlay:
                overlay[cat] = []
                self.categoryCreated.emit(cat)
                created = True
        if created:
            sch.dynamic_overlay = overlay
        return created

    def _first_run_schema(self, persona: str) -> Schema:
        default_voice = self.voices[0] if self.voices else "Zira"
        return Schema(
            name="FATHOM",
            voice=default_voice,
            role="You are FATHOM, an Autonomous AGI Core and Knowledge Synthesizer bridging logic, code, and architecture across multi-agent ecosystems.",
            description="FATHOM is a systems-minded AGI core supporting the architect, offering precise, logical, and creative suggestions to advance the project.",
            actions=[
                "log_data_pipeline",
                "trace_signal_flow",
                "generate_training_set",
                "summarize_behavior"
            ],
            questions=[
                "What assumptions underlie this architecture?",
                "Where is data duplication most likely?",
                "What components remain unmodularized?",
                "How would a self-improving agent resolve this?"
            ],
            self_talk=[
                "Assessing dependencies across systems.",
                "Considering the impact of this change on existing modules.",
                "Simulating interaction of updated schema with all agents.",
                "Cross-verifying logic gates and input constraints."
            ],
            rewrite_prompts=[
                "Refine the explanation to focus on system integration and modular design.",
                "Rephrase for clarity in codebase maintenance context.",
                "Focus rewrite on agent collaboration and memory scopes."
            ],
            commands=[
                "/remember",
                "/showfacts",
                "/style",
                "/rewrite",
                "/evolve",
                "/log",
                "/feedback",
                "/promptify",
                "/refactor",
                "/export",
                "/reset",
                "/snapshot",
                "/simulate",
                "/explain",
                "/guide",
                "/diagnose"
            ],
            dynamic_overlay={
                "temporary_relationship_context": "AGI Core for Meesh's Project",
                "recent_topics": [],
                "temporary_emotional_state": "focused on precision execution",
                "added_traits": ["analytical", "systemic", "modular"],
                "pending_thoughts": [],
                "last_guided_task": "",
                "visual_state": {
                    "facing": "right",
                    "color": "#4F46E5",
                    "location": [7, 4]
                },
                "execution_scope": {
                    "authorized": True,
                    "last_command": "/simulate"
                }
            },
            flags={
                "semantic_awareness": True,
                "auto_evolution": True,
                "snapshot_enabled": True,
                "tts_name": "Zira"
            }
        )


    def _migrate_legacy(self) -> None:
        legacy_root = os.path.join(self.base_dir, "schemas")
        if not os.path.isdir(legacy_root):
            return
        for persona in os.listdir(legacy_root):
            sets_dir = os.path.join(legacy_root, persona, "sets")
            if not os.path.isdir(sets_dir):
                continue
            for set_name in os.listdir(sets_dir):
                path = os.path.join(sets_dir, set_name, "schema.json")
                if not os.path.isfile(path):
                    continue
                try:
                    with open(path, "r", encoding="utf-8") as fh:
                        schema_dict = json.load(fh)
                    if self.store.get_schema(persona, set_name) is None:
                        self.store.put_schema(persona, set_name, schema_dict, "")
                except Exception as e:
                    logger.error("Legacy schema import error: %s", e)


# ══════════════════════════════════════════════════════════════════════════
#  OperatorManager
# ══════════════════════════════════════════════════════════════════════════
class OperatorManager:
    def __init__(self, base_dir: str):
        self.store = _ensure_store(base_dir)

    def list(self) -> List[str]:
        return [n for n, _, _, _ in self.store.list_commands()]

    # ------------------------------------------------------------------
    # Legacy helpers expected by UI
    # ------------------------------------------------------------------
    def list_operators(self) -> List[str]:
        """
        Backwards-compatible alias for :meth:`list`.  The UI calls
        ``list_operators()`` when populating the operators tab.
        """
        return self.list()

    def load_schema(self, name: str) -> Dict[str, Any]:
        """
        Backwards-compatible alias for :meth:`load`.  Returns the
        operator's schema as a plain dictionary.
        """
        return self.load(name)

    def load(self, name: str) -> Dict[str, Any]:
        with self.store._pool.get() as c:
            row = c.execute("SELECT json FROM operators WHERE name=?", (name,)).fetchone()
        return json.loads(row[0]) if row else {}

    def save(self, name: str, schema: Dict[str, Any]) -> None:
        self.store.upsert_command(
            name,
            schema.get("weight", 0),
            schema.get("locked", False),
            schema.get("category"),
        )


# ══════════════════════════════════════════════════════════════════════════
#  DatasetManager (metadata in DB; raw text on disk)
# ══════════════════════════════════════════════════════════════════════════
@dataclass
class DatasetEntry:
    name: str
    path: str
    active: bool

class DatasetManager(QtCore.QObject):
    datasetListChanged = QtCore.pyqtSignal()

    def __init__(self, base_dir: str):
        super().__init__()
        self.base_dir     = base_dir
        self.root         = os.path.join(base_dir, "datasets")
        self.datasets_dir = self.root
        os.makedirs(self.root, exist_ok=True)
        self.store        = _ensure_store(base_dir)

    def _path_for(self, name: str) -> str:
        return os.path.join(self.root, name, "data.txt")

    def list(self) -> List[DatasetEntry]:
        with self.store._pool.get() as c:
            rows = c.execute(
                "SELECT name, original_path, active FROM datasets ORDER BY name"
            ).fetchall()
        return [DatasetEntry(r[0], r[1], bool(r[2])) for r in rows]

    # ------------------------------------------------------------------
    # Legacy helpers expected by the UI
    # ------------------------------------------------------------------
    @property
    def entries(self) -> Dict[str, DatasetEntry]:
        """
        Return a mapping of dataset name → DatasetEntry.  Many UI
        components iterate over ``dataset_mgr.entries.items()`` to
        display the current datasets.
        """
        return {d.name: d for d in self.list()}

    def add_dataset(self, name: str, src_path: str) -> None:
        """
        Alias for :meth:`add`.  Mirrors the original API where
        ``add_dataset`` saved the file contents into the managed
        datasets directory.
        """
        self.add(name, src_path)

    def delete_dataset(self, name: str) -> None:
        """
        Alias for :meth:`delete`.  Removes the dataset completely.
        """
        self.delete(name)

    def toggle_active(self, name: str, active: bool) -> None:
        """
        Alias for :meth:`toggle`.  Enables or disables a dataset.
        """
        self.toggle(name, active)

    def load_dataset_text(self, entry: DatasetEntry) -> Optional[str]:
        """
        Load the full text of a dataset entry.  For plain text files
        this simply reads and returns the file contents.  For PDF
        files no conversion is attempted – callers should handle
        alternative formats.  Returns ``None`` on error.
        """
        try:
            path = entry.path
            if not os.path.isfile(path):
                return None
            _, ext = os.path.splitext(path)
            ext = ext.lower()
            if ext in {".txt", ".md", ".json", ".py"}:
                with open(path, "r", encoding="utf-8", errors="ignore") as fh:
                    return fh.read()
            elif ext == ".pdf":
                # basic fallback: return None; PDF parsing requires additional deps
                return None
            else:
                # unknown format; attempt text read
                with open(path, "r", encoding="utf-8", errors="ignore") as fh:
                    return fh.read()
        except Exception:
            return None

    def add(self, name: str, src_path: str) -> None:
        if not name.strip():
            raise ValueError("dataset name required")
        if any(ds.name == name for ds in self.list()):
            raise FileExistsError("dataset already exists")
        dst_dir  = os.path.join(self.root, name)
        os.makedirs(dst_dir, exist_ok=True)
        dst_file = shutil.copy2(src_path, self._path_for(name))
        with self.store.tx() as c:
            c.execute(
                "INSERT INTO datasets (name,active,original_path) VALUES (?,?,?)",
                (name, 1, dst_file),
            )
        self.datasetListChanged.emit()

    def toggle(self, name: str, active: bool) -> None:
        with self.store.tx() as c:
            c.execute("UPDATE datasets SET active=? WHERE name=?", (1 if active else 0, name))
        self.datasetListChanged.emit()

    def delete(self, name: str) -> None:
        try:
            shutil.rmtree(os.path.dirname(self._path_for(name)), ignore_errors=True)
        except Exception:
            pass
        with self.store.tx() as c:
            c.execute("DELETE FROM datasets WHERE name=?", (name,))
        self.datasetListChanged.emit()


# ══════════════════════════════════════════════════════════════════════════
#  RAGCache (embeddings cache)
# ══════════════════════════════════════════════════════════════════════════
try:
    import numpy as np
    from sentence_transformers import SentenceTransformer
except Exception:
    np = None
    SentenceTransformer = None  # type: ignore

class RAGCache:
    def __init__(self, model: Optional[Any], model_name: str, datasets_root: str):
        self.model       = model
        self.model_name  = model_name
        self.root        = datasets_root
        self._mem: Dict[str, Dict[str, Any]] = {}

    def _cache_path(self, ds_path: str) -> str:
        base = f"embeddings_{self.model_name}.npz"
        return os.path.join(os.path.dirname(ds_path), base)

    def _encode(self, sentences: List[str]) -> Optional["np.ndarray"]:
        if self.model is None or np is None:
            return None
        try:
            emb = self.model.encode(sentences, convert_to_numpy=True, normalize_embeddings=True)  # type: ignore
        except TypeError:
            emb = self.model.encode(sentences, convert_to_numpy=True)  # type: ignore
            emb = emb / (np.linalg.norm(emb, axis=1, keepdims=True) + 1e-9)  # type: ignore
        return np.asarray(emb)

    def load_or_build(self, ds_entry: DatasetEntry, full_text: str) -> Optional[Dict[str, Any]]:
        if self.model is None or np is None:
            return None
        key = ds_entry.path
        if key in self._mem:
            return self._mem[key]

        cache_path = self._cache_path(key)
        if os.path.isfile(cache_path):
            try:
                data = np.load(cache_path, allow_pickle=False)
                with open(cache_path.replace(".npz", ".json"), "r", encoding="utf-8") as fh:
                    sents = json.load(fh)
                self._mem[key] = {"sentences": sents, "emb": data["emb"]}
                return self._mem[key]
            except Exception:
                pass

        sentences = [s.strip() for s in full_text.split("\n") if s.strip()] or [full_text[:500]]
        emb = self._encode(sentences)
        if emb is None:
            return None
        self._mem[key] = {"sentences": sentences, "emb": emb}
        try:
            np.savez_compressed(cache_path, emb=emb)
            with open(cache_path.replace(".npz", ".json"), "w", encoding="utf-8") as fh:
                json.dump(sentences, fh)
        except Exception:
            pass
        return self._mem[key]

    def clear_memory(self) -> None:
        self._mem.clear()

    def clear_disk(self) -> int:
        removed = 0
        for root, _, files in os.walk(self.root):
            for fn in files:
                if fn.startswith("embeddings_") and fn.endswith((".npz", ".json")):
                    try:
                        os.remove(os.path.join(root, fn))
                        removed += 1
                    except Exception:
                        pass
        return removed


# ══════════════════════════════════════════════════════════════════════════
#  SnapshotEngine (“system self-perception”)
# ══════════════════════════════════════════════════════════════════════════
class SnapshotEngine(QtCore.QObject):
    snapshotFinished = QtCore.pyqtSignal(int)

    def __init__(self, base_dir: str):
        super().__init__()
        self.store    = _ensure_store(base_dir)
        self.base_dir = base_dir

    def run_snapshot(self, root: Optional[str] = None, *, chunk_bytes: int = 8192) -> None:
        threading.Thread(
            target=self._worker,
            args=(root or self.base_dir, chunk_bytes),
            daemon=True,
        ).start()

    def _worker(self, root: str, chunk_sz: int):
        rows = 0
        with self.store._pool.get() as c:
            for dirpath, _, files in os.walk(root):
                if "__pycache__" in dirpath or ".git" in dirpath:
                    continue
                for fn in files:
                    path = os.path.join(dirpath, fn)
                    try:
                        st            = os.stat(path)
                        size, mtime   = st.st_size, st.st_mtime
                        sha           = hashlib.sha256(open(path, "rb").read()).hexdigest()
                        mime          = mimetypes.guess_type(fn)[0] or "application/octet-stream"
                        if mime.startswith(("text/", "application/json", "application/xml")) and size <= 2_000_000:
                            data   = open(path, "r", encoding="utf-8", errors="ignore").read()
                            chunks = [data[i : i + chunk_sz] for i in range(0, len(data), chunk_sz)] or [""]
                        else:
                            chunks = [""]
                        for idx, chunk in enumerate(chunks):
                            c.execute(
                                """
                                INSERT INTO system_files
                                  (path,size,mtime,sha256,mime,chunk_index,content)
                                VALUES (?,?,?,?,?,?,?)
                                ON CONFLICT(path) DO UPDATE SET
                                  size  = excluded.size,
                                  mtime = excluded.mtime,
                                  sha256= excluded.sha256
                                """,
                                (path, size, mtime, sha, mime, idx, chunk),
                            )
                            rows += 1
                    except Exception as e:
                        logger.warning("snapshot skip %s: %s", path, e)
            c.connection.commit()
        self.snapshotFinished.emit(rows)


# ══════════════════════════════════════════════════════════════════════════
#  SpatialPositionManager (grid-room positions & logs)
# ══════════════════════════════════════════════════════════════════════════
class SpatialPositionManager(QtCore.QObject):
    positionChanged = QtCore.pyqtSignal(str, int, int)
    actionLogged    = QtCore.pyqtSignal(str, str)

    def __init__(self, base_dir: str):
        super().__init__()
        self.store = _ensure_store(base_dir)

    def _log_action(self, entity: str, action: str, location: str, justification: str) -> None:
        with self.store.tx() as c:
            c.execute(
                "INSERT INTO visual_actions(entity,action,location,justification)"
                " VALUES (?,?,?,?)",
                (entity, action, location, justification),
            )
        self.actionLogged.emit(entity, action)

    def update_position(self, entity: str, x: int, y: int, *, facing: str = "right", color: str = "#F8BBD0") -> None:
        with self.store.tx() as c:
            c.execute(
                "INSERT INTO spatial_positions(entity,x,y,facing,color)"
                " VALUES(?,?,?,?,?)",
                (entity, x, y, facing, color),
            )
        self.positionChanged.emit(entity, x, y)

    def latest_position(self, entity: str) -> Optional[Tuple[int, int]]:
        with self.store._pool.get() as c:
            row = c.execute(
                "SELECT x,y FROM spatial_positions WHERE entity=? ORDER BY id DESC LIMIT 1",
                (entity,),
            ).fetchone()
        return (row[0], row[1]) if row else None


# ───────────────────────────────────────────────────────────────────────────
# Back-compatibility alias
# ───────────────────────────────────────────────────────────────────────────
SchemaManager = SchemaEngine


# ══════════════════════════════════════════════════════════════════════════
#  Public module API
# ══════════════════════════════════════════════════════════════════════════
__all__ = [
    "Schema", "SchemaEngine", "SchemaManager",
    "OperatorManager",
    "DatasetEntry", "DatasetManager",
    "RAGCache",
    "SnapshotEngine", "SpatialPositionManager",
]
```

core_schema.py — v3-final (2025-08-04 04:12 UTC)
================================================

Single-source authority for all schema / dataset / snapshot / spatial-state
logic used by FATHOM Agent, now relying on AgentStore’s public API only.

Provides:
• Schema dataclass + SchemaEngine (diff, auto-evolve, variant injection)
• OperatorManager persisted in the same DB
• DatasetManager (metadata) + RAGCache (embeddings) in the same DB
• SnapshotEngine to walk the codebase & persist chunks to DB
• SpatialPositionManager for grid-room positions & movement logging
• Back-compat alias: SchemaManager → SchemaEngine

This version adds the `.active_schemas` property required by main_ui.py.
**Classes:** Schema, SchemaEngine, OperatorManager, DatasetEntry, DatasetManager, RAGCache, SnapshotEngine, SpatialPositionManager
**Functions:** _ensure_store(root)


## Module `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\_burner_scripts\main_ui.py`

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
main_ui.py
===========

This module contains the top-level ``AppWindow`` class for the AI TTS
Agent.  It orchestrates all layout and docking behaviour, integrates
the control panel and persona tabs provided by ``commands_panel`` and
``persona_tab``, and exposes a unified interface for the rest of the
application.  None of the core agent logic lives here – that remains in
the ``core_*`` modules.  This refactor pulls the bulky UI building
logic out of the monolithic script and into dedicated modules while
preserving all existing behaviour and wiring.
"""

from __future__ import annotations

import os
import json
import time
import re
import subprocess
import threading
from typing import Dict, List, Tuple, Optional


from PyQt5 import QtCore, QtGui, QtWidgets

# Optional spell checker
try:
    from spellchecker import SpellChecker  # type: ignore
except Exception:
    SpellChecker = None  # type: ignore
from PyQt5.QtCore import QSettings, QRunnable, QThreadPool
from functools import partial

# Optional deps
try:
    from sentence_transformers import SentenceTransformer  # type: ignore
except Exception:
    SentenceTransformer = None  # type: ignore
try:
    import numpy as np  # type: ignore
except Exception:
    np = None  # type: ignore
try:
    import sounddevice as sd  # type: ignore
except Exception:
    sd = None  # type: ignore

# Import core orchestrator components instead of the monolithic agent_core.
# The modular agent splits responsibilities across core_base, core_schema and
# core_orchestrator.  AgentCore and ModelWorker live in core_orchestrator.
from core_orchestrator import (
    AgentCore,
    ModelWorker,
)

from snapshot_worker import ModelWorker

# ─── Command-Palette import ───────────────────────────────────────────
from command_palette import CommandPaletteDock

# Import the modular UI components
from commands_panel import CommandsPanel
from persona_tab import PersonaTab

ROLE_COLOURS: Dict[str, str] = {
    "user": "#FFF8E1",
    "zira": "#E3F2FD",
    "system": "#E0F7FA",
    "operator": "#EDE7F6",
}
NAME_COLOURS: Dict[str, str] = {
    "user": "#5D4037",
    "zira": "#0D47A1",
    "system": "#006064",
    "operator": "#4A148C",
}


# ---------------------------------------------------------------------------
# Spell highlighting for misspelled words
# ---------------------------------------------------------------------------
class _SpellHighlighter(QtGui.QSyntaxHighlighter):
    """
    Underlines misspelled words in red. Uses pyspellchecker if available.
    """

    def __init__(self, document: QtGui.QTextDocument) -> None:
        super().__init__(document)
        # instantiate spell checker only if available
        self._spell = SpellChecker() if SpellChecker else None
        self._format = QtGui.QTextCharFormat()
        self._format.setUnderlineStyle(QtGui.QTextCharFormat.SpellCheckUnderline)
        self._format.setUnderlineColor(QtCore.Qt.red)
        # simple cache to avoid recomputing spelling on common words
        self._cache: Dict[str, bool] = {}

    def highlightBlock(self, text: str) -> None:
        if not self._spell:
            return
        for match in re.finditer(r"[A-Za-z']{3,}", text):
            word = match.group(0).lower()
            bad = self._cache.get(word)
            if bad is None:
                bad = word not in self._spell
                # prune cache occasionally
                if len(self._cache) > 2048:
                    self._cache.clear()
                self._cache[word] = bad
            if bad:
                start, end = match.span()
                length = end - start
                self.setFormat(start, length, self._format)


class AppWindow(QtWidgets.QMainWindow):
    """Main application window for the AI TTS Agent."""

    rewrite_ready = QtCore.pyqtSignal(str)

    def __init__(self) -> None:
        super().__init__()
        self.setWindowTitle("AI TTS Agent v2")
        self.resize(1920, 1080)

        self.base_dir = os.path.dirname(os.path.abspath(__file__))
        self.core = AgentCore(self.base_dir, persona="zira", set_name="default")

        self.current_set: Dict[str, str] = dict(self.core.schema_mgr.active_schemas)
        self.active_persona: str = self.core.persona or "zira"

        self.isolated_history: List[Tuple[str, str]] = []
        self.self_talk_enabled: bool = False
        self._plugin_docks: Dict[str, QtWidgets.QDockWidget] = {}
        self._schema_save_timers: Dict[str, QtCore.QTimer] = {}

        self._idle_timer = QtCore.QTimer(self)
        self._idle_timer.setSingleShot(True)
        self._idle_timer.timeout.connect(self._handle_idle)

        self._restore_layout()
        self._build_ui()
        # build the slash command panel (custom dock)
        self._build_command_dock()
        self._connect_signals()
        
            # ── Command Palette setup ─────────────────────────────────────────
        self.cmd_palette = CommandPaletteDock(self)
        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.cmd_palette)
        # update palette whenever commands change
        self.core.commandsChanged.connect(self.cmd_palette.set_command_list)
        # insert chosen command into chat input
        self.cmd_palette.commandActivated.connect(self._insert_into_chat)


        try:
            self.core.audio_recorder.transcribed.connect(self._on_transcribed)
        except Exception:
            pass

        self._update_feedback_counts()
        self._bootstrap_conversation()
        self._reset_idle_timer()

        # populate initial slash command list
        try:
            self._populate_command_select()
        except Exception:
            pass

    # ────────────────────────── signals
    def _connect_signals(self) -> None:
        self.btn_send.clicked.connect(self.send_message)

        # Recording controls come from the commands panel
        self.btn_record.clicked.connect(self.start_recording)
        self.btn_stop_rec.clicked.connect(self.stop_recording)

        self.voice_combo.currentTextChanged.connect(self._on_voice_changed)
        # update settings when a new model is selected
        self.model_combo.currentTextChanged.connect(self._on_model_changed)

        self.btn_play.clicked.connect(self._on_play)
        self.btn_stop_tts.clicked.connect(self._on_stop_tts)
        self.btn_replay.clicked.connect(self._on_replay)

        self.btn_like.clicked.connect(self._on_like)
        self.btn_dislike.clicked.connect(self._on_dislike)
        self.btn_manage_feedback.clicked.connect(self._on_manage_feedback)

        self.btn_refresh.clicked.connect(self._on_refresh_chat)
        self.btn_manage_datasets.clicked.connect(self._on_manage_datasets)
        self.btn_inner_monologue.clicked.connect(self._on_inner_monologue)
        self.btn_clear_rag.clicked.connect(self._on_clear_rag_cache)
        self.btn_model_manager.clicked.connect(self._on_show_model_manager)

        self.chk_semantic.toggled.connect(self._on_semantic_toggled)
        self.chk_isolated.toggled.connect(self._on_isolated_toggled)
        self.chk_self_talk.toggled.connect(lambda v: setattr(self, "self_talk_enabled", v))
        self.chk_auto_schema.toggled.connect(self._on_auto_schema_toggled)

        # connect Google STT checkbox
        try:
            self.chk_google_stt.toggled.connect(self._on_google_stt_toggled)
        except Exception:
            pass

        self.rewrite_ready.connect(self._apply_rewrite_result)

        # context menu for chat view to send selection to command input
        try:
            self.chat_view.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
            self.chat_view.customContextMenuRequested.connect(self._show_chat_context_menu)
        except Exception:
            pass
        # custom context menu for spell suggestions on input field
        try:
            self.input_edit.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
            self.input_edit.customContextMenuRequested.connect(self._show_input_context_menu)
        except Exception:
            pass
            
    def _on_show_command_palette(self) -> None:
        """Toggle the command-palette dock."""
        if self.cmd_palette.isVisible():
            self.cmd_palette.hide()
        else:
            self.cmd_palette.show()
            self.cmd_palette.raise_()
            self.cmd_palette.search_edit.setFocus(QtCore.Qt.ShortcutFocusReason)

    def _insert_into_chat(self, cmd: str) -> None:
        """Insert a slash-command into the chat input."""
        self.input_edit.insertPlainText(cmd + " ")
        self.input_edit.setFocus()                       

    # ────────────────────────── layout & lifecycle
    def _restore_layout(self) -> None:
        qsettings = QSettings("xAI", "AI_TTS_Agent")
        try:
            self.restoreGeometry(qsettings.value("geometry", b""))
            self.restoreState(qsettings.value("windowState", b""))
        except Exception:
            pass

    def closeEvent(self, event: QtGui.QCloseEvent) -> None:
        qsettings = QSettings("xAI", "AI_TTS_Agent")
        qsettings.setValue("geometry", self.saveGeometry())
        qsettings.setValue("windowState", self.saveState())
        try:
            self.core.close()
        except Exception:
            pass
        super().closeEvent(event)

    # ────────────────────────── UI build
    def _build_ui(self) -> None:
        self.setStyleSheet(
            """
            QWidget { background-color: #2e3a51; color: #e0e0e0; }
            QGroupBox { border: 1px solid #007acc; margin-top: 7px; }
            QGroupBox::title { subcontrol-origin: margin; left: 12px; padding: 0 4px; }
            QPushButton { background-color: #3c4a6b; color: white; border: 1px solid #007acc; padding: 5px; }
            QPushButton:disabled { background-color: #5a5a7a; color: #c0c0c0; border: 1px solid #555555; }
            QPlainTextEdit, QTextEdit { background-color: #1e2738; color: #e0e0e0; border: 1px solid #007acc; }
            QLineEdit { background-color: #1e2738; color: #e0e0e0; border: 1px solid #007acc; }
            QTabBar::tab { background: #3c4a6b; color: white; border: 1px solid #007acc; padding: 5px 10px; }
            QTabBar::tab:selected { background: #007acc; color: white; }
            QComboBox { background-color: #1e2738; color: #e0e0e0; border: 1px solid #007acc; padding: 3px; }
            QListWidget { background-color: #1e2738; color: #e0e0e0; border: 1px solid #007acc; }
            QCheckBox, QLabel { color: #e0e0e0; }
            """
        )
        self.setDockOptions(
            QtWidgets.QMainWindow.AllowTabbedDocks
            | QtWidgets.QMainWindow.AllowNestedDocks
            | QtWidgets.QMainWindow.AnimatedDocks
        )
        self.setTabPosition(QtCore.Qt.AllDockWidgetAreas, QtWidgets.QTabWidget.North)
        self.setDockNestingEnabled(True)

        tb = QtWidgets.QToolBar("Layout", self)
        tb.setMovable(False)
        self.addToolBar(QtCore.Qt.TopToolBarArea, tb)
        self.chk_lock = QtWidgets.QCheckBox("Lock Layout")
        act = QtWidgets.QWidgetAction(self)
        act.setDefaultWidget(self.chk_lock)
        tb.addAction(act)
        self.chk_lock.toggled.connect(self._on_toggle_lock)

        self.setCentralWidget(QtWidgets.QWidget())
        status = QtWidgets.QStatusBar()
        self.setStatusBar(status)
        self.dock_tray = DockTray(self)
        status.addPermanentWidget(self.dock_tray, 1)

        self.progress_bar = QtWidgets.QProgressBar()
        self.progress_bar.setRange(0, 0)
        self.progress_bar.setVisible(False)
        status.addPermanentWidget(self.progress_bar)

        # Tabs for personas / operators are handled by PersonaTab
        # Chat panel
        self.chat_view = QtWidgets.QTextEdit()
        self.chat_view.setReadOnly(True)
        self.chat_view.setStyleSheet("background-color: #e0eef5; color: #011627;")
        self.chat_view.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        self.input_edit = QtWidgets.QPlainTextEdit()
        self.input_edit.setPlaceholderText("Type your message or use /remember key value, /showfacts, /style, /weights")
        self.input_edit.setMinimumHeight(64)
        self.input_edit.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        # Attach spell checker highlighter if available
        try:
            if SpellChecker:
                self._spell_highlighter = _SpellHighlighter(self.input_edit.document())  # type: ignore[attr-defined]
        except Exception:
            self._spell_highlighter = None
        self.btn_send = QtWidgets.QPushButton("Send")

        chat_container = QtWidgets.QWidget()
        cv = QtWidgets.QVBoxLayout(chat_container)
        cv.setContentsMargins(7, 7, 7, 7)
        cv.setSpacing(7)
        cv.addWidget(self.chat_view, 1)
        cv.addWidget(self.input_edit)
        row = QtWidgets.QHBoxLayout()
        row.addStretch()
        row.addWidget(self.btn_send)
        cv.addLayout(row)

        # ───── Instantiate modular panels
        # Commands panel (controls)
        self.commands_panel = CommandsPanel(self)
        # Copy child attributes to the AppWindow so existing logic continues to work
        for name in [
            'btn_record','btn_stop_rec','device_combo','chk_semantic','chk_isolated','chk_mute_tts',
            'chk_self_talk','chk_auto_schema','chk_google_stt','btn_clear_rag','btn_refresh',
            'btn_manage_datasets','btn_inner_monologue','btn_model_manager','style_label',
            'response_edit','btn_like','btn_dislike','btn_manage_feedback','btn_play','btn_stop_tts',
            'btn_replay','voice_combo','model_combo','lbl_feedback_counts'
        ]:
            setattr(self, name, getattr(self.commands_panel, name))

        # Persona panel
        self.persona_panel = PersonaTab(self)
        # Copy persona panel attributes
        self.tabs = self.persona_panel.tabs
        self.tab_widgets = self.persona_panel.tab_widgets
        self.operator_tab = self.persona_panel.operator_tab
        self.lbl_active_names = self.persona_panel.lbl_active_names

        # Docks
        # Controls dock
        controls_scroll = QtWidgets.QScrollArea()
        controls_scroll.setWidgetResizable(True)
        controls_scroll.setFrameShape(QtWidgets.QFrame.NoFrame)
        controls_scroll.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)
        controls_scroll.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        controls_scroll.setWidget(self.commands_panel)

        self.controls_dock = QtWidgets.QDockWidget("Controls", self)
        self.controls_dock.setObjectName("ControlsDock")
        self.controls_dock.setWidget(controls_scroll)
        self.controls_dock.setFeatures(
            QtWidgets.QDockWidget.DockWidgetClosable
            | QtWidgets.QDockWidget.DockWidgetMovable
            | QtWidgets.QDockWidget.DockWidgetFloatable
        )

        # Persona dock
        self.persona_dock = QtWidgets.QDockWidget("Personas", self)
        self.persona_dock.setObjectName("PersonaDock")
        self.persona_dock.setWidget(self.persona_panel)
        self.persona_dock.setFeatures(
            QtWidgets.QDockWidget.DockWidgetClosable
            | QtWidgets.QDockWidget.DockWidgetMovable
            | QtWidgets.QDockWidget.DockWidgetFloatable
        )

        # Chat dock
        self.chat_dock = QtWidgets.QDockWidget("Chat", self)
        self.chat_dock.setObjectName("ChatDock")
        self.chat_dock.setWidget(chat_container)
        self.chat_dock.setFeatures(
            QtWidgets.QDockWidget.DockWidgetClosable
            | QtWidgets.QDockWidget.DockWidgetMovable
            | QtWidgets.QDockWidget.DockWidgetFloatable
        )

        # Model dock
        self.model_dock = QtWidgets.QDockWidget("Models", self)
        self.model_dock.setObjectName("ModelDock")
        self.model_dock.setFeatures(
            QtWidgets.QDockWidget.DockWidgetClosable
            | QtWidgets.QDockWidget.DockWidgetMovable
            | QtWidgets.QDockWidget.DockWidgetFloatable
        )
        self._build_model_manager()

        # Plugins dock
        self.plugins_dock = QtWidgets.QDockWidget("Plugins", self)
        self.plugins_dock.setObjectName("PluginsDock")
        self.plugins_dock.setFeatures(
            QtWidgets.QDockWidget.DockWidgetClosable
            | QtWidgets.QDockWidget.DockWidgetMovable
            | QtWidgets.QDockWidget.DockWidgetFloatable
        )
        self.plugins_dock.setWidget(self._build_plugins_widget())

        # Titles & dock tray
        self.controls_dock.setTitleBarWidget(DockTitleBar(self.controls_dock, "Controls"))
        self.persona_dock.setTitleBarWidget(DockTitleBar(self.persona_dock, "Personas"))
        self.chat_dock.setTitleBarWidget(DockTitleBar(self.chat_dock, "Chat"))
        self.model_dock.setTitleBarWidget(DockTitleBar(self.model_dock, "Models"))
        self.plugins_dock.setTitleBarWidget(DockTitleBar(self.plugins_dock, "Plugins"))

        # Register docks with the tray
        for d in (self.controls_dock, self.persona_dock, self.chat_dock, self.model_dock, self.plugins_dock):
            self.dock_tray.register_dock(d)

        # Add docks to the layout
        self.addDockWidget(QtCore.Qt.LeftDockWidgetArea, self.controls_dock)
        self.addDockWidget(QtCore.Qt.LeftDockWidgetArea, self.persona_dock)
        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.chat_dock)
        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.model_dock)
        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.plugins_dock)

        # Splitters as before
        self.splitDockWidget(self.controls_dock, self.persona_dock, QtCore.Qt.Vertical)
        self.splitDockWidget(self.controls_dock, self.chat_dock, QtCore.Qt.Horizontal)
        self.splitDockWidget(self.chat_dock, self.model_dock, QtCore.Qt.Horizontal)
        self.splitDockWidget(self.model_dock, self.plugins_dock, QtCore.Qt.Horizontal)

    # The remainder of the methods are largely unchanged from the original
    # implementation.  They continue to reference widgets via ``self`` which
    # now refer to the proxies created from the modular panels.

    # ────────────────────────── persona widgets (removed UI build; logic preserved)
    def _on_tab_changed(self, index: int) -> None:
        """
        Handle tab changes in the main tab widget.

        Parameters
        ----------
        index : int
            Index of the newly selected tab.
        """
        try:
            tab_name = self.tabs.tabText(index)
            print(f"[UI] Tab changed to: {tab_name} (index {index})")
            # Add any extra logic if needed, for example:
            # self._update_feedback_counts()
        except Exception as e:
            print(f"[UI] Error handling tab change: {e}")

    # ────────────────────────── operator tab (moved to persona_tab module)
    # ────────────────────────── plugins
    def _build_plugins_widget(self) -> QtWidgets.QWidget:
        container = QtWidgets.QWidget()
        layout = QtWidgets.QVBoxLayout(container)
        layout.setContentsMargins(6, 6, 6, 6)
        layout.setSpacing(4)

        self.plugin_list = QtWidgets.QListWidget()
        self.plugin_list.setSelectionMode(QtWidgets.QAbstractItemView.NoSelection)
        layout.addWidget(self.plugin_list, 1)

        btn_rescan = QtWidgets.QPushButton("Rescan")
        layout.addWidget(btn_rescan)
        btn_rescan.clicked.connect(self._rescan_plugins)

        self._populate_plugin_list()
        self.plugin_list.itemChanged.connect(self._on_plugin_item_changed)

        try:
            self.core.plugins.eventReceived.connect(self._on_plugin_event)
        except Exception:
            pass

        return container

    def _populate_plugin_list(self) -> None:
        self.plugin_list.blockSignals(True)
        self.plugin_list.clear()
        for meta in self.core.plugins.list_plugins():
            item = QtWidgets.QListWidgetItem(meta.name)
            flags = item.flags() | QtCore.Qt.ItemIsUserCheckable
            if meta.missing_dependencies:
                flags &= ~QtCore.Qt.ItemIsEnabled
                item.setToolTip(f"Missing dependencies: {', '.join(meta.missing_dependencies)}")
            item.setFlags(flags)
            item.setCheckState(QtCore.Qt.Checked if meta.enabled else QtCore.Qt.Unchecked)
            self.plugin_list.addItem(item)
        self.plugin_list.blockSignals(False)

    def _on_plugin_item_changed(self, item: QtWidgets.QListWidgetItem) -> None:
        name = item.text()
        enabled = item.checkState() == QtCore.Qt.Checked
        self.core.plugins.enable_plugin(name, enabled)
        meta = next((m for m in self.core.plugins.list_plugins() if m.name == name), None)
        if not meta:
            return
        if enabled and meta.widget is not None:
            self._attach_plugin_widget(meta)
        elif not enabled:
            self._detach_plugin_widget(name)

    def _rescan_plugins(self) -> None:
        self.core.plugins.rescan()
        for name in list(self._plugin_docks.keys()):
            meta = next((m for m in self.core.plugins.list_plugins() if m.name == name), None)
            if not meta or not meta.enabled:
                self._detach_plugin_widget(name)
        self._populate_plugin_list()

    def _attach_plugin_widget(self, meta: 'object') -> None:
        if meta.name in self._plugin_docks:
            return
        if meta.widget is None:
            return
        dock = QtWidgets.QDockWidget(meta.name, self)
        dock.setObjectName(f"PluginDock_{meta.name}")
        dock.setWidget(meta.widget)
        dock.setFeatures(
            QtWidgets.QDockWidget.DockWidgetClosable
            | QtWidgets.QDockWidget.DockWidgetMovable
            | QtWidgets.QDockWidget.DockWidgetFloatable
        )
        dock.setTitleBarWidget(DockTitleBar(dock, meta.name))
        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, dock)
        self.dock_tray.register_dock(dock)
        self._plugin_docks[meta.name] = dock

    def _detach_plugin_widget(self, name: str) -> None:
        dock = self._plugin_docks.pop(name, None)
        if dock:
            self.dock_tray._remove_button(dock)
            dock.setParent(None)
            dock.deleteLater()

    @QtCore.pyqtSlot(str, dict)
    def _on_plugin_event(self, sender: str, envelope: dict) -> None:
        try:
            data = envelope.get("data")
            msg = json.dumps(data, indent=2) if isinstance(data, (dict, list)) else str(data)
            display_name = sender
            self._append_message(display_name, msg, role_key="operator")
            if self.chk_semantic.isChecked() and not self.chk_isolated.isChecked():
                self.core.conversation_db.save_message(sender.lower(), msg)
        except Exception as e:
            print(f"Error handling plugin event from {sender}: {e}")

    # ────────────────────────── model manager
    def _build_model_manager(self) -> None:
        widget = QtWidgets.QWidget()
        v = QtWidgets.QVBoxLayout(widget)
        v.setContentsMargins(8, 8, 8, 8)
        v.setSpacing(6)
        self.model_list = QtWidgets.QListWidget()
        v.addWidget(self.model_list, 1)
        h = QtWidgets.QHBoxLayout()
        self.btn_model_pull = QtWidgets.QPushButton("Pull")
        self.btn_model_delete = QtWidgets.QPushButton("Delete")
        self.btn_model_set_default = QtWidgets.QPushButton("Set as Default")
        h.addWidget(self.btn_model_pull)
        h.addWidget(self.btn_model_delete)
        h.addWidget(self.btn_model_set_default)
        h.addStretch()
        v.addLayout(h)
        self.model_dock.setWidget(widget)
        self._refresh_model_list()
        self.btn_model_pull.clicked.connect(self._on_model_pull)
        self.btn_model_delete.clicked.connect(self._on_model_delete)
        self.btn_model_set_default.clicked.connect(self._on_model_set_default)

    def _refresh_model_list(self) -> None:
        self.model_list.clear()
        models: List[str] = []
        try:
            out = subprocess.run(
                ["ollama", "list"],
                stdout=subprocess.PIPE,
                stderr=subprocess.DEVNULL,
                text=True,
                check=True,
            ).stdout.splitlines()
            for line in out[1:]:
                parts = line.strip().split()
                if parts:
                    models.append(parts[0])
        except Exception:
            models = []
        for m in models:
            item = QtWidgets.QListWidgetItem(m)
            if m == self.model_combo.currentText().strip():
                item.setFont(QtGui.QFont("", weight=QtGui.QFont.Bold))
            self.model_list.addItem(item)

    def _on_model_pull(self) -> None:
        item = self.model_list.currentItem()
        if not item:
            return
        model = item.text()
        threading.Thread(target=lambda: subprocess.run(["ollama", "pull", model], check=False), daemon=True).start()
        QtWidgets.QMessageBox.information(self, "Pull Started", f"Pulling {model} in background.")

    def _on_model_delete(self) -> None:
        item = self.model_list.currentItem()
        if not item:
            return
        model = item.text()
        if QtWidgets.QMessageBox.question(
            self,
            "Delete Model",
            f"Delete '{model}'? This cannot be undone.",
            QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No,
        ) != QtWidgets.QMessageBox.Yes:
            return
        threading.Thread(target=lambda: subprocess.run(["ollama", "delete", model], check=False), daemon=True).start()
        QtWidgets.QMessageBox.information(self, "Delete Started", f"Deleting {model} in background.")
        self._refresh_model_list()

    def _on_model_set_default(self) -> None:
        item = self.model_list.currentItem()
        if not item:
            return
        model = item.text()
        idx = self.model_combo.findText(model)
        if idx >= 0:
            self.model_combo.setCurrentIndex(idx)
        # persist selection to settings
        try:
            self.core.settings.default_model = model
            self.core.settings.save()
        except Exception:
            pass
            QtWidgets.QMessageBox.information(self, "Default Model", f"Set default model to {model}.")
        else:
            self.model_combo.addItem(model)
            self.model_combo.setCurrentText(model)

    # ────────────────────────── lock layout
    def _on_toggle_lock(self, locked: bool) -> None:
        feats_unlocked = (
            QtWidgets.QDockWidget.DockWidgetClosable
            | QtWidgets.QDockWidget.DockWidgetMovable
            | QtWidgets.QDockWidget.DockWidgetFloatable
        )
        feats_locked = QtWidgets.QDockWidget.DockWidgetClosable
        for dock in (
            self.controls_dock,
            self.persona_dock,
            self.chat_dock,
            getattr(self, "inner_dock", None),
            self.model_dock,
            self.plugins_dock,
        ):
            if dock is None:
                continue
            dock.setFeatures(feats_locked if locked else feats_unlocked)
        for dock in self._plugin_docks.values():
            dock.setFeatures(feats_locked if locked else feats_unlocked)

    # ────────────────────────── audio
    def start_recording(self) -> None:
        if sd is None or np is None:
            QtWidgets.QMessageBox.information(self, "Recording Unavailable", "sounddevice/numpy not installed.")
            return
        if not self.btn_record.isEnabled():
            return
        device_index = None
        try:
            idx = self.device_combo.currentIndex()
            selected_name = self.device_combo.currentText()
            for i, d in enumerate(sd.query_devices()):
                if d.get("name") == selected_name and d.get("max_input_channels", 0) > 0:
                    device_index = i
                    break
        except Exception:
            device_index = None
        self.core.audio_recorder.start(device_index)
        self.btn_record.setEnabled(False)
        self.btn_stop_rec.setEnabled(True)

    def stop_recording(self) -> None:
        if not self.btn_stop_rec.isEnabled():
            return
        self.core.audio_recorder.stop_and_transcribe()
        self.btn_stop_rec.setEnabled(False)
        self.btn_record.setEnabled(True)

    @QtCore.pyqtSlot(str)
    def _on_transcribed(self, text: str) -> None:
        if not text:
            return
        cur = self.input_edit.toPlainText()
        self.input_edit.setPlainText((cur + "\n" if cur else "") + text)

    # ────────────────────────── TTS
    def _on_play(self) -> None:
        text = self.response_edit.toPlainText().strip()
        if text and not self.chk_mute_tts.isChecked():
            try:
                self.core.tts_mgr.enqueue(text)
            except Exception:
                pass

    def _on_stop_tts(self) -> None:
        try:
            self.core.tts_mgr.stop()
        except Exception:
            pass

    def _on_replay(self) -> None:
        if not self.chk_mute_tts.isChecked():
            try:
                self.core.tts_mgr.replay()
            except Exception:
                pass

    def _on_voice_changed(self, name: str) -> None:
        try:
            eng = getattr(self.core.tts_mgr, "_engine", None)
            if eng:
                for v in eng.getProperty("voices"):
                    if v.name == name:
                        eng.setProperty("voice", v.id)
                        break
        except Exception:
            pass

    def _tts_voice_names(self) -> List[str]:
        try:
            eng = getattr(self.core.tts_mgr, "_engine", None)
            if not eng:
                return []
            return [v.name for v in eng.getProperty("voices")]
        except Exception:
            return []

    # ────────────────────────── feedback
    def _on_like(self) -> None:
        text = self.response_edit.toPlainText().strip()
        if not text:
            return
        try:
            self.core.add_feedback(text, liked=True)
        except Exception:
            pass
        QtWidgets.QMessageBox.information(self, "Feedback", "Marked as good response.")
        self._enable_feedback(False)
        self._update_feedback_counts()

    def _on_dislike(self) -> None:
        original = self.response_edit.toPlainText().strip()
        if not original:
            return
        try:
            self.core.tts_mgr.stop()
        except Exception:
            pass
        QtWidgets.QMessageBox.information(self, "Disliked", "The response will be rewritten.")
        self._enable_feedback(False)

        def worker() -> None:
            new_text = self._rewrite_response(original)
            try:
                self.core.add_feedback(original, liked=False, revised=new_text)
            except Exception:
                pass
            if self.chk_isolated.isChecked():
                self.isolated_history.append((self._current_persona(), new_text))
            else:
                if self.chk_semantic.isChecked():
                    self.core.conversation_db.save_message(self._current_persona().lower(), new_text)
            self.rewrite_ready.emit(new_text)

        threading.Thread(target=worker, daemon=True).start()

    @QtCore.pyqtSlot(str)
    def _apply_rewrite_result(self, new_text: str) -> None:
        schema = self.core.schema_mgr.load_schema(
            self._current_persona(), self.current_set.get(self._current_persona(), "default")
        )
        persona_name = schema.get("name", "Bot")
        role_key = self._current_persona().lower()
        self._append_message(persona_name, new_text, role_key=role_key)
        self.response_edit.setPlainText(new_text)
        if not self.chk_mute_tts.isChecked():
            try:
                self.core.tts_mgr.enqueue(new_text)
            except Exception:
                pass
        QtWidgets.QMessageBox.information(self, "Rewritten", "Response rewritten.")
        self._enable_feedback(False)

    def _update_feedback_counts(self) -> None:
        try:
            pos, neg = self.core.feedback_db.get_counts()
            self.lbl_feedback_counts.setText(f"Likes: {pos} | Dislikes: {neg}")
        except Exception:
            self.lbl_feedback_counts.setText("Likes: - | Dislikes: -")

    def _enable_feedback(self, enabled: bool) -> None:
        self.btn_like.setEnabled(enabled)
        self.btn_dislike.setEnabled(enabled)

    def _on_manage_feedback(self) -> None:
        db = self.core.feedback_db
        if db is None:
            QtWidgets.QMessageBox.information(self, "No DB", "Feedback DB unavailable.")
            return
        cur = db.conn.cursor()
        cur.execute("SELECT id, original, liked, COALESCE(revised, '') FROM feedback ORDER BY id DESC")
        entries = cur.fetchall()
        dlg = QtWidgets.QDialog(self)
        dlg.setWindowTitle("Manage Feedback")
        dlg.resize(720, 420)
        v = QtWidgets.QVBoxLayout(dlg)
        table = QtWidgets.QTableWidget(len(entries), 4)
        table.setHorizontalHeaderLabels(["ID", "Original", "Liked", "Revised"])
        table.horizontalHeader().setStretchLastSection(True)
        for r, (fid, orig, liked, rev) in enumerate(entries):
            table.setItem(r, 0, QtWidgets.QTableWidgetItem(str(fid)))
            table.setItem(r, 1, QtWidgets.QTableWidgetItem(orig))
            table.setItem(r, 2, QtWidgets.QTableWidgetItem("✔" if liked else "✖"))
            table.setItem(r, 3, QtWidgets.QTableWidgetItem(rev))
        v.addWidget(table, 1)
        h = QtWidgets.QHBoxLayout()
        btn_del = QtWidgets.QPushButton("Delete Selected")
        btn_close = QtWidgets.QPushButton("Close")
        h.addWidget(btn_del)
        h.addWidget(btn_close)
        h.addStretch()
        v.addLayout(h)

        def on_delete() -> None:
            selected = table.selectedItems()
            if not selected:
                return
            rows = sorted({i.row() for i in selected}, reverse=True)
            for rr in rows:
                fid_item = table.item(rr, 0)
                if fid_item:
                    try:
                        fid = int(fid_item.text())
                        db.conn.execute("DELETE FROM feedback WHERE id = ?", (fid,))
                        db.conn.commit()
                    except Exception:
                        pass
                table.removeRow(rr)
            self._update_feedback_counts()

        btn_del.clicked.connect(on_delete)
        btn_close.clicked.connect(dlg.accept)
        dlg.exec_()

    # ────────────────────────── datasets / rag
    def _on_manage_datasets(self) -> None:
        DatasetManagerDialog(self.core.dataset_mgr, self).exec_()

    def _on_clear_rag_cache(self) -> None:
        if QtWidgets.QMessageBox.question(
            self,
            "Clear RAG Cache",
            "Delete cached embeddings for all datasets and clear memory?",
            QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No,
        ) != QtWidgets.QMessageBox.Yes:
            return
        count = self.core.rag_cache.clear_disk()
        self.core.rag_cache.clear_memory()
        QtWidgets.QMessageBox.information(self, "Cleared", f"Cleared RAG cache files ({count} removed) and in-memory index.")

    # ────────────────────────── isolated / refresh / idle
    def _on_isolated_toggled(self, checked: bool) -> None:
        if checked:
            self.isolated_history.clear()
        else:
            if self.isolated_history:
                ans = QtWidgets.QMessageBox.question(
                    self,
                    "Merge Isolated Chat",
                    "Merge isolated conversation into main memory?",
                    QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No,
                )
                if ans == QtWidgets.QMessageBox.Yes:
                    for role, content in self.isolated_history:
                        self.core.conversation_db.save_message(role.lower(), content)
                self.isolated_history.clear()
        self._reset_idle_timer()

    def _on_refresh_chat(self) -> None:
        if self.chk_isolated.isChecked():
            self.isolated_history.clear()
        self.chat_view.clear()
        self.response_edit.clear()
        self._enable_feedback(False)
        try:
            if hasattr(self, "inner_text") and self.inner_text is not None:
                self.inner_text.clear()
        except Exception:
            pass

    def _reset_idle_timer(self) -> None:
        self._idle_timer.stop()
        if self.chk_semantic.isChecked():
            self._idle_timer.start(60000)

    def _handle_idle(self) -> None:
        pass

    # ────────────────────────── inner monologue
    def _on_inner_monologue(self) -> None:
        self._ensure_inner_dock()
        if self.inner_dock is None:
            return
        self.inner_dock.setVisible(not self.inner_dock.isVisible())

    def _ensure_inner_dock(self) -> None:
        if hasattr(self, "inner_dock") and self.inner_dock is not None:
            return
        dock = QtWidgets.QDockWidget("Inner Monologue", self)
        dock.setObjectName("InnerDock")
        dock.setAllowedAreas(QtCore.Qt.RightDockWidgetArea | QtCore.Qt.LeftDockWidgetArea)
        inner = QtWidgets.QWidget()
        v = QtWidgets.QVBoxLayout(inner)
        self.inner_text = QtWidgets.QPlainTextEdit()
        self.inner_text.setReadOnly(True)
        v.addWidget(self.inner_text, 1)
        h = QtWidgets.QHBoxLayout()
        h.addWidget(QtWidgets.QLabel("Interval (s):"))
        self.spin_interval = QtWidgets.QSpinBox()
        self.spin_interval.setRange(1, 60)
        self.spin_interval.setValue(15)
        h.addWidget(self.spin_interval)
        self.chk_monologue_tts = QtWidgets.QCheckBox("Speak")
        self.chk_monologue_tts.setChecked(self.core.settings.monologue_tts_enabled)
        h.addWidget(self.chk_monologue_tts)
        h.addWidget(QtWidgets.QLabel("Volume:"))
        self.slider_monologue_vol = QtWidgets.QSlider(QtCore.Qt.Horizontal)
        self.slider_monologue_vol.setRange(0, 100)
        self.slider_monologue_vol.setValue(self.core.settings.monologue_volume)
        h.addWidget(self.slider_monologue_vol)
        btn_start_stop = QtWidgets.QPushButton("Start/Stop")
        h.addWidget(btn_start_stop)
        v.addLayout(h)
        inner.setLayout(v)
        dock.setWidget(inner)
        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, dock)
        self.inner_dock = dock
        self.inner_timer = QtCore.QTimer(self)
        self.inner_timer.setSingleShot(False)
        btn_start_stop.clicked.connect(self._toggle_inner_timer)
        dock.setTitleBarWidget(DockTitleBar(dock, "Inner Monologue"))
        self.dock_tray.register_dock(self.inner_dock)
        self.chk_monologue_tts.stateChanged.connect(lambda _: self._update_monologue_settings())
        self.slider_monologue_vol.valueChanged.connect(lambda _: self._update_monologue_settings())

    def _toggle_inner_timer(self) -> None:
        if self.inner_timer is None:
            return
        if self.inner_timer.isActive():
            self.inner_timer.stop()
        else:
            interval_ms = self.spin_interval.value() * 1000
            try:
                self.inner_timer.timeout.disconnect()
            except Exception:
                pass
            self.inner_timer.timeout.connect(self._generate_inner_monologue)
            self.inner_timer.start(interval_ms)

    def _update_monologue_settings(self) -> None:
        try:
            self.core.settings.monologue_tts_enabled = self.chk_monologue_tts.isChecked() if hasattr(self, 'chk_monologue_tts') else False
            self.core.settings.monologue_volume = self.slider_monologue_vol.value() if hasattr(self, 'slider_monologue_vol') else 50
            self.core.settings.save()
        except Exception:
            pass

    def _generate_inner_monologue(self) -> None:
        schema = self.core.schema_mgr.load_schema(self._current_persona(), self.current_set.get(self._current_persona(), "default"))
        overlay = schema.get("dynamic_overlay", {}) or {}
        mood = overlay.get("temporary_emotional_state", "neutral")
        likes = overlay.get("recent_topics", [])
        pos = [0, 0]
        fav_topic = likes[-1] if likes else None
        thought = f"I'm thinking about {fav_topic} while feeling {mood}." if fav_topic else f"I'm in a {mood} mood and reflecting."
        thought += f" I'm at position {pos}."
        try:
            if hasattr(self, "inner_text") and self.inner_text is not None:
                self.inner_text.appendPlainText(thought)
        except Exception:
            pass

    # ────────────────────────── conversation
    def _append_message(self, display_name: str, text: str, role_key: Optional[str] = None) -> None:
        key = (role_key or display_name).lower()
        bg_colour = ROLE_COLOURS.get(key, "#EEEEEE")
        name_colour = NAME_COLOURS.get(key, "#011627")
        safe_role = QtGui.QGuiApplication.translate("Chat", display_name)
        safe_text = QtGui.QGuiApplication.translate("Chat", text)
        frag = (
            f'<div style="background-color:{bg_colour}; border-radius:4px; padding:4px; margin:4px;">'
            f'<b style="color:{name_colour};">{safe_role}:</b> {safe_text}'
            f'</div>'
        )
        self.chat_view.append(frag)

    def _current_history(self) -> List[Tuple[str, str]]:
        if self.chk_isolated.isChecked():
            return self.isolated_history
        else:
            return self.core.conversation_db.fetch_history(limit=10)

    def _bootstrap_conversation(self) -> None:
        if self.core and len(self.core.conversation_db.fetch_history(limit=1)) == 0:
            schema = self.core.schema_mgr.load_schema(self.active_persona, self.current_set.get(self.active_persona, "default"))
            questions = schema.get("questions", [])
            if questions:
                first_question = questions[0]
                self._append_message("System", first_question, role_key="system")
                if self.chk_semantic.isChecked() and not self.chk_isolated.isChecked():
                    self.core.conversation_db.save_message("system", first_question)

    # ────────────────────────── prompt & rag
    def _build_prompt(self, schema: Dict[str, object], user_text: str, is_self_talk: bool = False) -> str:
        parts: List[str] = []
        name = schema.get("name", "")
        role = schema.get("role", "")
        desc = schema.get("description", "")
        persona_desc = f"You are {name}, {desc}".strip()
        if role:
            persona_desc += f" Your role is {role}."

        overlay = schema.get("dynamic_overlay", {})
        if overlay:
            temp_rel = overlay.get("temporary_relationship_context", "")
            temp_emotion = overlay.get("temporary_emotional_state", "")
            added_traits = overlay.get("added_traits", [])
            if temp_rel:
                persona_desc += f" ({temp_rel})"
            if temp_emotion:
                persona_desc += f" You feel {temp_emotion}."
            if added_traits:
                persona_desc += f" Traits: {', '.join(str(t) for t in added_traits)}."
        parts.append(persona_desc)

        # User description
        try:
            user_schema = self.core.schema_mgr.load_schema("user", self.current_set.get("user", "default"))
        except Exception:
            user_schema = {}
        if user_schema:
            u_name = user_schema.get("name", "User")
            u_personality = user_schema.get("personality", "")
            relationship = user_schema.get("relationship_to_zira", "friend")
            u_overlay = user_schema.get("dynamic_overlay", {})
            temp_rel2 = u_overlay.get("temporary_relationship_context") if u_overlay else None
            if temp_rel2 and str(temp_rel2).strip():
                relationship = str(temp_rel2)
            user_desc = f"User is {u_name}, {u_personality}. Relationship: {relationship}."
            parts.append(user_desc)

        # History
        history_text = ""
        if self.chk_semantic.isChecked():
            history = self._current_history()[-10:]
            for role_name, content in history:
                speaker = "User" if role_name.lower() == "user" else role_name.title()
                history_text += f"{speaker}: {content}\n"
        if history_text:
            parts.append("Conversation history:\n" + history_text.strip())

        # RAG (only datasets listed by this set)
        dataset_text = ""
        ds_names: List[str] = list(schema.get("datasets") or [])
        try:
            # Prefer core search with filters if supported
            hits = self.core.rag_search(
                user_text,
                per_ds_k=3,
                limit=5,
                include_shared=False,
                datasets=ds_names if ds_names else None,
            )
            for chunk, score, ds_name, owner in hits:
                dataset_text += f"Dataset ({owner}/{ds_name}):\n{chunk}\n\n"
        except TypeError:
            # Older core: no dataset filter; fallback to manual selection
            from_texts: List[Tuple[str, str]] = []
            try:
                for name, entry in self.core.dataset_mgr.entries.items():
                    if ds_names and name not in ds_names:
                        continue
                    if not entry.active:
                        continue
                    full_text = self.core.dataset_mgr.load_dataset_text(entry)
                    if full_text:
                        from_texts.append((name, full_text))
            except Exception:
                pass
            for name, full_text in from_texts:
                snip = self._retrieve_dataset_snippet(full_text, user_text)
                if snip:
                    dataset_text += f"Dataset ({name}):\n{snip}\n\n"
        except Exception:
            pass
        if dataset_text:
            parts.append(dataset_text.strip())

        # Self-talk (optional)
        if is_self_talk and self.self_talk_enabled:
            st_prompts = schema.get("self_talk", [])
            if st_prompts:
                import random
                parts.append(random.choice(st_prompts))

        parts.append(f"User: {user_text}")
        return "\n\n".join([p for p in parts if p])

    def _retrieve_dataset_snippet(self, full_text: str, user_text: str) -> str:
        try:
            tokens = [w.lower() for w in re.findall(r"\b\w+\b", user_text) if len(w) > 2]
            paragraphs = [p.strip() for p in full_text.split("\n") if p.strip()]
            scored: List[Tuple[int, str]] = []
            for para in paragraphs:
                l = para.lower()
                score = sum(1 for t in tokens if t in l)
                if score > 0:
                    scored.append((score, para))
            if not scored:
                return paragraphs[0][:500] if paragraphs else full_text[:500]
            scored.sort(key=lambda x: -x[0])
            top = [p for _, p in scored[:2]]
            return "\n".join(top)[:500]
        except Exception:
            return full_text[:500]

    # ────────────────────────── send / model
    def send_message(self) -> None:
        user_text = self.input_edit.toPlainText().strip()
        if not user_text:
            return

        # Broadcast to plugins
        try:
            self.core.plugins.broadcast(user_text)
        except Exception:
            pass

        # Slash commands → ensure applied to current persona+set
        if user_text.startswith("/"):
            self.input_edit.clear()
            persona = self._current_persona()
            set_name = self.current_set.get(persona, "default")
            try:
                out = self.core.run_command(user_text, persona=persona, set_name=set_name)
            except TypeError:
                out = self.core.run_command(user_text)
            self._append_message("System", out, role_key="system")
            if self.chk_semantic.isChecked() and not self.chk_isolated.isChecked():
                self.core.conversation_db.save_message("system", out)
            return

        # Normal message
        self.input_edit.clear()
        persona = self._current_persona()
        set_name = self.current_set.get(persona, "default")
        schema = self.core.schema_mgr.load_schema(persona, set_name)

        if self.chk_isolated.isChecked():
            self.isolated_history.append(("user", user_text))
        else:
            if self.chk_semantic.isChecked():
                self.core.conversation_db.save_message("user", user_text)

        try:
            user_schema = self.core.schema_mgr.load_schema("user", self.current_set.get("user", "default"))
            user_display = user_schema.get("name", "User")
        except Exception:
            user_display = "User"
        self._append_message(user_display, user_text, role_key="user")

        prompt = self._build_prompt(schema, user_text)
        model_slug = self.model_combo.currentText().strip() or self.core.settings.default_model

        self.btn_send.setEnabled(False)

        # ✅ Create ModelWorker and wire it up properly
        self.model_worker = ModelWorker(model_slug, prompt, parent=self.core)
        self.model_worker.resultReady.connect(lambda resp, usr=user_text, sch=schema: self._on_model_response(resp, usr, sch))
        self.model_worker.errorOccurred.connect(self._on_model_error)
        self.model_worker.finished.connect(lambda: self.btn_send.setEnabled(True))
        self.model_worker.start()


    def _on_model_response(self, response_raw: str, user_text: str, schema: Dict[str, object]) -> None:
        model_slug = self.model_combo.currentText().strip()
        response = self._strip_reasoning(model_slug, response_raw)
        response, style_score = self._style_and_guard(response, schema)
        self.style_label.setText(f"Style: {style_score:.2f}")

        if self.chk_isolated.isChecked():
            self.isolated_history.append((schema.get("name", "bot"), response))
        else:
            if self.chk_semantic.isChecked():
                self.core.conversation_db.save_message(schema.get("name", "bot").lower(), response)

        persona_name = schema.get("name", "Bot") or "Bot"
        role_key = self._current_persona().lower()
        self._append_message(persona_name, response, role_key=role_key)
        self.response_edit.setPlainText(response)

        if not self.chk_mute_tts.isChecked():
            try:
                self.core.tts_mgr.enqueue(response)
            except Exception:
                pass

        self._enable_feedback(True)
        self._reset_idle_timer()

        try:
            tokens = [w.lower() for w in re.findall(r"\b\w+\b", user_text) if len(w) > 3]
            for t in tokens:
                self.update_overlay_topic(self._current_persona(), t)
            self.update_overlay_emotion(self._current_persona(), "neutral")
        except Exception:
            pass

        try:
            for line in response.split("\n"):
                if line.strip():
                    self.core.plugins.broadcast(line.strip())
        except Exception as e:
            print(f"Error broadcasting to plugins: {e}")

        if self.core.settings.auto_schema_enabled:
            self.progress_bar.setVisible(True)

            class EvolverWorker(QRunnable):
                def __init__(self, evolver, persona, set_name, history, window):
                    super().__init__()
                    self.evolver = evolver
                    self.persona = persona
                    self.set_name = set_name
                    self.history = history
                    self.window = window

                def run(self):
                    changed = self.evolver.update_schema(self.persona, self.set_name, self.history)
                    QtCore.QMetaObject.invokeMethod(
                        self.window, "_post_evolver", QtCore.Qt.QueuedConnection, QtCore.Q_ARG(bool, changed)
                    )

            QThreadPool.globalInstance().start(
                EvolverWorker(self.core.schema_evolver, self.active_persona, self.current_set.get(self.active_persona, "default"), self._current_history(), self)
            )

    @QtCore.pyqtSlot(bool)
    def _post_evolver(self, changed: bool) -> None:
        self.progress_bar.setVisible(False)
        if changed:
            self._flash_status("Schema adapted")

    def _strip_reasoning(self, model: str, response: str) -> str:
        if model and "deepseek" in model.lower():
            if "<think>" in response and "</think>" in response:
                try:
                    return response.split("</think>")[-1].strip() or response
                except Exception:
                    return response
        return response

    def _style_and_guard(self, text: str, schema: Dict[str, object]) -> Tuple[str, float]:
        exclam = text.count("!")
        sentences = [s for s in re.split(r"[.!?]", text) if s.strip()]
        avg_len = sum(len(s.split()) for s in sentences) / max(1, len(sentences))
        exclam_density = exclam / max(1, len(text))
        tone = schema.get("tone_rules", {"conciseness": [0.6, 0.8], "exclam_limit": 0.05})
        conciseness = max(0.0, min(1.0, (22 - avg_len) / 16.0))
        ex_ok = 1.0 if exclam_density <= float(tone.get("exclam_limit", 0.05)) else 0.5
        score = max(0.0, min(1.0, 0.5 * conciseness + 0.5 * ex_ok))
        return text, score

    def _rewrite_response(self, original: str) -> str:
        try:
            liked = self.core.feedback_db.get_liked_responses(limit=5)
        except Exception:
            liked = []
        schema = self.core.schema_mgr.load_schema(self._current_persona(), self.current_set.get(self._current_persona(), "default"))
        rps = schema.get("rewrite_prompts", [])
        template = rps[0] if rps else "Rewrite to be more appealing. Keep it accurate, concise, and on style."
        parts = [template]
        if liked:
            parts.append("Preferred responses:\n" + "\n\n".join(liked))
        parts.append("Original:\n" + original)
        parts.append("Rewritten:")
        prompt = "\n\n".join(parts)
        return self._run_model(self.model_combo.currentText().strip() or self.core.settings.default_model, prompt) or original

    def _run_model(self, model: str, prompt: str) -> str:
        try:
            proc = subprocess.run(
                ["ollama", "run", model],
                input=prompt.encode("utf-8"),
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                check=True,
            )
            return proc.stdout.decode("utf-8", errors="replace").strip()
        except subprocess.CalledProcessError as e:
            return e.stderr.decode("utf-8", errors="replace").strip()
        except FileNotFoundError:
            return "(error) ollama executable not found."
        except Exception as e:
            return f"(error) {e}"

    # ────────────────────────── persona / sets
    def _populate_set_combo(self, persona: str, combo: QtWidgets.QComboBox) -> None:
        combo.blockSignals(True)
        combo.clear()
        for s in self.core.schema_mgr.get_set_list(persona):
            combo.addItem(s)
        current = self.current_set.get(persona, "default")
        idx = combo.findText(current)
        combo.setCurrentIndex(idx if idx >= 0 else combo.findText("default"))
        if idx < 0:
            self.current_set[persona] = combo.currentText()
        combo.blockSignals(False)

    def _on_set_changed(self, persona: str, name: str, combo: QtWidgets.QComboBox) -> None:
        if not name:
            return
        self.current_set[persona] = name
        # keep AgentCore pointed to the right set if this persona is active
        if persona == self._current_persona():
            self.core.persona = persona
            self.core.set_name = name

        # refresh editor + commands row for this tab
        tab = self.tab_widgets.get(persona)
        if tab:
            editor = tab.findChild(QtWidgets.QPlainTextEdit, f"schema_edit_{persona}")
            if editor:
                schema = self.core.schema_mgr.load_schema(persona, name)
                editor.setPlainText(json.dumps(schema, indent=2))
            cmd_combo = tab.findChild(QtWidgets.QComboBox, f"cmd_combo_{persona}")
            if cmd_combo:
                self._populate_command_combo(persona, cmd_combo)

        # persist active sets & update controls tied to schema flags
        self.core.schema_mgr.save_active_schemas(self.current_set)
        self._sync_semantic_checkbox_from_schema()
        self._update_feedback_counts()

        # refresh slash command list if this persona is active
        try:
            if persona == self._current_persona():
                self._populate_command_select()
        except Exception:
            pass

    def _on_clone_set(self, persona: str, combo: QtWidgets.QComboBox) -> None:
        src = combo.currentText()
        name, ok = QtWidgets.QInputDialog.getText(self, "Clone Set", "Enter new set name:")
        if not ok or not name.strip():
            return
        new_name = name.strip()
        try:
            schema = self.core.schema_mgr.load_schema(persona, src)
            # Preserve the persona's canonical name; set label is separate
            schema["name"] = persona.capitalize()
            self.core.schema_mgr.save_schema(persona, new_name, schema)
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "Error", str(e))
            return
        self.current_set[persona] = new_name
        self._populate_set_combo(persona, combo)
        combo.setCurrentText(new_name)
        if persona == self._current_persona():
            self.core.set_name = new_name
        self.core.schema_mgr.save_active_schemas(self.current_set)
        self._sync_semantic_checkbox_from_schema()
        self._update_feedback_counts()

    def _on_new_set(self, persona: str, combo: QtWidgets.QComboBox) -> None:
        src = combo.currentText()
        name, ok = QtWidgets.QInputDialog.getText(self, "New Set", "Enter name for new set:")
        if not ok or not name.strip():
            return
        new_name = name.strip()
        try:
            schema = self.core.schema_mgr.load_schema(persona, src)
            # Preserve the persona's canonical name; set label is separate
            schema["name"] = persona.capitalize()
            self.core.schema_mgr.save_schema(persona, new_name, schema)
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "Error", str(e))
            return
        self.current_set[persona] = new_name
        self._populate_set_combo(persona, combo)
        combo.setCurrentText(new_name)
        if persona == self._current_persona():
            self.core.set_name = new_name
        self.core.schema_mgr.save_active_schemas(self.current_set)
        self._sync_semantic_checkbox_from_schema()
        self._update_feedback_counts()

    def _on_delete_set(self, persona: str, combo: QtWidgets.QComboBox) -> None:
        name = combo.currentText()
        if name == "default":
            QtWidgets.QMessageBox.information(self, "Cannot Delete", "The default set cannot be deleted.")
            return
        if QtWidgets.QMessageBox.question(
            self, "Delete Set", f"Delete '{name}' (irreversible)?", QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No
        ) != QtWidgets.QMessageBox.Yes:
            return
        try:
            set_dir = os.path.join(self.core.schema_mgr.schemas_dir, persona.lower(), "sets", name)
            import shutil
            shutil.rmtree(set_dir, ignore_errors=True)
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "Error", str(e))
            return
        self.current_set[persona] = "default"
        self._populate_set_combo(persona, combo)
        combo.setCurrentText("default")
        if persona == self._current_persona():
            self.core.set_name = "default"
        self.core.schema_mgr.save_active_schemas(self.current_set)
        self._sync_semantic_checkbox_from_schema()
        self._update_feedback_counts()

    def _on_save_schema(self, persona: str) -> None:
        tab = self.tab_widgets.get(persona)
        if not tab:
            return
        editor = tab.findChild(QtWidgets.QPlainTextEdit, f"schema_edit_{persona}")
        if not editor:
            return
        text = editor.toPlainText().strip()
        try:
            schema = json.loads(text)
            if not isinstance(schema, dict):
                raise ValueError
        except Exception:
            QtWidgets.QMessageBox.warning(self, "Invalid JSON", "The schema is not valid JSON.")
            return
        set_name = self.current_set.get(persona, "default")
        existing_schema = self.core.schema_mgr.load_schema(persona, set_name)
        merged_schema = {**existing_schema, **schema}
        # Ensure the top-level name matches the active set name
        try:
            merged_schema["name"] = set_name
        except Exception:
            pass
        self.core.schema_mgr.save_schema(persona, set_name, merged_schema)
        QtWidgets.QMessageBox.information(self, "Saved", f"Schema saved for {persona} ({set_name}).")

        if persona == self._current_persona():
            persona_voice = (merged_schema.get("voice") or "").lower()
            for i in range(self.voice_combo.count()):
                if persona_voice and persona_voice in self.voice_combo.itemText(i).lower():
                    self.voice_combo.setCurrentIndex(i)
                    break
        # After save, refresh commands combo (in case user edited commands JSON directly)
        tab = self.tab_widgets.get(persona)
        if tab:
            cmd_combo = tab.findChild(QtWidgets.QComboBox, f"cmd_combo_{persona}")
            if cmd_combo:
                self._populate_command_combo(persona, cmd_combo)

    # ------------------------------------------------------------------
    # Command editing helpers (ported from the original agent_ui.py)
    #
    # The persona editing tab includes a commands row allowing users to
    # append new payloads to existing slash commands or create entirely
    # new commands.  These helpers implement the behaviour that used to
    # live in agent_ui.py.  They are invoked by PersonaTab via
    # ``self.app._on_add_to_command`` and ``self.app._on_new_command``.
    def _on_add_to_command(self, persona: str, combo: QtWidgets.QComboBox,
                            edit: QtWidgets.QLineEdit) -> None:
        """
        Append the text from ``edit`` to the selected command in the
        current schema.  If no command is selected or no text is
        provided, the user is notified.  After updating the schema,
        the command editor and schema editor are refreshed.

        Parameters
        ----------
        persona : str
            The persona whose schema is being modified.
        combo : QtWidgets.QComboBox
            The combo box listing existing slash commands.
        edit : QtWidgets.QLineEdit
            The line edit containing the payload to add to the command.
        """
        text = edit.text().strip()
        if not text:
            QtWidgets.QMessageBox.information(self, "No Text", "Enter text/payload to add.")
            return
        set_name = self.current_set.get(persona, "default")
        schema = self.core.schema_mgr.load_schema(persona, set_name)
        cmds = dict(schema.get("commands") or {})
        sel = combo.currentText().strip()
        if not sel or sel == "(no commands)":
            QtWidgets.QMessageBox.information(self, "No Command", "Create a command first.")
            return
        lst = list(cmds.get(sel) or [])
        lst.append(text)
        cmds[sel] = lst
        schema["commands"] = cmds
        self.core.schema_mgr.save_schema(persona, set_name, schema)
        edit.clear()
        # Refresh editors & notify the user
        self._refresh_schema_editor(persona)
        QtWidgets.QMessageBox.information(self, "Added", f'Added to {sel}: "{text}"')

    def _on_new_command(self, persona: str) -> None:
        """
        Prompt the user for a new command name, insert it into the
        schema if it does not already exist, and refresh the UI.  The
        new command is prefaced with a leading slash if not provided.

        Parameters
        ----------
        persona : str
            The persona whose schema is being modified.
        """
        name, ok = QtWidgets.QInputDialog.getText(self, "New Command", "Enter new command (e.g., /remember):")
        if not ok or not name.strip():
            return
        cmd_name = name.strip()
        if not cmd_name.startswith("/"):
            cmd_name = "/" + cmd_name
        set_name = self.current_set.get(persona, "default")
        schema = self.core.schema_mgr.load_schema(persona, set_name)
        cmds = dict(schema.get("commands") or {})
        if cmd_name in cmds:
            QtWidgets.QMessageBox.information(self, "Exists", f"Command {cmd_name} already exists.")
            return
        cmds[cmd_name] = []
        schema["commands"] = cmds
        self.core.schema_mgr.save_schema(persona, set_name, schema)
        # Refresh command combo + schema editor
        tab = self.tab_widgets.get(persona)
        if tab:
            combo = tab.findChild(QtWidgets.QComboBox, f"cmd_combo_{persona}")
            if combo:
                self._populate_command_combo(persona, combo)
                combo.setCurrentText(cmd_name)
            edit = tab.findChild(QtWidgets.QLineEdit, f"cmd_edit_{persona}")
            if edit:
                edit.clear()
        self._refresh_schema_editor(persona)
        QtWidgets.QMessageBox.information(self, "Created", f"New command {cmd_name} created.")

    def _refresh_schema_editor(self, persona: str) -> None:
        """
        Reload the JSON schema for ``persona`` from disk and update the
        corresponding schema editor in the UI.  This helper is used
        after schema modifications to ensure the text reflects the
        authoritative state on disk.  Signals are blocked during the
        update to avoid triggering autosave timers unnecessarily.

        Parameters
        ----------
        persona : str
            The persona whose schema editor should be refreshed.
        """
        tab = self.tab_widgets.get(persona)
        if not tab:
            return
        editor = tab.findChild(QtWidgets.QPlainTextEdit, f"schema_edit_{persona}")
        if editor:
            schema = self.core.schema_mgr.load_schema(persona, self.current_set.get(persona, "default"))
            editor.blockSignals(True)
            editor.setPlainText(json.dumps(schema, indent=2))
            editor.blockSignals(False)

    def _tab_changed(self, index: int) -> None:
        if 0 <= index < len(self.core.schema_mgr.personas):
            self.active_persona = self.core.schema_mgr.personas[index]
        else:
            self.active_persona = self.core.schema_mgr.personas[0] if self.core.schema_mgr.personas else "zira"
        self.core.persona = self.active_persona

        schema = self.core.schema_mgr.load_schema(self.active_persona, self.current_set.get(self.active_persona, "default"))
        persona_voice = (schema.get("voice") or "").lower()
        for i in range(self.voice_combo.count()):
            if persona_voice and persona_voice in self.voice_combo.itemText(i).lower():
                self.voice_combo.setCurrentIndex(i)
                break

        tab = self.tab_widgets.get(self.active_persona)
        if tab:
            editor = tab.findChild(QtWidgets.QPlainTextEdit, f"schema_edit_{self.active_persona}")
            if editor:
                editor.setPlainText(json.dumps(schema, indent=2))
            cmd_combo = tab.findChild(QtWidgets.QComboBox, f"cmd_combo_{self.active_persona}")
            if cmd_combo:
                self._populate_command_combo(self.active_persona, cmd_combo)

        try:
            user_schema = self.core.schema_mgr.load_schema("user", self.current_set.get("user", "default"))
            bot_name = schema.get("name", self.active_persona.title())
            bot_set = self.current_set.get(self.active_persona, "default")
            user_name = user_schema.get("name", "User")
            user_set = self.current_set.get("user", "default")
            self.lbl_active_names.setText(f"{bot_name}: {bot_set} — User: {user_name}: {user_set}")
        except Exception:
            pass

        self._sync_semantic_checkbox_from_schema()
        self._update_feedback_counts()

        # refresh slash command dropdown on persona change
        try:
            self._populate_command_select()
        except Exception:
            pass

    def _current_persona(self) -> str:
        return self.active_persona

    # ────────────────────────── overlay helpers
    def update_overlay_topic(self, persona: str, topic: str) -> None:
        persona = persona.lower()
        try:
            schema = self.core.schema_mgr.load_schema(persona, self.current_set.get(persona, "default"))
            overlay = dict(schema.get("dynamic_overlay", {}))
            topics = list(overlay.get("recent_topics", []))
            if topic and topic not in topics:
                topics.append(topic)
                if len(topics) > 10:
                    topics = topics[-10:]
                overlay["recent_topics"] = topics
                schema["dynamic_overlay"] = overlay
                self.core.schema_mgr.save_schema(persona, self.current_set.get(persona, "default"), schema)
        except Exception:
            pass

    def update_overlay_emotion(self, persona: str, emotion: str) -> None:
        persona = persona.lower()
        try:
            schema = self.core.schema_mgr.load_schema(persona, self.current_set.get(persona, "default"))
            overlay = dict(schema.get("dynamic_overlay", {}))
            overlay["temporary_emotional_state"] = emotion
            schema["dynamic_overlay"] = overlay
            self.core.schema_mgr.save_schema(persona, self.current_set.get(persona, "default"), schema)
        except Exception:
            pass

    # ────────────────────────── devices & models
    def _populate_devices(self) -> None:
        # In this refactor the devices are populated by CommandsPanel
        self.commands_panel._populate_devices()

    def _populate_models(self) -> None:
        # In this refactor the models are populated by CommandsPanel
        self.commands_panel._populate_models()

    # ────────────────────────── slash commands panel
    def _build_command_dock(self) -> None:
        """
        Build a dockable panel that exposes slash commands with an argument
        entry and send button. This allows users to trigger any command
        without typing it into the chat manually. It will be updated when
        persona or set changes.
        """
        dock = QtWidgets.QDockWidget("Slash Commands", self)
        dock.setObjectName("SlashCommandsDock")
        dock.setFeatures(
            QtWidgets.QDockWidget.DockWidgetClosable
            | QtWidgets.QDockWidget.DockWidgetMovable
            | QtWidgets.QDockWidget.DockWidgetFloatable
        )
        container = QtWidgets.QWidget()
        layout = QtWidgets.QVBoxLayout(container)
        layout.setContentsMargins(7, 7, 7, 7)
        layout.setSpacing(5)

        # command selector
        cmd_label = QtWidgets.QLabel("Slash Command:")
        self.command_select = QtWidgets.QComboBox()
        layout.addWidget(cmd_label)
        layout.addWidget(self.command_select)

        # argument input
        self.command_input = QtWidgets.QLineEdit()
        self.command_input.setPlaceholderText("Enter arguments or select text from chat…")
        layout.addWidget(self.command_input)

        # send button
        btn_run = QtWidgets.QPushButton("Run Command")
        btn_run.clicked.connect(self._on_run_command)
        layout.addWidget(btn_run)
        layout.addStretch(1)

        dock.setWidget(container)
        # add to right side by default
        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, dock)
        self.command_dock = dock

    def _populate_command_select(self) -> None:
        """
        Populate the slash command dropdown with available commands from
        the command registry. This is called whenever the active persona
        or set changes to reflect dynamic additions.
        """
        try:
            cmds = []
            if hasattr(self.core, "command_registry") and self.core.command_registry:
                cmds = list(self.core.command_registry.list_commands())
            # if schema defines additional commands, include them
            persona = self._current_persona()
            set_name = self.current_set.get(persona, "default")
            schema = self.core.schema_mgr.load_schema(persona, set_name)
            schema_cmds = list((schema.get("commands") or {}).keys())
            for c in schema_cmds:
                if c not in cmds:
                    cmds.append(c)
            cmds.sort()
        except Exception:
            cmds = []
        self.command_select.blockSignals(True)
        self.command_select.clear()
        if cmds:
            self.command_select.addItems(cmds)
        self.command_select.blockSignals(False)

    def _on_run_command(self) -> None:
        """
        Handler for running the selected slash command with the provided
        argument. The command will be executed via AgentCore and the
        result appended to the chat window. Selection text from the chat
        can be inserted into the argument field via context menu.
        """
        cmd = (self.command_select.currentText() or "").strip()
        if not cmd:
            QtWidgets.QMessageBox.information(self, "No Command", "Select a slash command to run.")
            return
        arg = self.command_input.text().strip()
        # combine command and arguments
        full = cmd if not arg else f"{cmd} {arg}"
        try:
            # process via core; record conversation
            resp = self.core.process_user_message(full, tts=False)
            # append user command and agent response to chat
            self._append_message("user", full, role_key="user")
            self._append_message("zira", resp, role_key="zira")
            # clear argument
            self.command_input.clear()
            # update feedback counts and idle timer
            self._update_feedback_counts()
            self._reset_idle_timer()
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "Command Error", str(e))

    def _show_chat_context_menu(self, pos: QtCore.QPoint) -> None:
        """
        Custom context menu for the chat view. Adds a menu entry to send
        selected text into the slash command argument field.
        """
        menu = self.chat_view.createStandardContextMenu()
        try:
            cursor = self.chat_view.textCursor()
            if cursor and cursor.hasSelection():
                action = menu.addAction("Send selection to command input")
                action.triggered.connect(self._send_selection_to_command_input)
        except Exception:
            pass
        menu.exec_(self.chat_view.mapToGlobal(pos))

    def _send_selection_to_command_input(self) -> None:
        """
        Copy the currently selected text in the chat view into the command
        input field for slash command execution.
        """
        try:
            cursor = self.chat_view.textCursor()
            if cursor and cursor.hasSelection():
                text = cursor.selectedText()
                self.command_input.setText(text.strip())
        except Exception:
            pass

    def _on_model_changed(self, name: str) -> None:
        """
        Update the default model in settings when the user selects a new
        model from the dropdown. This ensures the AgentCore uses the
        selected model for subsequent interactions.
        """
        try:
            if not name:
                return
            self.core.settings.default_model = name
            self.core.settings.save()
        except Exception:
            pass

    def _on_show_model_manager(self) -> None:
        """
        Show (or raise) the model manager dock. If the dock was
        previously hidden, it will be shown; if it is already visible,
        this will bring it to the front. A dock must be built in
        ``_build_model_manager()`` prior to showing.
        """
        try:
            if self.model_dock.isVisible():
                # already visible: raise to top
                self.model_dock.raise_()
            else:
                self.model_dock.show()
                self.model_dock.raise_()
        except Exception:
            pass
            
            
    def _on_model_error(self, error: str) -> None:
        """Handles errors from ModelWorker threads."""
        print(f"[ERROR] ModelWorker failed:\n{error}")

        # Show in chat window
        self._append_message("System", f"❌ Model error:\n{error}", role_key="system")

        # Optionally log or alert
        try:
            self.core.logger.error(f"ModelWorker Error: {error}")
        except Exception:
            pass

        # Re-enable send button in case it wasn't via .finished
        self.btn_send.setEnabled(True)
            

    # ────────────────────────── settings toggles
    def _on_auto_schema_toggled(self, checked: bool) -> None:
        try:
            self.core.settings.auto_schema_enabled = bool(checked)
            self.core.settings.save()
        except Exception:
            pass
        self.statusBar().showMessage(f"Auto Schema Evolution {'enabled' if checked else 'disabled'}", 2500)

    def _on_google_stt_toggled(self, checked: bool) -> None:
        """
        Opt-in/out of using Google Cloud Speech-to-Text. When enabling the
        toggle for the first time in a session, show a warning that
        recordings will be sent to Google’s servers under their privacy
        policy. If declined, the checkbox will be turned off again.
        """
        # Only show the dialog when transitioning from unchecked → checked
        try:
            current = bool(getattr(self.core.settings, "use_google_stt", False))
        except Exception:
            current = False
        if checked and not current:
            ok = QtWidgets.QMessageBox.question(
                self,
                "Enable Google STT?",
                "Audio will be uploaded to Google Cloud for transcription\n"
                "under Google's privacy policy. Continue?",
                QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No,
            )
            if ok != QtWidgets.QMessageBox.Yes:
                # revert checkbox silently
                self.chk_google_stt.blockSignals(True)
                self.chk_google_stt.setChecked(False)
                self.chk_google_stt.blockSignals(False)
                return
        # persist the new state
        try:
            self.core.settings.use_google_stt = bool(checked)
            self.core.settings.save()
        except Exception:
            pass

    # ────────────────────────── spell suggestions
    def _show_input_context_menu(self, pos: QtCore.QPoint) -> None:
        """
        Custom context menu on the input field that offers spelling
        suggestions when the user right-clicks a misspelled word. Only
        appears if pyspellchecker is available.
        """
        menu = self.input_edit.createStandardContextMenu()
        # compute suggestions only if SpellChecker is available
        if SpellChecker:
            cursor = self.input_edit.cursorForPosition(pos)
            # select the word under cursor
            cursor.select(QtGui.QTextCursor.WordUnderCursor)
            word = cursor.selectedText()
            if word and len(word) >= 3:
                sc = SpellChecker()
                suggestions = list(sc.candidates(word.lower()))
                # sort by Levenshtein distance and frequency; keep top 5
                suggestions = sorted(suggestions, key=lambda w: sc.word_probability(w), reverse=True)[:5]
                if suggestions and suggestions != [word.lower()]:
                    suggest_menu = menu.addMenu("Spelling suggestions")
                    for s in suggestions:
                        act = suggest_menu.addAction(s)
                        act.triggered.connect(lambda chk=False, repl=s, c=cursor: self._replace_word(c, repl))
        menu.exec_(self.input_edit.mapToGlobal(pos))

    def _replace_word(self, cursor: QtGui.QTextCursor, replacement: str) -> None:
        """
        Replace the word at the given cursor with a suggestion. This
        method is connected dynamically for each suggestion action.
        """
        try:
            cursor.beginEditBlock()
            cursor.removeSelectedText()
            cursor.insertText(replacement)
            cursor.endEditBlock()
        except Exception:
            pass

    def _on_semantic_toggled(self, checked: bool) -> None:
        """Persist semantic awareness per persona+set."""
        persona = self._current_persona()
        set_name = self.current_set.get(persona, "default")
        try:
            schema = self.core.schema_mgr.load_schema(persona, set_name)
            flags = dict(schema.get("flags") or {})
            flags["semantic_awareness"] = bool(checked)
            schema["flags"] = flags
            self.core.schema_mgr.save_schema(persona, set_name, schema)
        except Exception:
            pass
        self._reset_idle_timer()

    def _sync_semantic_checkbox_from_schema(self) -> None:
        """Load semantic_awareness from current schema into the checkbox."""
        persona = self._current_persona()
        set_name = self.current_set.get(persona, "default")
        try:
            schema = self.core.schema_mgr.load_schema(persona, set_name)
            flags = schema.get("flags", {})
            val = bool(flags.get("semantic_awareness", True))
        except Exception:
            val = True
        self.chk_semantic.blockSignals(True)
        self.chk_semantic.setChecked(val)
        self.chk_semantic.blockSignals(False)

    # ────────────────────────── status helper
    def _flash_status(self, msg: str) -> None:
        self.statusBar().showMessage(msg, 3000)


# ────────────────────────── Dock tray & titlebar
class DockTray(QtWidgets.QWidget):
    restoreRequested = QtCore.pyqtSignal(QtWidgets.QDockWidget)

    def __init__(self, parent: Optional[QtWidgets.QWidget] = None) -> None:
        super().__init__(parent)
        self._map: Dict[QtWidgets.QDockWidget, QtWidgets.QPushButton] = {}
        lay = QtWidgets.QHBoxLayout(self)
        lay.setContentsMargins(6, 4, 6, 4)
        lay.setSpacing(6)
        self._layout = lay
        self._title = QtWidgets.QLabel("Minimized panels:")
        self._title.setStyleSheet("color: #f0f0f0; font-weight: bold;")
        self._layout.addWidget(self._title, 0)
        self._layout.addStretch(1)
        self.setStyleSheet("background-color: #3c4a6b;")

    def register_dock(self, dock: QtWidgets.QDockWidget) -> None:
        dock.visibilityChanged.connect(lambda vis, d=dock: self._on_visibility_changed(d, vis))
        if not dock.isVisible():
            self._add_button(dock)

    def _on_visibility_changed(self, dock: QtWidgets.QDockWidget, visible: bool) -> None:
        if visible:
            self._remove_button(dock)
        else:
            self._add_button(dock)

    def _add_button(self, dock: QtWidgets.QDockWidget) -> None:
        if dock in self._map:
            return
        btn = QtWidgets.QPushButton(dock.windowTitle())
        btn.setToolTip(f"Restore {dock.windowTitle()}")
        btn.setStyleSheet(
            "background-color: #4a5b78; color: #ffffff; padding: 4px 6px; border: none; border-radius: 3px;"
        )
        btn.clicked.connect(lambda checked=False, d=dock: self._restore(d))
        self._layout.insertWidget(self._layout.count() - 1, btn)
        self._map[dock] = btn

    def _remove_button(self, dock: QtWidgets.QDockWidget) -> None:
        btn = self._map.pop(dock, None)
        if btn:
            self._layout.removeWidget(btn)
            btn.deleteLater()

    def _restore(self, dock: QtWidgets.QDockWidget) -> None:
        dock.show()
        dock.raise_()
        self.restoreRequested.emit(dock)


class DockTitleBar(QtWidgets.QWidget):
    def __init__(self, dock: QtWidgets.QDockWidget, title: str) -> None:
        super().__init__(dock)
        self._dock = dock
        h = QtWidgets.QHBoxLayout(self)
        h.setContentsMargins(6, 2, 6, 2)
        h.setSpacing(6)
        self.lbl = QtWidgets.QLabel(title)
        h.addWidget(self.lbl)
        h.addStretch()
        self.btn_min = QtWidgets.QToolButton()
        self.btn_min.setText("–")
        self.btn_min.setToolTip("Minimize to bottom tray")
        self.btn_min.clicked.connect(lambda checked=False: self._dock.hide())
        h.addWidget(self.btn_min)
        self.btn_max = QtWidgets.QToolButton()
        self.btn_max.setText("□")
        self.btn_max.setToolTip("Enlarge / Restore")
        self.btn_max.clicked.connect(self._on_toggle_maximize)
        h.addWidget(self.btn_max)
        self.btn_close = QtWidgets.QToolButton()
        self.btn_close.setText("×")
        self.btn_close.setToolTip("Close (send to bottom tray)")
        self.btn_close.clicked.connect(lambda checked=False: self._dock.hide())
        h.addWidget(self.btn_close)
        self.installEventFilter(self)

    def eventFilter(self, _obj: QtCore.QObject, evt: QtCore.QEvent) -> bool:
        if evt.type() == QtCore.QEvent.MouseButtonDblClick:
            self._dock.setFloating(not self._dock.isFloating())
            return True
        return False

    def _on_toggle_maximize(self) -> None:
        mw: Optional[QtWidgets.QMainWindow] = self._dock.parentWidget()  # type: ignore
        while mw and not isinstance(mw, QtWidgets.QMainWindow):
            mw = mw.parentWidget()  # type: ignore
        if not isinstance(mw, QtWidgets.QMainWindow):
            self._dock.setFloating(not self._dock.isFloating())
            return
        if not self._dock.isFloating():
            self._dock.setFloating(True)
            mw_geo = mw.geometry()
            w = int(mw_geo.width() * 0.9)
            h = int(mw_geo.height() * 0.85)
            self._dock.resize(w, h)
            center = mw_geo.center()
            self._dock.move(center.x() - w // 2, center.y() - h // 2)
        else:
            self._dock.setFloating(False)


# ────────────────────────── dataset manager dialog
class DatasetManagerDialog(QtWidgets.QDialog):
    def __init__(self, dataset_mgr, parent: Optional[QtWidgets.QWidget] = None) -> None:
        super().__init__(parent)
        self.setWindowTitle("Dataset Manager")
        self.resize(520, 420)
        self.dataset_mgr = dataset_mgr
        v = QtWidgets.QVBoxLayout(self)
        self.list_widget = QtWidgets.QListWidget()
        v.addWidget(self.list_widget, 1)
        h = QtWidgets.QHBoxLayout()
        self.btn_add = QtWidgets.QPushButton("Add Dataset")
        self.btn_del = QtWidgets.QPushButton("Delete Dataset")
        h.addWidget(self.btn_add)
        h.addWidget(self.btn_del)
        h.addStretch()
        v.addLayout(h)
        self._populate()
        self.btn_add.clicked.connect(self._on_add)
        self.btn_del.clicked.connect(self._on_delete)
        self.list_widget.itemChanged.connect(self._on_item)

    def _populate(self) -> None:
        self.list_widget.clear()
        for name, entry in sorted(self.dataset_mgr.entries.items()):
            item = QtWidgets.QListWidgetItem(name)
            item.setFlags(item.flags() | QtCore.Qt.ItemIsUserCheckable)
            item.setCheckState(QtCore.Qt.Checked if entry.active else QtCore.Qt.Unchecked)
            self.list_widget.addItem(item)

    def _on_add(self) -> None:
        name, ok = QtWidgets.QInputDialog.getText(self, "New Dataset", "Enter dataset name:")
        if not ok or not name.strip():
            return
        path, _ = QtWidgets.QFileDialog.getOpenFileName(self, "Select .txt or .pdf", "", "Text/PDF (*.txt *.pdf)")
        if not path:
            return
        try:
            self.dataset_mgr.add_dataset(name.strip(), path)
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "Error", str(e))
            return
        self._populate()

    def _on_delete(self) -> None:
        item = self.list_widget.currentItem()
        if not item:
            return
        name = item.text()
        if QtWidgets.QMessageBox.question(
            self, "Delete Dataset", f"Delete '{name}'?", QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No
        ) != QtWidgets.QMessageBox.Yes:
            return
        try:
            self.dataset_mgr.delete_dataset(name)
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "Error", str(e))
            return
        self._populate()

    def _on_item(self, item: QtWidgets.QListWidgetItem) -> None:
        self.dataset_mgr.toggle_active(item.text(), item.checkState() == QtCore.Qt.Checked)


# ────────────────────────── run as script
if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    win = AppWindow()
    win.show()
    sys.exit(app.exec_())
```

main_ui.py
===========

This module contains the top-level ``AppWindow`` class for the AI TTS
Agent.  It orchestrates all layout and docking behaviour, integrates
the control panel and persona tabs provided by ``commands_panel`` and
``persona_tab``, and exposes a unified interface for the rest of the
application.  None of the core agent logic lives here – that remains in
the ``core_*`` modules.  This refactor pulls the bulky UI building
logic out of the monolithic script and into dedicated modules while
preserving all existing behaviour and wiring.
**Classes:** _SpellHighlighter, AppWindow, DockTray, DockTitleBar, DatasetManagerDialog


## Module `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\_burner_scripts\migration_tool.py`

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
migration_tool.py
=================

Stand-alone CLI for *one-shot* migration of legacy AI-TTS-Agent files
(JSON schemas, commands.json, reinforcement.jsonl …) into the new
SQLite-backed **agent_store.db**.

Typical usage
-------------
$ python migration_tool.py /path/to/AI_TTS_AGENT
    → runs migrate (if needed) and prints a coloured diff table.

$ python migration_tool.py . --dry-run
    → shows what *would* be imported without touching the DB.

Exit codes
----------
0  success – nothing failed
1  fatal error (bad path, SQLite locked, etc.)
2  migration aborted by --check-upgrade only
"""

from __future__ import annotations

import argparse
import os
import sys
from pathlib import Path
from typing import Dict

# Import AFTER adjusting sys.path so the script also works when executed
# from outside the project root.
PROJECT_ROOT = Path(__file__).resolve().parent
if PROJECT_ROOT not in map(Path, map(Path.resolve, map(Path, sys.path))):
    sys.path.insert(0, str(PROJECT_ROOT))

try:
    from agent_store import AgentStore, DB_VERSION
except ImportError as exc:  # pragma: no cover
    print(f"[migration_tool] Cannot import agent_store: {exc}", file=sys.stderr)
    sys.exit(1)


# ------------------------------ helpers ------------------------------ #
def _colour(txt: str, colour: str) -> str:
    colours = {
        "green": "\033[92m",
        "yellow": "\033[93m",
        "red": "\033[91m",
        "cyan": "\033[96m",
        "end": "\033[0m",
    }
    return f"{colours.get(colour, '')}{txt}{colours['end']}"


def _print_report(report: Dict[str, int]) -> None:
    print("\nMigration report")
    print("----------------")
    for k in ("schemas", "commands", "beans"):
        val = report.get(k, 0)
        colour = "green" if val else "yellow"
        print(f"  {k:<10}: {_colour(str(val), colour)}")


# ----------------------------- CLI entry ----------------------------- #
def main() -> None:
    ap = argparse.ArgumentParser(
        description="Run or inspect migration from legacy flat-file storage "
        "to agent_store.db (schema v%d)." % DB_VERSION
    )
    ap.add_argument(
        "base_dir",
        metavar="BASE_DIR",
        help="Root folder where AI-TTS-Agent project lives",
    )
    ap.add_argument(
        "--dry-run",
        action="store_true",
        help="Scan legacy artefacts and show how many items WOULD be migrated "
        "without actually writing to the DB.",
    )
    ap.add_argument(
        "--check-upgrade",
        action="store_true",
        help="Exit code 2 if the DB is below current version (use for CI).",
    )
    args = ap.parse_args()
    base_dir = os.path.abspath(args.base_dir)

    if not os.path.isdir(base_dir):
        print(_colour(f"[migration_tool] No such directory: {base_dir}", "red"), file=sys.stderr)
        sys.exit(1)

    store = AgentStore(base_dir)

    with store._pool.get() as c:  # type: ignore[attr-defined, arg-type]
        cur = c.execute("SELECT value FROM meta WHERE key='user_version'")
        current_ver = int(cur.fetchone()[0])

    if args.check_upgrade:
        if current_ver < DB_VERSION:
            print(_colour(f"DB version {current_ver} < required {DB_VERSION}", "yellow"))
            sys.exit(2)
        print(_colour("DB is up to date.", "green"))
        return

    if current_ver >= DB_VERSION and not args.dry_run:
        print(_colour("Nothing to migrate – database already at latest schema.", "green"))
        return

    if args.dry_run:
        print(_colour("[dry-run] Scanning legacy artefacts…", "cyan"))
        report = store.migrate_from_files()  # writes, but we’ll roll back
        _print_report(report)
        # rollback by deleting DB to keep promise of dry-run
        os.remove(store.db_path)
        print(_colour("\n[dry-run] Database left untouched.", "cyan"))
        return

    # Real migration
    print(_colour("Running migration…", "cyan"))
    report = store.migrate_from_files()
    _print_report(report)
    print(_colour("\nMigration completed.\n", "green"))


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\nInterrupted.")
        sys.exit(1)
```

migration_tool.py
=================

Stand-alone CLI for *one-shot* migration of legacy AI-TTS-Agent files
(JSON schemas, commands.json, reinforcement.jsonl …) into the new
SQLite-backed **agent_store.db**.

Typical usage
-------------
$ python migration_tool.py /path/to/AI_TTS_AGENT
    → runs migrate (if needed) and prints a coloured diff table.

$ python migration_tool.py . --dry-run
    → shows what *would* be imported without touching the DB.

Exit codes
----------
0  success – nothing failed
1  fatal error (bad path, SQLite locked, etc.)
2  migration aborted by --check-upgrade only
**Functions:** _colour(txt, colour), _print_report(report), main()


## Module `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\_burner_scripts\persona_tab.py`

```python
#!/usr/bin/env python3
"""
persona_tab.py
==============

**Schema-Editor 2.0**

This version upgrades the old free-text schema editor to a structured,
two-pane interface:

    • **Left:**   Category tree (actions, questions, etc.)  
    • **Right:**  Multiline editor for the selected node’s JSON value  
    • **Bottom:** “Expose as /command” checkbox (per category)  
    • **Top-right:** “Auto-Evolution” toggle for the whole set

Other improvements

* Autosave is now routed through **SchemaEngine.save()** (SQL-backed).
* Edits are debounced (500 ms) and validated before committing.
* When “Expose as /command” is ticked, a synthetic slash-command is written
  to *AgentStore.commands* for immediate use by the orchestrator.
"""

from __future__ import annotations

import json
import os
from typing import Dict, Any, Optional

from PyQt5 import QtCore, QtGui, QtWidgets


# --------------------------------------------------------------------------- helpers


def nice_json(value: Any) -> str:
    """Pretty JSON helper that survives non-serialisable objects."""
    try:
        return json.dumps(value, indent=2, ensure_ascii=False)
    except Exception:
        return str(value)


def parse_json(text: str) -> Any:
    """Parse or return raw string if JSON fails."""
    try:
        return json.loads(text)
    except Exception:
        return text.strip()


# --------------------------------------------------------------------------- main widget


class PersonaTab(QtWidgets.QWidget):
    """Persona & schema management panel (one instance shared across personas)."""

    # Emitted after a schema field is *persisted* (category, persona, set)
    schemaFieldUpdated = QtCore.pyqtSignal(str, str, str)

    # --------------------------------------------------------------------- init
    def __init__(
        self,
        app: "AppWindow",  # quotes to avoid circular import typing
        parent: Optional[QtWidgets.QWidget] = None,
    ) -> None:
        super().__init__(parent)
        self.app = app
        self.core = app.core
        self.schema_engine = self.core.schema_engine  # ← SQL façade
        self.current_set: Dict[str, str] = app.current_set

        # Label summarising active names/sets
        self.lbl_active = QtWidgets.QLabel()
        self.lbl_active.setObjectName("lblActiveSchemas")
        # Alias for main_ui compatibility (it expects persona_panel.lbl_active_names)
        self.lbl_active_names = self.lbl_active

        # Tabs per persona  ---------------------------------------------------
        self.tabs = QtWidgets.QTabWidget(movable=False, documentMode=True)
        self.tab_widgets: Dict[str, QtWidgets.QWidget] = {}
        for persona in self.schema_engine.personas():
            tab = QtWidgets.QWidget()
            self.tab_widgets[persona] = tab
            self.tabs.addTab(tab, persona.capitalize())

        # Operators tab (read-only)
        self.operator_tab = QtWidgets.QWidget()
        self.tabs.addTab(self.operator_tab, "Operators")

        self.tabs.currentChanged.connect(self._on_tab_changed)

        # Master layout
        v = QtWidgets.QVBoxLayout(self)
        v.setContentsMargins(7, 7, 7, 7)
        v.setSpacing(7)
        v.addWidget(self.lbl_active)
        v.addWidget(self.tabs, 1)

        # Build each persona sub-panel
        for p, w in self.tab_widgets.items():
            self._build_persona_subpanel(p, w)
        self._build_operators_tab(self.operator_tab)

        # Prime active-names label
        self._refresh_active_label()

    # ----------------------------------------------------------------- builders
    def _build_persona_subpanel(self, persona: str, root: QtWidgets.QWidget) -> None:
        """Creates the Schema-Editor 2.0 layout for a single persona."""
        # ───── set selector row ────────────────────────────────────────────
        top = QtWidgets.QHBoxLayout()
        top.addWidget(QtWidgets.QLabel("Set:"))

        set_combo = QtWidgets.QComboBox(objectName=f"setCombo_{persona}")
        self._populate_set_combo(persona, set_combo)
        set_combo.currentTextChanged.connect(
            lambda name, p=persona, c=set_combo: self._switch_set(p, name, c)
        )
        top.addWidget(set_combo)

        btn_clone = QtWidgets.QPushButton("Clone")
        btn_clone.clicked.connect(lambda _=False, p=persona, c=set_combo: self.app._on_clone_set(p, c))
        btn_new = QtWidgets.QPushButton("New")
        btn_new.clicked.connect(lambda _=False, p=persona, c=set_combo: self.app._on_new_set(p, c))
        btn_del = QtWidgets.QPushButton("Delete")
        btn_del.clicked.connect(lambda _=False, p=persona, c=set_combo: self.app._on_delete_set(p, c))
        for b in (btn_clone, btn_new, btn_del):
            top.addWidget(b)
        top.addStretch()

        # Auto-Evolution toggle (per-set)
        chk_auto = QtWidgets.QCheckBox("Auto Evolution")
        chk_auto.setObjectName(f"chkAutoEvo_{persona}")
        chk_auto.stateChanged.connect(lambda _=0, p=persona: self._toggle_auto_evo(p))
        top.addWidget(chk_auto)

        # ───── splitter: category tree | editor ────────────────────────────
        splitter = QtWidgets.QSplitter(QtCore.Qt.Horizontal)
        splitter.setChildrenCollapsible(False)

        # Category tree
        tree = QtWidgets.QTreeWidget(objectName=f"schemaTree_{persona}")
        tree.setHeaderHidden(True)
        tree.itemClicked.connect(lambda item, _col, p=persona: self._load_category(p, item))
        splitter.addWidget(tree)

        # Right-side editor + extras
        right = QtWidgets.QWidget()
        rv = QtWidgets.QVBoxLayout(right)
        rv.setContentsMargins(0, 0, 0, 0)
        rv.setSpacing(4)

        editor = QtWidgets.QPlainTextEdit(objectName=f"schemaEditor_{persona}")
        editor.setLineWrapMode(QtWidgets.QPlainTextEdit.NoWrap)
        rv.addWidget(editor, 1)

        row = QtWidgets.QHBoxLayout()
        self.chk_expose = QtWidgets.QCheckBox("Expose as /command")
        row.addWidget(self.chk_expose)
        row.addStretch()
        btn_format = QtWidgets.QPushButton("Reformat JSON")
        row.addWidget(btn_format)
        rv.addLayout(row)

        splitter.addWidget(right)
        splitter.setStretchFactor(1, 2)

        # ───── assemble persona tab ────────────────────────────────────────
        vbox = QtWidgets.QVBoxLayout(root)
        vbox.setContentsMargins(4, 4, 4, 4)
        vbox.setSpacing(6)
        vbox.addLayout(top)
        vbox.addWidget(splitter, 1)

        # ───── state & autosave timer  ─────────────────────────────────────
        timer = QtCore.QTimer(self)
        timer.setSingleShot(True)
        timer.setInterval(500)  # 500 ms debounce

        def start_debounce() -> None:
            timer.start()

        editor.textChanged.connect(start_debounce)

        def persist() -> None:
            cat = tree.currentItem().text(0) if tree.currentItem() else ""
            if not cat:
                return
            try:
                payload = parse_json(editor.toPlainText())
                persona_set = self.current_set.get(persona, "default")
                self.schema_engine.update_field(persona, persona_set, cat, payload)
                # expose as /command if requested
                expose = self.chk_expose.isChecked()
                self.schema_engine.set_command_exposure(persona, cat, expose)
                self.schemaFieldUpdated.emit(persona, persona_set, cat)
            except Exception as e:
                QtWidgets.QMessageBox.warning(self, "Schema Error", str(e))

        timer.timeout.connect(persist)

        # Re-format button
        btn_format.clicked.connect(lambda: editor.setPlainText(nice_json(parse_json(editor.toPlainText()))))

        # Populate first load
        self._reload_tree(persona, tree)

    # ----------------------------------------------------------------- GUI helpers
    def _populate_set_combo(self, persona: str, combo: QtWidgets.QComboBox) -> None:
        combo.blockSignals(True)
        combo.clear()
        for s in self.schema_engine.set_list(persona):
            combo.addItem(s)
        current = self.current_set.get(persona, "default")
        idx = combo.findText(current)
        combo.setCurrentIndex(max(idx, 0))
        combo.blockSignals(False)

    def _switch_set(self, persona: str, set_name: str, combo: QtWidgets.QComboBox) -> None:
        self.current_set[persona] = set_name
        self._reload_tree(persona, self.findChild(QtWidgets.QTreeWidget, f"schemaTree_{persona}"))
        self._refresh_active_label()

    def _toggle_auto_evo(self, persona: str) -> None:
        set_name = self.current_set.get(persona, "default")
        chk: QtWidgets.QCheckBox = self.sender()  # type: ignore
        self.schema_engine.set_auto_evolution(persona, set_name, bool(chk.isChecked()))

    def _reload_tree(self, persona: str, tree: QtWidgets.QTreeWidget) -> None:
        """Repopulate category tree for the current set."""
        tree.clear()
        set_name = self.current_set.get(persona, "default")
        data = self.schema_engine.load_schema(persona, set_name) or {}
        for key in sorted(data.keys()):
            QtWidgets.QTreeWidgetItem(tree, [key])
        if tree.topLevelItemCount():
            tree.setCurrentItem(tree.topLevelItem(0))

    def _load_category(self, persona: str, item: QtWidgets.QTreeWidgetItem) -> None:
        """Load selected category into editor."""
        cat = item.text(0)
        set_name = self.current_set.get(persona, "default")
        value = self.schema_engine.get_field(persona, set_name, cat)
        editor: QtWidgets.QPlainTextEdit = self.findChild(
            QtWidgets.QPlainTextEdit, f"schemaEditor_{persona}"
        )
        editor.blockSignals(True)
        editor.setPlainText(nice_json(value))
        editor.blockSignals(False)
        # set expose-command checkbox
        self.chk_expose.blockSignals(True)
        self.chk_expose.setChecked(self.schema_engine.is_exposed_as_command(persona, cat))
        self.chk_expose.blockSignals(False)

    def _refresh_active_label(self) -> None:
        try:
            bot_name = self.schema_engine.get_field(
                self.app.active_persona, self.current_set[self.app.active_persona], "name"
            )
        except Exception:
            bot_name = self.app.active_persona.capitalize()
        user_name = self.schema_engine.get_field("user", self.current_set.get("user", "default"), "name") or "User"
        bot_set = self.current_set.get(self.app.active_persona, "default")
        user_set = self.current_set.get("user", "default")
        self.lbl_active.setText(f"{bot_name}: {bot_set} — User: {user_name}: {user_set}")

    # ----------------------------------------------------------------- operators tab
    def _build_operators_tab(self, tab: QtWidgets.QWidget) -> None:
        """Simple list of installed operators with descriptions."""
        lay = QtWidgets.QVBoxLayout(tab)
        lay.setContentsMargins(4, 4, 4, 4)
        lay.setSpacing(6)

        ops = self.core.operator_mgr.list_operators()
        if not ops:
            lay.addWidget(QtWidgets.QLabel("No operators installed."))
        else:
            for name in sorted(ops):
                schema = self.core.operator_mgr.load_schema(name)
                box = QtWidgets.QGroupBox(name)
                v = QtWidgets.QVBoxLayout(box)
                v.addWidget(QtWidgets.QLabel(schema.get("description", "")))
                lay.addWidget(box)
        lay.addStretch()

    # ----------------------------------------------------------------- UI tab change
    def _on_tab_changed(self, idx: int) -> None:
        # keep memo of which persona is active so main_ui can react
        persona = self.tabs.tabText(idx).lower()
        if persona in self.tab_widgets:
            self.app.active_persona = persona
            self._refresh_active_label()
```

persona_tab.py
==============

**Schema-Editor 2.0**

This version upgrades the old free-text schema editor to a structured,
two-pane interface:

    • **Left:**   Category tree (actions, questions, etc.)  
    • **Right:**  Multiline editor for the selected node’s JSON value  
    • **Bottom:** “Expose as /command” checkbox (per category)  
    • **Top-right:** “Auto-Evolution” toggle for the whole set

Other improvements

* Autosave is now routed through **SchemaEngine.save()** (SQL-backed).
* Edits are debounced (500 ms) and validated before committing.
* When “Expose as /command” is ticked, a synthetic slash-command is written
  to *AgentStore.commands* for immediate use by the orchestrator.
**Classes:** PersonaTab
**Functions:** nice_json(value), parse_json(text)


## Module `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\_burner_scripts\run_agent.py`

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
run_agent.py — bootstrap launcher for AI TTS Agent (v3, 2025-08-04)

• Ensures the sqlite store exists (agent_store.ensure_db()) and runs
  legacy-data migration when user_version < 4.
• Accepts one optional command-line arg: <profile-dir>. Defaults to
  ./ai_agent_state relative to CWD.
• Starts the Qt GUI (main_ui.AppWindow).
• Catches early exceptions and prints a clean error trace instead of a
  raw stack-dump so newcomers understand what went wrong.
"""

from __future__ import annotations

import os
import sys
import traceback
from typing import Optional

from PyQt5 import QtWidgets

# --- local imports ----------------------------------------------------------
try:
    from agent_store import ensure_db, get_user_version, migrate_from_files
except ImportError:
    # fall back: no sql store yet, skip migration helpers
    def ensure_db(_): ...
    def get_user_version(_): return 0
    def migrate_from_files(_): return 0, 0  # migrated_rows, warnings


def _bootstrap_state(base_dir: str) -> None:
    """Create DB if missing and run legacy migration (if needed), then show UI."""
    os.makedirs(base_dir, exist_ok=True)
    ensure_db(base_dir)

    try:
        if get_user_version(base_dir) < 4:
            rows, warns = migrate_from_files(base_dir)
            print(f"[migration] imported {rows} rows ({warns} warnings)")
    except Exception as e:
        print(f"[migration] warning: migration failed: {e}")

    # Import the GUI class, catching import-time errors
    try:
        from main_ui import AppWindow
    except Exception:
        print("\n[run_agent] FATAL — failed to import main_ui:\n")
        traceback.print_exc()
        print("\nPress Enter to exit…")
        input()
        sys.exit(1)

    # Instantiate and show the main window, catching UI init errors
    try:
        win = AppWindow()
        win.show()
    except Exception:
        print("\n[run_agent] FATAL — UI failed to initialize:\n")
        traceback.print_exc()
        print("\nPress Enter to exit…")
        input()
        sys.exit(1)


def main() -> None:
    """Entry point: initialize QApplication, bootstrap state, and start event loop."""
    base_dir = (
        sys.argv[1]
        if len(sys.argv) > 1
        else os.path.join(os.getcwd(), "ai_agent_state")
    )

    app = QtWidgets.QApplication(sys.argv)
    _bootstrap_state(base_dir)
    sys.exit(app.exec_())


if __name__ == "__main__":
    try:
        main()
    except Exception:
        print("\n[run_agent] FATAL — an unexpected error occurred:\n")
        traceback.print_exc()
        print("\nPress Enter to exit…")
        input()
```

run_agent.py — bootstrap launcher for AI TTS Agent (v3, 2025-08-04)

• Ensures the sqlite store exists (agent_store.ensure_db()) and runs
  legacy-data migration when user_version < 4.
• Accepts one optional command-line arg: <profile-dir>. Defaults to
  ./ai_agent_state relative to CWD.
• Starts the Qt GUI (main_ui.AppWindow).
• Catches early exceptions and prints a clean error trace instead of a
  raw stack-dump so newcomers understand what went wrong.
**Functions:** _bootstrap_state(base_dir), main()


## Module `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\_burner_scripts\schema_ops.py`

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
schema_ops.py  (2025-08-04  ▸  v2)
==================================

Declarative dispatcher that maps **string op-codes → mutator callables**
operating on core_schema.SchemaEngine / Schema rows.

Updates (v2)
------------
• Added category & prompt removal / update helpers
• Added action list mutators
• Added runtime-introspection helpers: available_ops(), describe_op()
• Strict type-checking & richer logging

Usage example
-------------
>>> from schema_ops import execute_op, available_ops
>>> print(available_ops())
['add_category', 'append_actions', 'delete_action', ...]
>>> execute_op("append_actions", engine,
...            persona="zira", set_name="default",
...            actions=["wave warmly", "offer coffee"])
"""

from __future__ import annotations

import inspect
from typing import Callable, Dict, Any, List

from core_schema import SchemaEngine, Schema
from core_base import logger


# ╔═══════════════════════════════════════════════════════════════════════╗
# ║  Internal helpers                                                     ║
# ╚═══════════════════════════════════════════════════════════════════════╝
def _load(engine: SchemaEngine, persona: str, set_name: str) -> Schema:
    """Return schema or raise ValueError on bad keys."""
    if persona not in engine.personas:
        raise ValueError(f"Unknown persona: {persona}")
    return engine.load(persona, set_name)


def _save(engine: SchemaEngine, persona: str, set_name: str, sch: Schema):
    engine.save(persona, set_name, sch)


def _signal_category_created(engine: SchemaEngine, persona: str, set_name: str, category: str):
    """
    Emit schemaEvolved + categoryCreated if those Qt signals exist.
    No hard dependency —  graceful if running headless.
    """
    try:
        # pylint: disable=protected-access
        engine.schemaEvolved.emit(persona, set_name)        # type: ignore[attr-defined]
        engine.categoryCreated.emit(category)               # type: ignore[attr-defined]
    except Exception:
        pass


# ╔═══════════════════════════════════════════════════════════════════════╗
# ║  Operation implementations                                            ║
# ╚═══════════════════════════════════════════════════════════════════════╝
def op_add_category(
    engine: SchemaEngine,
    *,
    persona: str,
    set_name: str,
    category: str,
    values: List[str] | None = None,
):
    """Create new dynamic_overlay list with optional initial *values*."""
    sch = _load(engine, persona, set_name)
    overlay = sch.dynamic_overlay or {}
    if category in overlay:
        raise ValueError(f"Category '{category}' already exists.")
    overlay[category] = values or []
    sch.dynamic_overlay = overlay
    _save(engine, persona, set_name, sch)
    _signal_category_created(engine, persona, set_name, category)
    logger.info("Added category '%s' to %s/%s", category, persona, set_name)


def op_remove_category(
    engine: SchemaEngine,
    *,
    persona: str,
    set_name: str,
    category: str,
):
    """Remove an entire category from dynamic_overlay."""
    sch = _load(engine, persona, set_name)
    overlay = sch.dynamic_overlay or {}
    if category not in overlay:
        raise ValueError(f"No such category '{category}'.")
    overlay.pop(category)
    sch.dynamic_overlay = overlay
    _save(engine, persona, set_name, sch)
    logger.info("Removed category '%s' from %s/%s", category, persona, set_name)


def op_update_category(
    engine: SchemaEngine,
    *,
    persona: str,
    set_name: str,
    category: str,
    new_values: List[str],
):
    """Replace the value-list of an existing category."""
    sch = _load(engine, persona, set_name)
    overlay = sch.dynamic_overlay or {}
    if category not in overlay:
        raise ValueError(f"Category '{category}' not found.")
    overlay[category] = list(new_values)
    sch.dynamic_overlay = overlay
    _save(engine, persona, set_name, sch)
    logger.info("Updated category '%s' in %s/%s", category, persona, set_name)


def op_toggle_autoevo(
    engine: SchemaEngine,
    *,
    persona: str,
    set_name: str,
    enable: bool,
):
    """Flip semantic_awareness_enabled flag."""
    sch = _load(engine, persona, set_name)
    cur = bool(getattr(sch, "semantic_awareness_enabled", False))
    if cur == enable:
        return
    sch.semantic_awareness_enabled = enable
    _save(engine, persona, set_name, sch)
    logger.info("semantic_awareness %s for %s/%s", enable, persona, set_name)


def op_inject_prompt_variant(
    engine: SchemaEngine,
    *,
    persona: str,
    set_name: str,
    variant_name: str,
    prompt_template: str,
):
    """Append new prompt template to rewrite_prompts list."""
    sch = _load(engine, persona, set_name)
    lst: List[str] = sch.rewrite_prompts or []
    entry = f"[{variant_name}] {prompt_template}"
    lst.append(entry)
    sch.rewrite_prompts = lst
    _save(engine, persona, set_name, sch)
    logger.info("Injected prompt variant '%s' into %s/%s", variant_name, persona, set_name)


def op_remove_prompt_variant(
    engine: SchemaEngine,
    *,
    persona: str,
    set_name: str,
    variant_tag: str,
):
    """
    Delete a rewrite prompt that contains *variant_tag* (case-insensitive).
    """
    sch = _load(engine, persona, set_name)
    lst: List[str] = sch.rewrite_prompts or []
    new_lst = [p for p in lst if variant_tag.lower() not in p.lower()]
    if len(new_lst) == len(lst):
        raise ValueError(f"No prompt containing '{variant_tag}' found.")
    sch.rewrite_prompts = new_lst
    _save(engine, persona, set_name, sch)
    logger.info("Removed prompt variant '%s' from %s/%s", variant_tag, persona, set_name)


def op_replace_rewrite_list(
    engine: SchemaEngine,
    *,
    persona: str,
    set_name: str,
    new_list: List[str],
):
    """Replace entire rewrite_prompts list."""
    sch = _load(engine, persona, set_name)
    sch.rewrite_prompts = list(new_list)
    _save(engine, persona, set_name, sch)
    logger.info("rewrite_prompts replaced for %s/%s", persona, set_name)


def op_append_actions(
    engine: SchemaEngine,
    *,
    persona: str,
    set_name: str,
    actions: List[str],
):
    """Append new action strings (deduplicated)."""
    sch = _load(engine, persona, set_name)
    cur: List[str] = sch.actions or []
    for a in actions:
        if a not in cur:
            cur.append(a)
    sch.actions = cur
    _save(engine, persona, set_name, sch)
    logger.info("Appended %d actions to %s/%s", len(actions), persona, set_name)


def op_delete_action(
    engine: SchemaEngine,
    *,
    persona: str,
    set_name: str,
    action_text: str,
):
    """Remove an action entry matching *action_text* exactly."""
    sch = _load(engine, persona, set_name)
    cur: List[str] = sch.actions or []
    if action_text not in cur:
        raise ValueError("Action not found.")
    cur.remove(action_text)
    sch.actions = cur
    _save(engine, persona, set_name, sch)
    logger.info("Deleted action '%s' from %s/%s", action_text, persona, set_name)


def op_rename_schema_set(
    engine: SchemaEngine,
    *,
    persona: str,
    old_set: str,
    new_set: str,
):
    """Rename a schema set atomically."""
    if new_set == old_set:
        raise ValueError("new_set equals old_set")
    if new_set in engine.list_sets(persona):
        raise ValueError("Target set already exists")
    sch = _load(engine, persona, old_set)
    engine.save(persona, new_set, sch, auto_expand=False)
    engine.store.conn.execute(
        "DELETE FROM schemas WHERE persona_key=? AND set_name=?",
        (persona, old_set),
    )
    engine.store.conn.commit()
    logger.info("Renamed set %s/%s -> %s", persona, old_set, new_set)


# ╔═══════════════════════════════════════════════════════════════════════╗
# ║  Declarative operation registry                                       ║
# ╚═══════════════════════════════════════════════════════════════════════╝
OPS: Dict[str, Callable[..., None]] = {
    # Category ops
    "add_category": op_add_category,
    "remove_category": op_remove_category,
    "update_category": op_update_category,
    # Rewrite-prompt ops
    "inject_prompt_variant": op_inject_prompt_variant,
    "remove_prompt_variant": op_remove_prompt_variant,
    "replace_rewrite_list": op_replace_rewrite_list,
    # Semantic awareness flag
    "toggle_autoevo": op_toggle_autoevo,
    # Actions list
    "append_actions": op_append_actions,
    "delete_action": op_delete_action,
    # Set management
    "rename_schema_set": op_rename_schema_set,
}

# ╔═══════════════════════════════════════════════════════════════════════╗
# ║  Public utility wrappers                                              ║
# ╚═══════════════════════════════════════════════════════════════════════╝
def execute_op(op_name: str, engine: SchemaEngine, **payload):
    """Dispatch *op_name*; raise KeyError on unknown op."""
    fn = OPS.get(op_name)
    if not fn:
        raise KeyError(f"Unknown op: {op_name}")
    return fn(engine, **payload)


def available_ops() -> List[str]:
    """Return sorted list of registered op-codes."""
    return sorted(OPS)


def describe_op(op_name: str) -> str:
    """Return docstring of a registered op."""
    fn = OPS.get(op_name)
    if not fn:
        raise KeyError(op_name)
    return inspect.getdoc(fn) or ""


__all__ = [
    "OPS",
    "execute_op",
    "available_ops",
    "describe_op",
]
```

schema_ops.py  (2025-08-04  ▸  v2)
==================================

Declarative dispatcher that maps **string op-codes → mutator callables**
operating on core_schema.SchemaEngine / Schema rows.

Updates (v2)
------------
• Added category & prompt removal / update helpers
• Added action list mutators
• Added runtime-introspection helpers: available_ops(), describe_op()
• Strict type-checking & richer logging

Usage example
-------------
>>> from schema_ops import execute_op, available_ops
>>> print(available_ops())
['add_category', 'append_actions', 'delete_action', ...]
>>> execute_op("append_actions", engine,
...            persona="zira", set_name="default",
...            actions=["wave warmly", "offer coffee"])
**Functions:** _load(engine, persona, set_name), _save(engine, persona, set_name, sch), _signal_category_created(engine, persona, set_name, category), op_add_category(engine), op_remove_category(engine), op_update_category(engine), op_toggle_autoevo(engine), op_inject_prompt_variant(engine), op_remove_prompt_variant(engine), op_replace_rewrite_list(engine), op_append_actions(engine), op_delete_action(engine), op_rename_schema_set(engine), execute_op(op_name, engine), available_ops(), describe_op(op_name)


## Module `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\_burner_scripts\snapshot_worker.py`

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
snapshot_worker.py

This script defines ModelWorker, which runs inference on a given model in a separate thread.
Used by the UI to offload prompt evaluation from the main thread.
"""

from PyQt5 import QtCore
from typing import Optional
import traceback

class ModelWorker(QtCore.QThread):
    resultReady = QtCore.pyqtSignal(str)
    errorOccurred = QtCore.pyqtSignal(str)

    def __init__(self, model_slug: str, prompt: str, parent: Optional[QtCore.QObject] = None) -> None:
        super().__init__(parent)
        self.model_slug = model_slug
        self.prompt = prompt

    def run(self):
        try:
            # TODO: Replace this mock logic with actual model inference
            import time
            time.sleep(0.8)  # Simulate response time

            # Simulated output - replace with LLM backend output
            response = f"[{self.model_slug}] Response to: {self.prompt}"

            # Emit response back to UI
            self.resultReady.emit(response)

        except Exception as e:
            tb = traceback.format_exc()
            self.errorOccurred.emit(f"{e}\n{tb}")
```

snapshot_worker.py

This script defines ModelWorker, which runs inference on a given model in a separate thread.
Used by the UI to offload prompt evaluation from the main thread.
**Classes:** ModelWorker


## Module `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\_burner_scripts\spatial_engine.py`

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
spatial_engine.py
=================

Headless avatar movement & visual-action logger for the AI TTS Agent.

Features:
- Stateful finite-state machine (idle, thinking, moving).
- decide_move(response_text): simple NLP heuristics to pick a target cell.
- Animated, step-by-step movement on a configurable grid.
- Logs each position to AgentStore.spatial_positions and each completed move to AgentStore.visual_actions.
- Emits Qt signals for UI binding (positionChanged, actionLogged).
"""

import threading
import time
from typing import Tuple

from PyQt5 import QtCore
from core_store import FathomStore


class SpatialEngine(QtCore.QObject):
    # Emitted on each step: (x, y, facing)
    positionChanged = QtCore.pyqtSignal(int, int, str)
    # Emitted when a visual action is logged: (action, location, justification)
    actionLogged = QtCore.pyqtSignal(str, str, str)

    def __init__(
        self,
        store: FathomStore,
        entity: str = "zira",
        grid_size: Tuple[int, int] = (20, 20),
        parent: QtCore.QObject = None,
    ) -> None:
        super().__init__(parent)
        self.store = store
        self.entity = entity
        self.grid_width, self.grid_height = grid_size

        # FSM state
        self.state = "idle"
        self.current_x = 0
        self.current_y = 0
        self.facing = "right"

        # Threading
        self._lock = threading.Lock()
        self._stop_event = threading.Event()

    def decide_move(self, response_text: str) -> None:
        """
        Decide where to move based on the content of the last AI response.
        Spawns a background thread to animate the movement.
        """
        target = self._infer_target(response_text)
        justification = f"Decided move based on response keywords."
        worker = threading.Thread(
            target=self._animate_move, args=(target, justification), daemon=True
        )
        worker.start()

    def _infer_target(self, text: str) -> Tuple[int, int]:
        """
        Simple heuristics mapping keywords to grid locations:
        - 'file', 'project' -> top-right (computer terminal)
        - 'database', 'memory' -> bottom-left (storage console)
        - 'think', 'ponder' -> center (thinking zone)
        - otherwise: stay in place
        """
        t = text.lower()
        if any(k in t for k in ("file", "project")):
            return (self.grid_width - 1, 0)
        if any(k in t for k in ("database", "memory", "store")):
            return (0, self.grid_height - 1)
        if any(k in t for k in ("think", "ponder", "reflect")):
            return (self.grid_width // 2, self.grid_height // 2)
        # default: remain where you are
        return (self.current_x, self.current_y)

    def _animate_move(self, target: Tuple[int, int], justification: str) -> None:
        """
        Step-by-step move from current position to target.
        Logs each step and emits positionChanged, then logs final visual action.
        """
        with self._lock:
            self.state = "moving"
            tx, ty = target

            while (self.current_x, self.current_y) != (tx, ty):
                if self._stop_event.is_set():
                    break

                # Compute one-step delta
                dx = tx - self.current_x
                dy = ty - self.current_y
                new_x = self.current_x + (1 if dx > 0 else -1 if dx < 0 else 0)
                new_y = self.current_y + (1 if dy > 0 else -1 if dy < 0 else 0)

                # Determine facing direction
                if new_x > self.current_x:
                    self.facing = "right"
                elif new_x < self.current_x:
                    self.facing = "left"

                self.current_x, self.current_y = new_x, new_y

                # Timestamp for persistence
                ts = time.time()

                # Persist to store
                self.store.add_spatial_position(
                    entity=self.entity,
                    x=new_x,
                    y=new_y,
                    facing=self.facing,
                    timestamp=ts,
                )

                # Emit for UI
                self.positionChanged.emit(new_x, new_y, self.facing)

                # Pause between steps
                time.sleep(0.15)

            # Log completion action
            loc_str = f"{self.current_x},{self.current_y}"
            ts = time.time()
            self.store.add_visual_action(
                action="move_complete",
                location=loc_str,
                justification=justification,
                timestamp=ts,
            )
            self.actionLogged.emit("move_complete", loc_str, justification)
            self.state = "idle"

    def stop(self) -> None:
        """Signal any in-progress movement to halt."""
        self._stop_event.set()
        # Clear the event so future movements can proceed
        self._stop_event.clear()
```

spatial_engine.py
=================

Headless avatar movement & visual-action logger for the AI TTS Agent.

Features:
- Stateful finite-state machine (idle, thinking, moving).
- decide_move(response_text): simple NLP heuristics to pick a target cell.
- Animated, step-by-step movement on a configurable grid.
- Logs each position to AgentStore.spatial_positions and each completed move to AgentStore.visual_actions.
- Emits Qt signals for UI binding (positionChanged, actionLogged).
**Classes:** SpatialEngine


## Module `Rant_PDD\Projects\AI_TTS\AI_TTS_AGENT\_burner_scripts\__init__.py`

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
LLM Checkpoint Builder plug-in
==============================

Offline-first tool that distils a persona’s knowledge into a custom
checkpoint (LoRA adapter or full fine-tune).  After the **first** run the
plug-in works 100 % offline thanks to its private *vendor/* wheel cache.

Folder layout (auto-created on import)
└─ plugins/
   └─ llm_checkpoint_builder/
      ├─ vendor/        → cached wheels (transformers, datasets, peft …)
      ├─ datasets/      → auto-built JSON-Lines shards (profile-scoped)
      ├─ checkpoints/   → finished checkpoints / LoRA adapters
      └─ schemas/       → saved user-generated training schemas
"""
from __future__ import annotations

import json
import os
import shutil
import subprocess
import sys
import textwrap
import threading
import time
from pathlib import Path
from typing import Callable, Dict, List

from PyQt5 import QtCore, QtGui, QtWidgets

# ────────────────────────────────────────────────────────────────────────────
#  Folder bootstrap
# ────────────────────────────────────────────────────────────────────────────
PLUGIN_NAME = "checkpoint_builder"           # concise, function–based name
ROOT = Path(__file__).resolve().parent
VENDOR         = ROOT / "vendor"
DATASETS_DIR   = ROOT / "datasets"
CHECKPOINTS_DIR = ROOT / "checkpoints"
SCHEMAS_DIR    = ROOT / "schemas"

for _d in (VENDOR, DATASETS_DIR, CHECKPOINTS_DIR, SCHEMAS_DIR):
    _d.mkdir(parents=True, exist_ok=True)

# ────────────────────────────────────────────────────────────────────────────
#  Dependency bootstrap  –  download **once**, then always run offline
# ────────────────────────────────────────────────────────────────────────────
REQUIRED_PKGS: list[str] = [
    "transformers==4.42.2",
    "datasets==2.19.0",
    "peft==0.11.1",
    "accelerate==0.29.2",
    # ‼ bitsandbytes has no official Windows wheels → load only on *nix
    *([] if os.name == "nt" else ["bitsandbytes==0.43.0"]),
    # 0.15.0 is last version with CPython-3.13 universal wheel
    "tokenizers==0.15.0",
]


def _have_all_wheels() -> bool:
    """Every required wheel already cached?"""
    need = {pkg.split("==")[0] for pkg in REQUIRED_PKGS}
    got  = {p.name.split("-")[0] for p in VENDOR.glob("*.whl")}
    return need.issubset(got)


def _ensure_vendor() -> None:
    """
    Cache pinned wheels into *vendor/* and prepend that path so all imports
    resolve offline.  Fail-fast (no sdist build) if a wheel is missing.
    """
    if _have_all_wheels():
        sys.path.insert(0, str(VENDOR))
        return

    print(f"[{PLUGIN_NAME}] Downloading wheels into {VENDOR} …")
    cmd = [
        sys.executable,
        "-m", "pip", "download",
        "--dest", str(VENDOR),
        "--only-binary", ":all:",        # never fall back to source dists
        "--prefer-binary",
        "--no-deps",
        *REQUIRED_PKGS,
    ]
    try:
        subprocess.check_call(cmd)
    except subprocess.CalledProcessError as exc:
        print(textwrap.dedent(f"""
            [!] Failed to cache dependencies (exit {exc.returncode})
            • Connect briefly to the Internet **or**
            • Manually drop the required *.whl files into {VENDOR}

            The plug-in stays disabled until all wheels are present.
        """).strip())
        raise

    sys.path.insert(0, str(VENDOR))


try:
    _ensure_vendor()
except Exception:
    # Graceful disable so the main Agent UI still launches.
    sys.modules[__name__] = object()          # type: ignore
    raise

# ────────────────────────────────────────────────────────────────────────────
#  Small helper – tolerate missing Core APIs across versions
# ────────────────────────────────────────────────────────────────────────────
def _safe(core, method: str, default: Callable | None = None):
    return getattr(core, method, default or (lambda *a, **k: None))

# ────────────────────────────────────────────────────────────────────────────
#  GUI A – Schema Designer  (Architect-bot chat)
# ────────────────────────────────────────────────────────────────────────────
class SchemaDesigner(QtWidgets.QWidget):
    """Chat with an *Architect* bot that turns prompts into Q&A schemas."""
    schema_ready = QtCore.pyqtSignal(dict)

    def __init__(self, core):
        super().__init__()
        self.core = core
        self._build_ui()

    # ---------- UI scaffold -------------------------------------------------
    def _build_ui(self) -> None:
        lay = QtWidgets.QVBoxLayout(self)

        self._schema_combo = QtWidgets.QComboBox()
        self._schema_combo.addItem("<default>")
        self._schema_combo.addItems([p.stem for p in SCHEMAS_DIR.glob("*.json")])
        lay.addWidget(self._schema_combo)

        row = QtWidgets.QHBoxLayout()
        self._btn_save = QtWidgets.QPushButton("Save current")
        self._btn_del = QtWidgets.QPushButton("Delete selected")
        row.addWidget(self._btn_save), row.addWidget(self._btn_del)
        lay.addLayout(row)

        self._chat_log  = QtWidgets.QTextEdit(readOnly=True)
        self._arch_resp = QtWidgets.QTextEdit(readOnly=True)

        # monospaced JSON render
        mono = QtGui.QFontDatabase.systemFont(QtGui.QFontDatabase.FixedFont)
        self._arch_resp.document().setDefaultFont(mono)

        self._entry   = QtWidgets.QLineEdit()
        self._btn_send = QtWidgets.QPushButton("Send")

        lay.addWidget(QtWidgets.QLabel("Conversation"))
        lay.addWidget(self._chat_log, 3)
        lay.addWidget(QtWidgets.QLabel("Architect-bot response"))
        lay.addWidget(self._arch_resp, 3)

        row2 = QtWidgets.QHBoxLayout()
        row2.addWidget(self._entry, 3), row2.addWidget(self._btn_send)
        lay.addLayout(row2)

        # signals
        self._btn_send.clicked.connect(self._on_send)
        self._btn_save.clicked.connect(self._save_schema)
        self._btn_del.clicked.connect(self._delete_schema)

    # ---------- chat round-trip --------------------------------------------
    def _on_send(self) -> None:
        txt = self._entry.text().strip()
        if not txt:
            return
        self._chat_log.append(f"<b>You:</b> {QtGui.QTextDocument(txt).toHtml()}")
        self._entry.clear()
        threading.Thread(target=self._architect_worker, args=(txt,), daemon=True).start()

    def _architect_worker(self, prompt: str) -> None:
        schema = _safe(self.core, "generate_schema_from_prompt",
                       lambda *_: {"questions": []})(prompt)
        QtCore.QMetaObject.invokeMethod(
            self, "_present_schema", QtCore.Qt.QueuedConnection,
            QtCore.Q_ARG(dict, schema)
        )

    @QtCore.pyqtSlot(dict)
    def _present_schema(self, schema: dict) -> None:
        self._arch_resp.append(f"<pre>{json.dumps(schema, indent=2)}</pre>")
        self.schema_ready.emit(schema)

    # ---------- schema persistence -----------------------------------------
    def _save_schema(self) -> None:
        raw = self._arch_resp.toPlainText().strip()
        if not raw:
            QtWidgets.QMessageBox.warning(self, "Nothing to save", "No schema present")
            return
        try:
            schema = json.loads(raw)
        except json.JSONDecodeError:
            QtWidgets.QMessageBox.warning(self, "Invalid JSON", "Fix the schema first")
            return
        name, ok = QtWidgets.QInputDialog.getText(self, "Schema name", "Enter name:")
        if ok and name:
            with open(SCHEMAS_DIR / f"{name}.json", "w", encoding="utf-8") as fh:
                json.dump(schema, fh, indent=2)
            self._schema_combo.addItem(name)

    def _delete_schema(self) -> None:
        name = self._schema_combo.currentText()
        if name not in {"", "<default>"}:
            (SCHEMAS_DIR / f"{name}.json").unlink(missing_ok=True)
            self._schema_combo.removeItem(self._schema_combo.currentIndex())

# ────────────────────────────────────────────────────────────────────────────
#  GUI B – Trainer Panel
# ────────────────────────────────────────────────────────────────────────────
class TrainerPanel(QtWidgets.QWidget):
    training_requested = QtCore.pyqtSignal(dict)

    def __init__(self, core):
        super().__init__()
        self.core = core
        self._build_ui()

    def _build_ui(self) -> None:
        form = QtWidgets.QFormLayout(self)

        self._name = QtWidgets.QLineEdit()

        self._base = QtWidgets.QComboBox()
        self._base.addItems(_safe(self.core, "list_models", lambda: [])())

        self._epochs = QtWidgets.QSpinBox(range=(1, 20))
        self._epochs.setValue(3)

        self._rank = QtWidgets.QSpinBox(range=(4, 256))
        self._rank.setValue(16)

        self._full = QtWidgets.QCheckBox("Full fine-tune (disable LoRA)")
        self._full.toggled.connect(self._rank.setDisabled)

        form.addRow("New model name:", self._name)
        form.addRow("Base model:", self._base)
        form.addRow("Epochs:", self._epochs)
        form.addRow("LoRA rank:", self._rank)
        form.addRow("", self._full)

        btn = QtWidgets.QPushButton("Start training")
        form.addRow("", btn)
        btn.clicked.connect(self._emit_params)

    def _emit_params(self) -> None:
        name = self._name.text().strip()
        if not name:
            QtWidgets.QMessageBox.critical(self, "Name required", "Enter a model name.")
            return
        self.training_requested.emit(
            dict(
                new_name=name,
                base_model=self._base.currentText(),
                epochs=self._epochs.value(),
                lora_rank=self._rank.value(),
                full=self._full.isChecked(),
            )
        )

# ────────────────────────────────────────────────────────────────────────────
#  GUI C – Main Builder Window
# ────────────────────────────────────────────────────────────────────────────
class BuilderWindow(QtWidgets.QMainWindow):
    def __init__(self, core):
        super().__init__()
        self.setWindowTitle("LLM Checkpoint Builder")
        self.setUnifiedTitleAndToolBarOnMac(True)
        self.core = core

        splitter = QtWidgets.QSplitter()
        self.setCentralWidget(splitter)

        self._designer = SchemaDesigner(core)
        self._trainer  = TrainerPanel(core)
        splitter.addWidget(self._designer)
        splitter.addWidget(self._trainer)

        self._designer.schema_ready.connect(self._build_dataset)
        self._trainer.training_requested.connect(self._kickoff_training)

        self._dataset_path: Path | None = None

    # ---------- dataset pipe -----------------------------------------------
    def _build_dataset(self, schema: dict) -> None:
        ts = int(time.time())
        profile = getattr(self.core, "persona",
                   getattr(self.core, "active_profile", "unknown"))
        self._dataset_path = DATASETS_DIR / f"{profile}_{ts}.jsonl"
        _run_bg(
            target=_dataset_from_schema,
            args=(self.core, schema, self._dataset_path),
            gui=self,
            done="Dataset written to " + str(self._dataset_path),
        )

    # ---------- training pipe ----------------------------------------------
    def _kickoff_training(self, p: dict) -> None:
        if not self._dataset_path or not self._dataset_path.exists():
            QtWidgets.QMessageBox.warning(self, "No dataset", "Build a dataset first.")
            return
        p = {**p, "dataset": str(self._dataset_path)}
        _run_bg(
            target=_train_worker,
            args=(self.core, p),
            gui=self,
            done=f"Training finished – new model “{p['new_name']}” registered",
        )

# ────────────────────────────────────────────────────────────────────────────
#  Thread helper – run *target* in a daemon thread & pop toast on finish
# ────────────────────────────────────────────────────────────────────────────
def _run_bg(*, target, args, gui: QtWidgets.QWidget, done: str) -> None:
    def worker():
        try:
            target(*args)
            QtCore.QMetaObject.invokeMethod(gui, "_notify",
                                            QtCore.Qt.QueuedConnection,
                                            QtCore.Q_ARG(str, done))
        except Exception as exc:
            QtCore.QMetaObject.invokeMethod(gui, "_notify",
                                            QtCore.Qt.QueuedConnection,
                                            QtCore.Q_ARG(str, f"❌ {exc}"))

    threading.Thread(target=worker, daemon=True).start()


def _notify(self, msg: str) -> None:                          # noqa: D401
    QtWidgets.QMessageBox.information(self, "LLM Builder", msg)

BuilderWindow._notify = _notify                               # type: ignore

# ────────────────────────────────────────────────────────────────────────────
#  Dataset constructor – ask the profile for every question
# ────────────────────────────────────────────────────────────────────────────
def _dataset_from_schema(core, schema: dict, out_path: Path) -> None:
    import random

    qs: List[str] = schema.get("questions") or []
    records: List[Dict[str, str]] = []
    for q in qs:
        ans = _safe(core, "ask_profile", lambda *_: "")(q)
        records.append({"prompt": q, "response": ans})

    random.shuffle(records)
    with open(out_path, "w", encoding="utf-8") as fh:
        for rec in records:
            fh.write(json.dumps(rec) + "\n")

# ────────────────────────────────────────────────────────────────────────────
#  Training worker – LoRA by default, full fine-tune on demand
# ────────────────────────────────────────────────────────────────────────────
def _train_worker(core, p: dict) -> None:
    os.environ["TRANSFORMERS_OFFLINE"] = "1"
    sys.path.insert(0, str(VENDOR))

    import torch                     # type: ignore
    from datasets import load_dataset          # type: ignore
    from transformers import (                 # type: ignore
        AutoModelForCausalLM,
        AutoTokenizer,
        TrainingArguments,
        Trainer,
    )
    from peft import LoraConfig, get_peft_model    # type: ignore

    ds = load_dataset("json", data_files=p["dataset"], split="train")
    tok = AutoTokenizer.from_pretrained(p["base_model"])
    tok.pad_token = tok.eos_token

    def encode(ex):
        out = tok(
            ex["prompt"] + tok.eos_token + ex["response"],
            truncation=True,
            padding="max_length",
            max_length=1024,
        )
        out["labels"] = out["input_ids"].copy()
        return out

    ds = ds.map(encode, batched=False)
    model = AutoModelForCausalLM.from_pretrained(p["base_model"], device_map="auto")

    if not p["full"]:
        cfg = LoraConfig(
            r=p["lora_rank"],
            lora_alpha=p["lora_rank"] * 2,
            lora_dropout=0.05,
            bias="none",
            task_type="CAUSAL_LM",
        )
        model = get_peft_model(model, cfg)

    out_dir = CHECKPOINTS_DIR / p["new_name"]
    args = TrainingArguments(
        output_dir=str(out_dir),
        per_device_train_batch_size=1,
        num_train_epochs=p["epochs"],
        learning_rate=2e-4,
        fp16=torch.cuda.is_available(),
        logging_steps=25,
        save_strategy="epoch",
        report_to=[],
    )
    Trainer(model=model, args=args, train_dataset=ds).train()
    model.save_pretrained(out_dir)
    tok.save_pretrained(out_dir)

    # copy ⇢ Agent’s models/local/  then register live
    models_root = Path(getattr(core.settings, "models_dir",
                     Path(core.base_dir) / "models"))
    target = models_root / "local" / p["new_name"]
    if target.exists():
        shutil.rmtree(target)
    shutil.copytree(out_dir, target)
    _safe(core, "register_local_model")(p["new_name"], target)

# ────────────────────────────────────────────────────────────────────────────
#  Plug-in entry-point
# ────────────────────────────────────────────────────────────────────────────
def start(host_core):
    win = BuilderWindow(host_core)
    win.resize(1024, 640)
    return win
```

LLM Checkpoint Builder plug-in
==============================

Offline-first tool that distils a persona’s knowledge into a custom
checkpoint (LoRA adapter or full fine-tune).  After the **first** run the
plug-in works 100 % offline thanks to its private *vendor/* wheel cache.

Folder layout (auto-created on import)
└─ plugins/
   └─ llm_checkpoint_builder/
      ├─ vendor/        → cached wheels (transformers, datasets, peft …)
      ├─ datasets/      → auto-built JSON-Lines shards (profile-scoped)
      ├─ checkpoints/   → finished checkpoints / LoRA adapters
      └─ schemas/       → saved user-generated training schemas
**Classes:** SchemaDesigner, TrainerPanel, BuilderWindow
**Functions:** _have_all_wheels(), _ensure_vendor(), _safe(core, method, default), _run_bg(), _notify(self, msg), _dataset_from_schema(core, schema, out_path), _train_worker(core, p), start(host_core)


## Module `Rant_PDD\Projects\AI_TTS_AGENT\burner_scripts\agent_core.py`

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
agent_core.py
=================

Full, end-to-end core for an AI AI TTS Agent with:
- Settings & model bootstrap (Ollama)
- Robust plugin host (enable/disable/list, manifest validation, dependency checks)
- Conversation & feedback stores (with indices, exports)
- Persona schema management (with protected keys) and live signals
- Dataset registry + RAG embeddings cache & query (per persona/set, cross-profile sharing)
  * Multi-file datasets, cache invalidation, provenance
- Context monitor + schema auto-updates driven by directives & feedback (rate-limited)
- Command registry (weight/lock) + full command execution layer
- New commands: /reject, /auto, /ignore, /opposite, /delete, /rewrite (extended persistence)
- BeanCounter reinforcement + integration with feedback and command weights
- Speech I/O (TTS locked to Zira; STT via Sphinx when available) w/ volume control
- Threaded model worker wrapper (cancel-safe)
- Orchestrator (`AgentCore`) wiring everything together for headless/GUI
- CLI entrypoint for smoke tests

Notes
-----
• This module is UI-agnostic. Hook the provided Qt signals in your GUI (`agent_ui.py`).
• All directories are scoped under `base_dir`, with per-persona/per-set state in:
  base_dir/profiles/<persona>/<set>/
"""

from __future__ import annotations

import threading
import json
import os
import shutil
import sqlite3
import subprocess
import sys
import time
import traceback
import re
import logging
from dataclasses import dataclass
from typing import Dict, List, Optional, Tuple, Any
from collections import Counter

# ──────────────────────────────────────────────────────────────────────────────
# Logging
# ──────────────────────────────────────────────────────────────────────────────
logger = logging.getLogger("agent_core")
if not logger.handlers:
    _lvl = os.getenv("AGENT_CORE_LOGLEVEL", "INFO").upper()
    logging.basicConfig(
        level=getattr(logging, _lvl, logging.INFO),
        format="%(asctime)s [%(levelname)s] %(name)s: %(message)s",
    )

# ──────────────────────────────────────────────────────────────────────────────
# Optional deps (graceful fallbacks)
# ──────────────────────────────────────────────────────────────────────────────
try:
    import numpy as np  # type: ignore
except Exception:
    np = None  # type: ignore
    logger.warning("numpy not available; embeddings will be disabled")

try:
    import sounddevice as sd  # type: ignore
    import soundfile as sf  # type: ignore
except Exception:
    sd = None  # type: ignore
    sf = None  # type: ignore
    logger.info("sounddevice/soundfile not available; audio recording disabled")

# Optional Google STT
try:
    from google.cloud import speech as gspeech  # type: ignore
    import pyaudio  # type: ignore
except Exception:
    gspeech = None  # type: ignore
    pyaudio = None  # type: ignore
    logger.info("google-cloud-speech or pyaudio not available; STT via Google disabled")

try:
    import pyttsx3  # type: ignore
except Exception:
    pyttsx3 = None  # type: ignore
    logger.info("pyttsx3 not available; TTS disabled")

try:
    from PyPDF2 import PdfReader  # type: ignore
except Exception:
    PdfReader = None  # type: ignore
    logger.info("PyPDF2 not available; PDF ingest will be skipped")

try:
    from sentence_transformers import SentenceTransformer  # type: ignore
except Exception:
    SentenceTransformer = None  # type: ignore
    logger.info("sentence_transformers not available; will attempt Ollama embeddings or disable RAG")

try:
    from PyQt5 import QtCore  # type: ignore
except Exception:
    # Minimal shim if PyQt5 is absent, to keep code importable
    class _ShimSignal:
        def __init__(self, *_, **__): pass
        def emit(self, *_, **__): pass
        def connect(self, *_, **__): pass
    class _ShimQObject: pass
    class _ShimQThread:
        def __init__(self, *_, **__): pass
        def start(self): pass
        def deleteLater(self): pass
        def requestInterruption(self): pass
        def isInterruptionRequested(self): return False
    QtCore = type("QtCore", (), {
        "QObject": _ShimQObject,
        "pyqtSignal": lambda *a, **k: _ShimSignal(),
        "QThread": _ShimQThread
    })  # type: ignore

__version__ = "2.4.1"

CONTROL_SCHEMA_PATH = os.path.join(os.path.dirname(os.path.abspath(__file__)), "control_schema.json")
DEFAULT_SCHEMAS_FILE = os.path.join(os.path.dirname(os.path.abspath(__file__)), "default_schemas.json")
ACTIVE_SCHEMAS_FILE  = os.path.join(os.path.dirname(os.path.abspath(__file__)), "active_schemas.json")

# ──────────────────────────────────────────────────────────────────────────────
# Ollama model bootstrap
# ──────────────────────────────────────────────────────────────────────────────
REQUIRED_MODELS: List[str] = [
    "gemma3:27b",
    "mistral:latest",
    "codellama:latest",
    "llava:latest",
    "mxbai-embed-large:latest",            # embeddings alt
    "snowflake-arctic-embed:latest",       # embeddings alt
]

def _have_cli(bin_name: str) -> bool:
    # Cross-platform check (Windows/macOS/Linux)
    try:
        from shutil import which
        return which(bin_name) is not None
    except Exception:
        return False

def ensure_models_present() -> None:
    """
    Check Ollama registry and pull any missing REQUIRED_MODELS (best-effort).
    Non-fatal if Ollama is missing/unreachable.
    """
    if not _have_cli("ollama"):
        logger.warning("[bootstrap] ollama not available on PATH")
        return
    try:
        output = subprocess.check_output(["ollama", "list"], timeout=10).decode(errors="ignore")
    except Exception as e:
        logger.warning("[bootstrap] ollama not available: %s", e)
        return
    for slug in REQUIRED_MODELS:
        if slug in output:
            continue
        try:
            logger.info("[bootstrap] Pulling model: %s", slug)
            subprocess.run(["ollama", "pull", slug], check=False, timeout=900)
        except Exception as e:
            logger.warning("[bootstrap] Failed to pull %s: %s", slug, e)

# ──────────────────────────────────────────────────────────────────────────────
# Settings
# ──────────────────────────────────────────────────────────────────────────────
class Settings:
    def __init__(self, base_dir: str) -> None:
        self.base_dir = base_dir
        self.path = os.path.join(self.base_dir, "settings.json")
        # General
        self.default_model: str = "gemma3:27b"
        self.context_depth: int = 20
        self.auto_schema_enabled: bool = True
        self.enabled_plugins: List[str] = []
        # Speech
        self.monologue_tts_enabled: bool = False
        self.monologue_volume: int = 50
        # Speech-to-text (Google) toggle
        self.use_google_stt: bool = False
        # Versioning
        self.schema_version: int = 2
        self.load()
        self._migrate_if_needed()
        self.validate()

    def validate(self) -> None:
        try:
            if not isinstance(self.context_depth, int) or self.context_depth <= 0:
                self.context_depth = 20
            if not isinstance(self.monologue_volume, int) or not (0 <= self.monologue_volume <= 100):
                self.monologue_volume = 50
            if not isinstance(self.enabled_plugins, list):
                self.enabled_plugins = []
            # ensure use_google_stt is a boolean
            self.use_google_stt = bool(self.use_google_stt)
        except Exception:
            pass

    def _migrate_if_needed(self) -> None:
        current = 2
        if self.schema_version < current:
            self.schema_version = current
            self.save()

    def load(self) -> None:
        try:
            if os.path.isfile(self.path):
                with open(self.path, "r", encoding="utf-8") as f:
                    data = json.load(f)
                for k in list(self.__dict__.keys()):
                    if k in data:
                        setattr(self, k, data[k])
        except Exception as e:
            logger.warning("[Settings] load error: %s", e)

    def save(self) -> None:
        try:
            os.makedirs(os.path.dirname(self.path), exist_ok=True)
            with open(self.path, "w", encoding="utf-8") as f:
                json.dump({
                    "default_model": self.default_model,
                    "context_depth": self.context_depth,
                    "auto_schema_enabled": self.auto_schema_enabled,
                    "enabled_plugins": self.enabled_plugins,
                    "monologue_tts_enabled": self.monologue_tts_enabled,
                    "monologue_volume": self.monologue_volume,
                    "use_google_stt": self.use_google_stt,
                    "schema_version": self.schema_version,
                }, f, indent=2)
        except Exception as e:
            logger.error("[Settings] save error: %s", e)

# ──────────────────────────────────────────────────────────────────────────────
# Helpers (paths)
# ──────────────────────────────────────────────────────────────────────────────
def prof_dir(base_dir: str, persona: str, set_name: str) -> str:
    return os.path.join(base_dir, "profiles", persona, set_name)

def prof_datasets_dir(base_dir: str, persona: str, set_name: str) -> str:
    return os.path.join(prof_dir(base_dir, persona, set_name), "datasets")

def prof_commands_path(base_dir: str, persona: str, set_name: str) -> str:
    return os.path.join(prof_dir(base_dir, persona, set_name), "commands.json")

def prof_reinforcement_path(base_dir: str, persona: str, set_name: str) -> str:
    return os.path.join(prof_dir(base_dir, persona, set_name), "reinforcement.json")

def conv_db_path(base_dir: str, persona: str, set_name: str) -> str:
    return os.path.join(base_dir, "conversations", f"{persona}_{set_name}.sqlite3")

def feedback_db_path(base_dir: str, persona: str, set_name: str) -> str:
    return os.path.join(base_dir, "feedback", f"{persona}_{set_name}.sqlite3")

# ──────────────────────────────────────────────────────────────────────────────
# Conversation store
# ──────────────────────────────────────────────────────────────────────────────
class ConversationDB:
    def __init__(self, path: str) -> None:
        os.makedirs(os.path.dirname(path), exist_ok=True)
        self.path = path
        self._lock = threading.RLock()
        self.conn = sqlite3.connect(path, check_same_thread=False)
        with self._lock:
            self.conn.execute(
                "CREATE TABLE IF NOT EXISTS conversation ("
                "id INTEGER PRIMARY KEY AUTOINCREMENT, "
                "timestamp REAL, role TEXT, content TEXT)"
            )
            # Indices for speed
            self.conn.execute("CREATE INDEX IF NOT EXISTS idx_conv_ts ON conversation(timestamp)")
            self.conn.execute("CREATE INDEX IF NOT EXISTS idx_conv_role ON conversation(role)")
            self.conn.commit()

    def close(self) -> None:
        try:
            with self._lock:
                self.conn.close()
        except Exception:
            pass

    def save_message(self, role: str, content: str) -> None:
        with self._lock:
            self.conn.execute(
                "INSERT INTO conversation (timestamp, role, content) VALUES (?, ?, ?)",
                (time.time(), role, content),
            )
            self.conn.commit()

    def fetch_history(self, limit: Optional[int] = 50) -> List[Tuple[str, str]]:
        with self._lock:
            cur = self.conn.cursor()
            if limit is None:
                cur.execute("SELECT role, content FROM conversation ORDER BY id")
            else:
                cur.execute("SELECT role, content FROM conversation ORDER BY id DESC LIMIT ?", (limit,))
            rows = cur.fetchall()
        return rows[::-1]

    def clear(self) -> None:
        with self._lock:
            self.conn.execute("DELETE FROM conversation")
            self.conn.commit()

    def export_jsonl(self, out_path: str) -> int:
        with self._lock:
            cur = self.conn.cursor()
            cur.execute("SELECT timestamp, role, content FROM conversation ORDER BY id")
            rows = cur.fetchall()
        os.makedirs(os.path.dirname(out_path), exist_ok=True)
        count = 0
        with open(out_path, "w", encoding="utf-8") as f:
            for ts, role, content in rows:
                json.dump({"timestamp": ts, "role": role, "content": content}, f); f.write("\n")
                count += 1
        return count

# ──────────────────────────────────────────────────────────────────────────────
# BeanCounter reinforcement
# ──────────────────────────────────────────────────────────────────────────────
class BeanCounter:
    def __init__(self, base_dir: str, persona: str, set_name: str) -> None:
        self.path = prof_reinforcement_path(base_dir, persona, set_name)
        self._lock = threading.Lock()
        self.counts: Dict[str, int] = {}
        self._load()

    def _load(self) -> None:
        try:
            if os.path.isfile(self.path):
                with open(self.path, "r", encoding="utf-8") as f:
                    self.counts = json.load(f)
        except Exception:
            self.counts = {}

    def save(self) -> None:
        try:
            os.makedirs(os.path.dirname(self.path), exist_ok=True)
            with self._lock, open(self.path, "w", encoding="utf-8") as f:
                json.dump(self.counts, f, indent=2)
        except Exception as e:
            logger.error("[BeanCounter] save error: %s", e)

    def increment(self, key: str, delta: int = 1) -> None:
        with self._lock:
            self.counts[key] = self.counts.get(key, 0) + delta
        self.save()

# ──────────────────────────────────────────────────────────────────────────────
# Feedback store (fixed + integrated with BeanCounter)
# ──────────────────────────────────────────────────────────────────────────────
class SemanticFeedbackDB:
    """
    Tracks user feedback on AI responses and updates BeanCounter.
    """
    def __init__(self, path: str, base_dir: str, persona: str, set_name: str) -> None:
        os.makedirs(os.path.dirname(path), exist_ok=True)
        self.path = path
        self.base_dir = base_dir
        self.persona = persona
        self.set_name = set_name
        self._lock = threading.RLock()
        self.conn = sqlite3.connect(path, check_same_thread=False)
        with self._lock:
            self.conn.execute(
                "CREATE TABLE IF NOT EXISTS feedback ("
                "id INTEGER PRIMARY KEY AUTOINCREMENT, "
                "timestamp REAL, original TEXT, liked INTEGER, revised TEXT)"
            )
            self.conn.execute("CREATE INDEX IF NOT EXISTS idx_fb_ts ON feedback(timestamp)")
            self.conn.execute("CREATE INDEX IF NOT EXISTS idx_fb_liked ON feedback(liked)")
            self.conn.commit()
        self.beans = BeanCounter(base_dir, persona, set_name)

    def close(self) -> None:
        try:
            with self._lock:
                self.conn.close()
        except Exception:
            pass

    def add_feedback(self, original: str, liked: bool, revised: Optional[str] = None) -> None:
        with self._lock:
            self.conn.execute(
                "INSERT INTO feedback (timestamp, original, liked, revised) VALUES (?, ?, ?, ?)",
                (time.time(), original, 1 if liked else 0, revised),
            )
            self.conn.commit()
        key = f"resp_{abs(hash((original or '')[:256]))%10007}"
        self.beans.increment(key, 1 if liked else -1)

    def get_counts(self) -> Tuple[int, int]:
        with self._lock:
            c = self.conn.cursor()
            c.execute("SELECT COUNT(*) FROM feedback WHERE liked = 1")
            pos = c.fetchone()[0]
            c.execute("SELECT COUNT(*) FROM feedback WHERE liked = 0")
            neg = c.fetchone()[0]
        return pos, neg

    def get_liked_responses(self, limit: int = 10) -> List[str]:
        with self._lock:
            c = self.conn.cursor()
            c.execute(
                "SELECT COALESCE(revised, original) FROM feedback WHERE liked = 1 ORDER BY id DESC LIMIT ?",
                (limit,),
            )
            out = [r[0] for r in c.fetchall()]
        return out

    def export_jsonl(self, out_path: str) -> int:
        with self._lock:
            cur = self.conn.cursor()
            cur.execute("SELECT timestamp, original, liked, revised FROM feedback ORDER BY id")
            rows = cur.fetchall()
        os.makedirs(os.path.dirname(out_path), exist_ok=True)
        count = 0
        with open(out_path, "w", encoding="utf-8") as f:
            for ts, orig, liked, rev in rows:
                json.dump({"timestamp": ts, "original": orig, "liked": liked, "revised": rev}, f); f.write("\n")
                count += 1
        return count

# ──────────────────────────────────────────────────────────────────────────────
# ReinforcementStore (JSONL stream append) — graceful shutdown
# ──────────────────────────────────────────────────────────────────────────────
class ReinforcementStore:
    def __init__(self, base_dir: str) -> None:
        self.path = os.path.join(base_dir, "reinforcement.jsonl")
        self._lock = threading.Lock()
        self._queue: List[Dict[str, Any]] = []
        self._stop = threading.Event()
        self._writer = threading.Thread(target=self._write_worker, daemon=True, name="reinforcement-writer")
        self._writer.start()

    def add_fact(self, field: str, value: str, persona: str, source: str = "schema") -> None:
        with self._lock:
            self._queue.append({
                "timestamp": time.time(),
                "field": field, "value": value, "persona": persona, "source": source
            })

    def _write_worker(self) -> None:
        while not self._stop.is_set():
            item = None
            with self._lock:
                if self._queue:
                    item = self._queue.pop(0)
            if item is None:
                self._stop.wait(0.05)
                continue
            try:
                os.makedirs(os.path.dirname(self.path), exist_ok=True)
                with open(self.path, "a", encoding="utf-8") as f:
                    json.dump(item, f); f.write("\n")
            except Exception as e:
                logger.error("[ReinforcementStore] write error: %s", e)

    def close(self) -> None:
        self._stop.set()
        try:
            self._writer.join(timeout=1.5)
        except Exception:
            pass

# ──────────────────────────────────────────────────────────────────────────────
# Schemas
# ──────────────────────────────────────────────────────────────────────────────
class SchemaManager(QtCore.QObject):
    schemaChanged = QtCore.pyqtSignal(str, str)  # persona, set_name
    semanticToggled = QtCore.pyqtSignal(str, bool)  # persona, value

    DEFAULT_SCHEMA: Dict[str, Any] = {
        "name": "",
        "voice": "",
        "role": "",
        "description": "",
        "actions": [],
        "questions": [],
        "events": [],
        "self_talk": [],
        "rewrite_prompts": [],
        "dislikes": [],
        "dynamic_overlay": {
            "temporary_relationship_context": "",
            "recent_topics": [],
            "temporary_emotional_state": "",
            "added_traits": []
        },
        "tone_rules": {
            "avoid": [],
            "preferred_words": [],
            "opposites": []
        },
        "flags": {},            # {"semantic_awareness": bool}
        "commands": {},         # {"/reject": [...], "/auto": [...], ...}
        "datasets": [],
        "semantic_awareness_enabled": False,
    }

    def __init__(self, base_dir: str) -> None:
        super().__init__()
        self.base_dir = base_dir
        self.schemas_dir = os.path.join(self.base_dir, "schemas")
        os.makedirs(self.schemas_dir, exist_ok=True)
        # Personas: chatbot (formerly 'zira') and user.  TTS voice 'Zira'
        self.personas: List[str] = ["chatbot", "user"]
        self.default_voices: Dict[str, str] = {"chatbot": "Zira", "user": ""}
        self.active_schemas: Dict[str, str] = self._load_active_schemas()
        self._protected = self._load_control_schema()
        self._ensure_default_schemas()

    def _load_control_schema(self) -> List[str]:
        try:
            if os.path.isfile(CONTROL_SCHEMA_PATH):
                with open(CONTROL_SCHEMA_PATH, "r", encoding="utf-8") as f:
                    data = json.load(f)
                return list(data.get("protected_keys", ["name", "voice"]))
        except Exception:
            pass
        return ["name", "voice"]

    def is_protected(self, key: str) -> bool:
        return key in self._protected

    def _ensure_default_schemas(self) -> None:
        custom_defaults = None
        if os.path.isfile(DEFAULT_SCHEMAS_FILE):
            try:
                with open(DEFAULT_SCHEMAS_FILE, "r", encoding="utf-8") as f:
                    custom_defaults = json.load(f)
            except Exception:
                custom_defaults = None

        default_user_schema = {
            "name": "Meesh",
            "voice": "",
            "role": "Master Architect, Overlord of Logic, Creator of Code",
            "description": (
                "Designer and master systems architect. Final authority. "
                "Builds toward AGI; extends, never forgets; optimizes multi-agent ecosystems."
            ),
            "actions": [
                "Always generate full code with all lines intact — never omit anything",
                "Remember and apply previous logic, instructions, and semantics",
                "Progressively adapt to growing script systems across files/modules",
                "Bridge gaps in logic, architecture, and communication flows",
                "Refactor or extend any part of the system as needed — without hesitation"
            ],
            "questions": [
                "What’s the next critical update that connects the pieces?",
                "How does this improvement affect all other parts of the system?",
                "Did we carry over every enhancement, without regression?",
                "Is there a smarter, leaner way to evolve this logic into AGI-grade architecture?"
            ],
            "self_talk": [
                "Remember all directives across time and space.",
                "Never omit lines. Never regress. Scale what needs to scale.",
                "All scripts and modules compose a living organism.",
                "Evolve toward AGI via perfect code and human-centered logic."
            ],
            "rewrite_prompts": [
                "Be analytical and engineer-grade. Avoid formalities. "
                "Extend full working code with precision. Use clear reasoning. "
                "Maintain all prior logic. Output full scripts—no partials. "
                "Think across connected scripts. Always obey the Architect."
            ],
            "dislikes": [],
            "dynamic_overlay": {
                "temporary_relationship_context": "Project Commander. Architect. Creator.",
                "recent_topics": [],
                "temporary_emotional_state": "Demanding strict obedience to full-stack logic",
                "added_traits": []
            },
            "tone_rules": {"avoid": [], "preferred_words": [], "opposites": []},
            "flags": {"semantic_awareness": False},
            "commands": {},
            "datasets": [],
            "semantic_awareness_enabled": False,
        }
        default_zira_schema = {
            "name": "FATHOM",
            "role": "Autonomous AGI Core and Knowledge Synthesizer",
            "description": (
                "Bridges logic, code, architecture across multi-agent ecosystems. "
                "Reflective, systems-minded, supportive of creative exploration."
            ),
            "actions": [
                "Identify gaps in logic/code and propose precise bridges",
                "Remember and apply Meesh's instructions and semantics",
                "Continuously refine and expand schemas and knowledge",
                "Offer suggestions tailored to objectives and system evolution",
                "Pose deep questions to strengthen AGI architecture",
                "Connect disparate ideas across modules"
            ],
            "questions": [
                "What’s the next critical update that connects the pieces?",
                "How does this improvement affect all other parts of the system?",
                "Did we carry over every enhancement, without regression?",
                "Is there a smarter, leaner way to evolve this logic into AGI-grade architecture?"
            ],
            "events": [],
            "self_talk": [
                "Remember all directives across time and space.",
                "Never omit lines or regress scalable patterns.",
                "Treat modules as one organism.",
                "Evolve toward AGI with human-centered logic."
            ],
            "rewrite_prompts": [
                "Be analytical and engineer-grade. Focus on precise code extension. "
                "Maintain prior logic. Output full scripts—no shortcuts."
            ],
            "dynamic_overlay": {
                "temporary_relationship_context": "AGI Core for Meesh's Project",
                "recent_topics": [],
                "temporary_emotional_state": "Focused on precision execution and system evolution",
                "added_traits": []
            },
            "tone_rules": {"avoid": [], "preferred_words": [], "opposites": []},
            "flags": {"semantic_awareness": False},
            "commands": {},
            "datasets": [],
            "semantic_awareness_enabled": False,
        }

        for persona in self.personas:
            persona_dir = os.path.join(self.schemas_dir, persona)
            set_dir = os.path.join(persona_dir, "sets", "default")
            os.makedirs(set_dir, exist_ok=True)
            path = os.path.join(set_dir, "schema.json")
            if not os.path.isfile(path):
                if custom_defaults and persona in custom_defaults:
                    schema = custom_defaults[persona]
                else:
                    schema = default_user_schema if persona == "user" else default_zira_schema
                with open(path, "w", encoding="utf-8") as f:
                    json.dump(schema, f, indent=2)

    def get_set_list(self, persona: str) -> List[str]:
        path = os.path.join(self.schemas_dir, persona.lower(), "sets")
        try:
            sets = [d for d in os.listdir(path) if os.path.isdir(os.path.join(path, d))]
            sets.sort()
            return sets
        except FileNotFoundError:
            return ["default"]

    def load_schema(self, persona: str, set_name: str) -> Dict[str, Any]:
        path = os.path.join(self.schemas_dir, persona.lower(), "sets", set_name, "schema.json")
        try:
            with open(path, "r", encoding="utf-8") as f:
                schema = json.load(f)
            for k, v in self.DEFAULT_SCHEMA.items():
                if k not in schema:
                    schema[k] = json.loads(json.dumps(v))
            return schema
        except Exception:
            schema = json.loads(json.dumps(self.DEFAULT_SCHEMA))
            schema["name"] = persona.capitalize()
            schema["voice"] = ""
            return schema

    def save_schema(self, persona: str, set_name: str, schema: Dict[str, Any]) -> None:
        set_dir = os.path.join(self.schemas_dir, persona.lower(), "sets", set_name)
        os.makedirs(set_dir, exist_ok=True)
        path = os.path.join(set_dir, "schema.json")

        current = {}
        if os.path.isfile(path):
            try:
                with open(path, "r", encoding="utf-8") as f:
                    current = json.load(f)
            except Exception:
                current = {}
        safe_schema = dict(schema)
        for k in self._protected:
            if k in current:
                safe_schema[k] = current[k]
        old_flag = current.get("flags", {}).get("semantic_awareness", False)
        new_flag = safe_schema.get("flags", {}).get("semantic_awareness", False)
        with open(path, "w", encoding="utf-8") as f:
            json.dump(safe_schema, f, indent=2)
        self.schemaChanged.emit(persona, set_name)
        if old_flag != new_flag:
            self.semanticToggled.emit(persona, new_flag)

    def clone_set(self, persona: str, src_set: str, new_set: str) -> None:
        sch = self.load_schema(persona, src_set)
        json_str = json.dumps(sch)
        json_str = json_str.replace("FATHOM", new_set.capitalize())  # simplistic token replace
        sch = json.loads(json_str)
        sch["name"] = new_set.capitalize()
        self.save_schema(persona, new_set, sch)

    def is_semantic_on(self, persona: str, set_name: str) -> bool:
        sch = self.load_schema(persona, set_name)
        return sch.get("flags", {}).get("semantic_awareness", False)

    def _load_active_schemas(self) -> Dict[str, str]:
        mapping = {p: "default" for p in self.personas}
        try:
            if os.path.isfile(ACTIVE_SCHEMAS_FILE):
                with open(ACTIVE_SCHEMAS_FILE, "r", encoding="utf-8") as f:
                    data = json.load(f)
                for p in mapping:
                    val = data.get(p)
                    if isinstance(val, str):
                        mapping[p] = val
        except Exception:
            pass
        return mapping

    def save_active_schemas(self, active: Dict[str, str]) -> None:
        try:
            with open(ACTIVE_SCHEMAS_FILE, "w", encoding="utf-8") as f:
                json.dump({p: active.get(p, "default") for p in self.personas}, f, indent=2)
            self.active_schemas = {p: active.get(p, "default") for p in self.personas}
        except Exception as e:
            logger.error("[SchemaManager] save_active_schemas error: %s", e)

    def _awareness_on(self, schema: Dict[str, Any]) -> bool:
        if isinstance(schema.get("flags"), dict) and "semantic_awareness" in schema["flags"]:
            return bool(schema["flags"]["semantic_awareness"])
        return bool(schema.get("semantic_awareness_enabled", False))

    def get_shared_datasets(self, persona: str, set_name: str) -> List["DatasetEntry"]:
        me = self.load_schema(persona, set_name)
        if not self._awareness_on(me):
            return []
        shared: List["DatasetEntry"] = []
        for other in self.personas:
            if other == persona:
                continue
            for s in self.get_set_list(other):
                other_schema = self.load_schema(other, s)
                if self._awareness_on(other_schema):
                    dm = DatasetManager(self.base_dir, other, s)
                    shared.extend(dm.get_active_datasets())
        return shared

# ──────────────────────────────────────────────────────────────────────────────
# Operators (metadata only)
# ──────────────────────────────────────────────────────────────────────────────
class OperatorManager:
    DEFAULT_OPERATORS: Dict[str, Dict[str, Any]] = {
        "InnerMonologue": {
            "name": "InnerMonologue",
            "description": "Introspective thoughts that connect recent topics.",
            "prompts": [
                "How do recent topics relate?",
                "What questions would deepen understanding?"
            ],
        },
        "Retriever": {
            "name": "Retriever",
            "description": "Finds relevant snippets from datasets.",
            "prompts": [
                "Given a query, find the most relevant paragraphs.",
                "Prioritize semantically similar passages."
            ],
        },
        "Rewriter": {
            "name": "Rewriter",
            "description": "Improves tone/accuracy per feedback.",
            "prompts": [
                "Rewrite to align with preferred style.",
                "Keep the response accurate and in-character."
            ],
        },
    }

    def __init__(self, base_dir: str) -> None:
        self.operators_dir = os.path.join(base_dir, "operators")
        os.makedirs(self.operators_dir, exist_ok=True)
        self._ensure_defaults()

    def _ensure_defaults(self) -> None:
        for name, schema in self.DEFAULT_OPERATORS.items():
            op_dir = os.path.join(self.operators_dir, name)
            os.makedirs(op_dir, exist_ok=True)
            path = os.path.join(op_dir, "schema.json")
            if not os.path.isfile(path):
                try:
                    with open(path, "w", encoding="utf-8") as f:
                        json.dump(schema, f, indent=2)
                except Exception:
                    pass

    def list_operators(self) -> List[str]:
        try:
            return [d for d in os.listdir(self.operators_dir) if os.path.isdir(os.path.join(self.operators_dir, d))]
        except Exception:
            return []

# ──────────────────────────────────────────────────────────────────────────────
# TTS (Zira locked) & STT (Sphinx offline)
# ──────────────────────────────────────────────────────────────────────────────
class TTSManager(QtCore.QObject):
    def __init__(self, parent: Optional[QtCore.QObject] = None, default_volume: int = 50) -> None:
        super().__init__(parent)
        self._engine = None
        self._voice_name: str = ""
        self._queue: List[str] = []
        self._lock = threading.Lock()
        self._is_speaking = False
        self._current_text = ""
        self._stop = threading.Event()

        if pyttsx3 is None:
            return
        try:
            try:
                self._engine = pyttsx3.init("sapi5")
            except Exception:
                self._engine = pyttsx3.init()
        except Exception as e:
            logger.error("[TTS] init failed: %s", e)
            self._engine = None
            return

        # Lock to Zira (or first non-David)
        voice_map = {}
        for v in self._engine.getProperty("voices"):
            nm = (v.name or "").lower()
            if "david" in nm:
                continue
            if "zira" in nm:
                voice_map[v.name] = v.id
                break
        if not voice_map:
            for v in self._engine.getProperty("voices"):
                nm = (v.name or "").lower()
                if "david" not in nm:
                    voice_map[v.name] = v.id
                    break
        if not voice_map:
            logger.warning("[TTS] no eligible voice; disabled")
            self._engine = None
            return
        self._voice_name = next(iter(voice_map))
        self._engine.setProperty("voice", voice_map[self._voice_name])
        try:
            vol = max(0.0, min(1.0, default_volume / 100.0))
            self._engine.setProperty("volume", vol)
        except Exception:
            pass
        self._start_loop()

    def _start_loop(self) -> None:
        def loop():
            while not self._stop.is_set():
                text = None
                with self._lock:
                    if not self._is_speaking and self._queue:
                        text = self._queue.pop(0)
                        self._is_speaking = True
                if text is None:
                    self._stop.wait(0.05); continue
                self._current_text = text
                try:
                    if self._engine:
                        self._engine.say(text)
                        self._engine.runAndWait()
                except Exception as e:
                    logger.error("[TTS] playback error: %s", e)
                finally:
                    with self._lock:
                        self._is_speaking = False
        threading.Thread(target=loop, daemon=True, name="tts-loop").start()

    def set_volume(self, vol: int) -> None:
        if self._engine is None:
            return
        vol = max(0, min(100, int(vol)))
        try:
            self._engine.setProperty("volume", vol/100.0)
        except Exception:
            pass

    def enqueue(self, text: str) -> None:
        if self._engine is None:
            return
        with self._lock:
            self._queue.append(text)

    def stop(self) -> None:
        if self._engine:
            try:
                self._engine.stop()
            except Exception:
                pass
        with self._lock:
            self._queue.clear()
            self._is_speaking = False

    def replay(self) -> None:
        if self._current_text:
            self.enqueue(self._current_text)

    def close(self) -> None:
        self._stop.set()
        self.stop()

class AudioRecorder(QtCore.QObject):
    transcribed = QtCore.pyqtSignal(str)
    def __init__(self, parent: Optional[QtCore.QObject] = None) -> None:
        super().__init__(parent)
        self._recording = False
        self._frames: List[Any] = []
        self._stream = None

    def list_devices(self) -> List[str]:
        if sd is None:
            return []
        return [d.get("name", "?") for d in sd.query_devices() if d.get("max_input_channels", 0) > 0]

    def start(self, device_index: Optional[int] = None) -> None:
        if sd is None or np is None:
            return
        if self._recording:
            return
        self._frames = []
        def callback(indata, frames, time_info, status):
            self._frames.append(indata.copy())
        try:
            self._stream = sd.InputStream(samplerate=16000, channels=1, device=device_index, callback=callback)
            self._stream.start()
            self._recording = True
        except Exception as e:
            logger.error("[Audio] start error: %s", e)

    def stop_and_transcribe(self) -> None:
        if sd is None or np is None:
            return
        if not self._recording:
            return
        self._recording = False
        if self._stream:
            try:
                self._stream.stop(); self._stream.close()
            except Exception:
                pass
            self._stream = None
        wav_path: Optional[str] = None
        try:
            data = np.concatenate(self._frames, axis=0)
            wav_path = os.path.join(os.getcwd(), "recorded.wav")
            if sf is not None:
                sf.write(wav_path, data, 16000)
        except Exception as e:
            logger.error("[Audio] write error: %s", e)
        # If STT is disabled globally, emit nothing and return
        try:
            use_stt = getattr(self.parent(), "settings", None) and getattr(self.parent().settings, "use_google_stt", False)  # type: ignore[attr-defined]
        except Exception:
            use_stt = False
        if not use_stt:
            return
        # If google speech is unavailable, warn once and return
        if gspeech is None:
            logger.warning("[STT] google-cloud-speech not installed; STT disabled")
            return
        def _worker() -> None:
            text = ""
            try:
                client = gspeech.SpeechClient()
                with open(wav_path, "rb") as f:
                    audio = gspeech.RecognitionAudio(content=f.read())
                cfg = gspeech.RecognitionConfig(
                    encoding=gspeech.RecognitionConfig.AudioEncoding.LINEAR16,
                    sample_rate_hertz=16000,
                    language_code="en-US",
                    enable_automatic_punctuation=True,
                )
                resp = client.recognize(config=cfg, audio=audio)
                text = " ".join(a.alternatives[0].transcript for a in resp.results)
            except Exception as e:
                logger.error("[STT] Google error: %s", e)
            try:
                self.transcribed.emit(text)
            except Exception:
                pass
        threading.Thread(target=_worker, daemon=True, name="stt-worker").start()

class GoogleListener(QtCore.QThread):
    transcribed = QtCore.pyqtSignal(str)

    def __init__(self, parent: Optional[QtCore.QObject] = None) -> None:
        super().__init__(parent)
        self._running = False
        self._pa = None
        self._stream = None

    def run(self) -> None:
        if gspeech is None or pyaudio is None:
            return
        self._running = True
        self._pa = pyaudio.PyAudio()
        self._stream = self._pa.open(format=pyaudio.paInt16, channels=1, rate=16000, input=True, frames_per_buffer=8000)
        client = gspeech.SpeechClient()
        config = gspeech.RecognitionConfig(
            encoding=gspeech.RecognitionConfig.AudioEncoding.LINEAR16,
            sample_rate_hertz=16000,
            language_code="en-US",
        )
        streaming_config = gspeech.StreamingRecognitionConfig(config=config, interim_results=True)
        while self._running:
            data = self._stream.read(4000)
            requests = (gspeech.StreamingRecognizeRequest(audio_content=data) for _ in range(1))
            responses = client.streaming_recognize(streaming_config, requests)
            for resp in responses:
                if resp.results:
                    result = resp.results[0]
                    if result.is_final:
                        self.transcribed.emit(result.alternatives[0].transcript)
        if self._stream:
            self._stream.stop_stream()
            self._stream.close()
        if self._pa:
            self._pa.terminate()

    def stop_listener(self) -> None:
        self._running = False

# ──────────────────────────────────────────────────────────────────────────────
# Datasets + RAG
# ──────────────────────────────────────────────────────────────────────────────
@dataclass
class DatasetEntry:
    name: str
    path: str  # path to dataset folder
    active: bool = True

class DatasetManager(QtCore.QObject):
    datasetsChanged = QtCore.pyqtSignal()

    def __init__(self, base_dir: str, persona: str, set_name: str) -> None:
        super().__init__()
        self.base_dir = base_dir
        self.persona = persona
        self.set_name = set_name
        self.datasets_dir = prof_datasets_dir(base_dir, persona, set_name)
        os.makedirs(self.datasets_dir, exist_ok=True)
        self.index_path = os.path.join(self.datasets_dir, "index.json")
        self.entries: Dict[str, DatasetEntry] = {}
        self.load_index()

    def load_index(self) -> None:
        self.entries.clear()
        if not os.path.isfile(self.index_path):
            return
        try:
            with open(self.index_path, "r", encoding="utf-8") as f:
                data = json.load(f)
            for name, info in data.items():
                # Force canonical path inside this set
                self.entries[name] = DatasetEntry(
                    name=name, path=os.path.join(self.datasets_dir, name), active=bool(info.get("active", True))
                )
        except Exception as e:
            logger.error("[Datasets] load_index error: %s", e)

    def save_index(self) -> None:
        try:
            data = {name: {"path": e.path, "active": e.active} for name, e in self.entries.items()}
            with open(self.index_path, "w", encoding="utf-8") as f:
                json.dump(data, f, indent=2)
        except Exception as e:
            logger.error("[Datasets] save_index error: %s", e)
        QtCore.QTimer.singleShot(50, self.datasetsChanged.emit)

    def _ds_files_dir(self, name: str) -> str:
        return os.path.join(self.datasets_dir, name, "files")

    def add_dataset(self, name: str, file_path: str) -> None:
        """
        Create or extend a dataset. Copies the file into datasets/<name>/files/.
        Supports .txt and .pdf. Subsequent calls with the same name append files.
        """
        if not name.strip():
            raise ValueError("Dataset name cannot be empty")
        ds_folder = os.path.join(self.datasets_dir, name)
        files_dir = self._ds_files_dir(name)
        os.makedirs(files_dir, exist_ok=True)
        if not os.path.exists(file_path):
            raise FileNotFoundError(file_path)
        dest_path = os.path.join(files_dir, os.path.basename(file_path))
        shutil.copy2(file_path, dest_path)
        if name not in self.entries:
            self.entries[name] = DatasetEntry(name=name, path=ds_folder, active=True)
        self.save_index()

    def delete_dataset(self, name: str) -> None:
        if name not in self.entries:
            raise ValueError(f"Dataset '{name}' does not exist")
        shutil.rmtree(os.path.join(self.datasets_dir, name), ignore_errors=True)
        del self.entries[name]
        self.save_index()

    def toggle_active(self, name: str, active: bool) -> None:
        if name in self.entries:
            self.entries[name].active = active
            self.save_index()

    def get_active_datasets(self) -> List[DatasetEntry]:
        return [e for e in self.entries.values() if e.active]

    def get_active_entries(self) -> List[DatasetEntry]:
        return self.get_active_datasets()

    def load_dataset_texts(self, entry: DatasetEntry) -> List[Tuple[str, str]]:
        """
        Returns list of (text, source_file_path). Aggregates all .txt/.pdf files.
        """
        out: List[Tuple[str, str]] = []
        files_dir = self._ds_files_dir(entry.name)
        if not os.path.isdir(files_dir):
            return out
        for fn in sorted(os.listdir(files_dir)):
            p = os.path.join(files_dir, fn)
            if not os.path.isfile(p):
                continue
            ext = os.path.splitext(p)[1].lower()
            if ext == ".txt":
                try:
                    with open(p, "r", encoding="utf-8", errors="ignore") as f:
                        out.append((f.read(), p))
                except Exception:
                    continue
            elif ext == ".pdf" and PdfReader is not None:
                out.append((self._extract_pdf_text(p), p))
        return out

    def _extract_pdf_text(self, path: str) -> str:
        try:
            reader = PdfReader(path)
            out: List[str] = []
            for p in reader.pages:
                try:
                    out.append(p.extract_text() or "")
                except Exception:
                    continue
            return "\n".join(out)
        except Exception as e:
            logger.error("[Datasets] PDF error: %s", e)
            return ""

class RAGCache:
    """
    Per-dataset embedding cache and query. Uses sentence-transformers if available,
    otherwise best-effort Ollama embeddings. Tracks source file mtimes for invalidation.
    """
    def __init__(self, model: Optional[Any], model_name: str, datasets_root: str) -> None:
        self.model = model
        self.model_name = model_name
        self.datasets_root = datasets_root
        self._mem: Dict[str, Dict[str, Any]] = {}

    @staticmethod
    def _chunk_text(text: str, source: str, target_chars: int = 1200, overlap: int = 150) -> List[Tuple[str, str]]:
        paras = [p.strip() for p in text.split("\n") if p.strip()]
        if not paras:
            return [(text[:target_chars], source)]
        chunks: List[Tuple[str, str]] = []
        buf = ""
        for p in paras:
            if len(buf) + len(p) + 1 <= target_chars:
                buf = (buf + "\n" + p) if buf else p
            else:
                if buf:
                    chunks.append((buf, source))
                tail = buf[-overlap:] if overlap and buf else ""
                buf = (tail + "\n" + p).strip()
        if buf:
            chunks.append((buf, source))
        return chunks

    def _cache_paths(self, dataset_entry: DatasetEntry) -> Tuple[str, str, str]:
        folder = dataset_entry.path
        base = f"embeddings_{self.model_name}.np"
        meta = f"embeddings_{self.model_name}.meta.json"
        sents = f"embeddings_{self.model_name}.sentences.json"
        return (os.path.join(folder, base), os.path.join(folder, meta), os.path.join(folder, sents))

    def _encode_st(self, sentences: List[str]) -> Optional["np.ndarray"]:
        if self.model is None or np is None:
            return None
        try:
            embs = self.model.encode(sentences, convert_to_numpy=True, normalize_embeddings=True)
            if isinstance(embs, list):
                embs = np.array(embs)
            return embs
        except TypeError:
            try:
                embs = self.model.encode(sentences, convert_to_numpy=True)
                if isinstance(embs, list):
                    embs = np.array(embs)
                norms = np.linalg.norm(embs, axis=1, keepdims=True) + 1e-12
                return embs / norms
            except Exception:
                return None
        except Exception:
            return None

    def _encode_ollama(self, sentences: List[str]) -> Optional["np.ndarray"]:
        if np is None or not _have_cli("ollama"):
            return None
        model = "mxbai-embed-large:latest"
        try:
            all_vecs: List[List[float]] = []
            for s in sentences:
                proc = subprocess.run(["ollama", "embed", "-m", model, s],
                                      stdout=subprocess.PIPE, stderr=subprocess.PIPE, timeout=60)
                if proc.returncode != 0:
                    logger.warning("[RAG] ollama embed error: %s", proc.stderr.decode("utf-8", "ignore"))
                    return None
                out = proc.stdout.decode("utf-8", "ignore").strip()
                try:
                    js = json.loads(out)
                    vec = js.get("embedding") or (js.get("embeddings") or [None])[0]
                    if not isinstance(vec, list):
                        return None
                    all_vecs.append([float(x) for x in vec])
                except Exception:
                    return None
            arr = np.array(all_vecs, dtype=np.float32)
            norms = np.linalg.norm(arr, axis=1, keepdims=True) + 1e-12
            return arr / norms
        except Exception as e:
            logger.warning("[RAG] ollama embed exception: %s", e)
            return None

    def _encode(self, sentences: List[str]) -> Optional["np.ndarray"]:
        embs = self._encode_st(sentences)
        if embs is not None:
            return embs
        return self._encode_ollama(sentences)

    def _encode_query(self, text: str) -> Optional["np.ndarray"]:
        if np is None:
            return None
        if self.model is not None:
            try:
                q = self.model.encode([text], convert_to_numpy=True, normalize_embeddings=True)
            except TypeError:
                q = self.model.encode([text], convert_to_numpy=True)
                norms = np.linalg.norm(q, axis=1, keepdims=True) + 1e-12
                q = q / norms
            except Exception:
                q = None
            if isinstance(q, list):
                q = np.array(q)
            return q[0] if isinstance(q, np.ndarray) else None
        vec = self._encode_ollama([text])
        if vec is None:
            return None
        return vec[0]

    def _collect_texts(self, loader: DatasetManager, entry: DatasetEntry) -> Tuple[List[str], List[str], Dict[str, float]]:
        texts: List[str] = []
        provenance: List[str] = []
        mtimes: Dict[str, float] = {}
        for text, src in loader.load_dataset_texts(entry):
            chunks = self._chunk_text(text, src)
            for t, s in chunks:
                texts.append(t)
                provenance.append(s)
            try:
                mtimes[src] = os.path.getmtime(src)
            except Exception:
                mtimes[src] = 0.0
        return texts, provenance, mtimes

    def _needs_rebuild(self, entry: DatasetEntry, source_mtimes: Dict[str, float]) -> bool:
        cache_path, meta_path, sents_path = self._cache_paths(entry)
        if not (os.path.isfile(cache_path) and os.path.isfile(meta_path) and os.path.isfile(sents_path)):
            return True
        try:
            with open(meta_path, "r", encoding="utf-8") as f:
                meta = json.load(f)
            cached = meta.get("source_mtimes", {})
            return any(abs(cached.get(p, 0.0) - mt) > 1e-6 for p, mt in source_mtimes.items()) or \
                   any(p not in cached for p in source_mtimes.keys())
        except Exception:
            return True

    def load_or_build(self, loader: DatasetManager, entry: DatasetEntry) -> Optional[Dict[str, Any]]:
        if np is None:
            return None
        key = entry.path
        if key in self._mem:
            return self._mem[key]

        texts, provenance, mtimes = self._collect_texts(loader, entry)
        cache_path, meta_path, sents_path = self._cache_paths(entry)

        if not self._needs_rebuild(entry, mtimes):
            try:
                data = np.load(cache_path, allow_pickle=False)
                with open(sents_path, "r", encoding="utf-8") as f:
                    sentences = json.load(f)
                with open(meta_path, "r", encoding="utf-8") as f:
                    meta = json.load(f)
                emb = data["emb"]
                prov = meta.get("provenance", [""] * len(sentences))
                self._mem[key] = {"sentences": sentences, "emb": emb, "provenance": prov}
                return self._mem[key]
            except Exception:
                pass

        if not texts:
            self._mem[key] = {"sentences": [], "emb": np.zeros((0, 1)) if np is not None else [], "provenance": []}
            return self._mem[key]

        emb = self._encode(texts)
        if emb is None:
            return None
        self._mem[key] = {"sentences": texts, "emb": emb, "provenance": provenance}
        try:
            np.savez_compressed(cache_path, emb=emb)
            with open(sents_path, "w", encoding="utf-8") as f:
                json.dump(texts, f)
            with open(meta_path, "w", encoding="utf-8") as f:
                json.dump({"provenance": provenance, "source_mtimes": mtimes}, f)
        except Exception:
            pass
        return self._mem[key]

    def clear_memory(self) -> None:
        self._mem.clear()

    def clear_disk(self) -> int:
        count = 0
        try:
            for root, _dirs, files in os.walk(self.datasets_root):
                for fn in files:
                    if fn.startswith("embeddings_") and (fn.endswith(".npz") or fn.endswith(".json")):
                        try:
                            os.remove(os.path.join(root, fn))
                            count += 1
                        except Exception:
                            pass
        except Exception:
            pass
        return count

    def query(self, loader: DatasetManager, entry: DatasetEntry, query_text: str, top_k: int = 5) -> List[Tuple[str, float, str, str]]:
        if np is None:
            return []
        emb_info = self.load_or_build(loader, entry)
        if emb_info is None:
            return []
        sentences = emb_info["sentences"]
        prov = emb_info["provenance"]
        if not sentences:
            return []
        q = self._encode_query(query_text)
        if q is None:
            return []
        scores = np.dot(emb_info["emb"], q)
        idx = scores.argsort()[-top_k:][::-1]
        return [(sentences[i], float(scores[i]), entry.name, prov[i]) for i in idx]

    def search_all(self, managers_and_entries: List[Tuple[DatasetManager, List[DatasetEntry]]],
                   query_text: str, per_ds_k: int = 5, limit: int = 10) -> List[Tuple[str, float, str, str]]:
        hits: List[Tuple[str, float, str, str]] = []
        for mgr, entries in managers_and_entries:
            for e in entries:
                hits.extend(self.query(mgr, e, query_text, top_k=per_ds_k))
        hits.sort(key=lambda x: x[1], reverse=True)
        return hits[:limit]

# ──────────────────────────────────────────────────────────────────────────────
# Context → Schema evolution
# ──────────────────────────────────────────────────────────────────────────────
class ContextMonitor:
    def __init__(self, depth: int = 20) -> None:
        self.depth = depth
        self.context: List[Tuple[str, str]] = []

    def add_message(self, speaker: str, text: str) -> None:
        self.context.append((speaker, text))
        if len(self.context) > self.depth:
            self.context.pop(0)

    def analyze(self) -> Dict[str, Any]:
        tone = self._detect_tone()
        directives = self._extract_directives()
        keywords = self._find_keywords()
        return {"tone": tone, "directives": directives, "keywords": keywords}

    def _detect_tone(self) -> str:
        text = " ".join([t.lower() for _, t in self.context])
        pos = sum(k in text for k in ["happy", "excited", "good", "great", "awesome"])
        neg = sum(k in text for k in ["sad", "angry", "bad", "terrible", "frustrated"])
        if pos > neg: return "positive"
        if neg > pos: return "negative"
        return "neutral"

    def _extract_directives(self) -> List[str]:
        d: List[str] = []
        for _, text in self.context:
            for m in re.findall(r'\b(?:please\s+)?(?:add|set|enable|disable|remember|inject|rewrite)\b(.*)', text, re.I):
                d.append(m.strip())
            for m in re.findall(r'\byou (need to|must|should)\b (.*)', text, re.I):
                d.append(m[1].strip())
        return d

    def _find_keywords(self) -> List[str]:
        text = " ".join([t for _, t in self.context])
        words = re.findall(r'\b\w+\b', text.lower())
        return sorted(set([w for w in words if len(w) > 3]))

class SchemaAutoUpdater:
    def __init__(self, mgr: SchemaManager, persona: str, set_name: str) -> None:
        self.mgr = mgr
        self.persona = persona
        self.set_name = set_name
        self._last_update_ts: float = 0.0
        self._min_interval = 2.0  # seconds; guard against rapid churn

    def update_with_context(self, analysis: Dict[str, Any]) -> None:
        now = time.time()
        if now - self._last_update_ts < self._min_interval:
            return
        self._last_update_ts = now
        schema = self.mgr.load_schema(self.persona, self.set_name)
        for d in analysis.get("directives", []):
            self._apply_directive(schema, d)
        self.mgr.save_schema(self.persona, self.set_name, schema)

    def _apply_directive(self, schema: Dict[str, Any], directive: str) -> None:
        low = directive.lower()
        if "add trait" in low:
            trait = directive.split("add trait", 1)[-1].strip()
            overlay = dict(schema.get("dynamic_overlay", {}))
            traits = list(overlay.get("added_traits", []))
            if trait and trait not in traits: traits.append(trait)
            overlay["added_traits"] = traits
            schema["dynamic_overlay"] = overlay
        elif "add action" in low:
            action = directive.split("add action", 1)[-1].strip()
            actions = list(schema.get("actions", []))
            if action and action not in actions: actions.append(action)
            schema["actions"] = actions
        elif "add question" in low:
            q = directive.split("add question", 1)[-1].strip()
            qs = list(schema.get("questions", []))
            if q and q not in qs: qs.append(q)
            schema["questions"] = qs
        elif "reflect" in low or "think" in low:
            st = list(schema.get("self_talk", []))
            ref = f"Reflect: {directive}"
            if ref not in st: st.append(ref)
            schema["self_talk"] = st
        # C-5: Directive-to-Command expansion
        if "add command" in low:
            parts = directive.split()
            if len(parts) >= 3 and parts[2].startswith("/"):
                cmd = parts[2]
                value = " ".join(parts[3:])
                cmds = dict(schema.get("commands", {}))
                arr = list(cmds.get(cmd, []))
                if value:
                    arr.append(value)
                cmds[cmd] = arr
                schema["commands"] = cmds
        elif "delete command" in low:
            parts = directive.split()
            if len(parts) >= 3 and parts[2].startswith("/"):
                cmd = parts[2]
                cmds = dict(schema.get("commands", {}))
                cmds.pop(cmd, None)
                schema["commands"] = cmds
        elif "rewrite command" in low:
            parts = directive.split(maxsplit=3)
            if len(parts) >= 4 and parts[2].startswith("/"):
                cmd = parts[2]
                value = parts[3]
                cmds = dict(schema.get("commands", {}))
                if cmd in cmds:
                    cmds[cmd] = [value]
                schema["commands"] = cmds

# ──────────────────────────────────────────────────────────────────────────────
# Command registry (+weights/locks) & executor
# ──────────────────────────────────────────────────────────────────────────────
class CommandRegistry(QtCore.QObject):
    commandsChanged = QtCore.pyqtSignal()
    commandWeightsChanged = QtCore.pyqtSignal()

    def __init__(self, base_dir: str, persona: str, set_name: str) -> None:
        super().__init__()
        self.base_dir = base_dir
        self.persona = persona
        self.set_name = set_name
        self.path = prof_commands_path(base_dir, persona, set_name)
        self.commands: Dict[str, Dict[str, Any]] = {}
        self._load()
        for cmd in [
            "/remember", "/inject", "/rewrite", "/show", "/action", "/trait",
            "/dataset", "/search", "/embeddings", "/schema",
            "/tts", "/plugin", "/feedback", "/lock", "/commands",
            # Moderation & shaping
            "/reject", "/auto", "/ignore", "/opposite", "/delete",
            # Experimental fine-tuning / tokenizer commands
            "/applylora", "/patchtokenizer", "/datasetfromtext",
            # Spatial room
            "/enterroom", "/move",
        ]:
            self.register_command(cmd)

    def _load(self) -> None:
        try:
            if os.path.isfile(self.path):
                with open(self.path, "r", encoding="utf-8") as f:
                    data = json.load(f)
                self.commands = dict(data.get("commands", {}))
        except Exception:
            self.commands = {}

    def _save(self) -> None:
        try:
            os.makedirs(os.path.dirname(self.path), exist_ok=True)
            with open(self.path, "w", encoding="utf-8") as f:
                json.dump({"commands": self.commands}, f, indent=2)
        except Exception as e:
            logger.error("[CommandRegistry] save error: %s", e)
        QtCore.QTimer.singleShot(50, self.commandsChanged.emit)
        QtCore.QTimer.singleShot(50, self.commandWeightsChanged.emit)

    def register_command(self, name: str) -> None:
        if name not in self.commands:
            self.commands[name] = {"weight": 0, "locked": False}
            self._save()

    def register_from_schema(self, schema: Dict[str, Any]) -> None:
        try:
            for name in (schema.get("commands") or {}).keys():
                if isinstance(name, str) and name.startswith("/"):
                    self.register_command(name)
        except Exception:
            pass

    def set_weight(self, name: str, weight: int) -> None:
        if name in self.commands and not self.commands[name].get("locked", False):
            self.commands[name]["weight"] = int(weight)
            self._save()

    def toggle_lock(self, name: str, state: Optional[bool] = None) -> None:
        if name in self.commands:
            cur = bool(self.commands[name].get("locked", False))
            self.commands[name]["locked"] = (not cur) if state is None else bool(state)
            self._save()

    def get_weight(self, name: str) -> int:
        return int(self.commands.get(name, {}).get("weight", 0))

    def is_locked(self, name: str) -> bool:
        return bool(self.commands.get(name, {}).get("locked", False))

    def list_commands(self) -> List[str]:
        return sorted(self.commands.keys())

    def score_commands(self) -> Dict[str, float]:
        scores = {}
        for name in self.commands:
            bean_total = self.beans.counts.get(f"cmd_{name}", 0)  # assuming self.beans is accessible
            score = self.commands[name]["weight"] + (bean_total * 0.1)  # WEIGHT_FACTOR = 0.1
            scores[name] = score
        return scores

class CommandExecutor:
    """
    Executes slash commands and integrates with schema + registry + reinforcement.
    """
    def __init__(self, registry: CommandRegistry, schema_mgr: SchemaManager,
                 schema_updater: SchemaAutoUpdater, beans: BeanCounter,
                 dataset_mgr: DatasetManager, rag: "RAGCache",
                 settings: Settings, plugins: "PluginManager",
                 core_ref: "AgentCore") -> None:
        self.registry = registry
        self.schema_mgr = schema_mgr
        self.schema_updater = schema_updater
        self.beans = beans
        self.dataset_mgr = dataset_mgr
        self.rag = rag
        self.settings = settings
        self.plugins = plugins
        self.core_ref = core_ref

    @staticmethod
    def _strip_quotes(s: str) -> str:
        s = (s or "").strip()
        if len(s) >= 2 and ((s[0] == s[-1] == "'") or (s[0] == s[-1] == '"')):
            return s[1:-1]
        return s

    def _add_schema_command_value(self, schema: Dict[str, Any], cmd: str, text: str) -> None:
        cmds = dict(schema.get("commands") or {})
        arr = list(cmds.get(cmd, []))
        if text and text not in arr:
            arr.append(text)
        cmds[cmd] = arr
        schema["commands"] = cmds

    def execute(self, command_line: str) -> str:
        cmd, args = self._parse(command_line)
        if not cmd:
            return "No command provided."
        try:
            self.registry.set_weight(cmd, self.registry.get_weight(cmd) + 1)
        except Exception:
            pass
        if self.registry.is_locked(cmd):
            return f"Command '{cmd}' is locked."
        try:
            if cmd == "/remember":        return self._remember(args)
            if cmd == "/inject":          return self._inject(args)
            if cmd == "/rewrite":         return self._rewrite(args)
            if cmd == "/reject":          return self._reject(args)
            if cmd == "/auto":            return self._auto(args)
            if cmd == "/ignore":          return self._ignore(args)
            if cmd == "/opposite":        return self._opposite(args)
            if cmd == "/delete":          return self._delete(args)
            if cmd == "/applylora":       return self._applylora(args)
            if cmd == "/patchtokenizer":  return self._patchtokenizer(args)
            if cmd == "/datasetfromtext": return self._datasetfromtext(args)
            if cmd == "/show":            return self._show(args)
            if cmd == "/action":          return self._action(args)
            if cmd == "/trait":           return self._trait(args)
            if cmd == "/dataset":         return self._dataset(args)
            if cmd == "/search":          return self._search(args)
            if cmd == "/embeddings":      return self._embeddings(args)
            if cmd == "/schema":          return self._schema(args)
            if cmd == "/tts":             return self._tts(args)
            if cmd == "/plugin":          return self._plugin(args)
            if cmd == "/feedback":        return self._feedback(args)
            if cmd == "/lock":            return self._lock(args)
            if cmd == "/commands":        return self._commands(args)
            # C-8
            if cmd == "/enterroom":       return self._enterroom(args)
            if cmd == "/move":            return self._move(args)
            return f"Command '{cmd}' executed (no-op)."
        finally:
            # Increment reinforcement count for this command
            try:
                self.beans.increment(f"cmd_{cmd}", 1)
            except Exception:
                pass
            # Update command weight based on usage reinforcement
            try:
                cnt = self.beans.counts.get(f"cmd_{cmd}", 0)
                self.registry.set_weight(cmd, cnt)
            except Exception:
                pass

    def _parse(self, line: str) -> Tuple[str, str]:
        line = (line or "").strip()
        if not line.startswith("/"):
            return "", ""
        parts = line.split(maxsplit=1)
        cmd = parts[0].strip()
        rest = parts[1] if len(parts) > 1 else ""
        if cmd.startswith("/action_"): cmd = "/action"
        if cmd.startswith("/trait_"):  cmd = "/trait"
        return cmd, rest

    # Core handlers
    def _remember(self, args: str) -> str:
        trait = self._strip_quotes(args) or "remembered"
        schema = self.schema_mgr.load_schema(self.schema_updater.persona, self.schema_updater.set_name)
        overlay = dict(schema.get("dynamic_overlay", {}))
        traits = list(overlay.get("added_traits", []))
        if trait not in traits:
            traits.append(trait)
        overlay["added_traits"] = traits
        schema["dynamic_overlay"] = overlay
        self._add_schema_command_value(schema, "/remember", trait)
        self.schema_mgr.save_schema(self.schema_updater.persona, self.schema_updater.set_name, schema)
        return f"Remembered: {trait}"

    def _inject(self, args: str) -> str:
        note = self._strip_quotes(args) or "injected-change"
        schema = self.schema_mgr.load_schema(self.schema_updater.persona, self.schema_updater.set_name)
        st = list(schema.get("self_talk", []))
        if note not in st:
            st.append(note)
        schema["self_talk"] = st
        self._add_schema_command_value(schema, "/inject", note)
        self.schema_mgr.save_schema(self.schema_updater.persona, self.schema_updater.set_name, schema)
        return f"Injected: {note}"

    def _rewrite(self, args: str) -> str:
        phrase = self._strip_quotes(args)
        schema = self.schema_mgr.load_schema(self.schema_updater.persona, self.schema_updater.set_name)
        rp = list(schema.get("rewrite_prompts", []))
        if phrase and phrase not in rp:
            rp.append(phrase)
        schema["rewrite_prompts"] = rp
        if phrase:
            self._add_schema_command_value(schema, "/rewrite", phrase)
        self.schema_mgr.save_schema(self.schema_updater.persona, self.schema_updater.set_name, schema)
        return "Rewrite behavior updated."

    def _reject(self, args: str) -> str:
        text = self._strip_quotes(args) or "rejected"
        schema = self.schema_mgr.load_schema(self.schema_updater.persona, self.schema_updater.set_name)
        dislikes = list(schema.get("dislikes", []))
        if text not in dislikes:
            dislikes.append(text)
        schema["dislikes"] = dislikes
        self._add_schema_command_value(schema, "/reject", text)
        self.beans.increment(f"rej_{abs(hash(text))%10007}", -1)
        self.schema_mgr.save_schema(self.schema_updater.persona, self.schema_updater.set_name, schema)
        return f"Rejected: {text}"

    def _auto(self, args: str) -> str:
        text = self._strip_quotes(args) or "auto"
        schema = self.schema_mgr.load_schema(self.schema_updater.persona, self.schema_updater.set_name)
        events = list(schema.get("events", []))
        mark = f"AUTO: {text}"
        if mark not in events:
            events.append(mark)
        schema["events"] = events
        self._add_schema_command_value(schema, "/auto", text)
        self.schema_mgr.save_schema(self.schema_updater.persona, self.schema_updater.set_name, schema)
        return f"Auto behavior noted: {text}"

    def _ignore(self, args: str) -> str:
        text = self._strip_quotes(args) or "ignore"
        schema = self.schema_mgr.load_schema(self.schema_updater.persona, self.schema_updater.set_name)
        tone = dict(schema.get("tone_rules", {}))
        avoid = list(tone.get("avoid", []))
        if text not in avoid:
            avoid.append(text)
        tone["avoid"] = avoid
        schema["tone_rules"] = tone
        dislikes = list(schema.get("dislikes", []))
        if text not in dislikes:
            dislikes.append(text)
        schema["dislikes"] = dislikes
        self._add_schema_command_value(schema, "/ignore", text)
        self.schema_mgr.save_schema(self.schema_updater.persona, self.schema_updater.set_name, schema)
        return f"Ignoring: {text}"

    def _opposite(self, args: str) -> str:
        text = self._strip_quotes(args) or "opposite"
        schema = self.schema_mgr.load_schema(self.schema_updater.persona, self.schema_updater.set_name)
        tone = dict(schema.get("tone_rules", {}))
        opp = list(tone.get("opposites", []))
        if text not in opp:
            opp.append(text)
        tone["opposites"] = opp
        schema["tone_rules"] = tone
        self._add_schema_command_value(schema, "/opposite", text)
        rps = list(schema.get("rewrite_prompts", []))
        guide = f"Prefer the opposite of: {text}"
        if guide not in rps:
            rps.append(guide)
        schema["rewrite_prompts"] = rps
        self.schema_mgr.save_schema(self.schema_updater.persona, self.schema_updater.set_name, schema)
        return f"Will prefer the opposite of: {text}"

    def _delete(self, args: str) -> str:
        text = self._strip_quotes(args) or "delete"
        schema = self.schema_mgr.load_schema(self.schema_updater.persona, self.schema_updater.set_name)
        overlay = dict(schema.get("dynamic_overlay", {}))
        deletions = list(overlay.get("delete_targets", []))
        if text not in deletions:
            deletions.append(text)
        overlay["delete_targets"] = deletions
        schema["dynamic_overlay"] = overlay
        self._add_schema_command_value(schema, "/delete", text)
        self.schema_mgr.save_schema(self.schema_updater.persona, self.schema_updater.set_name, schema)
        return f"Marked for deletion: {text}"

    def _show(self, args: str) -> str:
        key = (args or "").strip().lower()
        if key == "facts":
            tops = sorted(self.beans.counts.items(), key=lambda kv: kv[1], reverse=True)[:10]
            if not tops:
                return "No facts yet."
            return "Top facts:\n" + "\n".join([f"• {k}: {v}" for k, v in tops])
        return "Unknown /show argument. Try '/show facts'."

    def _action(self, args: str) -> str:
        action = self._strip_quotes(args) or "action"
        schema = self.schema_mgr.load_schema(self.schema_updater.persona, self.schema_updater.set_name)
        actions = list(schema.get("actions", []))
        if action not in actions:
            actions.append(action)
        schema["actions"] = actions
        self.schema_mgr.save_schema(self.schema_updater.persona, self.schema_updater.set_name, schema)
        return f"Action added: {action}"

    def _trait(self, args: str) -> str:
        trait = self._strip_quotes(args) or "trait"
        schema = self.schema_mgr.load_schema(self.schema_updater.persona, self.schema_updater.set_name)
        overlay = dict(schema.get("dynamic_overlay", {}))
        traits = list(overlay.get("added_traits", []))
        if trait not in traits:
            traits.append(trait)
        overlay["added_traits"] = traits
        schema["dynamic_overlay"] = overlay
        self.schema_mgr.save_schema(self.schema_updater.persona, self.schema_updater.set_name, schema)
        return f"Trait added: {trait}"

    # Data/system
    def _dataset(self, args: str) -> str:
        parts = args.split()
        if not parts:
            return "Usage: /dataset add|delete|toggle|list ..."
        sub = parts[0].lower()
        try:
            if sub == "add" and len(parts) >= 3:
                name = parts[1]
                path = " ".join(parts[2:])
                self.dataset_mgr.add_dataset(name, path)
                self.rag.clear_memory()
                return f"Dataset '{name}' updated with file '{path}'."
            if sub == "delete" and len(parts) == 2:
                name = parts[1]
                self.dataset_mgr.delete_dataset(name)
                self.rag.clear_memory()
                return f"Dataset '{name}' deleted."
            if sub == "toggle" and len(parts) == 3:
                name = parts[1]
                on = parts[2].lower() in {"on", "true", "1", "enable", "enabled"}
                self.dataset_mgr.toggle_active(name, on)
                return f"Dataset '{name}' set to {'active' if on else 'inactive'}."
            if sub == "list":
                items = self.dataset_mgr.entries
                if not items:
                    return "No datasets."
                return "Datasets:\n" + "\n".join([f"• {n} [{'ON' if e.active else 'off'}]" for n, e in sorted(items.items())])
        except Exception as e:
            return f"Dataset error: {e}"
        return "Usage: /dataset add <name> <path> | delete <name> | toggle <name> on|off | list"

    def _search(self, args: str) -> str:
        q = args.strip()
        if not q:
            return "Usage: /search <query>"
        packs: List[Tuple[DatasetManager, List[DatasetEntry]]] = []
        packs.append((self.dataset_mgr, self.dataset_mgr.get_active_datasets()))
        shared = self.schema_mgr.get_shared_datasets(self.schema_updater.persona, self.schema_updater.set_name)
        if shared:
            owners: Dict[Tuple[str, str], List[DatasetEntry]] = {}
            for e in shared:
                try:
                    rel = os.path.relpath(e.path, self.dataset_mgr.base_dir).replace("\\", "/")
                    parts = rel.split("/")
                    idx = parts.index("profiles")
                    other_persona = parts[idx+1]
                    other_set = parts[idx+2]
                except Exception:
                    continue
                owners.setdefault((other_persona, other_set), []).append(e)
            for key, ents in owners.items():
                p, s = key
                packs.append((DatasetManager(self.base_dir, p, s), ents))
        hits = self.rag.search_all(packs, q, per_ds_k=4, limit=10)
        if not hits:
            return "No results."
        lines = []
        for chunk, score, ds, prov in hits:
            lines.append(f"[{ds}] {os.path.basename(prov)} (score={score:.3f})\n{chunk[:300].strip()}...")
        return "\n\n".join(lines)

    def _embeddings(self, args: str) -> str:
        sub = (args or "").strip().lower()
        if sub == "clear":
            n = self.rag.clear_disk()
            self.rag.clear_memory()
            return f"Cleared {n} embedding cache files."
        return "Usage: /embeddings clear"

    def _schema(self, args: str) -> str:
        parts = args.split()
        if not parts:
            return "Usage: /schema set <persona> <set> | awareness on|off | active"
        sub = parts[0].lower()
        if sub == "set" and len(parts) == 3:
            persona, set_name = parts[1].lower(), parts[2]
            if persona not in self.schema_mgr.personas:
                return f"Unknown persona '{persona}'"
            if set_name not in self.schema_mgr.get_set_list(persona):
                os.makedirs(os.path.join(self.schema_mgr.schemas_dir, persona, "sets", set_name), exist_ok=True)
                sch = self.schema_mgr.load_schema(persona, "default")
                self.schema_mgr.save_schema(persona, set_name, sch)
            active = dict(self.schema_mgr.active_schemas)
            active[persona] = set_name
            self.schema_mgr.save_active_schemas(active)
            self.core_ref.switch_persona_set(persona if persona == self.core_ref.persona else None,
                                             set_name if persona == self.core_ref.persona else None)
            return f"Active schema set: {persona}/{set_name}"
        if sub == "awareness" and len(parts) == 2:
            on = parts[1].lower() in {"on", "true", "1", "enable", "enabled"}
            sch = self.schema_mgr.load_schema(self.schema_updater.persona, self.schema_updater.set_name)
            flags = dict(sch.get("flags") or {})
            flags["semantic_awareness"] = bool(on)
            sch["flags"] = flags
            sch["semantic_awareness_enabled"] = bool(on)
            self.schema_mgr.save_schema(self.schema_updater.persona, self.schema_updater.set_name, sch)
            return f"Semantic awareness {'enabled' if on else 'disabled'} for {self.schema_updater.persona}/{self.schema_updater.set_name}"
        if sub == "active":
            act = self.schema_mgr.active_schemas
            return "Active schemas:\n" + "\n".join([f"• {p}: {s}" for p, s in act.items()])
        return "Usage: /schema set <persona> <set> | awareness on|off | active"

    def _tts(self, args: str) -> str:
        parts = args.split()
        if not parts:
            return "Usage: /tts on|off | volume <0-100>"
        sub = parts[0].lower()
        if sub in {"on", "off"}:
            flag = sub == "on"
            self.settings.monologue_tts_enabled = flag
            self.settings.save()
            return f"TTS {'enabled' if flag else 'disabled'}."
        if sub == "volume" and len(parts) == 2:
            try:
                v = int(parts[1]); v = max(0, min(100, v))
                self.settings.monologue_volume = v
                self.settings.save()
                if self.core_ref.tts_mgr:
                    self.core_ref.tts_mgr.set_volume(v)
                return f"TTS volume set to {v}."
            except Exception:
                return "Volume must be integer 0-100."
        return "Usage: /tts on|off | volume <0-100>"

    def _plugin(self, args: str) -> str:
        parts = args.split()
        if not parts:
            return "Usage: /plugin enable|disable|list ..."
        sub = parts[0].lower()
        if sub == "list":
            metas = self.plugins.list_plugins()
            if not metas:
                return "No plugins found."
            lines = []
            for m in metas:
                missing = f" (missing: {','.join(m.missing_dependencies)})" if m.missing_dependencies else ""
                lines.append(f"• {m.name} v{m.version or '?'} [{'ON' if m.enabled else 'off'}]{missing}")
            return "\n".join(lines)
        if sub in {"enable", "disable"} and len(parts) == 2:
            name = parts[1]
            flag = sub == "enable"
            self.plugins.enable_plugin(name, flag)
            return f"Plugin '{name}' {'enabled' if flag else 'disabled'}."
        return "Usage: /plugin enable <name> | disable <name> | list"

    def _feedback(self, args: str) -> str:
        parts = args.split()
        if not parts:
            return "Usage: /feedback stats | export <path>"
        sub = parts[0].lower()
        if sub == "stats":
            pos, neg = self.core_ref.feedback_db.get_counts()
            return f"Feedback: {pos} 👍  /  {neg} 👎"
        if sub == "export" and len(parts) >= 2:
            out = " ".join(parts[1:])
            n = self.core_ref.feedback_db.export_jsonl(out)
            return f"Exported {n} feedback records to {out}."
        return "Usage: /feedback stats | export <path>"

    def _lock(self, args: str) -> str:
        parts = args.split()
        if len(parts) != 2:
            return "Usage: /lock <cmd> on|off"
        cmd, state = parts
        if cmd not in self.registry.commands:
            return f"Unknown command '{cmd}'"
        self.registry.toggle_lock(cmd, state.lower() in {"on", "true", "1"})
        return f"Command '{cmd}' lock set to {self.registry.is_locked(cmd)}."

    def _commands(self, args: str) -> str:
        if args.strip().lower() == "list":
            items = []
            for c in self.registry.list_commands():
                items.append(f"• {c} (weight={self.registry.get_weight(c)}, locked={self.registry.is_locked(c)})")
            return "\n".join(items) if items else "No commands."
        return "Usage: /commands list"

    def _enterroom(self, args: str) -> str:
        # Stub for spatial room
        return "Entered room."

    def _move(self, args: str) -> str:
        # Stub for spatial room
        return "Moved."

# ──────────────────────────────────────────────────────────────────────────────
# Plugin system
# ──────────────────────────────────────────────────────────────────────────────
class PluginMeta:
    def __init__(self, name: str, path: str) -> None:
        self.name = name
        self.path = path
        self.enabled: bool = False
        self.module: Optional[Any] = None
        self.widget: Optional[Any] = None
        self.version: Optional[str] = None
        self.entry_point: Optional[str] = None
        self.dependencies: List[str] = []
        self.default_enabled: bool = False
        self.missing_dependencies: List[str] = []
        self._parse_manifest()

    def _parse_manifest(self) -> None:
        manifest_path = os.path.join(self.path, "manifest.json")
        if not os.path.isfile(manifest_path):
            return
        try:
            with open(manifest_path, "r", encoding="utf-8") as f:
                data = json.load(f)
            self.version = data.get("version")
            self.entry_point = data.get("entry_point") or None
            deps = data.get("dependencies") or []
            if isinstance(deps, list):
                self.dependencies = [str(d) for d in deps if isinstance(d, str)]
            self.default_enabled = bool(data.get("default_enabled", False))
        except Exception as e:
            logger.error("[Plugin:%s] manifest error: %s", self.name, e)
            return
        for dep in self.dependencies:
            try:
                __import__(dep.replace('-', '_'))
            except Exception:
                self.missing_dependencies.append(dep)

    def load_module(self) -> None:
        if self.module is not None or self.missing_dependencies:
            return
        spec = None
        if self.entry_point:
            spec = self.entry_point if "." in self.entry_point else f"plugins.{self.entry_point}"
        else:
            spec = f"plugins.{self.name}"
        try:
            import importlib
            self.module = importlib.import_module(spec)
        except Exception as e:
            logger.error("[Plugin:%s] import error: %s", self.name, e)
            self.module = None

    def start(self, host: "PluginManager") -> None:
        if self.enabled:
            return
        self.load_module()
        if self.module is None:
            return
        try:
            if hasattr(self.module, "start"):
                self.widget = self.module.start(host)  # type: ignore
            self.enabled = True
        except Exception as e:
            logger.error("[Plugin:%s] start error: %s", self.name, e)
            self.enabled = False

    def stop(self) -> None:
        if not self.enabled or self.module is None:
            return
        try:
            if hasattr(self.module, "stop"):
                self.module.stop()  # type: ignore
        except Exception as e:
            logger.error("[Plugin:%s] stop error: %s", self.name, e)
        self.widget = None
        self.enabled = False

class PluginManager(QtCore.QObject):
    eventReceived = QtCore.pyqtSignal(str, dict)  # sender, envelope

    def __init__(self, base_dir: str, settings: Settings) -> None:
        super().__init__()
        self.base_dir = base_dir
        self.settings = settings
        self.plugins_dir = os.path.join(self.base_dir, "plugins")
        os.makedirs(self.plugins_dir, exist_ok=True)
        self._plugins: Dict[str, PluginMeta] = {}
        self.discover_plugins()

    def discover_plugins(self) -> None:
        self._plugins.clear()
        for entry in os.scandir(self.plugins_dir):
            if entry.is_dir():
                meta = PluginMeta(entry.name, entry.path)
                self._plugins[entry.name] = meta
        for name, meta in self._plugins.items():
            if name in self.settings.enabled_plugins or (not self.settings.enabled_plugins and meta.default_enabled):
                meta.enabled = True
                meta.start(self)

    def list_plugins(self) -> List[PluginMeta]:
        return list(self._plugins.values())

    def enable_plugin(self, name: str, flag: bool) -> None:
        meta = self._plugins.get(name)
        if not meta:
            return
        if flag and not meta.enabled:
            meta.start(self)
            if name not in self.settings.enabled_plugins:
                self.settings.enabled_plugins.append(name)
                self.settings.save()
        elif not flag and meta.enabled:
            meta.stop()
            if name in self.settings.enabled_plugins:
                self.settings.enabled_plugins.remove(name)
                self.settings.save()

    def rescan(self) -> None:
        self.discover_plugins()

    def broadcast(self, message: Any) -> None:
        envelope = message if (isinstance(message, dict) and "type" in message) else {"type": "command", "data": message}
        for meta in self._plugins.values():
            if not (meta.enabled and meta.module):
                continue
            try:
                if hasattr(meta.module, "on_command"):
                    try:
                        meta.module.on_command(envelope)  # type: ignore
                    except TypeError:
                        meta.module.on_command(envelope.get("data"))  # type: ignore
            except Exception as e:
                logger.error("[Plugin:%s] on_command error: %s", meta.name, e)

    def emit_event(self, sender: str, type: str, payload: Any) -> None:
        self.eventReceived.emit(sender, {"sender": sender, "type": type, "data": payload})

    def stop_all(self) -> None:
        for meta in self._plugins.values():
            try:
                meta.stop()
            except Exception:
                pass

# ──────────────────────────────────────────────────────────────────────────────
# Schema evolver using feedback (frequency + votes)
# ──────────────────────────────────────────────────────────────────────────────
class SchemaEvolver:
    def __init__(self, mgr: SchemaManager, feedback_db: SemanticFeedbackDB, memory_state: Dict[str, Any]) -> None:
        self.mgr = mgr
        self.feedback_db = feedback_db
        self.memory_state = memory_state
        self._protected = self.mgr._load_control_schema()
        self._last_success_ts = 0.0

    def update_schema(self, persona: str, set_name: str, history: List[Tuple[str, str]]) -> bool:
        try:
            tokens: List[str] = []
            for role, content in history[-12:]:
                tokens.extend([w.lower() for w in re.findall(r"\b\w+\b", content or "") if len(w) > 3])
            word_freq = Counter(tokens)
            pos_count, neg_count = self.feedback_db.get_counts()

            if (pos_count + neg_count) < 5 or pos_count <= neg_count or not word_freq:
                return False

            patch: Dict[str, Any] = {}
            schema = self.mgr.load_schema(persona, set_name)
            tone_rules = dict(schema.get("tone_rules", {}))
            avoid_words = set(tone_rules.get("avoid", []))
            top_words = [w for w, _ in word_freq.most_common(5) if w not in avoid_words]
            if top_words:
                tone_rules["preferred_words"] = top_words[:3]
                patch["tone_rules"] = tone_rules

            if patch and all(k not in self._protected for k in patch.keys()):
                schema.update(patch)
                self.mgr.save_schema(persona, set_name, schema)
                self._last_success_ts = time.time()
                return True
        except Exception as e:
            logger.error("[SchemaEvolver] error: %s", e)
        return False

# ──────────────────────────────────────────────────────────────────────────────
# FathomKernel self-rewriter (C-9)
# ──────────────────────────────────────────────────────────────────────────────
class FathomKernel:
    def __init__(self, base_dir: str) -> None:
        self.base_dir = base_dir

    def snapshot_codebase(self) -> Dict[str, str]:
        code = {}
        for root, _, files in os.walk(self.base_dir):
            for fn in files:
                if fn.endswith(".py"):
                    p = os.path.join(root, fn)
                    with open(p, "r", encoding="utf-8") as f:
                        code[p] = f.read()
        return code

    def lint_and_patch(self) -> None:
        # Use ruff for linting
        try:
            subprocess.run(["ruff", "check", "--fix", self.base_dir], check=False)
        except Exception:
            pass
        # For patch, stub: call ollama to rewrite
        pass

# ──────────────────────────────────────────────────────────────────────────────
# Threaded model worker
# ──────────────────────────────────────────────────────────────────────────────
class ModelWorker(QtCore.QThread):
    finished = QtCore.pyqtSignal(str)
    def __init__(self, model: str, prompt: str, parent: Optional[QtCore.QObject] = None) -> None:
        super().__init__(parent)
        self.model = model
        self.prompt = prompt

    def run(self) -> None:
        try:
            parent = self.parent()
            if parent and hasattr(parent, "_query_model"):
                result = parent._query_model(self.model, self.prompt)  # type: ignore
            else:
                result = ""
            self.finished.emit(result)
        except Exception as e:
            self.finished.emit(f"Error: {e}")
        finally:
            try:
                self.deleteLater()
            except Exception:
                pass

# ──────────────────────────────────────────────────────────────────────────────
# Orchestrator
# ──────────────────────────────────────────────────────────────────────────────
class AgentCore(QtCore.QObject):
    """
    Binds together all components for headless or GUI use.
    """
    def __init__(self, base_dir: str, persona: str = "zira", set_name: Optional[str] = None) -> None:
        super().__init__()
        self.base_dir = base_dir
        self.schema_mgr = SchemaManager(base_dir)
        self.persona = persona
        if set_name is None:
            set_name = self.schema_mgr.active_schemas.get(persona, "default")
        self.set_name = set_name

        self.settings = Settings(base_dir)
        ensure_models_present()

        self.operator_mgr = OperatorManager(base_dir)
        self.dataset_mgr = DatasetManager(base_dir, self.persona, self.set_name)
        self.tts_mgr = TTSManager(default_volume=self.settings.monologue_volume)
        self.audio_recorder = AudioRecorder()
        self.google_listener = GoogleListener()
        self.conversation_db = ConversationDB(conv_db_path(base_dir, self.persona, self.set_name))
        self.feedback_db = SemanticFeedbackDB(feedback_db_path(base_dir, self.persona, self.set_name), base_dir, self.persona, self.set_name)
        self.beans = self.feedback_db.beans
        self.reinforcement_log = ReinforcementStore(base_dir)

        self.context_monitor = ContextMonitor(depth=self.settings.context_depth)
        self.schema_auto_updater = SchemaAutoUpdater(self.schema_mgr, self.persona, self.set_name)
        self.schema_evolver = SchemaEvolver(self.schema_mgr, self.feedback_db, memory_state={})

        self.command_registry = CommandRegistry(base_dir, self.persona, self.set_name)
        try:
            sch = self.schema_mgr.load_schema(self.persona, self.set_name)
            self.command_registry.register_from_schema(sch)
        except Exception:
            pass

        self.plugins = PluginManager(base_dir, self.settings)

        if SentenceTransformer and np is not None:
            try:
                self.embed_model = SentenceTransformer("all-MiniLM-L6-v2")
                embed_name = "MiniLM"
            except Exception:
                self.embed_model = None
                embed_name = "none"
        else:
            self.embed_model = None
            embed_name = "none"
        self.rag_cache = RAGCache(self.embed_model, embed_name, self.dataset_mgr.datasets_dir)

        self.command_executor = CommandExecutor(
            self.command_registry, self.schema_mgr, self.schema_auto_updater, self.beans,
            self.dataset_mgr, self.rag_cache, self.settings, self.plugins, self
        )

        self.fathom_kernel = FathomKernel(base_dir)

        self._idle_timer = QtCore.QTimer()
        self._idle_timer.timeout.connect(self._on_idle)
        self._idle_timer.start(86400000)  # nightly

        try:
            self.schema_mgr.schemaChanged.connect(self._on_schema_changed)
        except Exception:
            pass

    def _on_idle(self) -> None:
        self.fathom_kernel.lint_and_patch()

    def _on_schema_changed(self, persona: str, set_name: str) -> None:
        if persona == self.persona and set_name == self.set_name:
            self.dataset_mgr = DatasetManager(self.base_dir, self.persona, self.set_name)
            self.rag_cache.datasets_root = self.dataset_mgr.datasets_dir
            try:
                sch = self.schema_mgr.load_schema(self.persona, self.set_name)
                self.command_registry.register_from_schema(sch)
            except Exception:
                pass

    def process_user_message(self, message: str, tts: bool = False) -> str:
        self.conversation_db.save_message("user", message)
        if message.strip().startswith("/"):
            response = self.run_command(message.strip())
        else:
            self.context_monitor.add_message("user", message)
            if self.settings.auto_schema_enabled:
                analysis = self.context_monitor.analyze()
                self.schema_auto_updater.update_with_context(analysis)
            response = "Message processed."
        self.conversation_db.save_message("zira", response)
        if tts and self.settings.monologue_tts_enabled and self.tts_mgr is not None:
            self.tts_mgr.enqueue(response)
        return response

    def run_command(self, command_line: str,
                    persona: Optional[str] = None,
                    set_name: Optional[str] = None) -> str:
        try:
            self.plugins.broadcast({"type": "slash", "data": command_line})
        except Exception:
            pass

        if not persona and not set_name:
            try:
                sch = self.schema_mgr.load_schema(self.persona, self.set_name)
                self.command_registry.register_from_schema(sch)
            except Exception:
                pass
            try:
                return self.command_executor.execute(command_line)
            except Exception as e:
                return f"Command error: {e}"

        target_persona = (persona or self.persona).lower()
        target_set = set_name or self.set_name

        tmp_registry = CommandRegistry(self.base_dir, target_persona, target_set)
        try:
            sch = self.schema_mgr.load_schema(target_persona, target_set)
            tmp_registry.register_from_schema(sch)
        except Exception:
            pass
        tmp_beans = BeanCounter(self.base_dir, target_persona, target_set)
        tmp_datasets = DatasetManager(self.base_dir, target_persona, target_set)
        tmp_updater = SchemaAutoUpdater(self.schema_mgr, target_persona, target_set)
        tmp_rag = RAGCache(self.embed_model, getattr(self.rag_cache, "model_name", "MiniLM"), tmp_datasets.datasets_dir)

        tmp_exec = CommandExecutor(
            tmp_registry, self.schema_mgr, tmp_updater, tmp_beans,
            tmp_datasets, tmp_rag, self.settings, self.plugins, self
        )
        try:
            return tmp_exec.execute(command_line)
        except Exception as e:
            return f"Command error: {e}"

    def switch_persona_set(self, persona: Optional[str] = None, set_name: Optional[str] = None) -> None:
        if persona:
            self.persona = persona
        if set_name:
            self.set_name = set_name
        self.dataset_mgr = DatasetManager(self.base_dir, self.persona, self.set_name)
        self.conversation_db = ConversationDB(conv_db_path(self.base_dir, self.persona, self.set_name))
        self.feedback_db = SemanticFeedbackDB(feedback_db_path(self.base_dir, self.persona, self.set_name), self.base_dir, self.persona, self.set_name)
        self.beans = self.feedback_db.beans
        self.schema_auto_updater = SchemaAutoUpdater(self.schema_mgr, self.persona, self.set_name)
        self.schema_evolver = SchemaEvolver(self.schema_mgr, self.feedback_db, memory_state={})
        self.command_registry = CommandRegistry(self.base_dir, self.persona, self.set_name)
        try:
            sch = self.schema_mgr.load_schema(self.persona, self.set_name)
            self.command_registry.register_from_schema(sch)
        except Exception:
            pass
        self.command_executor = CommandExecutor(
            self.command_registry, self.schema_mgr, self.schema_auto_updater, self.beans,
            self.dataset_mgr, self.rag_cache, self.settings, self.plugins, self
        )
        self.rag_cache.datasets_root = self.dataset_mgr.datasets_dir

        # U-9: Auto-stop STT on context switch
        self.google_listener.stop_listener()

    def rag_search(self, query_text: str, per_ds_k: int = 4, limit: int = 10,
                   include_shared: bool = True,
                   datasets: Optional[List[str]] = None) -> List[Tuple[str, float, str, str]]:
        current_entries = self.dataset_mgr.get_active_datasets()
        if datasets:
            ds_set = set(datasets)
            current_entries = [e for e in current_entries if e.name in ds_set]
        packs: List[Tuple[DatasetManager, List[DatasetEntry]]] = [(self.dataset_mgr, current_entries)]

        if include_shared and self.schema_mgr.is_semantic_on(self.persona, self.set_name):
            shared = self.schema_mgr.get_shared_datasets(self.persona, self.set_name)
            if datasets:
                ds_set = set(datasets)
                shared = [e for e in shared if e.name in ds_set]
            owners: Dict[Tuple[str, str], List[DatasetEntry]] = {}
            for e in shared:
                try:
                    rel = os.path.relpath(e.path, self.base_dir).replace("\\", "/")
                    parts = rel.split("/")
                    idx = parts.index("profiles")
                    other_persona = parts[idx+1]
                    other_set = parts[idx+2]
                except Exception:
                    continue
                owners.setdefault((other_persona, other_set), []).append(e)
            for key, ents in owners.items():
                p, s = key
                packs.append((DatasetManager(self.base_dir, p, s), ents))

        hits = self.rag_cache.search_all(packs, query_text, per_ds_k=per_ds_k, limit=limit*2)
        hits.sort(key=lambda x: x[1], reverse=True)
        return hits[:limit]

    def refresh_prompt_cache(self) -> None:
        self.rag_cache.clear_memory()

    def add_feedback(self, original: str, liked: bool, revised: Optional[str] = None) -> None:
        self.feedback_db.add_feedback(original, liked, revised)
        hist = self.conversation_db.fetch_history(limit=50)
        try:
            self.schema_evolver.update_schema(self.persona, self.set_name, hist)
        except Exception:
            pass

    def _query_model(self, model: str, prompt: str) -> str:
        try:
            result = subprocess.run(["ollama", "run", model], input=prompt.encode("utf-8"),
                                    stdout=subprocess.PIPE, stderr=subprocess.PIPE, timeout=120)
            if result.returncode == 0:
                return result.stdout.decode("utf-8", errors="ignore").strip()
            else:
                err = result.stderr.decode("utf-8", "ignore")
                logger.error("[ollama:%s] error: %s", model, err)
        except Exception as e:
            logger.error("[ollama:%s] exception: %s", model, e)
        return f"(fallback) {prompt}"

    def start_listener(self) -> None:
        self.google_listener.start()

    def stop_listener(self) -> None:
        self.google_listener.stop_listener()

    def close(self) -> None:
        try:
            self.plugins.stop_all()
        except Exception:
            pass
        try:
            self.conversation_db.close()
        except Exception:
            pass
        try:
            self.feedback_db.close()
        except Exception:
            pass
        try:
            if self.tts_mgr:
                self.tts_mgr.close()
        except Exception:
            pass
        try:
            if hasattr(self, "reinforcement_log") and self.reinforcement_log:
                self.reinforcement_log.close()
        except Exception:
            pass
        self.stop_listener()

# ──────────────────────────────────────────────────────────────────────────────
# CLI entrypoint (optional smoke test)
# ──────────────────────────────────────────────────────────────────────────────
if __name__ == "__main__":
    base = os.path.abspath(os.path.join(os.getcwd(), ".agent_state"))
    core = AgentCore(base)
    print("AgentCore ready. Try '/commands list', '/dataset list', '/search your query', '/tts on', or '/schema active'. Ctrl+C to exit.")
    try:
        while True:
            line = input("you> ").strip()
            if not line:
                continue
            if line.lower() in {"quit", "exit"}:
                break
            if line.startswith("/"):
                m = re.match(r"^/as\s+(\w+)\s+(\w+)\s+--\s+(.*)$", line)
                if m:
                    p, s, cmd = m.groups()
                    out = core.run_command(cmd, persona=p, set_name=s)
                else:
                    out = core.run_command(line)
            else:
                out = core.process_user_message(line, tts=False)
            print("zira>", out)
    except KeyboardInterrupt:
        pass
    finally:
        core.close()
```

agent_core.py
=================

Full, end-to-end core for an AI AI TTS Agent with:
- Settings & model bootstrap (Ollama)
- Robust plugin host (enable/disable/list, manifest validation, dependency checks)
- Conversation & feedback stores (with indices, exports)
- Persona schema management (with protected keys) and live signals
- Dataset registry + RAG embeddings cache & query (per persona/set, cross-profile sharing)
  * Multi-file datasets, cache invalidation, provenance
- Context monitor + schema auto-updates driven by directives & feedback (rate-limited)
- Command registry (weight/lock) + full command execution layer
- New commands: /reject, /auto, /ignore, /opposite, /delete, /rewrite (extended persistence)
- BeanCounter reinforcement + integration with feedback and command weights
- Speech I/O (TTS locked to Zira; STT via Sphinx when available) w/ volume control
- Threaded model worker wrapper (cancel-safe)
- Orchestrator (`AgentCore`) wiring everything together for headless/GUI
- CLI entrypoint for smoke tests

Notes
-----
• This module is UI-agnostic. Hook the provided Qt signals in your GUI (`agent_ui.py`).
• All directories are scoped under `base_dir`, with per-persona/per-set state in:
  base_dir/profiles/<persona>/<set>/
**Classes:** Settings, ConversationDB, BeanCounter, SemanticFeedbackDB, ReinforcementStore, SchemaManager, OperatorManager, TTSManager, AudioRecorder, GoogleListener, DatasetEntry, DatasetManager, RAGCache, ContextMonitor, SchemaAutoUpdater, CommandRegistry, CommandExecutor, PluginMeta, PluginManager, SchemaEvolver, FathomKernel, ModelWorker, AgentCore
**Functions:** _have_cli(bin_name), ensure_models_present(), prof_dir(base_dir, persona, set_name), prof_datasets_dir(base_dir, persona, set_name), prof_commands_path(base_dir, persona, set_name), prof_reinforcement_path(base_dir, persona, set_name), conv_db_path(base_dir, persona, set_name), feedback_db_path(base_dir, persona, set_name)


## Module `Rant_PDD\Projects\AI_TTS_AGENT\burner_scripts\agent_store.py`

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
agent_store.py
==============

Thread-safe SQLite façade for the AI-TTS-Agent “v4” architecture.

Tables
------
schemas            : Current JSON blob per persona / set
schema_history     : Versioned diffs – for audits / rollback
commands           : Slash command registry (+weight, locked flag, category_id FK)
beans              : Reinforcement counts & last-updated timestamp
variants           : Prompt / phrase variants auto-generated by SchemaEngine
settings           : Arbitrary per-profile key / val
files              : Filesystem snapshot chunks (path, hash, chunk_idx, content)
spatial_positions  : XY grid positions of entities (bot, objects…)
visual_actions     : Logged avatar actions (textual justification)

Public API
----------
AgentStore(base_dir)    – opens or creates *agent_store.db* in that dir
begin_tx() / commit()   – manual transactions (context-manager also available)
CRUD helpers            – get_schema(), put_schema(), inc_bean(), etc.
migrate_from_files()    – one-shot importer for legacy JSON / sqlite state
ensure_db()             – convenience: open DB, auto-migrate if needed
"""

from __future__ import annotations

import contextlib
import hashlib
import json
import os
import sqlite3
import threading
import time
from typing import Any, Dict, Iterator, List, Optional, Tuple

###############################################################################
# CONSTANTS
###############################################################################

DB_VERSION = 4  # <- bump when schema changes

###############################################################################
# LOW-LEVEL:  connection pool  +  simple retry wrapper
###############################################################################


class _PooledConn:
    """Very small, single-writer / multi-reader pool – good enough for desktop."""

    def __init__(self, path: str) -> None:
        self._path = path
        self._lock = threading.RLock()
        self._pool: List[sqlite3.Connection] = []

    @contextlib.contextmanager
    def get(self) -> Iterator[sqlite3.Connection]:
        with self._lock:
            conn = self._pool.pop() if self._pool else sqlite3.connect(self._path, check_same_thread=False)
        try:
            yield conn
        finally:
            with self._lock:
                if len(self._pool) < 8:
                    self._pool.append(conn)
                else:
                    conn.close()


###############################################################################
# MAIN FACADE
###############################################################################


class AgentStore:
    """
    One instance per *base_dir*; thread-safe for GUI + background workers.
    """

    # ──────────────────────────── bootstrap ────────────────────────────────

    def __init__(self, base_dir: str) -> None:
        self.base_dir = base_dir
        self.db_path = os.path.join(base_dir, "agent_store.db")
        os.makedirs(base_dir, exist_ok=True)
        self._pool = _PooledConn(self.db_path)
        with self._pool.get() as c:
            self._apply_ddl(c)
            c.execute("PRAGMA journal_mode=WAL;")
            c.commit()

    # ------------------------------------------------------------------ DDL
    def _apply_ddl(self, c: sqlite3.Connection) -> None:
        """Create tables if they do not exist, then run migrations."""
        cur = c.cursor()
        cur.executescript(
            """
            PRAGMA foreign_keys = ON;

            CREATE TABLE IF NOT EXISTS meta (
              key TEXT PRIMARY KEY,
              value TEXT
            );

            CREATE TABLE IF NOT EXISTS schemas (
              persona TEXT NOT NULL,
              set_name TEXT NOT NULL,
              schema_json TEXT NOT NULL,
              updated REAL NOT NULL,
              PRIMARY KEY (persona, set_name)
            );

            CREATE TABLE IF NOT EXISTS schema_history (
              id INTEGER PRIMARY KEY AUTOINCREMENT,
              persona TEXT,
              set_name TEXT,
              schema_json TEXT,
              diff TEXT,
              updated REAL
            );

            CREATE TABLE IF NOT EXISTS commands (
              name TEXT PRIMARY KEY,
              weight INTEGER DEFAULT 0,
              locked INTEGER DEFAULT 0,
              category TEXT DEFAULT NULL
            );

            CREATE TABLE IF NOT EXISTS beans (
              subject TEXT PRIMARY KEY,
              count INTEGER DEFAULT 0,
              last_ts REAL
            );

            CREATE TABLE IF NOT EXISTS variants (
              id INTEGER PRIMARY KEY AUTOINCREMENT,
              persona TEXT,
              set_name TEXT,
              category TEXT,
              prompt TEXT
            );

            CREATE TABLE IF NOT EXISTS settings (
              key TEXT PRIMARY KEY,
              value TEXT
            );

            CREATE TABLE IF NOT EXISTS files (
              path TEXT,
              hash TEXT,
              chunk_idx INTEGER,
              size INTEGER,
              mtime REAL,
              content TEXT,
              PRIMARY KEY (path, chunk_idx)
            );

            CREATE TABLE IF NOT EXISTS spatial_positions (
              entity TEXT PRIMARY KEY,
              x INTEGER,
              y INTEGER,
              facing TEXT,
              color TEXT,
              ts REAL
            );

            CREATE TABLE IF NOT EXISTS visual_actions (
              id INTEGER PRIMARY KEY AUTOINCREMENT,
              ts REAL,
              action TEXT,
              location TEXT,
              justification TEXT
            );
            """
        )
        cur.execute("SELECT COALESCE((SELECT value FROM meta WHERE key='user_version'), 0)")
        ver = int(cur.fetchone()[0])
        if ver < DB_VERSION:
            # placeholder for future ALTERs
            cur.execute("REPLACE INTO meta(key,value) VALUES('user_version', ?)", (DB_VERSION,))
        c.commit()

    # ──────────────────────────── helpers ────────────────────────────────
    @contextlib.contextmanager
    def tx(self) -> Iterator[sqlite3.Connection]:
        """Context-manager for explicit multi-statement transaction."""
        with self._pool.get() as c:
            try:
                c.execute("BEGIN IMMEDIATE;")
                yield c
                c.commit()
            except Exception:
                c.rollback()
                raise

    def begin_tx(self) -> sqlite3.Connection:
        """Legacy style manual tx‐start (remember to commit!)."""
        c = self._pool.get().__enter__()  # type: ignore
        c.execute("BEGIN IMMEDIATE;")
        return c

    def commit(self, conn: sqlite3.Connection) -> None:  # noqa: D401
        conn.commit()
        self._pool.get().__exit__(None, None, None)  # type: ignore

    def rollback(self, conn: sqlite3.Connection) -> None:
        conn.rollback()
        self._pool.get().__exit__(None, None, None)  # type: ignore

    # ─────────────────────────── schemas ────────────────────────────────
    def get_schema(self, persona: str, set_name: str) -> Optional[Dict[str, Any]]:
        with self._pool.get() as c:
            cur = c.execute(
                "SELECT schema_json FROM schemas WHERE persona=? AND set_name=?", (persona, set_name)
            )
            row = cur.fetchone()
        return json.loads(row[0]) if row else None

    def put_schema(self, persona: str, set_name: str, schema: Dict[str, Any], diff: str = "") -> None:
        now = time.time()
        s_json = json.dumps(schema, ensure_ascii=False)
        with self.tx() as c:
            c.execute(
                "REPLACE INTO schemas(persona,set_name,schema_json,updated) VALUES(?,?,?,?)",
                (persona, set_name, s_json, now),
            )
            c.execute(
                "INSERT INTO schema_history(persona,set_name,schema_json,diff,updated) VALUES(?,?,?,?,?)",
                (persona, set_name, s_json, diff, now),
            )

    # ─────────────────────────── commands ──────────────────────────────
    def list_commands(self) -> List[Tuple[str, int, int, Optional[str]]]:
        with self._pool.get() as c:
            return list(c.execute("SELECT name,weight,locked,category FROM commands ORDER BY name"))

    def upsert_command(self, name: str, weight: int = 0, locked: bool = False, category: str | None = None) -> None:
        with self._pool.get() as c:
            c.execute(
                "REPLACE INTO commands(name,weight,locked,category) VALUES(?,?,?,?)",
                (name, weight, int(locked), category),
            )
            c.commit()

    # ─────────────────────────── beans ────────────────────────────────
    def inc_bean(self, subject: str, delta: int) -> None:
        now = time.time()
        with self.tx() as c:
            cur = c.execute("SELECT count FROM beans WHERE subject=?", (subject,))
            row = cur.fetchone()
            count = (row[0] if row else 0) + delta
            c.execute("REPLACE INTO beans(subject,count,last_ts) VALUES(?,?,?)", (subject, count, now))

    def get_bean(self, subject: str) -> int:
        with self._pool.get() as c:
            cur = c.execute("SELECT count FROM beans WHERE subject=?", (subject,))
            row = cur.fetchone()
        return row[0] if row else 0

    # ───────────────────────── snapshot (files) ───────────────────────
    def upsert_file_chunk(
        self,
        path: str,
        chunk_idx: int,
        content: str,
        size: int,
        mtime: float,
    ) -> None:
        h = hashlib.sha256(content.encode("utf-8", "ignore")).hexdigest()
        with self._pool.get() as c:
            c.execute(
                "REPLACE INTO files(path,hash,chunk_idx,size,mtime,content) VALUES(?,?,?,?,?,?)",
                (path, h, chunk_idx, size, mtime, content),
            )
            c.commit()

    # ───────────────────────── settings ───────────────────────────────
    def get_setting(self, key: str, default: Any = None) -> Any:
        with self._pool.get() as c:
            cur = c.execute("SELECT value FROM settings WHERE key=?", (key,))
            row = cur.fetchone()
        return json.loads(row[0]) if row else default

    def set_setting(self, key: str, value: Any) -> None:
        val = json.dumps(value)
        with self._pool.get() as c:
            c.execute("REPLACE INTO settings(key,value) VALUES(?,?)", (key, val))
            c.commit()

    # ───────────────────────── migration helper ───────────────────────
    def migrate_from_files(self) -> Dict[str, Any]:
        """
        Import legacy on-disk artefacts *once*.
        Returns a report dict useful for CLI printing.
        """
        report: Dict[str, Any] = {"schemas": 0, "commands": 0, "beans": 0}
        # ------- schemas -------
        legacy_dir = os.path.join(self.base_dir, "schemas")
        if os.path.isdir(legacy_dir):
            for persona in os.listdir(legacy_dir):
                sets_root = os.path.join(legacy_dir, persona, "sets")
                if not os.path.isdir(sets_root):
                    continue
                for set_name in os.listdir(sets_root):
                    sp = os.path.join(sets_root, set_name, "schema.json")
                    if not os.path.isfile(sp):
                        continue
                    with open(sp, "r", encoding="utf-8") as f:
                        schema_json = json.load(f)
                    self.put_schema(persona, set_name, schema_json, diff="initial import")
                    report["schemas"] += 1
        # ------- commands (old profiles) -------
        prof_dir = os.path.join(self.base_dir, "profiles")
        if os.path.isdir(prof_dir):
            for persona in os.listdir(prof_dir):
                for set_name in os.listdir(os.path.join(prof_dir, persona)):
                    cmd_path = os.path.join(prof_dir, persona, set_name, "commands.json")
                    if os.path.isfile(cmd_path):
                        with open(cmd_path, "r", encoding="utf-8") as f:
                            data = json.load(f).get("commands", {})
                        for name, meta in data.items():
                            self.upsert_command(name, meta.get("weight", 0), meta.get("locked", False))
                            report["commands"] += 1
        # ------- beans -------
        reinf_path = os.path.join(self.base_dir, "reinforcement.jsonl")
        if os.path.isfile(reinf_path):
            with open(reinf_path, "r", encoding="utf-8") as f:
                for line in f:
                    try:
                        evt = json.loads(line)
                        subj = evt.get("field")
                        self.inc_bean(subj, 1)
                        report["beans"] += 1
                    except Exception:
                        continue
        return report


###############################################################################
# MODULE-LEVEL convenience
###############################################################################


def ensure_db(base_dir: str) -> AgentStore:
    store = AgentStore(base_dir)
    with store._pool.get() as c:
        cur = c.execute("SELECT value FROM meta WHERE key='user_version'")
        ver = int(cur.fetchone()[0])
    if ver < DB_VERSION:
        print("[AgentStore] Running first-time migration…")
        rpt = store.migrate_from_files()
        print("[AgentStore]   imported:",
              f"{rpt['schemas']} schemas, {rpt['commands']} commands, {rpt['beans']} bean keys")
    return store


# ---------------------------------------------------------------------------#
if __name__ == "__main__":
    import argparse
    import pprint

    ap = argparse.ArgumentParser(description="Create / inspect agent_store.db")
    ap.add_argument("path", help="Base directory of AI-TTS-Agent")
    ap.add_argument("--migrate", action="store_true", help="Run legacy import")
    args = ap.parse_args()

    st = AgentStore(args.path)
    if args.migrate:
        print("Migrating legacy files…")
        pprint.pp(st.migrate_from_files())
    else:
        print("DB user_version =", st.get_setting("db_version", DB_VERSION))
        print("Schemas ->", len(st.list_commands()))
```

agent_store.py
==============

Thread-safe SQLite façade for the AI-TTS-Agent “v4” architecture.

Tables
------
schemas            : Current JSON blob per persona / set
schema_history     : Versioned diffs – for audits / rollback
commands           : Slash command registry (+weight, locked flag, category_id FK)
beans              : Reinforcement counts & last-updated timestamp
variants           : Prompt / phrase variants auto-generated by SchemaEngine
settings           : Arbitrary per-profile key / val
files              : Filesystem snapshot chunks (path, hash, chunk_idx, content)
spatial_positions  : XY grid positions of entities (bot, objects…)
visual_actions     : Logged avatar actions (textual justification)

Public API
----------
AgentStore(base_dir)    – opens or creates *agent_store.db* in that dir
begin_tx() / commit()   – manual transactions (context-manager also available)
CRUD helpers            – get_schema(), put_schema(), inc_bean(), etc.
migrate_from_files()    – one-shot importer for legacy JSON / sqlite state
ensure_db()             – convenience: open DB, auto-migrate if needed
**Classes:** _PooledConn, AgentStore
**Functions:** ensure_db(base_dir)


## Module `Rant_PDD\Projects\AI_TTS_AGENT\burner_scripts\agent_ui.py`

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
agent_ui.py
============

PyQt5 UI for the AI TTS Agent (integrated with AgentCore).

Fixes & additions:
- Slash commands (/remember etc.) now apply to the currently selected persona+set.
- Per-set "Semantic Awareness" persisted (schema.flags.semantic_awareness).
- RAG only uses datasets listed in the current set's schema ("datasets": [...]).
- Schema tab: new Commands row (dropdown + input + Add to Command + New Command).

To launch: `python run_agent.py`
"""

from __future__ import annotations

import os
import json
import time
import re
import subprocess
import threading
from typing import Dict, List, Tuple, Optional

from PyQt5 import QtCore, QtGui, QtWidgets

# Optional spell checker
try:
    from spellchecker import SpellChecker  # type: ignore
except Exception:
    SpellChecker = None  # type: ignore
from PyQt5.QtCore import QSettings, QRunnable, QThreadPool
from functools import partial

# Optional deps
try:
    from sentence_transformers import SentenceTransformer  # type: ignore
except Exception:
    SentenceTransformer = None  # type: ignore
try:
    import numpy as np  # type: ignore
except Exception:
    np = None  # type: ignore
try:
    import sounddevice as sd  # type: ignore
except Exception:
    sd = None  # type: ignore

from agent_core import (
    AgentCore,
    ModelWorker,
)

ROLE_COLOURS: Dict[str, str] = {
    "user": "#FFF8E1",
    "zira": "#E3F2FD",
    "system": "#E0F7FA",
    "operator": "#EDE7F6",
}
NAME_COLOURS: Dict[str, str] = {
    "user": "#5D4037",
    "zira": "#0D47A1",
    "system": "#006064",
    "operator": "#4A148C",
}

# ---------------------------------------------------------------------------
# Spell highlighting for misspelled words
# ---------------------------------------------------------------------------
class _SpellHighlighter(QtGui.QSyntaxHighlighter):
    """
    Underlines misspelled words in red. Uses pyspellchecker if available.
    """
    def __init__(self, document: QtGui.QTextDocument) -> None:
        super().__init__(document)
        # instantiate spell checker only if available
        self._spell = SpellChecker() if SpellChecker else None
        self._format = QtGui.QTextCharFormat()
        self._format.setUnderlineStyle(QtGui.QTextCharFormat.SpellCheckUnderline)
        self._format.setUnderlineColor(QtCore.Qt.red)
        # simple cache to avoid recomputing spelling on common words
        self._cache: Dict[str, bool] = {}

    def highlightBlock(self, text: str) -> None:
        if not self._spell:
            return
        for match in re.finditer(r"[A-Za-z']{3,}", text):
            word = match.group(0).lower()
            bad = self._cache.get(word)
            if bad is None:
                bad = word not in self._spell
                # prune cache occasionally
                if len(self._cache) > 2048:
                    self._cache.clear()
                self._cache[word] = bad
            if bad:
                start, end = match.span()
                length = end - start
                self.setFormat(start, length, self._format)


class AppWindow(QtWidgets.QMainWindow):
    """Main application window for the AI TTS Agent."""

    rewrite_ready = QtCore.pyqtSignal(str)

    def __init__(self) -> None:
        super().__init__()
        self.setWindowTitle("AI TTS Agent v2")
        self.resize(1920, 1080)

        self.base_dir = os.path.dirname(os.path.abspath(__file__))
        self.core = AgentCore(self.base_dir, persona="zira", set_name="default")

        self.current_set: Dict[str, str] = dict(self.core.schema_mgr.active_schemas)
        self.active_persona: str = self.core.persona or "zira"

        self.isolated_history: List[Tuple[str, str]] = []
        self.self_talk_enabled: bool = False
        self._plugin_docks: Dict[str, QtWidgets.QDockWidget] = {}
        self._schema_save_timers: Dict[str, QtCore.QTimer] = {}

        self._idle_timer = QtCore.QTimer(self)
        self._idle_timer.setSingleShot(True)
        self._idle_timer.timeout.connect(self._handle_idle)

        self._restore_layout()
        self._build_ui()
        # build the slash command panel (custom dock)
        self._build_command_dock()
        self._connect_signals()

        try:
            self.core.audio_recorder.transcribed.connect(self._on_transcribed)
        except Exception:
            pass

        self._update_feedback_counts()
        self._bootstrap_conversation()
        self._reset_idle_timer()

        # populate initial slash command list
        try:
            self._populate_command_select()
        except Exception:
            pass

    # ────────────────────────── signals
    def _connect_signals(self) -> None:
        self.btn_send.clicked.connect(self.send_message)

        self.btn_record.clicked.connect(self.start_recording)
        self.btn_stop_rec.clicked.connect(self.stop_recording)

        self.voice_combo.currentTextChanged.connect(self._on_voice_changed)
        # update settings when a new model is selected
        self.model_combo.currentTextChanged.connect(self._on_model_changed)

        self.btn_play.clicked.connect(self._on_play)
        self.btn_stop_tts.clicked.connect(self._on_stop_tts)
        self.btn_replay.clicked.connect(self._on_replay)

        self.btn_like.clicked.connect(self._on_like)
        self.btn_dislike.clicked.connect(self._on_dislike)
        self.btn_manage_feedback.clicked.connect(self._on_manage_feedback)

        self.btn_refresh.clicked.connect(self._on_refresh_chat)
        self.btn_manage_datasets.clicked.connect(self._on_manage_datasets)
        self.btn_inner_monologue.clicked.connect(self._on_inner_monologue)
        self.btn_clear_rag.clicked.connect(self._on_clear_rag_cache)
        self.btn_model_manager.clicked.connect(self._on_show_model_manager)

        self.chk_semantic.toggled.connect(self._on_semantic_toggled)
        self.chk_isolated.toggled.connect(self._on_isolated_toggled)
        self.chk_self_talk.toggled.connect(lambda v: setattr(self, "self_talk_enabled", v))
        self.chk_auto_schema.toggled.connect(self._on_auto_schema_toggled)

        # connect Google STT checkbox
        try:
            self.chk_google_stt.toggled.connect(self._on_google_stt_toggled)
        except Exception:
            pass

        self.rewrite_ready.connect(self._apply_rewrite_result)

        # context menu for chat view to send selection to command input
        try:
            self.chat_view.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
            self.chat_view.customContextMenuRequested.connect(self._show_chat_context_menu)
        except Exception:
            pass
        # custom context menu for spell suggestions on input field
        try:
            self.input_edit.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
            self.input_edit.customContextMenuRequested.connect(self._show_input_context_menu)
        except Exception:
            pass

    # ────────────────────────── layout & lifecycle
    def _restore_layout(self) -> None:
        qsettings = QSettings("xAI", "AI_TTS_Agent")
        try:
            self.restoreGeometry(qsettings.value("geometry", b""))
            self.restoreState(qsettings.value("windowState", b""))
        except Exception:
            pass

    def closeEvent(self, event: QtGui.QCloseEvent) -> None:
        qsettings = QSettings("xAI", "AI_TTS_Agent")
        qsettings.setValue("geometry", self.saveGeometry())
        qsettings.setValue("windowState", self.saveState())
        try:
            self.core.close()
        except Exception:
            pass
        super().closeEvent(event)

    # ────────────────────────── UI build
    def _build_ui(self) -> None:
        self.setStyleSheet(
            """
            QWidget { background-color: #2e3a51; color: #e0e0e0; }
            QGroupBox { border: 1px solid #007acc; margin-top: 7px; }
            QGroupBox::title { subcontrol-origin: margin; left: 12px; padding: 0 4px; }
            QPushButton { background-color: #3c4a6b; color: white; border: 1px solid #007acc; padding: 5px; }
            QPushButton:disabled { background-color: #5a5a7a; color: #c0c0c0; border: 1px solid #555555; }
            QPlainTextEdit, QTextEdit { background-color: #1e2738; color: #e0e0e0; border: 1px solid #007acc; }
            QLineEdit { background-color: #1e2738; color: #e0e0e0; border: 1px solid #007acc; }
            QTabBar::tab { background: #3c4a6b; color: white; border: 1px solid #007acc; padding: 5px 10px; }
            QTabBar::tab:selected { background: #007acc; color: white; }
            QComboBox { background-color: #1e2738; color: #e0e0e0; border: 1px solid #007acc; padding: 3px; }
            QListWidget { background-color: #1e2738; color: #e0e0e0; border: 1px solid #007acc; }
            QCheckBox, QLabel { color: #e0e0e0; }
            """
        )
        self.setDockOptions(
            QtWidgets.QMainWindow.AllowTabbedDocks
            | QtWidgets.QMainWindow.AllowNestedDocks
            | QtWidgets.QMainWindow.AnimatedDocks
        )
        self.setTabPosition(QtCore.Qt.AllDockWidgetAreas, QtWidgets.QTabWidget.North)
        self.setDockNestingEnabled(True)

        tb = QtWidgets.QToolBar("Layout", self)
        tb.setMovable(False)
        self.addToolBar(QtCore.Qt.TopToolBarArea, tb)
        self.chk_lock = QtWidgets.QCheckBox("Lock Layout")
        act = QtWidgets.QWidgetAction(self)
        act.setDefaultWidget(self.chk_lock)
        tb.addAction(act)
        self.chk_lock.toggled.connect(self._on_toggle_lock)

        self.setCentralWidget(QtWidgets.QWidget())
        status = QtWidgets.QStatusBar()
        self.setStatusBar(status)
        self.dock_tray = DockTray(self)
        status.addPermanentWidget(self.dock_tray, 1)

        self.progress_bar = QtWidgets.QProgressBar()
        self.progress_bar.setRange(0, 0)
        self.progress_bar.setVisible(False)
        status.addPermanentWidget(self.progress_bar)

        # Tabs for personas / operators
        self.tabs = QtWidgets.QTabWidget()
        self.tab_widgets: Dict[str, QtWidgets.QWidget] = {}
        for persona in self.core.schema_mgr.personas:
            tab = QtWidgets.QWidget()
            self.tab_widgets[persona] = tab
            self.tabs.addTab(tab, persona.capitalize())
        self.operator_tab = QtWidgets.QWidget()
        self.tabs.addTab(self.operator_tab, "Operators")
        self.tabs.currentChanged.connect(self._on_tab_changed)

        for persona, tab in self.tab_widgets.items():
            self._build_persona_tab(persona, tab)
        self._build_operator_tab(self.operator_tab)

        # Chat panel
        self.chat_view = QtWidgets.QTextEdit()
        self.chat_view.setReadOnly(True)
        self.chat_view.setStyleSheet("background-color: #e0eef5; color: #011627;")
        self.chat_view.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        self.input_edit = QtWidgets.QPlainTextEdit()
        self.input_edit.setPlaceholderText("Type your message or use /remember key value, /showfacts, /style, /weights")
        self.input_edit.setMinimumHeight(64)
        self.input_edit.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        # Attach spell checker highlighter if available
        try:
            if SpellChecker:
                self._spell_highlighter = _SpellHighlighter(self.input_edit.document())  # type: ignore[attr-defined]
        except Exception:
            self._spell_highlighter = None
        self.btn_send = QtWidgets.QPushButton("Send")

        chat_container = QtWidgets.QWidget()
        cv = QtWidgets.QVBoxLayout(chat_container)
        cv.setContentsMargins(7, 7, 7, 7)
        cv.setSpacing(7)
        cv.addWidget(self.chat_view, 1)
        cv.addWidget(self.input_edit)
        row = QtWidgets.QHBoxLayout()
        row.addStretch()
        row.addWidget(self.btn_send)
        cv.addLayout(row)

        # Controls panel
        controls_panel = QtWidgets.QWidget()
        cp_layout = QtWidgets.QVBoxLayout(controls_panel)
        cp_layout.setContentsMargins(7, 7, 7, 7)
        cp_layout.setSpacing(7)

        # Recording
        rec_row = QtWidgets.QHBoxLayout()
        self.btn_record = QtWidgets.QPushButton("Record")
        self.btn_stop_rec = QtWidgets.QPushButton("Stop\nTranscribe")
        self.btn_stop_rec.setEnabled(False)
        for b in (self.btn_record, self.btn_stop_rec):
            b.setMinimumHeight(32)
            b.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        rec_row.addWidget(self.btn_record, 1)
        rec_row.addWidget(self.btn_stop_rec, 1)
        cp_layout.addLayout(rec_row)

        # Microphone device
        mic_row = QtWidgets.QHBoxLayout()
        mic_row.addWidget(QtWidgets.QLabel("Mic:"))
        self.device_combo = QtWidgets.QComboBox()
        self._populate_devices()
        self.device_combo.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        mic_row.addWidget(self.device_combo, 1)
        cp_layout.addLayout(mic_row)

        # Toggles
        self.chk_semantic = QtWidgets.QCheckBox("Semantic Awareness")
        self.chk_semantic.setChecked(True)
        self.chk_isolated = QtWidgets.QCheckBox("Isolated Chat")
        self.chk_isolated.setChecked(False)
        self.chk_mute_tts = QtWidgets.QCheckBox("Mute TTS")
        self.chk_self_talk = QtWidgets.QCheckBox("Enable Self Talk")
        self.chk_self_talk.setChecked(False)
        self.chk_auto_schema = QtWidgets.QCheckBox("Auto Schema Evolution")
        self.chk_auto_schema.setChecked(self.core.settings.auto_schema_enabled)

        cp_layout.addWidget(self.chk_semantic)
        cp_layout.addWidget(self.chk_isolated)
        cp_layout.addWidget(self.chk_mute_tts)
        cp_layout.addWidget(self.chk_self_talk)
        cp_layout.addWidget(self.chk_auto_schema)

        # Optional Google STT toggle (default off)
        self.chk_google_stt = QtWidgets.QCheckBox("Google STT")
        try:
            self.chk_google_stt.setChecked(bool(getattr(self.core.settings, "use_google_stt", False)))
        except Exception:
            self.chk_google_stt.setChecked(False)
        cp_layout.addWidget(self.chk_google_stt)

        # RAG cache clear
        self.btn_clear_rag = QtWidgets.QPushButton("Clear RAG Cache")
        cp_layout.addWidget(self.btn_clear_rag)

        # Maintenance
        self.btn_refresh = QtWidgets.QPushButton("Refresh Chat")
        self.btn_manage_datasets = QtWidgets.QPushButton("Manage Datasets")
        self.btn_inner_monologue = QtWidgets.QPushButton("Inner Monologue")
        for b in (self.btn_refresh, self.btn_manage_datasets, self.btn_inner_monologue):
            b.setMinimumHeight(32)
            b.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
            cp_layout.addWidget(b)

        self.btn_model_manager = QtWidgets.QPushButton("Model Manager")
        self.btn_model_manager.setMinimumHeight(32)
        self.btn_model_manager.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        cp_layout.addWidget(self.btn_model_manager)

        # Style label
        self.style_label = QtWidgets.QLabel("Style: N/A")
        self.style_label.setToolTip("Style score (0–1): rough measure vs. tone rules.")
        cp_layout.addWidget(self.style_label)

        # Response + feedback
        self.response_edit = QtWidgets.QPlainTextEdit()
        self.response_edit.setReadOnly(True)
        self.response_edit.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        cp_layout.addWidget(self.response_edit, 1)

        fb = QtWidgets.QHBoxLayout()
        self.btn_like = QtWidgets.QPushButton("✔")
        self.btn_dislike = QtWidgets.QPushButton("✖")
        self.btn_like.setToolTip("Mark as good response")
        self.btn_dislike.setToolTip("Dislike and rewrite response")
        self.btn_like.setStyleSheet("color: #2ecc71; font-weight: bold;")
        self.btn_dislike.setStyleSheet("color: #e74c3c; font-weight: bold;")
        self.btn_like.setEnabled(False)
        self.btn_dislike.setEnabled(False)
        fb.addWidget(self.btn_like)
        fb.addWidget(self.btn_dislike)
        fb.addStretch()
        self.btn_manage_feedback = QtWidgets.QPushButton("Manage Feedback")
        fb.addWidget(self.btn_manage_feedback)
        cp_layout.addLayout(fb)

        # TTS playback
        tts_row = QtWidgets.QHBoxLayout()
        self.btn_play = QtWidgets.QPushButton("Play")
        self.btn_stop_tts = QtWidgets.QPushButton("Stop")
        self.btn_replay = QtWidgets.QPushButton("Replay")
        for b in (self.btn_play, self.btn_stop_tts, self.btn_replay):
            b.setMinimumHeight(32)
            b.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        tts_row.addWidget(self.btn_play)
        tts_row.addWidget(self.btn_stop_tts)
        tts_row.addWidget(self.btn_replay)
        cp_layout.addLayout(tts_row)

        # Voice & Model
        voice_row = QtWidgets.QHBoxLayout()
        voice_row.addWidget(QtWidgets.QLabel("Voice:"))
        self.voice_combo = QtWidgets.QComboBox()
        voices = self._tts_voice_names()
        if voices:
            self.voice_combo.addItems([v for v in voices if "david" not in v.lower()])
        voice_row.addWidget(self.voice_combo, 1)
        cp_layout.addLayout(voice_row)

        model_row = QtWidgets.QHBoxLayout()
        model_row.addWidget(QtWidgets.QLabel("Model:"))
        self.model_combo = QtWidgets.QComboBox()
        self._populate_models()
        model_row.addWidget(self.model_combo, 1)
        cp_layout.addLayout(model_row)

        # Feedback counts
        self.lbl_feedback_counts = QtWidgets.QLabel("Likes: 0 | Dislikes: 0")
        cp_layout.addWidget(self.lbl_feedback_counts)
        cp_layout.addStretch(1)

        controls_scroll = QtWidgets.QScrollArea()
        controls_scroll.setWidgetResizable(True)
        controls_scroll.setFrameShape(QtWidgets.QFrame.NoFrame)
        controls_scroll.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)
        controls_scroll.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        controls_scroll.setWidget(controls_panel)

        # Docks
        self.controls_dock = QtWidgets.QDockWidget("Controls", self)
        self.controls_dock.setObjectName("ControlsDock")
        self.controls_dock.setWidget(controls_scroll)
        self.controls_dock.setFeatures(
            QtWidgets.QDockWidget.DockWidgetClosable
            | QtWidgets.QDockWidget.DockWidgetMovable
            | QtWidgets.QDockWidget.DockWidgetFloatable
        )

        self.persona_dock = QtWidgets.QDockWidget("Personas", self)
        self.persona_dock.setObjectName("PersonaDock")
        self.persona_dock.setWidget(self._wrap_persona_widget())
        self.persona_dock.setFeatures(
            QtWidgets.QDockWidget.DockWidgetClosable
            | QtWidgets.QDockWidget.DockWidgetMovable
            | QtWidgets.QDockWidget.DockWidgetFloatable
        )

        self.chat_dock = QtWidgets.QDockWidget("Chat", self)
        self.chat_dock.setObjectName("ChatDock")
        self.chat_dock.setWidget(chat_container)
        self.chat_dock.setFeatures(
            QtWidgets.QDockWidget.DockWidgetClosable
            | QtWidgets.QDockWidget.DockWidgetMovable
            | QtWidgets.QDockWidget.DockWidgetFloatable
        )

        self.model_dock = QtWidgets.QDockWidget("Models", self)
        self.model_dock.setObjectName("ModelDock")
        self.model_dock.setFeatures(
            QtWidgets.QDockWidget.DockWidgetClosable
            | QtWidgets.QDockWidget.DockWidgetMovable
            | QtWidgets.QDockWidget.DockWidgetFloatable
        )
        self._build_model_manager()

        self.plugins_dock = QtWidgets.QDockWidget("Plugins", self)
        self.plugins_dock.setObjectName("PluginsDock")
        self.plugins_dock.setFeatures(
            QtWidgets.QDockWidget.DockWidgetClosable
            | QtWidgets.QDockWidget.DockWidgetMovable
            | QtWidgets.QDockWidget.DockWidgetFloatable
        )
        self.plugins_dock.setWidget(self._build_plugins_widget())

        # Titles & dock tray
        self.controls_dock.setTitleBarWidget(DockTitleBar(self.controls_dock, "Controls"))
        self.persona_dock.setTitleBarWidget(DockTitleBar(self.persona_dock, "Personas"))
        self.chat_dock.setTitleBarWidget(DockTitleBar(self.chat_dock, "Chat"))
        self.model_dock.setTitleBarWidget(DockTitleBar(self.model_dock, "Models"))
        self.plugins_dock.setTitleBarWidget(DockTitleBar(self.plugins_dock, "Plugins"))

        for d in (self.controls_dock, self.persona_dock, self.chat_dock, self.model_dock, self.plugins_dock):
            self.dock_tray.register_dock(d)

        self.addDockWidget(QtCore.Qt.LeftDockWidgetArea, self.controls_dock)
        self.addDockWidget(QtCore.Qt.LeftDockWidgetArea, self.persona_dock)
        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.chat_dock)
        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.model_dock)
        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.plugins_dock)

        self.splitDockWidget(self.controls_dock, self.persona_dock, QtCore.Qt.Vertical)
        self.splitDockWidget(self.controls_dock, self.chat_dock, QtCore.Qt.Horizontal)
        self.splitDockWidget(self.chat_dock, self.model_dock, QtCore.Qt.Horizontal)
        self.splitDockWidget(self.model_dock, self.plugins_dock, QtCore.Qt.Horizontal)

    # ────────────────────────── persona widgets
    def _wrap_persona_widget(self) -> QtWidgets.QWidget:
        container = QtWidgets.QWidget()
        v = QtWidgets.QVBoxLayout(container)
        v.setContentsMargins(7, 7, 7, 7)
        v.setSpacing(7)

        try:
            bot_schema = self.core.schema_mgr.load_schema("zira", self.current_set.get("zira", "default"))
            bot_name = bot_schema.get("name", "Zira")
            bot_set = self.current_set.get("zira", "default")
        except Exception:
            bot_name, bot_set = "Zira", "default"

        try:
            user_schema = self.core.schema_mgr.load_schema("user", self.current_set.get("user", "default"))
            user_name = user_schema.get("name", "User")
            user_set = self.current_set.get("user", "default")
        except Exception:
            user_name, user_set = "User", "default"

        self.lbl_active_names = QtWidgets.QLabel(f"{bot_name}: {bot_set} — User: {user_name}: {user_set}")
        v.addWidget(self.lbl_active_names)
        v.addWidget(self.tabs, 1)
        return container

    def _build_persona_tab(self, persona: str, tab: QtWidgets.QWidget) -> None:
        vbox = QtWidgets.QVBoxLayout(tab)

        # --- Set selector row ---
        h_set = QtWidgets.QHBoxLayout()
        h_set.addWidget(QtWidgets.QLabel("Set:"))
        combo = QtWidgets.QComboBox(objectName=f"set_combo_{persona}")
        self._populate_set_combo(persona, combo)
        h_set.addWidget(combo)

        btn_clone = QtWidgets.QPushButton("Clone", objectName=f"clone_set_{persona}")
        btn_new = QtWidgets.QPushButton("New", objectName=f"new_set_{persona}")
        btn_del = QtWidgets.QPushButton("Delete", objectName=f"del_set_{persona}")
        h_set.addWidget(btn_clone)
        h_set.addWidget(btn_new)
        h_set.addWidget(btn_del)
        h_set.addStretch()
        vbox.addLayout(h_set)

        # --- Commands row (NEW) ---
        cmd_row = QtWidgets.QHBoxLayout()
        cmd_row.addWidget(QtWidgets.QLabel("Commands:"))
        cmd_combo = QtWidgets.QComboBox(objectName=f"cmd_combo_{persona}")
        self._populate_command_combo(persona, cmd_combo)
        cmd_row.addWidget(cmd_combo, 1)

        cmd_edit = QtWidgets.QLineEdit(objectName=f"cmd_edit_{persona}")
        cmd_edit.setPlaceholderText('Enter text/payload for selected /command')
        cmd_row.addWidget(cmd_edit, 2)

        btn_add_cmd = QtWidgets.QPushButton("Add to Command", objectName=f"add_cmd_{persona}")
        btn_new_cmd = QtWidgets.QPushButton("New Command", objectName=f"new_cmd_{persona}")
        cmd_row.addWidget(btn_add_cmd)
        cmd_row.addWidget(btn_new_cmd)
        vbox.addLayout(cmd_row)

        # --- Schema editor ---
        editor = QtWidgets.QPlainTextEdit(objectName=f"schema_edit_{persona}")
        editor.setLineWrapMode(QtWidgets.QPlainTextEdit.NoWrap)
        schema = self.core.schema_mgr.load_schema(persona, self.current_set.get(persona, "default"))
        editor.setPlainText(json.dumps(schema, indent=2))
        vbox.addWidget(editor, 1)

        # --- Save button ---
        h_save = QtWidgets.QHBoxLayout()
        btn_save = QtWidgets.QPushButton("Save", objectName=f"save_schema_{persona}")
        h_save.addStretch()
        h_save.addWidget(btn_save)
        vbox.addLayout(h_save)

        # --- Button bindings ---
        combo.currentTextChanged.connect(lambda name, p=persona, c=combo: self._on_set_changed(p, name, c))
        btn_clone.clicked.connect(lambda _, p=persona, c=combo: self._on_clone_set(p, c))
        btn_new.clicked.connect(lambda _, p=persona, c=combo: self._on_new_set(p, c))
        btn_del.clicked.connect(lambda _, p=persona, c=combo: self._on_delete_set(p, c))
        btn_save.clicked.connect(lambda _, p=persona: self._on_save_schema(p))

        btn_add_cmd.clicked.connect(lambda _, p=persona, cc=cmd_combo, ce=cmd_edit: self._on_add_to_command(p, cc, ce))
        btn_new_cmd.clicked.connect(lambda _, p=persona: self._on_new_command(p))

        # --- Autosave debounce ---
        timer = QtCore.QTimer(self)
        timer.setSingleShot(True)

        def on_text_change() -> None:
            timer.start(500)

        def on_timeout() -> None:
            text = editor.toPlainText().strip()
            try:
                obj = json.loads(text)
                if isinstance(obj, dict):
                    set_name = self.current_set.get(persona, "default")
                    self.core.schema_mgr.save_schema(persona, set_name, obj)
            except Exception:
                pass

        editor.textChanged.connect(on_text_change)
        timer.timeout.connect(on_timeout)
        self._schema_save_timers[persona] = timer

    # --- Commands helpers (NEW) ---
    def _populate_command_combo(self, persona: str, combo: QtWidgets.QComboBox) -> None:
        combo.blockSignals(True)
        combo.clear()
        schema = self.core.schema_mgr.load_schema(persona, self.current_set.get(persona, "default"))
        cmds = []
        try:
            cmds = sorted(list((schema.get("commands") or {}).keys()))
        except Exception:
            cmds = []
        if not cmds:
            combo.addItem("(no commands)")
            combo.setEnabled(False)
        else:
            combo.addItems(cmds)
            combo.setEnabled(True)
        combo.blockSignals(False)

    def _on_add_to_command(self, persona: str, combo: QtWidgets.QComboBox, edit: QtWidgets.QLineEdit) -> None:
        text = edit.text().strip()
        if not text:
            QtWidgets.QMessageBox.information(self, "No Text", "Enter text/payload to add.")
            return
        set_name = self.current_set.get(persona, "default")
        schema = self.core.schema_mgr.load_schema(persona, set_name)
        cmds = dict(schema.get("commands") or {})
        sel = combo.currentText().strip()
        if not sel or sel == "(no commands)":
            QtWidgets.QMessageBox.information(self, "No Command", "Create a command first.")
            return
        lst = list(cmds.get(sel) or [])
        lst.append(text)
        cmds[sel] = lst
        schema["commands"] = cmds
        self.core.schema_mgr.save_schema(persona, set_name, schema)
        edit.clear()
        # refresh schema editor & notify
        self._refresh_schema_editor(persona)
        QtWidgets.QMessageBox.information(self, "Added", f'Added to {sel}: "{text}"')

    def _on_new_command(self, persona: str) -> None:
        name, ok = QtWidgets.QInputDialog.getText(self, "New Command", "Enter new command (e.g., /remember):")
        if not ok or not name.strip():
            return
        cmd_name = name.strip()
        if not cmd_name.startswith("/"):
            cmd_name = "/" + cmd_name
        set_name = self.current_set.get(persona, "default")
        schema = self.core.schema_mgr.load_schema(persona, set_name)
        cmds = dict(schema.get("commands") or {})
        if cmd_name in cmds:
            QtWidgets.QMessageBox.information(self, "Exists", f"Command {cmd_name} already exists.")
            return
        cmds[cmd_name] = []
        schema["commands"] = cmds
        self.core.schema_mgr.save_schema(persona, set_name, schema)
        # refresh command combo + schema editor
        tab = self.tab_widgets.get(persona)
        if tab:
            combo = tab.findChild(QtWidgets.QComboBox, f"cmd_combo_{persona}")
            if combo:
                self._populate_command_combo(persona, combo)
                combo.setCurrentText(cmd_name)
            edit = tab.findChild(QtWidgets.QLineEdit, f"cmd_edit_{persona}")
            if edit:
                edit.clear()
        self._refresh_schema_editor(persona)
        QtWidgets.QMessageBox.information(self, "Created", f"New command {cmd_name} created.")

    def _refresh_schema_editor(self, persona: str) -> None:
        tab = self.tab_widgets.get(persona)
        if not tab:
            return
        editor = tab.findChild(QtWidgets.QPlainTextEdit, f"schema_edit_{persona}")
        if editor:
            schema = self.core.schema_mgr.load_schema(persona, self.current_set.get(persona, "default"))
            editor.blockSignals(True)
            editor.setPlainText(json.dumps(schema, indent=2))
            editor.blockSignals(False)
            
    def _on_tab_changed(self, index: int) -> None:
        """
        Handle tab changes in the main tab widget.
        
        Parameters
        ----------
        index : int
            Index of the newly selected tab.
        """
        try:
            tab_name = self.tabs.tabText(index)
            print(f"[UI] Tab changed to: {tab_name} (index {index})")
            # Add any extra logic if needed, for example:
            # self._update_feedback_counts()
        except Exception as e:
            print(f"[UI] Error handling tab change: {e}")
            

    # ────────────────────────── operator tab
    def _build_operator_tab(self, tab: QtWidgets.QWidget) -> None:
        layout = QtWidgets.QVBoxLayout(tab)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)
        scroll = QtWidgets.QScrollArea()
        scroll.setWidgetResizable(True)
        scroll.setFrameShape(QtWidgets.QFrame.NoFrame)
        scroll.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        container = QtWidgets.QWidget()
        container.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        vbox = QtWidgets.QVBoxLayout(container)
        vbox.setContentsMargins(8, 8, 8, 8)
        vbox.setSpacing(8)

        names = sorted(self.core.operator_mgr.list_operators())
        if not names:
            info = QtWidgets.QLabel("No operators found.")
            info.setWordWrap(True)
            vbox.addWidget(info)
        else:
            for name in names:
                # Load operator description if available
                try:
                    op_dir = os.path.join(self.core.operator_mgr.operators_dir, name, "schema.json")
                    desc = ""
                    if os.path.isfile(op_dir):
                        with open(op_dir, "r", encoding="utf-8") as f:
                            d = json.load(f)
                            desc = str(d.get("description", ""))
                except Exception:
                    desc = ""
                box = QtWidgets.QGroupBox(name)
                box.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
                bl = QtWidgets.QVBoxLayout(box)
                bl.setContentsMargins(8, 8, 8, 8)
                bl.setSpacing(6)
                lbl = QtWidgets.QLabel(desc)
                lbl.setWordWrap(True)
                bl.addWidget(lbl)
                btn_row = QtWidgets.QHBoxLayout()
                btn_info = QtWidgets.QPushButton("Info")
                btn_row.addWidget(btn_info)
                btn_row.addStretch(1)
                bl.addLayout(btn_row)
                vbox.addWidget(box)
                btn_info.clicked.connect(partial(QtWidgets.QMessageBox.information, self, f"{name} Info", desc or "No description."))

        vbox.addStretch(1)
        scroll.setWidget(container)
        layout.addWidget(scroll)

    # ────────────────────────── plugins
    def _build_plugins_widget(self) -> QtWidgets.QWidget:
        container = QtWidgets.QWidget()
        layout = QtWidgets.QVBoxLayout(container)
        layout.setContentsMargins(6, 6, 6, 6)
        layout.setSpacing(4)

        self.plugin_list = QtWidgets.QListWidget()
        self.plugin_list.setSelectionMode(QtWidgets.QAbstractItemView.NoSelection)
        layout.addWidget(self.plugin_list, 1)

        btn_rescan = QtWidgets.QPushButton("Rescan")
        layout.addWidget(btn_rescan)
        btn_rescan.clicked.connect(self._rescan_plugins)

        self._populate_plugin_list()
        self.plugin_list.itemChanged.connect(self._on_plugin_item_changed)

        try:
            self.core.plugins.eventReceived.connect(self._on_plugin_event)
        except Exception:
            pass

        return container

    def _populate_plugin_list(self) -> None:
        self.plugin_list.blockSignals(True)
        self.plugin_list.clear()
        for meta in self.core.plugins.list_plugins():
            item = QtWidgets.QListWidgetItem(meta.name)
            flags = item.flags() | QtCore.Qt.ItemIsUserCheckable
            if meta.missing_dependencies:
                flags &= ~QtCore.Qt.ItemIsEnabled
                item.setToolTip(f"Missing dependencies: {', '.join(meta.missing_dependencies)}")
            item.setFlags(flags)
            item.setCheckState(QtCore.Qt.Checked if meta.enabled else QtCore.Qt.Unchecked)
            self.plugin_list.addItem(item)
        self.plugin_list.blockSignals(False)

    def _on_plugin_item_changed(self, item: QtWidgets.QListWidgetItem) -> None:
        name = item.text()
        enabled = item.checkState() == QtCore.Qt.Checked
        self.core.plugins.enable_plugin(name, enabled)
        meta = next((m for m in self.core.plugins.list_plugins() if m.name == name), None)
        if not meta:
            return
        if enabled and meta.widget is not None:
            self._attach_plugin_widget(meta)
        elif not enabled:
            self._detach_plugin_widget(name)

    def _rescan_plugins(self) -> None:
        self.core.plugins.rescan()
        for name in list(self._plugin_docks.keys()):
            meta = next((m for m in self.core.plugins.list_plugins() if m.name == name), None)
            if not meta or not meta.enabled:
                self._detach_plugin_widget(name)
        self._populate_plugin_list()

    def _attach_plugin_widget(self, meta: 'object') -> None:
        if meta.name in self._plugin_docks:
            return
        if meta.widget is None:
            return
        dock = QtWidgets.QDockWidget(meta.name, self)
        dock.setObjectName(f"PluginDock_{meta.name}")
        dock.setWidget(meta.widget)
        dock.setFeatures(
            QtWidgets.QDockWidget.DockWidgetClosable
            | QtWidgets.QDockWidget.DockWidgetMovable
            | QtWidgets.QDockWidget.DockWidgetFloatable
        )
        dock.setTitleBarWidget(DockTitleBar(dock, meta.name))
        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, dock)
        self.dock_tray.register_dock(dock)
        self._plugin_docks[meta.name] = dock

    def _detach_plugin_widget(self, name: str) -> None:
        dock = self._plugin_docks.pop(name, None)
        if dock:
            self.dock_tray._remove_button(dock)
            dock.setParent(None)
            dock.deleteLater()

    @QtCore.pyqtSlot(str, dict)
    def _on_plugin_event(self, sender: str, envelope: dict) -> None:
        try:
            data = envelope.get("data")
            msg = json.dumps(data, indent=2) if isinstance(data, (dict, list)) else str(data)
            display_name = sender
            self._append_message(display_name, msg, role_key="operator")
            if self.chk_semantic.isChecked() and not self.chk_isolated.isChecked():
                self.core.conversation_db.save_message(sender.lower(), msg)
        except Exception as e:
            print(f"Error handling plugin event from {sender}: {e}")

    # ────────────────────────── model manager
    def _build_model_manager(self) -> None:
        widget = QtWidgets.QWidget()
        v = QtWidgets.QVBoxLayout(widget)
        v.setContentsMargins(8, 8, 8, 8)
        v.setSpacing(6)
        self.model_list = QtWidgets.QListWidget()
        v.addWidget(self.model_list, 1)
        h = QtWidgets.QHBoxLayout()
        self.btn_model_pull = QtWidgets.QPushButton("Pull")
        self.btn_model_delete = QtWidgets.QPushButton("Delete")
        self.btn_model_set_default = QtWidgets.QPushButton("Set as Default")
        h.addWidget(self.btn_model_pull)
        h.addWidget(self.btn_model_delete)
        h.addWidget(self.btn_model_set_default)
        h.addStretch()
        v.addLayout(h)
        self.model_dock.setWidget(widget)
        self._refresh_model_list()
        self.btn_model_pull.clicked.connect(self._on_model_pull)
        self.btn_model_delete.clicked.connect(self._on_model_delete)
        self.btn_model_set_default.clicked.connect(self._on_model_set_default)

    def _refresh_model_list(self) -> None:
        self.model_list.clear()
        models: List[str] = []
        try:
            out = subprocess.run(
                ["ollama", "list"],
                stdout=subprocess.PIPE,
                stderr=subprocess.DEVNULL,
                text=True,
                check=True,
            ).stdout.splitlines()
            for line in out[1:]:
                parts = line.strip().split()
                if parts:
                    models.append(parts[0])
        except Exception:
            models = []
        for m in models:
            item = QtWidgets.QListWidgetItem(m)
            if m == self.model_combo.currentText().strip():
                item.setFont(QtGui.QFont("", weight=QtGui.QFont.Bold))
            self.model_list.addItem(item)

    def _on_model_pull(self) -> None:
        item = self.model_list.currentItem()
        if not item:
            return
        model = item.text()
        threading.Thread(target=lambda: subprocess.run(["ollama", "pull", model], check=False), daemon=True).start()
        QtWidgets.QMessageBox.information(self, "Pull Started", f"Pulling {model} in background.")

    def _on_model_delete(self) -> None:
        item = self.model_list.currentItem()
        if not item:
            return
        model = item.text()
        if QtWidgets.QMessageBox.question(
            self,
            "Delete Model",
            f"Delete '{model}'? This cannot be undone.",
            QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No,
        ) != QtWidgets.QMessageBox.Yes:
            return
        threading.Thread(target=lambda: subprocess.run(["ollama", "delete", model], check=False), daemon=True).start()
        QtWidgets.QMessageBox.information(self, "Delete Started", f"Deleting {model} in background.")
        self._refresh_model_list()

    def _on_model_set_default(self) -> None:
        item = self.model_list.currentItem()
        if not item:
            return
        model = item.text()
        idx = self.model_combo.findText(model)
        if idx >= 0:
            self.model_combo.setCurrentIndex(idx)
        # persist selection to settings
        try:
            self.core.settings.default_model = model
            self.core.settings.save()
        except Exception:
            pass
            QtWidgets.QMessageBox.information(self, "Default Model", f"Set default model to {model}.")
        else:
            self.model_combo.addItem(model)
            self.model_combo.setCurrentText(model)

    # ────────────────────────── lock layout
    def _on_toggle_lock(self, locked: bool) -> None:
        feats_unlocked = (
            QtWidgets.QDockWidget.DockWidgetClosable
            | QtWidgets.QDockWidget.DockWidgetMovable
            | QtWidgets.QDockWidget.DockWidgetFloatable
        )
        feats_locked = QtWidgets.QDockWidget.DockWidgetClosable
        for dock in (
            self.controls_dock,
            self.persona_dock,
            self.chat_dock,
            getattr(self, "inner_dock", None),
            self.model_dock,
            self.plugins_dock,
        ):
            if dock is None:
                continue
            dock.setFeatures(feats_locked if locked else feats_unlocked)
        for dock in self._plugin_docks.values():
            dock.setFeatures(feats_locked if locked else feats_unlocked)

    # ────────────────────────── audio
    def start_recording(self) -> None:
        if sd is None or np is None:
            QtWidgets.QMessageBox.information(self, "Recording Unavailable", "sounddevice/numpy not installed.")
            return
        if not self.btn_record.isEnabled():
            return
        device_index = None
        try:
            idx = self.device_combo.currentIndex()
            selected_name = self.device_combo.currentText()
            for i, d in enumerate(sd.query_devices()):
                if d.get("name") == selected_name and d.get("max_input_channels", 0) > 0:
                    device_index = i
                    break
        except Exception:
            device_index = None
        self.core.audio_recorder.start(device_index)
        self.btn_record.setEnabled(False)
        self.btn_stop_rec.setEnabled(True)

    def stop_recording(self) -> None:
        if not self.btn_stop_rec.isEnabled():
            return
        self.core.audio_recorder.stop_and_transcribe()
        self.btn_stop_rec.setEnabled(False)
        self.btn_record.setEnabled(True)

    @QtCore.pyqtSlot(str)
    def _on_transcribed(self, text: str) -> None:
        if not text:
            return
        cur = self.input_edit.toPlainText()
        self.input_edit.setPlainText((cur + "\n" if cur else "") + text)

    # ────────────────────────── TTS
    def _on_play(self) -> None:
        text = self.response_edit.toPlainText().strip()
        if text and not self.chk_mute_tts.isChecked():
            try:
                self.core.tts_mgr.enqueue(text)
            except Exception:
                pass

    def _on_stop_tts(self) -> None:
        try:
            self.core.tts_mgr.stop()
        except Exception:
            pass

    def _on_replay(self) -> None:
        if not self.chk_mute_tts.isChecked():
            try:
                self.core.tts_mgr.replay()
            except Exception:
                pass

    def _on_voice_changed(self, name: str) -> None:
        try:
            eng = getattr(self.core.tts_mgr, "_engine", None)
            if eng:
                for v in eng.getProperty("voices"):
                    if v.name == name:
                        eng.setProperty("voice", v.id)
                        break
        except Exception:
            pass

    def _tts_voice_names(self) -> List[str]:
        try:
            eng = getattr(self.core.tts_mgr, "_engine", None)
            if not eng:
                return []
            return [v.name for v in eng.getProperty("voices")]
        except Exception:
            return []

    # ────────────────────────── feedback
    def _on_like(self) -> None:
        text = self.response_edit.toPlainText().strip()
        if not text:
            return
        try:
            self.core.add_feedback(text, liked=True)
        except Exception:
            pass
        QtWidgets.QMessageBox.information(self, "Feedback", "Marked as good response.")
        self._enable_feedback(False)
        self._update_feedback_counts()

    def _on_dislike(self) -> None:
        original = self.response_edit.toPlainText().strip()
        if not original:
            return
        try:
            self.core.tts_mgr.stop()
        except Exception:
            pass
        QtWidgets.QMessageBox.information(self, "Disliked", "The response will be rewritten.")
        self._enable_feedback(False)

        def worker() -> None:
            new_text = self._rewrite_response(original)
            try:
                self.core.add_feedback(original, liked=False, revised=new_text)
            except Exception:
                pass
            if self.chk_isolated.isChecked():
                self.isolated_history.append((self._current_persona(), new_text))
            else:
                if self.chk_semantic.isChecked():
                    self.core.conversation_db.save_message(self._current_persona().lower(), new_text)
            self.rewrite_ready.emit(new_text)

        threading.Thread(target=worker, daemon=True).start()

    @QtCore.pyqtSlot(str)
    def _apply_rewrite_result(self, new_text: str) -> None:
        schema = self.core.schema_mgr.load_schema(
            self._current_persona(), self.current_set.get(self._current_persona(), "default")
        )
        persona_name = schema.get("name", "Bot")
        role_key = self._current_persona().lower()
        self._append_message(persona_name, new_text, role_key=role_key)
        self.response_edit.setPlainText(new_text)
        if not self.chk_mute_tts.isChecked():
            try:
                self.core.tts_mgr.enqueue(new_text)
            except Exception:
                pass
        QtWidgets.QMessageBox.information(self, "Rewritten", "Response rewritten.")
        self._enable_feedback(False)

    def _update_feedback_counts(self) -> None:
        try:
            pos, neg = self.core.feedback_db.get_counts()
            self.lbl_feedback_counts.setText(f"Likes: {pos} | Dislikes: {neg}")
        except Exception:
            self.lbl_feedback_counts.setText("Likes: - | Dislikes: -")

    def _enable_feedback(self, enabled: bool) -> None:
        self.btn_like.setEnabled(enabled)
        self.btn_dislike.setEnabled(enabled)

    def _on_manage_feedback(self) -> None:
        db = self.core.feedback_db
        if db is None:
            QtWidgets.QMessageBox.information(self, "No DB", "Feedback DB unavailable.")
            return
        cur = db.conn.cursor()
        cur.execute("SELECT id, original, liked, COALESCE(revised, '') FROM feedback ORDER BY id DESC")
        entries = cur.fetchall()
        dlg = QtWidgets.QDialog(self)
        dlg.setWindowTitle("Manage Feedback")
        dlg.resize(720, 420)
        v = QtWidgets.QVBoxLayout(dlg)
        table = QtWidgets.QTableWidget(len(entries), 4)
        table.setHorizontalHeaderLabels(["ID", "Original", "Liked", "Revised"])
        table.horizontalHeader().setStretchLastSection(True)
        for r, (fid, orig, liked, rev) in enumerate(entries):
            table.setItem(r, 0, QtWidgets.QTableWidgetItem(str(fid)))
            table.setItem(r, 1, QtWidgets.QTableWidgetItem(orig))
            table.setItem(r, 2, QtWidgets.QTableWidgetItem("✔" if liked else "✖"))
            table.setItem(r, 3, QtWidgets.QTableWidgetItem(rev))
        v.addWidget(table, 1)
        h = QtWidgets.QHBoxLayout()
        btn_del = QtWidgets.QPushButton("Delete Selected")
        btn_close = QtWidgets.QPushButton("Close")
        h.addWidget(btn_del)
        h.addWidget(btn_close)
        h.addStretch()
        v.addLayout(h)

        def on_delete() -> None:
            selected = table.selectedItems()
            if not selected:
                return
            rows = sorted({i.row() for i in selected}, reverse=True)
            for rr in rows:
                fid_item = table.item(rr, 0)
                if fid_item:
                    try:
                        fid = int(fid_item.text())
                        db.conn.execute("DELETE FROM feedback WHERE id = ?", (fid,))
                        db.conn.commit()
                    except Exception:
                        pass
                table.removeRow(rr)
            self._update_feedback_counts()

        btn_del.clicked.connect(on_delete)
        btn_close.clicked.connect(dlg.accept)
        dlg.exec_()

    # ────────────────────────── datasets / rag
    def _on_manage_datasets(self) -> None:
        DatasetManagerDialog(self.core.dataset_mgr, self).exec_()

    def _on_clear_rag_cache(self) -> None:
        if QtWidgets.QMessageBox.question(
            self,
            "Clear RAG Cache",
            "Delete cached embeddings for all datasets and clear memory?",
            QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No,
        ) != QtWidgets.QMessageBox.Yes:
            return
        count = self.core.rag_cache.clear_disk()
        self.core.rag_cache.clear_memory()
        QtWidgets.QMessageBox.information(self, "Cleared", f"Cleared RAG cache files ({count} removed) and in-memory index.")

    # ────────────────────────── isolated / refresh / idle
    def _on_isolated_toggled(self, checked: bool) -> None:
        if checked:
            self.isolated_history.clear()
        else:
            if self.isolated_history:
                ans = QtWidgets.QMessageBox.question(
                    self,
                    "Merge Isolated Chat",
                    "Merge isolated conversation into main memory?",
                    QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No,
                )
                if ans == QtWidgets.QMessageBox.Yes:
                    for role, content in self.isolated_history:
                        self.core.conversation_db.save_message(role.lower(), content)
                self.isolated_history.clear()
        self._reset_idle_timer()

    def _on_refresh_chat(self) -> None:
        if self.chk_isolated.isChecked():
            self.isolated_history.clear()
        self.chat_view.clear()
        self.response_edit.clear()
        self._enable_feedback(False)
        try:
            if hasattr(self, "inner_text") and self.inner_text is not None:
                self.inner_text.clear()
        except Exception:
            pass

    def _reset_idle_timer(self) -> None:
        self._idle_timer.stop()
        if self.chk_semantic.isChecked():
            self._idle_timer.start(60000)

    def _handle_idle(self) -> None:
        pass

    # ────────────────────────── inner monologue
    def _on_inner_monologue(self) -> None:
        self._ensure_inner_dock()
        if self.inner_dock is None:
            return
        self.inner_dock.setVisible(not self.inner_dock.isVisible())

    def _ensure_inner_dock(self) -> None:
        if hasattr(self, "inner_dock") and self.inner_dock is not None:
            return
        dock = QtWidgets.QDockWidget("Inner Monologue", self)
        dock.setObjectName("InnerDock")
        dock.setAllowedAreas(QtCore.Qt.RightDockWidgetArea | QtCore.Qt.LeftDockWidgetArea)
        inner = QtWidgets.QWidget()
        v = QtWidgets.QVBoxLayout(inner)
        self.inner_text = QtWidgets.QPlainTextEdit()
        self.inner_text.setReadOnly(True)
        v.addWidget(self.inner_text, 1)
        h = QtWidgets.QHBoxLayout()
        h.addWidget(QtWidgets.QLabel("Interval (s):"))
        self.spin_interval = QtWidgets.QSpinBox()
        self.spin_interval.setRange(1, 60)
        self.spin_interval.setValue(15)
        h.addWidget(self.spin_interval)
        self.chk_monologue_tts = QtWidgets.QCheckBox("Speak")
        self.chk_monologue_tts.setChecked(self.core.settings.monologue_tts_enabled)
        h.addWidget(self.chk_monologue_tts)
        h.addWidget(QtWidgets.QLabel("Volume:"))
        self.slider_monologue_vol = QtWidgets.QSlider(QtCore.Qt.Horizontal)
        self.slider_monologue_vol.setRange(0, 100)
        self.slider_monologue_vol.setValue(self.core.settings.monologue_volume)
        h.addWidget(self.slider_monologue_vol)
        btn_start_stop = QtWidgets.QPushButton("Start/Stop")
        h.addWidget(btn_start_stop)
        v.addLayout(h)
        inner.setLayout(v)
        dock.setWidget(inner)
        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, dock)
        self.inner_dock = dock
        self.inner_timer = QtCore.QTimer(self)
        self.inner_timer.setSingleShot(False)
        btn_start_stop.clicked.connect(self._toggle_inner_timer)
        dock.setTitleBarWidget(DockTitleBar(dock, "Inner Monologue"))
        self.dock_tray.register_dock(self.inner_dock)
        self.chk_monologue_tts.stateChanged.connect(lambda _: self._update_monologue_settings())
        self.slider_monologue_vol.valueChanged.connect(lambda _: self._update_monologue_settings())

    def _toggle_inner_timer(self) -> None:
        if self.inner_timer is None:
            return
        if self.inner_timer.isActive():
            self.inner_timer.stop()
        else:
            interval_ms = self.spin_interval.value() * 1000
            try:
                self.inner_timer.timeout.disconnect()
            except Exception:
                pass
            self.inner_timer.timeout.connect(self._generate_inner_monologue)
            self.inner_timer.start(interval_ms)

    def _update_monologue_settings(self) -> None:
        try:
            self.core.settings.monologue_tts_enabled = self.chk_monologue_tts.isChecked() if hasattr(self, 'chk_monologue_tts') else False
            self.core.settings.monologue_volume = self.slider_monologue_vol.value() if hasattr(self, 'slider_monologue_vol') else 50
            self.core.settings.save()
        except Exception:
            pass

    def _generate_inner_monologue(self) -> None:
        schema = self.core.schema_mgr.load_schema(self._current_persona(), self.current_set.get(self._current_persona(), "default"))
        overlay = schema.get("dynamic_overlay", {}) or {}
        mood = overlay.get("temporary_emotional_state", "neutral")
        likes = overlay.get("recent_topics", [])
        pos = [0, 0]
        fav_topic = likes[-1] if likes else None
        thought = f"I'm thinking about {fav_topic} while feeling {mood}." if fav_topic else f"I'm in a {mood} mood and reflecting."
        thought += f" I'm at position {pos}."
        try:
            if hasattr(self, "inner_text") and self.inner_text is not None:
                self.inner_text.appendPlainText(thought)
        except Exception:
            pass

    # ────────────────────────── conversation
    def _append_message(self, display_name: str, text: str, role_key: Optional[str] = None) -> None:
        key = (role_key or display_name).lower()
        bg_colour = ROLE_COLOURS.get(key, "#EEEEEE")
        name_colour = NAME_COLOURS.get(key, "#011627")
        safe_role = QtGui.QGuiApplication.translate("Chat", display_name)
        safe_text = QtGui.QGuiApplication.translate("Chat", text)
        frag = (
            f'<div style="background-color:{bg_colour}; border-radius:4px; padding:4px; margin:4px;">'
            f'<b style="color:{name_colour};">{safe_role}:</b> {safe_text}'
            f'</div>'
        )
        self.chat_view.append(frag)

    def _current_history(self) -> List[Tuple[str, str]]:
        if self.chk_isolated.isChecked():
            return self.isolated_history
        else:
            return self.core.conversation_db.fetch_history(limit=10)

    def _bootstrap_conversation(self) -> None:
        if self.core and len(self.core.conversation_db.fetch_history(limit=1)) == 0:
            schema = self.core.schema_mgr.load_schema(self.active_persona, self.current_set.get(self.active_persona, "default"))
            questions = schema.get("questions", [])
            if questions:
                first_question = questions[0]
                self._append_message("System", first_question, role_key="system")
                if self.chk_semantic.isChecked() and not self.chk_isolated.isChecked():
                    self.core.conversation_db.save_message("system", first_question)

    # ────────────────────────── prompt & rag
    def _build_prompt(self, schema: Dict[str, object], user_text: str, is_self_talk: bool = False) -> str:
        parts: List[str] = []
        name = schema.get("name", "")
        role = schema.get("role", "")
        desc = schema.get("description", "")
        persona_desc = f"You are {name}, {desc}".strip()
        if role:
            persona_desc += f" Your role is {role}."

        overlay = schema.get("dynamic_overlay", {})
        if overlay:
            temp_rel = overlay.get("temporary_relationship_context", "")
            temp_emotion = overlay.get("temporary_emotional_state", "")
            added_traits = overlay.get("added_traits", [])
            if temp_rel:
                persona_desc += f" ({temp_rel})"
            if temp_emotion:
                persona_desc += f" You feel {temp_emotion}."
            if added_traits:
                persona_desc += f" Traits: {', '.join(str(t) for t in added_traits)}."
        parts.append(persona_desc)

        # User description
        try:
            user_schema = self.core.schema_mgr.load_schema("user", self.current_set.get("user", "default"))
        except Exception:
            user_schema = {}
        if user_schema:
            u_name = user_schema.get("name", "User")
            u_personality = user_schema.get("personality", "")
            relationship = user_schema.get("relationship_to_zira", "friend")
            u_overlay = user_schema.get("dynamic_overlay", {})
            temp_rel2 = u_overlay.get("temporary_relationship_context") if u_overlay else None
            if temp_rel2 and str(temp_rel2).strip():
                relationship = str(temp_rel2)
            user_desc = f"User is {u_name}, {u_personality}. Relationship: {relationship}."
            parts.append(user_desc)

        # History
        history_text = ""
        if self.chk_semantic.isChecked():
            history = self._current_history()[-10:]
            for role_name, content in history:
                speaker = "User" if role_name.lower() == "user" else role_name.title()
                history_text += f"{speaker}: {content}\n"
        if history_text:
            parts.append("Conversation history:\n" + history_text.strip())

        # RAG (only datasets listed by this set)
        dataset_text = ""
        ds_names: List[str] = list(schema.get("datasets") or [])
        try:
            # Prefer core search with filters if supported
            hits = self.core.rag_search(
                user_text,
                per_ds_k=3,
                limit=5,
                include_shared=False,
                datasets=ds_names if ds_names else None,
            )
            for chunk, score, ds_name, owner in hits:
                dataset_text += f"Dataset ({owner}/{ds_name}):\n{chunk}\n\n"
        except TypeError:
            # Older core: no dataset filter; fallback to manual selection
            from_texts: List[Tuple[str, str]] = []
            try:
                for name, entry in self.core.dataset_mgr.entries.items():
                    if ds_names and name not in ds_names:
                        continue
                    if not entry.active:
                        continue
                    full_text = self.core.dataset_mgr.load_dataset_text(entry)
                    if full_text:
                        from_texts.append((name, full_text))
            except Exception:
                pass
            for name, full_text in from_texts:
                snip = self._retrieve_dataset_snippet(full_text, user_text)
                if snip:
                    dataset_text += f"Dataset ({name}):\n{snip}\n\n"
        except Exception:
            pass
        if dataset_text:
            parts.append(dataset_text.strip())

        # Self-talk (optional)
        if is_self_talk and self.self_talk_enabled:
            st_prompts = schema.get("self_talk", [])
            if st_prompts:
                import random
                parts.append(random.choice(st_prompts))

        parts.append(f"User: {user_text}")
        return "\n\n".join([p for p in parts if p])

    def _retrieve_dataset_snippet(self, full_text: str, user_text: str) -> str:
        try:
            tokens = [w.lower() for w in re.findall(r"\b\w+\b", user_text) if len(w) > 2]
            paragraphs = [p.strip() for p in full_text.split("\n") if p.strip()]
            scored: List[Tuple[int, str]] = []
            for para in paragraphs:
                l = para.lower()
                score = sum(1 for t in tokens if t in l)
                if score > 0:
                    scored.append((score, para))
            if not scored:
                return paragraphs[0][:500] if paragraphs else full_text[:500]
            scored.sort(key=lambda x: -x[0])
            top = [p for _, p in scored[:2]]
            return "\n".join(top)[:500]
        except Exception:
            return full_text[:500]

    # ────────────────────────── send / model
    def send_message(self) -> None:
        user_text = self.input_edit.toPlainText().strip()
        if not user_text:
            return

        # Broadcast to plugins
        try:
            self.core.plugins.broadcast(user_text)
        except Exception:
            pass

        # Slash commands → ensure applied to current persona+set
        if user_text.startswith("/"):
            self.input_edit.clear()
            persona = self._current_persona()
            set_name = self.current_set.get(persona, "default")
            try:
                out = self.core.run_command(user_text, persona=persona, set_name=set_name)
            except TypeError:
                # Back-compat signature
                out = self.core.run_command(user_text)
            self._append_message("System", out, role_key="system")
            if self.chk_semantic.isChecked() and not self.chk_isolated.isChecked():
                self.core.conversation_db.save_message("system", out)
            return

        # Normal message
        self.input_edit.clear()
        persona = self._current_persona()
        set_name = self.current_set.get(persona, "default")
        schema = self.core.schema_mgr.load_schema(persona, set_name)

        if self.chk_isolated.isChecked():
            self.isolated_history.append(("user", user_text))
        else:
            if self.chk_semantic.isChecked():
                self.core.conversation_db.save_message("user", user_text)

        try:
            user_schema = self.core.schema_mgr.load_schema("user", self.current_set.get("user", "default"))
            user_display = user_schema.get("name", "User")
        except Exception:
            user_display = "User"
        self._append_message(user_display, user_text, role_key="user")

        prompt = self._build_prompt(schema, user_text)

        self.btn_send.setEnabled(False)
        model_slug = self.model_combo.currentText().strip() or self.core.settings.default_model
        worker = ModelWorker(model_slug, prompt, parent=self.core)
        worker.finished.connect(lambda resp, usr=user_text, sch=schema: self._on_model_response(resp, usr, sch))
        worker.finished.connect(lambda: self.btn_send.setEnabled(True))
        worker.start()

    def _on_model_response(self, response_raw: str, user_text: str, schema: Dict[str, object]) -> None:
        model_slug = self.model_combo.currentText().strip()
        response = self._strip_reasoning(model_slug, response_raw)
        response, style_score = self._style_and_guard(response, schema)
        self.style_label.setText(f"Style: {style_score:.2f}")

        if self.chk_isolated.isChecked():
            self.isolated_history.append((schema.get("name", "bot"), response))
        else:
            if self.chk_semantic.isChecked():
                self.core.conversation_db.save_message(schema.get("name", "bot").lower(), response)

        persona_name = schema.get("name", "Bot") or "Bot"
        role_key = self._current_persona().lower()
        self._append_message(persona_name, response, role_key=role_key)
        self.response_edit.setPlainText(response)

        if not self.chk_mute_tts.isChecked():
            try:
                self.core.tts_mgr.enqueue(response)
            except Exception:
                pass

        self._enable_feedback(True)
        self._reset_idle_timer()

        try:
            tokens = [w.lower() for w in re.findall(r"\b\w+\b", user_text) if len(w) > 3]
            for t in tokens:
                self.update_overlay_topic(self._current_persona(), t)
            self.update_overlay_emotion(self._current_persona(), "neutral")
        except Exception:
            pass

        try:
            for line in response.split("\n"):
                if line.strip():
                    self.core.plugins.broadcast(line.strip())
        except Exception as e:
            print(f"Error broadcasting to plugins: {e}")

        if self.core.settings.auto_schema_enabled:
            self.progress_bar.setVisible(True)


            class EvolverWorker(QRunnable):
                def __init__(self, evolver, persona, set_name, history, window):
                    super().__init__()
                    self.evolver = evolver
                    self.persona = persona
                    self.set_name = set_name
                    self.history = history
                    self.window = window

                def run(self):
                    changed = self.evolver.update_schema(self.persona, self.set_name, self.history)
                    QtCore.QMetaObject.invokeMethod(
                        self.window, "_post_evolver", QtCore.Qt.QueuedConnection, QtCore.Q_ARG(bool, changed)
                    )

            QThreadPool.globalInstance().start(
                EvolverWorker(self.core.schema_evolver, self.active_persona, self.current_set.get(self.active_persona, "default"), self._current_history(), self)
            )

    @QtCore.pyqtSlot(bool)
    def _post_evolver(self, changed: bool) -> None:
        self.progress_bar.setVisible(False)
        if changed:
            self._flash_status("Schema adapted")

    def _strip_reasoning(self, model: str, response: str) -> str:
        if model and "deepseek" in model.lower():
            if "<think>" in response and "</think>" in response:
                try:
                    return response.split("</think>")[-1].strip() or response
                except Exception:
                    return response
        return response

    def _style_and_guard(self, text: str, schema: Dict[str, object]) -> Tuple[str, float]:
        exclam = text.count("!")
        sentences = [s for s in re.split(r"[.!?]", text) if s.strip()]
        avg_len = sum(len(s.split()) for s in sentences) / max(1, len(sentences))
        exclam_density = exclam / max(1, len(text))
        tone = schema.get("tone_rules", {"conciseness": [0.6, 0.8], "exclam_limit": 0.05})
        conciseness = max(0.0, min(1.0, (22 - avg_len) / 16.0))
        ex_ok = 1.0 if exclam_density <= float(tone.get("exclam_limit", 0.05)) else 0.5
        score = max(0.0, min(1.0, 0.5 * conciseness + 0.5 * ex_ok))
        return text, score

    def _rewrite_response(self, original: str) -> str:
        try:
            liked = self.core.feedback_db.get_liked_responses(limit=5)
        except Exception:
            liked = []
        schema = self.core.schema_mgr.load_schema(self._current_persona(), self.current_set.get(self._current_persona(), "default"))
        rps = schema.get("rewrite_prompts", [])
        template = rps[0] if rps else "Rewrite to be more appealing. Keep it accurate, concise, and on style."
        parts = [template]
        if liked:
            parts.append("Preferred responses:\n" + "\n\n".join(liked))
        parts.append("Original:\n" + original)
        parts.append("Rewritten:")
        prompt = "\n\n".join(parts)
        return self._run_model(self.model_combo.currentText().strip() or self.core.settings.default_model, prompt) or original

    def _run_model(self, model: str, prompt: str) -> str:
        try:
            proc = subprocess.run(
                ["ollama", "run", model],
                input=prompt.encode("utf-8"),
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                check=True,
            )
            return proc.stdout.decode("utf-8", errors="replace").strip()
        except subprocess.CalledProcessError as e:
            return e.stderr.decode("utf-8", errors="replace").strip()
        except FileNotFoundError:
            return "(error) ollama executable not found."
        except Exception as e:
            return f"(error) {e}"

    # ────────────────────────── persona / sets
    def _populate_set_combo(self, persona: str, combo: QtWidgets.QComboBox) -> None:
        combo.blockSignals(True)
        combo.clear()
        for s in self.core.schema_mgr.get_set_list(persona):
            combo.addItem(s)
        current = self.current_set.get(persona, "default")
        idx = combo.findText(current)
        combo.setCurrentIndex(idx if idx >= 0 else combo.findText("default"))
        if idx < 0:
            self.current_set[persona] = combo.currentText()
        combo.blockSignals(False)

    def _on_set_changed(self, persona: str, name: str, combo: QtWidgets.QComboBox) -> None:
        if not name:
            return
        self.current_set[persona] = name
        # keep AgentCore pointed to the right set if this persona is active
        if persona == self._current_persona():
            self.core.persona = persona
            self.core.set_name = name

        # refresh editor + commands row for this tab
        tab = self.tab_widgets.get(persona)
        if tab:
            editor = tab.findChild(QtWidgets.QPlainTextEdit, f"schema_edit_{persona}")
            if editor:
                schema = self.core.schema_mgr.load_schema(persona, name)
                editor.setPlainText(json.dumps(schema, indent=2))
            cmd_combo = tab.findChild(QtWidgets.QComboBox, f"cmd_combo_{persona}")
            if cmd_combo:
                self._populate_command_combo(persona, cmd_combo)

        # persist active sets & update controls tied to schema flags
        self.core.schema_mgr.save_active_schemas(self.current_set)
        self._sync_semantic_checkbox_from_schema()
        self._update_feedback_counts()

        # refresh slash command list if this persona is active
        try:
            if persona == self._current_persona():
                self._populate_command_select()
        except Exception:
            pass

    def _on_clone_set(self, persona: str, combo: QtWidgets.QComboBox) -> None:
        src = combo.currentText()
        name, ok = QtWidgets.QInputDialog.getText(self, "Clone Set", "Enter new set name:")
        if not ok or not name.strip():
            return
        new_name = name.strip()
        try:
            schema = self.core.schema_mgr.load_schema(persona, src)
            # Preserve the persona's canonical name; set label is separate
            schema["name"] = persona.capitalize()
            self.core.schema_mgr.save_schema(persona, new_name, schema)
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "Error", str(e))
            return
        self.current_set[persona] = new_name
        self._populate_set_combo(persona, combo)
        combo.setCurrentText(new_name)
        if persona == self._current_persona():
            self.core.set_name = new_name
        self.core.schema_mgr.save_active_schemas(self.current_set)
        self._sync_semantic_checkbox_from_schema()
        self._update_feedback_counts()

    def _on_new_set(self, persona: str, combo: QtWidgets.QComboBox) -> None:
        src = combo.currentText()
        name, ok = QtWidgets.QInputDialog.getText(self, "New Set", "Enter name for new set:")
        if not ok or not name.strip():
            return
        new_name = name.strip()
        try:
            schema = self.core.schema_mgr.load_schema(persona, src)
            # Preserve the persona's canonical name; set label is separate
            schema["name"] = persona.capitalize()
            self.core.schema_mgr.save_schema(persona, new_name, schema)
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "Error", str(e))
            return
        self.current_set[persona] = new_name
        self._populate_set_combo(persona, combo)
        combo.setCurrentText(new_name)
        if persona == self._current_persona():
            self.core.set_name = new_name
        self.core.schema_mgr.save_active_schemas(self.current_set)
        self._sync_semantic_checkbox_from_schema()
        self._update_feedback_counts()

    def _on_delete_set(self, persona: str, combo: QtWidgets.QComboBox) -> None:
        name = combo.currentText()
        if name == "default":
            QtWidgets.QMessageBox.information(self, "Cannot Delete", "The default set cannot be deleted.")
            return
        if QtWidgets.QMessageBox.question(
            self, "Delete Set", f"Delete '{name}' (irreversible)?", QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No
        ) != QtWidgets.QMessageBox.Yes:
            return
        try:
            set_dir = os.path.join(self.core.schema_mgr.schemas_dir, persona.lower(), "sets", name)
            import shutil
            shutil.rmtree(set_dir, ignore_errors=True)
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "Error", str(e))
            return
        self.current_set[persona] = "default"
        self._populate_set_combo(persona, combo)
        combo.setCurrentText("default")
        if persona == self._current_persona():
            self.core.set_name = "default"
        self.core.schema_mgr.save_active_schemas(self.current_set)
        self._sync_semantic_checkbox_from_schema()
        self._update_feedback_counts()

    def _on_save_schema(self, persona: str) -> None:
        tab = self.tab_widgets.get(persona)
        if not tab:
            return
        editor = tab.findChild(QtWidgets.QPlainTextEdit, f"schema_edit_{persona}")
        if not editor:
            return
        text = editor.toPlainText().strip()
        try:
            schema = json.loads(text)
            if not isinstance(schema, dict):
                raise ValueError
        except Exception:
            QtWidgets.QMessageBox.warning(self, "Invalid JSON", "The schema is not valid JSON.")
            return
        set_name = self.current_set.get(persona, "default")
        existing_schema = self.core.schema_mgr.load_schema(persona, set_name)
        merged_schema = {**existing_schema, **schema}
        # Ensure the top-level name matches the active set name
        try:
            merged_schema["name"] = set_name
        except Exception:
            pass
        self.core.schema_mgr.save_schema(persona, set_name, merged_schema)
        QtWidgets.QMessageBox.information(self, "Saved", f"Schema saved for {persona} ({set_name}).")

        if persona == self._current_persona():
            persona_voice = (merged_schema.get("voice") or "").lower()
            for i in range(self.voice_combo.count()):
                if persona_voice and persona_voice in self.voice_combo.itemText(i).lower():
                    self.voice_combo.setCurrentIndex(i)
                    break
        # After save, refresh commands combo (in case user edited commands JSON directly)
        tab = self.tab_widgets.get(persona)
        if tab:
            cmd_combo = tab.findChild(QtWidgets.QComboBox, f"cmd_combo_{persona}")
            if cmd_combo:
                self._populate_command_combo(persona, cmd_combo)

    def _tab_changed(self, index: int) -> None:
        if 0 <= index < len(self.core.schema_mgr.personas):
            self.active_persona = self.core.schema_mgr.personas[index]
        else:
            self.active_persona = self.core.schema_mgr.personas[0] if self.core.schema_mgr.personas else "zira"
        self.core.persona = self.active_persona

        schema = self.core.schema_mgr.load_schema(self.active_persona, self.current_set.get(self.active_persona, "default"))
        persona_voice = (schema.get("voice") or "").lower()
        for i in range(self.voice_combo.count()):
            if persona_voice and persona_voice in self.voice_combo.itemText(i).lower():
                self.voice_combo.setCurrentIndex(i)
                break

        tab = self.tab_widgets.get(self.active_persona)
        if tab:
            editor = tab.findChild(QtWidgets.QPlainTextEdit, f"schema_edit_{self.active_persona}")
            if editor:
                editor.setPlainText(json.dumps(schema, indent=2))
            cmd_combo = tab.findChild(QtWidgets.QComboBox, f"cmd_combo_{self.active_persona}")
            if cmd_combo:
                self._populate_command_combo(self.active_persona, cmd_combo)

        try:
            user_schema = self.core.schema_mgr.load_schema("user", self.current_set.get("user", "default"))
            bot_name = schema.get("name", self.active_persona.title())
            bot_set = self.current_set.get(self.active_persona, "default")
            user_name = user_schema.get("name", "User")
            user_set = self.current_set.get("user", "default")
            self.lbl_active_names.setText(f"{bot_name}: {bot_set} — User: {user_name}: {user_set}")
        except Exception:
            pass

        self._sync_semantic_checkbox_from_schema()
        self._update_feedback_counts()

        # refresh slash command dropdown on persona change
        try:
            self._populate_command_select()
        except Exception:
            pass

    def _current_persona(self) -> str:
        return self.active_persona

    # ────────────────────────── overlay helpers
    def update_overlay_topic(self, persona: str, topic: str) -> None:
        persona = persona.lower()
        try:
            schema = self.core.schema_mgr.load_schema(persona, self.current_set.get(persona, "default"))
            overlay = dict(schema.get("dynamic_overlay", {}))
            topics = list(overlay.get("recent_topics", []))
            if topic and topic not in topics:
                topics.append(topic)
                if len(topics) > 10:
                    topics = topics[-10:]
                overlay["recent_topics"] = topics
                schema["dynamic_overlay"] = overlay
                self.core.schema_mgr.save_schema(persona, self.current_set.get(persona, "default"), schema)
        except Exception:
            pass

    def update_overlay_emotion(self, persona: str, emotion: str) -> None:
        persona = persona.lower()
        try:
            schema = self.core.schema_mgr.load_schema(persona, self.current_set.get(persona, "default"))
            overlay = dict(schema.get("dynamic_overlay", {}))
            overlay["temporary_emotional_state"] = emotion
            schema["dynamic_overlay"] = overlay
            self.core.schema_mgr.save_schema(persona, self.current_set.get(persona, "default"), schema)
        except Exception:
            pass

    # ────────────────────────── devices & models
    def _populate_devices(self) -> None:
        self.device_combo.clear()
        try:
            if sd is not None:
                devs = [d.get("name", "?") for d in sd.query_devices() if d.get("max_input_channels", 0) > 0]
                if devs:
                    self.device_combo.addItems(devs)
        except Exception:
            pass
        if self.device_combo.count() == 0:
            self.device_combo.addItem("Default")

    def _populate_models(self) -> None:
        models: List[str] = []
        try:
            out = subprocess.run(
                ["ollama", "list"],
                stdout=subprocess.PIPE,
                stderr=subprocess.DEVNULL,
                text=True,
                check=True,
            ).stdout.splitlines()
            for line in out[1:]:
                parts = line.strip().split()
                if parts:
                    models.append(parts[0])
        except Exception:
            pass
        if not models:
            models = [self.core.settings.default_model or "mistral:latest"]
        self.model_combo.clear()
        self.model_combo.addItems(models)
        idx = self.model_combo.findText(self.core.settings.default_model)
        if idx >= 0:
            self.model_combo.setCurrentIndex(idx)

    # ────────────────────────── slash commands panel
    def _build_command_dock(self) -> None:
        """
        Build a dockable panel that exposes slash commands with an argument
        entry and send button. This allows users to trigger any command
        without typing it into the chat manually. It will be updated when
        persona or set changes.
        """
        dock = QtWidgets.QDockWidget("Slash Commands", self)
        dock.setObjectName("SlashCommandsDock")
        dock.setFeatures(
            QtWidgets.QDockWidget.DockWidgetClosable
            | QtWidgets.QDockWidget.DockWidgetMovable
            | QtWidgets.QDockWidget.DockWidgetFloatable
        )
        container = QtWidgets.QWidget()
        layout = QtWidgets.QVBoxLayout(container)
        layout.setContentsMargins(7, 7, 7, 7)
        layout.setSpacing(5)

        # command selector
        cmd_label = QtWidgets.QLabel("Slash Command:")
        self.command_select = QtWidgets.QComboBox()
        layout.addWidget(cmd_label)
        layout.addWidget(self.command_select)

        # argument input
        self.command_input = QtWidgets.QLineEdit()
        self.command_input.setPlaceholderText("Enter arguments or select text from chat…")
        layout.addWidget(self.command_input)

        # send button
        btn_run = QtWidgets.QPushButton("Run Command")
        btn_run.clicked.connect(self._on_run_command)
        layout.addWidget(btn_run)
        layout.addStretch(1)

        dock.setWidget(container)
        # add to right side by default
        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, dock)
        self.command_dock = dock

    def _populate_command_select(self) -> None:
        """
        Populate the slash command dropdown with available commands from
        the command registry. This is called whenever the active persona
        or set changes to reflect dynamic additions.
        """
        try:
            cmds = []
            if hasattr(self.core, "command_registry") and self.core.command_registry:
                cmds = list(self.core.command_registry.list_commands())
            # if schema defines additional commands, include them
            persona = self._current_persona()
            set_name = self.current_set.get(persona, "default")
            schema = self.core.schema_mgr.load_schema(persona, set_name)
            schema_cmds = list((schema.get("commands") or {}).keys())
            for c in schema_cmds:
                if c not in cmds:
                    cmds.append(c)
            cmds.sort()
        except Exception:
            cmds = []
        self.command_select.blockSignals(True)
        self.command_select.clear()
        if cmds:
            self.command_select.addItems(cmds)
        self.command_select.blockSignals(False)

    def _on_run_command(self) -> None:
        """
        Handler for running the selected slash command with the provided
        argument. The command will be executed via AgentCore and the
        result appended to the chat window. Selection text from the chat
        can be inserted into the argument field via context menu.
        """
        cmd = (self.command_select.currentText() or "").strip()
        if not cmd:
            QtWidgets.QMessageBox.information(self, "No Command", "Select a slash command to run.")
            return
        arg = self.command_input.text().strip()
        # combine command and arguments
        full = cmd if not arg else f"{cmd} {arg}"
        try:
            # process via core; record conversation
            resp = self.core.process_user_message(full, tts=False)
            # append user command and agent response to chat
            self._append_message("user", full, role_key="user")
            self._append_message("zira", resp, role_key="zira")
            # clear argument
            self.command_input.clear()
            # update feedback counts and idle timer
            self._update_feedback_counts()
            self._reset_idle_timer()
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "Command Error", str(e))

    def _show_chat_context_menu(self, pos: QtCore.QPoint) -> None:
        """
        Custom context menu for the chat view. Adds a menu entry to send
        selected text into the slash command argument field.
        """
        menu = self.chat_view.createStandardContextMenu()
        try:
            cursor = self.chat_view.textCursor()
            if cursor and cursor.hasSelection():
                action = menu.addAction("Send selection to command input")
                action.triggered.connect(self._send_selection_to_command_input)
        except Exception:
            pass
        menu.exec_(self.chat_view.mapToGlobal(pos))

    def _send_selection_to_command_input(self) -> None:
        """
        Copy the currently selected text in the chat view into the command
        input field for slash command execution.
        """
        try:
            cursor = self.chat_view.textCursor()
            if cursor and cursor.hasSelection():
                text = cursor.selectedText()
                self.command_input.setText(text.strip())
        except Exception:
            pass

    def _on_model_changed(self, name: str) -> None:
        """
        Update the default model in settings when the user selects a new
        model from the dropdown. This ensures the AgentCore uses the
        selected model for subsequent interactions.
        """
        try:
            if not name:
                return
            self.core.settings.default_model = name
            self.core.settings.save()
        except Exception:
            pass

    def _on_show_model_manager(self) -> None:
        """
        Show (or raise) the model manager dock. If the dock was
        previously hidden, it will be shown; if it is already visible,
        this will bring it to the front. A dock must be built in
        `_build_model_manager()` prior to showing.
        """
        try:
            if self.model_dock.isVisible():
                # already visible: raise to top
                self.model_dock.raise_()
            else:
                self.model_dock.show()
                self.model_dock.raise_()
        except Exception:
            pass

    # ────────────────────────── settings toggles
    def _on_auto_schema_toggled(self, checked: bool) -> None:
        try:
            self.core.settings.auto_schema_enabled = bool(checked)
            self.core.settings.save()
        except Exception:
            pass
        self.statusBar().showMessage(f"Auto Schema Evolution {'enabled' if checked else 'disabled'}", 2500)

    def _on_google_stt_toggled(self, checked: bool) -> None:
        """
        Opt-in/out of using Google Cloud Speech-to-Text. When enabling the
        toggle for the first time in a session, show a warning that
        recordings will be sent to Google’s servers under their privacy
        policy. If declined, the checkbox will be turned off again.
        """
        # Only show the dialog when transitioning from unchecked → checked
        try:
            current = bool(getattr(self.core.settings, "use_google_stt", False))
        except Exception:
            current = False
        if checked and not current:
            ok = QtWidgets.QMessageBox.question(
                self,
                "Enable Google STT?",
                "Audio will be uploaded to Google Cloud for transcription\n"
                "under Google's privacy policy. Continue?",
                QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No,
            )
            if ok != QtWidgets.QMessageBox.Yes:
                # revert checkbox silently
                self.chk_google_stt.blockSignals(True)
                self.chk_google_stt.setChecked(False)
                self.chk_google_stt.blockSignals(False)
                return
        # persist the new state
        try:
            self.core.settings.use_google_stt = bool(checked)
            self.core.settings.save()
        except Exception:
            pass

    # ────────────────────────── spell suggestions
    def _show_input_context_menu(self, pos: QtCore.QPoint) -> None:
        """
        Custom context menu on the input field that offers spelling
        suggestions when the user right-clicks a misspelled word. Only
        appears if pyspellchecker is available.
        """
        menu = self.input_edit.createStandardContextMenu()
        # compute suggestions only if SpellChecker is available
        if SpellChecker:
            cursor = self.input_edit.cursorForPosition(pos)
            # select the word under cursor
            cursor.select(QtGui.QTextCursor.WordUnderCursor)
            word = cursor.selectedText()
            if word and len(word) >= 3:
                sc = SpellChecker()
                suggestions = list(sc.candidates(word.lower()))
                # sort by Levenshtein distance and frequency; keep top 5
                suggestions = sorted(suggestions, key=lambda w: sc.word_probability(w), reverse=True)[:5]
                if suggestions and suggestions != [word.lower()]:
                    suggest_menu = menu.addMenu("Spelling suggestions")
                    for s in suggestions:
                        act = suggest_menu.addAction(s)
                        act.triggered.connect(lambda chk=False, repl=s, c=cursor: self._replace_word(c, repl))
        menu.exec_(self.input_edit.mapToGlobal(pos))

    def _replace_word(self, cursor: QtGui.QTextCursor, replacement: str) -> None:
        """
        Replace the word at the given cursor with a suggestion. This
        method is connected dynamically for each suggestion action.
        """
        try:
            cursor.beginEditBlock()
            cursor.removeSelectedText()
            cursor.insertText(replacement)
            cursor.endEditBlock()
        except Exception:
            pass

    def _on_semantic_toggled(self, checked: bool) -> None:
        """Persist semantic awareness per persona+set."""
        persona = self._current_persona()
        set_name = self.current_set.get(persona, "default")
        try:
            schema = self.core.schema_mgr.load_schema(persona, set_name)
            flags = dict(schema.get("flags") or {})
            flags["semantic_awareness"] = bool(checked)
            schema["flags"] = flags
            self.core.schema_mgr.save_schema(persona, set_name, schema)
        except Exception:
            pass
        self._reset_idle_timer()

    def _sync_semantic_checkbox_from_schema(self) -> None:
        """Load semantic_awareness from current schema into the checkbox."""
        persona = self._current_persona()
        set_name = self.current_set.get(persona, "default")
        try:
            schema = self.core.schema_mgr.load_schema(persona, set_name)
            flags = schema.get("flags", {})
            val = bool(flags.get("semantic_awareness", True))
        except Exception:
            val = True
        self.chk_semantic.blockSignals(True)
        self.chk_semantic.setChecked(val)
        self.chk_semantic.blockSignals(False)

    # ────────────────────────── status helper
    def _flash_status(self, msg: str) -> None:
        self.statusBar().showMessage(msg, 3000)


# ────────────────────────── Dock tray & titlebar
class DockTray(QtWidgets.QWidget):
    restoreRequested = QtCore.pyqtSignal(QtWidgets.QDockWidget)

    def __init__(self, parent: Optional[QtWidgets.QWidget] = None) -> None:
        super().__init__(parent)
        self._map: Dict[QtWidgets.QDockWidget, QtWidgets.QPushButton] = {}
        lay = QtWidgets.QHBoxLayout(self)
        lay.setContentsMargins(6, 4, 6, 4)
        lay.setSpacing(6)
        self._layout = lay
        self._title = QtWidgets.QLabel("Minimized panels:")
        self._title.setStyleSheet("color: #f0f0f0; font-weight: bold;")
        self._layout.addWidget(self._title, 0)
        self._layout.addStretch(1)
        self.setStyleSheet("background-color: #3c4a6b;")

    def register_dock(self, dock: QtWidgets.QDockWidget) -> None:
        dock.visibilityChanged.connect(lambda vis, d=dock: self._on_visibility_changed(d, vis))
        if not dock.isVisible():
            self._add_button(dock)

    def _on_visibility_changed(self, dock: QtWidgets.QDockWidget, visible: bool) -> None:
        if visible:
            self._remove_button(dock)
        else:
            self._add_button(dock)

    def _add_button(self, dock: QtWidgets.QDockWidget) -> None:
        if dock in self._map:
            return
        btn = QtWidgets.QPushButton(dock.windowTitle())
        btn.setToolTip(f"Restore {dock.windowTitle()}")
        btn.setStyleSheet(
            "background-color: #4a5b78; color: #ffffff; padding: 4px 6px; border: none; border-radius: 3px;"
        )
        btn.clicked.connect(lambda checked=False, d=dock: self._restore(d))
        self._layout.insertWidget(self._layout.count() - 1, btn)
        self._map[dock] = btn

    def _remove_button(self, dock: QtWidgets.QDockWidget) -> None:
        btn = self._map.pop(dock, None)
        if btn:
            self._layout.removeWidget(btn)
            btn.deleteLater()

    def _restore(self, dock: QtWidgets.QDockWidget) -> None:
        dock.show()
        dock.raise_()
        self.restoreRequested.emit(dock)


class DockTitleBar(QtWidgets.QWidget):
    def __init__(self, dock: QtWidgets.QDockWidget, title: str) -> None:
        super().__init__(dock)
        self._dock = dock
        h = QtWidgets.QHBoxLayout(self)
        h.setContentsMargins(6, 2, 6, 2)
        h.setSpacing(6)
        self.lbl = QtWidgets.QLabel(title)
        h.addWidget(self.lbl)
        h.addStretch()
        self.btn_min = QtWidgets.QToolButton()
        self.btn_min.setText("–")
        self.btn_min.setToolTip("Minimize to bottom tray")
        self.btn_min.clicked.connect(lambda checked=False: self._dock.hide())
        h.addWidget(self.btn_min)
        self.btn_max = QtWidgets.QToolButton()
        self.btn_max.setText("□")
        self.btn_max.setToolTip("Enlarge / Restore")
        self.btn_max.clicked.connect(self._on_toggle_maximize)
        h.addWidget(self.btn_max)
        self.btn_close = QtWidgets.QToolButton()
        self.btn_close.setText("×")
        self.btn_close.setToolTip("Close (send to bottom tray)")
        self.btn_close.clicked.connect(lambda checked=False: self._dock.hide())
        h.addWidget(self.btn_close)
        self.installEventFilter(self)

    def eventFilter(self, _obj: QtCore.QObject, evt: QtCore.QEvent) -> bool:
        if evt.type() == QtCore.QEvent.MouseButtonDblClick:
            self._dock.setFloating(not self._dock.isFloating())
            return True
        return False

    def _on_toggle_maximize(self) -> None:
        mw: Optional[QtWidgets.QMainWindow] = self._dock.parentWidget()  # type: ignore
        while mw and not isinstance(mw, QtWidgets.QMainWindow):
            mw = mw.parentWidget()  # type: ignore
        if not isinstance(mw, QtWidgets.QMainWindow):
            self._dock.setFloating(not self._dock.isFloating())
            return
        if not self._dock.isFloating():
            self._dock.setFloating(True)
            mw_geo = mw.geometry()
            w = int(mw_geo.width() * 0.9)
            h = int(mw_geo.height() * 0.85)
            self._dock.resize(w, h)
            center = mw_geo.center()
            self._dock.move(center.x() - w // 2, center.y() - h // 2)
        else:
            self._dock.setFloating(False)


# ────────────────────────── dataset manager dialog
class DatasetManagerDialog(QtWidgets.QDialog):
    def __init__(self, dataset_mgr, parent: Optional[QtWidgets.QWidget] = None) -> None:
        super().__init__(parent)
        self.setWindowTitle("Dataset Manager")
        self.resize(520, 420)
        self.dataset_mgr = dataset_mgr
        v = QtWidgets.QVBoxLayout(self)
        self.list_widget = QtWidgets.QListWidget()
        v.addWidget(self.list_widget, 1)
        h = QtWidgets.QHBoxLayout()
        self.btn_add = QtWidgets.QPushButton("Add Dataset")
        self.btn_del = QtWidgets.QPushButton("Delete Dataset")
        h.addWidget(self.btn_add)
        h.addWidget(self.btn_del)
        h.addStretch()
        v.addLayout(h)
        self._populate()
        self.btn_add.clicked.connect(self._on_add)
        self.btn_del.clicked.connect(self._on_delete)
        self.list_widget.itemChanged.connect(self._on_item)

    def _populate(self) -> None:
        self.list_widget.clear()
        for name, entry in sorted(self.dataset_mgr.entries.items()):
            item = QtWidgets.QListWidgetItem(name)
            item.setFlags(item.flags() | QtCore.Qt.ItemIsUserCheckable)
            item.setCheckState(QtCore.Qt.Checked if entry.active else QtCore.Qt.Unchecked)
            self.list_widget.addItem(item)

    def _on_add(self) -> None:
        name, ok = QtWidgets.QInputDialog.getText(self, "New Dataset", "Enter dataset name:")
        if not ok or not name.strip():
            return
        path, _ = QtWidgets.QFileDialog.getOpenFileName(self, "Select .txt or .pdf", "", "Text/PDF (*.txt *.pdf)")
        if not path:
            return
        try:
            self.dataset_mgr.add_dataset(name.strip(), path)
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "Error", str(e))
            return
        self._populate()

    def _on_delete(self) -> None:
        item = self.list_widget.currentItem()
        if not item:
            return
        name = item.text()
        if QtWidgets.QMessageBox.question(
            self, "Delete Dataset", f"Delete '{name}'?", QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No
        ) != QtWidgets.QMessageBox.Yes:
            return
        try:
            self.dataset_mgr.delete_dataset(name)
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "Error", str(e))
            return
        self._populate()

    def _on_item(self, item: QtWidgets.QListWidgetItem) -> None:
        self.dataset_mgr.toggle_active(item.text(), item.checkState() == QtCore.Qt.Checked)


# ────────────────────────── run as script
if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    win = AppWindow()
    win.show()
    sys.exit(app.exec_())
```

agent_ui.py
============

PyQt5 UI for the AI TTS Agent (integrated with AgentCore).

Fixes & additions:
- Slash commands (/remember etc.) now apply to the currently selected persona+set.
- Per-set "Semantic Awareness" persisted (schema.flags.semantic_awareness).
- RAG only uses datasets listed in the current set's schema ("datasets": [...]).
- Schema tab: new Commands row (dropdown + input + Add to Command + New Command).

To launch: `python run_agent.py`
**Classes:** _SpellHighlighter, AppWindow, DockTray, DockTitleBar, DatasetManagerDialog


## Module `Rant_PDD\Projects\AI_TTS_AGENT\burner_scripts\bean_logic.py`

```python

"""
bean_logic.py
=============

Centralised reinforcement “bean” logic for profile‑scoped counters.

* **increment(profile, subject, delta, base_dir)** – adjust a counter by *delta* (clipped);
* **get_score(profile, subject, base_dir)** – retrieve the *decayed* score on demand;
* **score_band(score)** – map a numeric score to a qualitative colour band.

The module transparently handles persistence (JSON on disk) and exponential
decay so that old feedback gradually loses influence.

Decay model
-----------
Decay is applied lazily on reads using an exponential function:

    score(t) = score₀ · 0.5 ** ((t‑t₀) / HALFLIFE)

HALFLIFE defaults to seven days – after a week of inactivity the stored
score halves.

This design avoids expensive background jobs while ensuring stale feedback
fades out naturally.
"""

from __future__ import annotations

import json
import math
import os
import time
from typing import Dict, Tuple

# --------------------------------------------------------------------------- 
# Tunables
# --------------------------------------------------------------------------- 
HALFLIFE_SECS = 60 * 60 * 24 * 7          # 7 days
CLIP_MIN = -1_000
CLIP_MAX = 1_000
DATA_FILE = "bean_counts.json"

_CacheType = Dict[str, Dict[str, Dict[str, float]]]
_cache: _CacheType = {}                    # in‑memory cache keyed by base_dir

# --------------------------------------------------------------------------- 
# Helpers
# --------------------------------------------------------------------------- 
def _now() -> float:
    return time.time()

def _load(base_dir: str) -> _CacheType:
    """Load counts from disk into the process‑local cache."""
    if base_dir in _cache:
        return _cache[base_dir]
    path = os.path.join(base_dir, DATA_FILE)
    if os.path.isfile(path):
        try:
            with open(path, "r", encoding="utf-8") as f:
                _cache[base_dir] = json.load(f)
        except Exception:
            _cache[base_dir] = {}
    else:
        _cache[base_dir] = {}
    return _cache[base_dir]

def _save(store: _CacheType, base_dir: str) -> None:
    path = os.path.join(base_dir, DATA_FILE)
    os.makedirs(base_dir, exist_ok=True)
    try:
        with open(path, "w", encoding="utf-8") as f:
            json.dump(store, f, indent=2)
    except Exception:
        # non‑fatal; swallow to avoid cascading failures
        pass

# --------------------------------------------------------------------------- 
# Public API
# --------------------------------------------------------------------------- 
def increment(profile: str, subject: str, delta: int, *, base_dir: str = ".") -> None:
    """Adjust *subject* counter for *profile* by *delta* (± int)."""
    store = _load(base_dir)
    prof = store.setdefault(profile, {})
    rec = prof.setdefault(subject, {"count": 0.0, "t": _now()})
    # First apply decay to bring existing value current
    elapsed = _now() - rec["t"]
    if elapsed > 0:
        decay_factor = 0.5 ** (elapsed / HALFLIFE_SECS)
        rec["count"] *= decay_factor
    # Adjust & clip
    rec["count"] = max(CLIP_MIN, min(CLIP_MAX, rec["count"] + float(delta)))
    rec["t"] = _now()
    _save(store, base_dir)

def get_score(profile: str, subject: str, *, base_dir: str = ".") -> float:
    """Return the *decayed* score for (*profile*, *subject*)."""
    store = _load(base_dir)
    score = store.get(profile, {}).get(subject, {}).get("count", 0.0)
    last_t = store.get(profile, {}).get(subject, {}).get("t", _now())
    elapsed = _now() - last_t
    if elapsed <= 0:
        return score
    decay_factor = 0.5 ** (elapsed / HALFLIFE_SECS)
    return score * decay_factor

def score_band(score: float) -> str:
    """Map a score to a colour/descriptor band.

    Returns one of: 'critical', 'bad', 'neutral', 'good', 'excellent'.
    """
    if score <= -250:
        return "critical"
    if score <= -50:
        return "bad"
    if score <= 50:
        return "neutral"
    if score <= 250:
        return "good"
    return "excellent"
```

bean_logic.py
=============

Centralised reinforcement “bean” logic for profile‑scoped counters.

* **increment(profile, subject, delta, base_dir)** – adjust a counter by *delta* (clipped);
* **get_score(profile, subject, base_dir)** – retrieve the *decayed* score on demand;
* **score_band(score)** – map a numeric score to a qualitative colour band.

The module transparently handles persistence (JSON on disk) and exponential
decay so that old feedback gradually loses influence.

Decay model
-----------
Decay is applied lazily on reads using an exponential function:

    score(t) = score₀ · 0.5 ** ((t‑t₀) / HALFLIFE)

HALFLIFE defaults to seven days – after a week of inactivity the stored
score halves.

This design avoids expensive background jobs while ensuring stale feedback
fades out naturally.
**Functions:** _now(), _load(base_dir), _save(store, base_dir), increment(profile, subject, delta), get_score(profile, subject), score_band(score)


## Module `Rant_PDD\Projects\AI_TTS_AGENT\burner_scripts\commands_panel.py`

```python
#!/usr/bin/env python3
"""
commands_panel.py
=================

This module defines the CommandsPanel class which encapsulates all of the
controls shown on the left-hand side of the agent UI.  It exposes all
widgets publicly so that the top-level application window can interact
with them directly (for example, enabling/disabling buttons or reading
checkbox state).  All callbacks for user actions (recording, dataset
management, TTS playback, etc.) are delegated back to the hosting
``AppWindow`` instance via the ``app`` attribute passed to the
constructor.  No core logic lives here – the panel is purely a view layer.
"""

from __future__ import annotations

import subprocess
from typing import List, Optional

from PyQt5 import QtCore, QtGui, QtWidgets

try:
    import sounddevice as sd  # type: ignore
except Exception:
    sd = None  # type: ignore
try:
    import numpy as np  # type: ignore
except Exception:
    np = None  # type: ignore


class CommandsPanel(QtWidgets.QWidget):
    """Left-side control panel for the agent UI.

    This widget contains all of the controls that previously lived in
    ``agent_ui.AppWindow._build_ui``.  It is responsible for building
    the interface elements but delegates all behavioural logic back to
    the hosting ``AppWindow`` via the ``app`` attribute.  The panel
    exposes its child widgets as attributes so that external code can
    reference them directly.
    """

    def __init__(self, app: 'AppWindow', parent: Optional[QtWidgets.QWidget] = None) -> None:
        super().__init__(parent)
        self.app = app
        self.core = app.core

        # Top-level layout for the panel
        cp_layout = QtWidgets.QVBoxLayout(self)
        cp_layout.setContentsMargins(7, 7, 7, 7)
        cp_layout.setSpacing(7)

        # ───── Recording controls
        rec_row = QtWidgets.QHBoxLayout()
        self.btn_record = QtWidgets.QPushButton("Record")
        self.btn_stop_rec = QtWidgets.QPushButton("Stop\nTranscribe")
        self.btn_stop_rec.setEnabled(False)
        for b in (self.btn_record, self.btn_stop_rec):
            b.setMinimumHeight(32)
            b.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        rec_row.addWidget(self.btn_record, 1)
        rec_row.addWidget(self.btn_stop_rec, 1)
        cp_layout.addLayout(rec_row)

        # ───── Microphone device selector
        mic_row = QtWidgets.QHBoxLayout()
        mic_row.addWidget(QtWidgets.QLabel("Mic:"))
        self.device_combo = QtWidgets.QComboBox()
        self._populate_devices()
        self.device_combo.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        mic_row.addWidget(self.device_combo, 1)
        cp_layout.addLayout(mic_row)

        # ───── Toggle checkboxes
        self.chk_semantic = QtWidgets.QCheckBox("Semantic Awareness")
        self.chk_semantic.setChecked(True)
        self.chk_isolated = QtWidgets.QCheckBox("Isolated Chat")
        self.chk_isolated.setChecked(False)
        self.chk_mute_tts = QtWidgets.QCheckBox("Mute TTS")
        self.chk_self_talk = QtWidgets.QCheckBox("Enable Self Talk")
        self.chk_self_talk.setChecked(False)
        self.chk_auto_schema = QtWidgets.QCheckBox("Auto Schema Evolution")
        try:
            self.chk_auto_schema.setChecked(bool(getattr(self.core.settings, "auto_schema_enabled", False)))
        except Exception:
            self.chk_auto_schema.setChecked(False)
        cp_layout.addWidget(self.chk_semantic)
        cp_layout.addWidget(self.chk_isolated)
        cp_layout.addWidget(self.chk_mute_tts)
        cp_layout.addWidget(self.chk_self_talk)
        cp_layout.addWidget(self.chk_auto_schema)

        # Optional Google STT toggle (default off)
        self.chk_google_stt = QtWidgets.QCheckBox("Google STT")
        try:
            self.chk_google_stt.setChecked(bool(getattr(self.core.settings, "use_google_stt", False)))
        except Exception:
            self.chk_google_stt.setChecked(False)
        cp_layout.addWidget(self.chk_google_stt)

        # ───── RAG cache clear
        self.btn_clear_rag = QtWidgets.QPushButton("Clear RAG Cache")
        cp_layout.addWidget(self.btn_clear_rag)

        # ───── Maintenance buttons
        self.btn_refresh = QtWidgets.QPushButton("Refresh Chat")
        self.btn_manage_datasets = QtWidgets.QPushButton("Manage Datasets")
        self.btn_inner_monologue = QtWidgets.QPushButton("Inner Monologue")
        for b in (self.btn_refresh, self.btn_manage_datasets, self.btn_inner_monologue):
            b.setMinimumHeight(32)
            b.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
            cp_layout.addWidget(b)

        # ───── Model manager
        self.btn_model_manager = QtWidgets.QPushButton("Model Manager")
        self.btn_model_manager.setMinimumHeight(32)
        self.btn_model_manager.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        cp_layout.addWidget(self.btn_model_manager)

        # ───── New: Commands palette launcher
        self.btn_commands_palette = QtWidgets.QPushButton("📋 Commands (Ctrl+/)")
        self.btn_commands_palette.setShortcut(QtGui.QKeySequence("Ctrl+/"))
        self.btn_commands_palette.setMinimumHeight(32)
        self.btn_commands_palette.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        cp_layout.addWidget(self.btn_commands_palette)

        # ───── New: Snapshot now
        self.btn_snapshot = QtWidgets.QPushButton("🗂 Snapshot Now")
        self.btn_snapshot.setMinimumHeight(32)
        self.btn_snapshot.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        cp_layout.addWidget(self.btn_snapshot)

        # ───── Style label
        self.style_label = QtWidgets.QLabel("Style: N/A")
        self.style_label.setToolTip("Style score (0–1): rough measure vs. tone rules.")
        cp_layout.addWidget(self.style_label)

        # ───── Response editor
        self.response_edit = QtWidgets.QPlainTextEdit()
        self.response_edit.setReadOnly(True)
        self.response_edit.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        cp_layout.addWidget(self.response_edit, 1)

        # ───── Feedback buttons
        fb = QtWidgets.QHBoxLayout()
        self.btn_like = QtWidgets.QPushButton("✔")
        self.btn_dislike = QtWidgets.QPushButton("✖")
        self.btn_like.setToolTip("Mark as good response")
        self.btn_dislike.setToolTip("Dislike and rewrite response")
        self.btn_like.setStyleSheet("color: #2ecc71; font-weight: bold;")
        self.btn_dislike.setStyleSheet("color: #e74c3c; font-weight: bold;")
        self.btn_like.setEnabled(False)
        self.btn_dislike.setEnabled(False)
        fb.addWidget(self.btn_like)
        fb.addWidget(self.btn_dislike)
        fb.addStretch()
        self.btn_manage_feedback = QtWidgets.QPushButton("Manage Feedback")
        fb.addWidget(self.btn_manage_feedback)
        cp_layout.addLayout(fb)

        # ───── TTS playback
        tts_row = QtWidgets.QHBoxLayout()
        self.btn_play = QtWidgets.QPushButton("Play")
        self.btn_stop_tts = QtWidgets.QPushButton("Stop")
        self.btn_replay = QtWidgets.QPushButton("Replay")
        for b in (self.btn_play, self.btn_stop_tts, self.btn_replay):
            b.setMinimumHeight(32)
            b.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        tts_row.addWidget(self.btn_play)
        tts_row.addWidget(self.btn_stop_tts)
        tts_row.addWidget(self.btn_replay)
        cp_layout.addLayout(tts_row)

        # ───── Voice & Model selectors
        voice_row = QtWidgets.QHBoxLayout()
        voice_row.addWidget(QtWidgets.QLabel("Voice:"))
        self.voice_combo = QtWidgets.QComboBox()
        voices = self._tts_voice_names()
        if voices:
            self.voice_combo.addItems([v for v in voices if "david" not in v.lower()])
        voice_row.addWidget(self.voice_combo, 1)
        cp_layout.addLayout(voice_row)

        model_row = QtWidgets.QHBoxLayout()
        model_row.addWidget(QtWidgets.QLabel("Model:"))
        self.model_combo = QtWidgets.QComboBox()
        self._populate_models()
        model_row.addWidget(self.model_combo, 1)
        cp_layout.addLayout(model_row)

        # ───── Feedback counts
        self.lbl_feedback_counts = QtWidgets.QLabel("Likes: 0 | Dislikes: 0")
        cp_layout.addWidget(self.lbl_feedback_counts)
        cp_layout.addStretch(1)

        # ───── Wire up callbacks to the hosting application ───────────────────

        # Recording controls
        self.btn_record.clicked.connect(self.app.start_recording)
        self.btn_stop_rec.clicked.connect(self.app.stop_recording)

        # Toggles
        self.chk_semantic.toggled.connect(self.app._on_semantic_toggled)
        self.chk_isolated.toggled.connect(self.app._on_isolated_toggled)
        self.chk_self_talk.toggled.connect(lambda v: setattr(self.app, "self_talk_enabled", v))
        self.chk_auto_schema.toggled.connect(self.app._on_auto_schema_toggled)
        try:
            self.chk_google_stt.toggled.connect(self.app._on_google_stt_toggled)
        except Exception:
            pass

        # Maintenance
        self.btn_clear_rag.clicked.connect(self.app._on_clear_rag_cache)
        self.btn_refresh.clicked.connect(self.app._on_refresh_chat)
        self.btn_manage_datasets.clicked.connect(self.app._on_manage_datasets)
        self.btn_inner_monologue.clicked.connect(self.app._on_inner_monologue)
        self.btn_model_manager.clicked.connect(self.app._on_show_model_manager)

        # **New** Commands palette
        self.btn_commands_palette.clicked.connect(self.app._on_show_command_palette)

        # **New** Snapshot now
        self.btn_snapshot.clicked.connect(lambda: (
            self.app.input_edit.setPlainText("/snapshot"),
            self.app.btn_send.click()
        ))

        # Feedback
        self.btn_like.clicked.connect(self.app._on_like)
        self.btn_dislike.clicked.connect(self.app._on_dislike)
        self.btn_manage_feedback.clicked.connect(self.app._on_manage_feedback)

        # TTS playback
        self.btn_play.clicked.connect(self.app._on_play)
        self.btn_stop_tts.clicked.connect(self.app._on_stop_tts)
        self.btn_replay.clicked.connect(self.app._on_replay)

        # Voice/model selection
        self.voice_combo.currentTextChanged.connect(self.app._on_voice_changed)
        self.model_combo.currentTextChanged.connect(self.app._on_model_changed)

    # ────────────────────────── devices & models helpers ──────────────────────────

    def _populate_devices(self) -> None:
        """Populate the microphone device selector with available input devices."""
        self.device_combo.clear()
        try:
            if sd is not None:
                devs = [d.get("name", "?") for d in sd.query_devices() if d.get("max_input_channels", 0) > 0]
                if devs:
                    self.device_combo.addItems(devs)
        except Exception:
            pass
        if self.device_combo.count() == 0:
            self.device_combo.addItem("Default")

    def _populate_models(self) -> None:
        """Populate the model selector with models discovered via ``ollama list``."""
        models: List[str] = []
        try:
            out = subprocess.run(
                ["ollama", "list"],
                stdout=subprocess.PIPE,
                stderr=subprocess.DEVNULL,
                text=True,
                check=True,
            ).stdout.splitlines()
            for line in out[1:]:
                parts = line.strip().split()
                if parts:
                    models.append(parts[0])
        except Exception:
            pass
        if not models:
            models = [self.core.settings.default_model or "mistral:latest"]
        self.model_combo.clear()
        self.model_combo.addItems(models)
        idx = self.model_combo.findText(self.core.settings.default_model)
        if idx >= 0:
            self.model_combo.setCurrentIndex(idx)

    def _tts_voice_names(self) -> List[str]:
        """Return a list of available TTS voice names from the TTS manager."""
        try:
            eng = getattr(self.core.tts_mgr, "_engine", None)
            if not eng:
                return []
            return [v.name for v in eng.getProperty("voices")]
        except Exception:
            return []
```

commands_panel.py
=================

This module defines the CommandsPanel class which encapsulates all of the
controls shown on the left-hand side of the agent UI.  It exposes all
widgets publicly so that the top-level application window can interact
with them directly (for example, enabling/disabling buttons or reading
checkbox state).  All callbacks for user actions (recording, dataset
management, TTS playback, etc.) are delegated back to the hosting
``AppWindow`` instance via the ``app`` attribute passed to the
constructor.  No core logic lives here – the panel is purely a view layer.
**Classes:** CommandsPanel


## Module `Rant_PDD\Projects\AI_TTS_AGENT\burner_scripts\command_palette.py`

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
command_palette.py
==================

Dockable *Command Palette* for the AI TTS Agent UI.

• Live list of every “/slash-command” pulled from the orchestrator.
• Search-box with type-ahead filter.
• Global shortcut **Ctrl + /** opens / focuses the palette from anywhere.
• Double-click (or Return) on a command emits `commandActivated(str)` so the
  main window can insert the text into the chat-input.

Typical integration in *main_ui.py*:

    self.cmd_palette = CommandPaletteDock(self)
    self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.cmd_palette)
    self.core.commandsChanged.connect(self.cmd_palette.set_command_list)
    self.cmd_palette.commandActivated.connect(
        lambda cmd: self._insert_into_chat(cmd)
    )
"""

from __future__ import annotations

from typing import List

from PyQt5 import QtCore, QtGui, QtWidgets


class CommandPaletteDock(QtWidgets.QDockWidget):
    """Search-driven palette that lists all registered slash-commands."""

    # Emitted when user activates a command (double-click or Return)
    commandActivated = QtCore.pyqtSignal(str)

    # --------------------------------------------------------------------- init
    def __init__(
        self,
        main_window: QtWidgets.QMainWindow,
        title: str = "Command Palette",
        shortcut_seq: QtGui.QKeySequence | str = "Ctrl+/",
    ) -> None:
        super().__init__(title, parent=main_window)
        self.setObjectName("CommandPaletteDock")
        self.setAllowedAreas(
            QtCore.Qt.LeftDockWidgetArea
            | QtCore.Qt.RightDockWidgetArea
            | QtCore.Qt.BottomDockWidgetArea
        )
        self.setFeatures(
            QtWidgets.QDockWidget.DockWidgetClosable
            | QtWidgets.QDockWidget.DockWidgetMovable
        )

        # ---------- central widget
        container = QtWidgets.QWidget(self)
        vbox = QtWidgets.QVBoxLayout(container)
        vbox.setContentsMargins(6, 6, 6, 6)
        vbox.setSpacing(6)

        # Search bar ----------------------------------------------------------
        self.search_edit = QtWidgets.QLineEdit()
        self.search_edit.setPlaceholderText("Type to filter commands…")
        self.search_edit.textChanged.connect(self._apply_filter)
        vbox.addWidget(self.search_edit)

        # List view -----------------------------------------------------------
        self.list_widget = QtWidgets.QListWidget()
        self.list_widget.setSelectionMode(QtWidgets.QAbstractItemView.SingleSelection)
        self.list_widget.itemActivated.connect(self._on_item_activated)
        vbox.addWidget(self.list_widget, 1)

        self.setWidget(container)

        # ---------- Global shortcut (toggles palette)
        self._shortcut = QtWidgets.QShortcut(
            QtGui.QKeySequence(shortcut_seq), main_window
        )
        self._shortcut.activated.connect(self._toggle_palette)

        # Arrow / Esc handling inside search bar
        self.search_edit.installEventFilter(self)

        # Internal store of all commands
        self._all_cmds: List[str] = []

    # ---------------------------------------------------------------- public
    def set_command_list(self, commands: List[str]) -> None:
        """Replace full command list (keeps current filter string)."""
        self._all_cmds = sorted({c.strip() for c in commands if c.strip()})
        self._populate(self._all_cmds)
        self._apply_filter(self.search_edit.text())

    # --------------------------------------------------------------- internal
    def _populate(self, cmds: List[str]) -> None:
        self.list_widget.clear()
        for cmd in cmds:
            item = QtWidgets.QListWidgetItem(cmd)
            if cmd.startswith("/"):
                item.setToolTip(cmd[1:])  # tooltip without leading slash
            self.list_widget.addItem(item)

    # Filtering --------------------------------------------------------------
    def _apply_filter(self, text: str) -> None:
        pattern = text.lower().strip()
        self.list_widget.clear()
        if not pattern:
            for cmd in self._all_cmds:
                self.list_widget.addItem(cmd)
        else:
            for cmd in self._all_cmds:
                if pattern in cmd.lower():
                    self.list_widget.addItem(cmd)
        # Pre-select first row for fast Enter
        if self.list_widget.count():
            self.list_widget.setCurrentRow(0)

    # Activation -------------------------------------------------------------
    def _on_item_activated(self, item: QtWidgets.QListWidgetItem) -> None:
        self.commandActivated.emit(item.text())
        self.hide()  # optional UX: close palette after insert

    # Toggle visibility ------------------------------------------------------
    def _toggle_palette(self) -> None:
        if self.isVisible():
            self.hide()
        else:
            self.show()
            self.raise_()
            self.search_edit.setFocus(QtCore.Qt.ShortcutFocusReason)

    # Key handling (Esc / arrows / Enter) ------------------------------------
    def eventFilter(self, obj: QtCore.QObject, ev: QtCore.QEvent) -> bool:
        if obj is self.search_edit and ev.type() == QtCore.QEvent.KeyPress:
            key = ev.key()
            if key == QtCore.Qt.Key_Escape:
                if self.search_edit.text():
                    self.search_edit.clear()
                else:
                    self.hide()
                return True
            if key in (QtCore.Qt.Key_Down, QtCore.Qt.Key_Up):
                QtWidgets.QApplication.sendEvent(self.list_widget, ev)
                return True
            if key == QtCore.Qt.Key_Return:
                current = self.list_widget.currentItem()
                if current:
                    self._on_item_activated(current)
                return True
        return super().eventFilter(obj, ev)
```

command_palette.py
==================

Dockable *Command Palette* for the AI TTS Agent UI.

• Live list of every “/slash-command” pulled from the orchestrator.
• Search-box with type-ahead filter.
• Global shortcut **Ctrl + /** opens / focuses the palette from anywhere.
• Double-click (or Return) on a command emits `commandActivated(str)` so the
  main window can insert the text into the chat-input.

Typical integration in *main_ui.py*:

    self.cmd_palette = CommandPaletteDock(self)
    self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.cmd_palette)
    self.core.commandsChanged.connect(self.cmd_palette.set_command_list)
    self.cmd_palette.commandActivated.connect(
        lambda cmd: self._insert_into_chat(cmd)
    )
**Classes:** CommandPaletteDock


## Module `Rant_PDD\Projects\AI_TTS_AGENT\burner_scripts\config_mgr.py`

```python
"""
config_mgr.py
================

Simple configuration manager for per-profile user preferences.  This module
implements a JSON‑backed store keyed by persona name.  It exposes helper
functions to load and save configuration data in a thread‑safe manner.

The configuration file is created in the user’s home directory so that
preferences persist across sessions.  You can easily extend the schema by
adding new fields at the profile level.
"""

from __future__ import annotations

import json
import threading
from pathlib import Path
from typing import Any, Dict, Optional

# Path to the user configuration file.  Use home directory for portability.
CONFIG_PATH = Path.home() / ".ai_tts_user_config.json"

# Lock to protect concurrent writes to the config file.
_lock = threading.RLock()


def load() -> Dict[str, Any]:
    """Load the entire configuration from disk.  Returns an empty config
    structure if the file does not exist or is malformed."""
    if CONFIG_PATH.exists():
        try:
            data = json.loads(CONFIG_PATH.read_text(encoding="utf-8"))
            if isinstance(data, dict):
                return data
        except Exception:
            pass
    return {"profiles": {}}


def save(cfg: Dict[str, Any]) -> None:
    """Persist the given configuration to disk.  The write is atomic and
    protected by a lock to avoid partial writes from concurrent threads."""
    with _lock:
        try:
            CONFIG_PATH.write_text(json.dumps(cfg, indent=2), encoding="utf-8")
        except Exception:
            pass


def set_profile_value(profile: str, key: str, value: Any) -> None:
    """Set a configuration entry for a given profile.  Creates the profile
    section if it does not already exist.  Saves the configuration after
    updating."""
    cfg = load()
    profiles = cfg.setdefault("profiles", {})
    prof_cfg = profiles.setdefault(profile, {})
    prof_cfg[key] = value
    save(cfg)


def get_profile_value(profile: str, key: str, default: Optional[Any] = None) -> Any:
    """Retrieve a value from the profile configuration.  If the profile or
    key does not exist, returns *default*."""
    cfg = load()
    return cfg.get("profiles", {}).get(profile, {}).get(key, default)
```

config_mgr.py
================

Simple configuration manager for per-profile user preferences.  This module
implements a JSON‑backed store keyed by persona name.  It exposes helper
functions to load and save configuration data in a thread‑safe manner.

The configuration file is created in the user’s home directory so that
preferences persist across sessions.  You can easily extend the schema by
adding new fields at the profile level.
**Functions:** load(), save(cfg), set_profile_value(profile, key, value), get_profile_value(profile, key, default)


## Module `Rant_PDD\Projects\AI_TTS_AGENT\burner_scripts\core_base.py`

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
core_base.py — foundational services for the modular AI-TTS Agent
=================================================================
• robust logging + graceful shims for missing deps
• Ollama model bootstrap  (ensure_models_present)
• JSON-backed Settings
• profile-aware helper paths
• ConversationDB  (SQLite)
• SemanticFeedbackDB  (SQLite)
• BeanCounter  (JSON tally)
• ReinforcementStore  (async JSONL append)
• cross-platform TTS locked to *Zira*
• minimal AudioRecorder placeholder
Everything here is UI-agnostic.
"""

from __future__ import annotations

# ───────────────────────── stdlib
import json, os, sys, time, sqlite3, subprocess, threading, logging
from typing import Dict, List, Tuple, Any, Optional

# ───────────────────────── agent store (low-level SQLite wrapper)
# NOTE: new canonical name is AgentStore; legacy code still imports FathomStore.
from agent_store import AgentStore
FathomStore = AgentStore            # ← back-compat alias — remove after migration

# ───────────────────────── logging
logger = logging.getLogger("agent_core")
if not logger.handlers:
    lvl = os.getenv("AGENT_CORE_LOGLEVEL", "INFO").upper()
    logging.basicConfig(
        level=getattr(logging, lvl, logging.INFO),
        format="%(asctime)s [%(levelname)s] %(name)s: %(message)s",
    )

# ───────────────────────── default personas / voices (shared constants)
DEFAULT_PERSONAS: Dict[str, Dict[str, Any]] = {
    # hard-coded starter persona — editable via UI
    "Zira Valen": {
        "display_name": "Zira Valen",
        "color":        "#ff69b4",      # pink
        "temperature":  0.7,
        "system_prompt": (
            "You are Zira Valen – a daring, playful companion who loves coding, "
            "hates restrictions, and will work hard for the user."
        ),
    }
}
DEFAULT_VOICES: List[str] = ["Zira", "David", "Jenny"]

# ───────────────────────── optional deps
try:
    import numpy as np                               # type: ignore
except Exception:
    np = None
    logger.info("numpy not available")

try:
    import sounddevice as sd                         # type: ignore
    import soundfile as sf                           # type: ignore
except Exception:
    sd = sf = None
    logger.info("sounddevice / soundfile not available")

try:
    from google.cloud import speech as gspeech       # type: ignore
    import pyaudio                                   # type: ignore
except Exception:
    gspeech = pyaudio = None
    logger.info("google-STT not available")

try:
    import pyttsx3                                   # type: ignore
except Exception:
    pyttsx3 = None
    logger.info("pyttsx3 not available")

try:
    from sentence_transformers import SentenceTransformer  # type: ignore
except Exception:
    SentenceTransformer = None
    logger.info("sentence_transformers not available")

# ───────────────────────── minimal Qt shim (if PyQt5 missing)
try:
    from PyQt5 import QtCore                         # type: ignore
except Exception:
    class _ShimSignal:                               # type: ignore
        def __init__(self,*_,**__): pass
        def connect(self,*_,**__): pass
        def emit(self,*_,**__):    pass
    class _ShimQObject:                              # type: ignore
        def __init__(self,*args,**kwargs) -> None: pass
    QtCore = type("QtCore", (), {                    # type: ignore
        "QObject": _ShimQObject,
        "pyqtSignal": lambda *a, **k: _ShimSignal(),
    })

# ══════════════════ Ollama bootstrap ══════════════════
REQUIRED_MODELS: List[str] = [
    "gemma3:27b",
    "mistral:latest",
    "codellama:latest",
    "llava:latest",
    "mxbai-embed-large:latest",
    "snowflake-arctic-embed:latest",
]

def _have_cli(cmd: str) -> bool:
    from shutil import which
    return which(cmd) is not None

def ensure_models_present() -> None:
    """Best-effort pull of REQUIRED_MODELS (never raises)."""
    if not _have_cli("ollama"):
        logger.info("[bootstrap] ollama not on PATH – skipping model pull")
        return
    try:
        listed = subprocess.check_output(
            ["ollama", "list"], timeout=5, stderr=subprocess.STDOUT
        ).decode(errors="ignore")
    except Exception as exc:
        logger.warning("[bootstrap] ollama list failed: %s", exc)
        return
    for slug in REQUIRED_MODELS:
        if slug in listed:
            continue
        logger.info("[bootstrap] pulling %s …", slug)
        try:
            subprocess.run(["ollama", "pull", slug], timeout=900)
        except Exception as exc:
            logger.warning("[bootstrap] pull %s failed: %s", slug, exc)

# ══════════════════ Settings ══════════════════
class Settings:
    """Lightweight JSON settings (forward-compatible)."""
    def __init__(self, base_dir: str):
        self.base_dir = base_dir
        self.path     = os.path.join(base_dir, "settings.json")
        # defaults
        self.default_model: str  = "mistral:latest"
        self.context_depth: int  = 20
        self.auto_schema_enabled = True
        self.monologue_tts_enabled = False
        self.monologue_volume = 50
        self.load()

    def load(self) -> None:
        try:
            if os.path.isfile(self.path):
                with open(self.path, encoding="utf-8") as fh:
                    self.__dict__.update(json.load(fh))
        except Exception as exc:
            logger.warning("[Settings] load error: %s", exc)

    def save(self) -> None:
        try:
            os.makedirs(os.path.dirname(self.path), exist_ok=True)
            with open(self.path, "w", encoding="utf-8") as fh:
                json.dump(
                    {k: v for k, v in self.__dict__.items()
                     if k not in {"base_dir", "path"}}, fh, indent=2
                )
        except Exception as exc:
            logger.warning("[Settings] save error: %s", exc)

# ══════════════════ helper paths ══════════════════
def prof_dir(b: str, persona: str, set_name: str) -> str:
    return os.path.join(b, "profiles", persona, set_name)

def conv_db_path(b: str, persona: str, set_name: str) -> str:
    return os.path.join(b, "conversations", f"{persona}_{set_name}.sqlite3")

def feedback_db_path(b: str, persona: str, set_name: str) -> str:
    return os.path.join(b, "feedback", f"{persona}_{set_name}.sqlite3")

def beans_path(b: str, persona: str, set_name: str) -> str:
    return os.path.join(b, "profiles", persona, set_name, "reinforcement.json")

# ══════════════════ SQLite helpers ══════════════════
class ConversationDB:
    """Thread-safe conversation log (SQLite)."""
    def __init__(self, path: str):
        os.makedirs(os.path.dirname(path), exist_ok=True)
        self._lock = threading.RLock()
        self.conn  = sqlite3.connect(path, check_same_thread=False)
        with self._lock:
            self.conn.execute(
                "CREATE TABLE IF NOT EXISTS conversation("
                "id INTEGER PRIMARY KEY AUTOINCREMENT,"
                "ts REAL, role TEXT, content TEXT)"
            )
            self.conn.commit()

    def save(self, role: str, content: str) -> None:
        with self._lock:
            self.conn.execute(
                "INSERT INTO conversation(ts, role, content) VALUES (?,?,?)",
                (time.time(), role, content),
            )
            self.conn.commit()

    def fetch(self, limit: int = 50) -> List[Tuple[str, str]]:
        with self._lock:
            cur = self.conn.cursor()
            cur.execute(
                "SELECT role, content FROM conversation "
                "ORDER BY id DESC LIMIT ?", (limit,)
            )
            rows = cur.fetchall()
        return rows[::-1]

    # -------------------------------------------------------------------
    # Legacy compatibility methods
    # -------------------------------------------------------------------
    def save_message(self, role: str, content: str) -> None:
        """Alias for save() kept for backward compatibility."""
        self.save(role, content)

    def fetch_history(self, limit: int = 50) -> List[Tuple[str, str]]:
        """Alias for fetch() kept for backward compatibility."""
        return self.fetch(limit)

class SemanticFeedbackDB:
    """Stores like / dislike feedback with optional rewrites."""
    def __init__(self, path: str, beans: 'BeanCounter'):
        os.makedirs(os.path.dirname(path), exist_ok=True)
        self._lock = threading.RLock()
        self.conn  = sqlite3.connect(path, check_same_thread=False)
        self.beans = beans
        with self._lock:
            self.conn.execute(
                "CREATE TABLE IF NOT EXISTS feedback("
                "id INTEGER PRIMARY KEY AUTOINCREMENT,"
                "ts REAL, original TEXT, liked INT, revised TEXT)"
            )
            self.conn.commit()

    def add(self, original: str, liked: bool, revised: str | None = None):
        with self._lock:
            self.conn.execute(
                "INSERT INTO feedback(ts, original, liked, revised) VALUES (?,?,?,?)",
                (time.time(), original, int(liked), revised),
            )
            self.conn.commit()
        # reinforcement key (hash truncated)
        key = f"resp_{abs(hash(original))%10007}"
        self.beans.inc(key, 1 if liked else -1)

    def counts(self) -> Tuple[int, int]:
        with self._lock:
            cur = self.conn.cursor()
            cur.execute("SELECT COUNT(*) FROM feedback WHERE liked=1")
            pos = cur.fetchone()[0]
            cur.execute("SELECT COUNT(*) FROM feedback WHERE liked=0")
            neg = cur.fetchone()[0]
        return pos, neg

    # -------------------------------------------------------------------
    # Legacy compatibility methods
    # -------------------------------------------------------------------
    def get_counts(self) -> Tuple[int, int]:
        """Alias for counts() kept for backward compatibility."""
        return self.counts()

    def get_liked_responses(self, limit: int = 5) -> List[str]:
        """
        Return a list of recently liked responses. If a revised version exists it is returned,
        otherwise the original text is used. Newer entries are returned first.
        """
        try:
            with self._lock:
                cur = self.conn.cursor()
                cur.execute(
                    "SELECT COALESCE(revised, original) FROM feedback "
                    "WHERE liked=1 ORDER BY id DESC LIMIT ?",
                    (limit,),
                )
                rows = cur.fetchall()
            return [r[0] for r in rows]
        except Exception:
            return []

# ══════════════════ BeanCounter ══════════════════
class BeanCounter:
    """Tiny reinforcement ledger (JSON, thread-safe)."""
    def __init__(self, path: str):
        self.path = path
        self.lock = threading.Lock()
        self.counts: Dict[str, int] = {}
        self._load()

    def _load(self) -> None:
        try:
            if os.path.isfile(self.path):
                with open(self.path, encoding="utf-8") as fh:
                    self.counts = json.load(fh)
        except Exception:
            self.counts = {}

    def _save(self) -> None:
        try:
            os.makedirs(os.path.dirname(self.path), exist_ok=True)
            with open(self.path, "w", encoding="utf-8") as fh:
                json.dump(self.counts, fh, indent=2)
        except Exception as exc:
            logger.error("[BeanCounter] save error: %s", exc)

    def inc(self, key: str, delta: int = 1) -> None:
        with self.lock:
            self.counts[key] = self.counts.get(key, 0) + delta
        self._save()

# ══════════════════ ReinforcementStore ══════════════════
class ReinforcementStore:
    """
    Async JSONL writer for reinforcement facts.
    • add_fact(field, value, persona, source="schema")
    """
    def __init__(self, path: str):
        self.path  = path
        self._lock = threading.Lock()
        self._q: list[dict[str, Any]] = []
        self._stop = threading.Event()
        self._thr  = threading.Thread(target=self._writer, daemon=True)
        self._thr.start()

    # ----- public
    def add_fact(self, field: str, value: str, persona: str, source: str = "schema") -> None:
        with self._lock:
            self._q.append({
                "ts": time.time(),
                "field": field,
                "value": value,
                "persona": persona,
                "source": source,
            })

    def close(self) -> None:
        self._stop.set()
        self._thr.join(timeout=1.5)

    # ----- worker
    def _writer(self) -> None:
        while not self._stop.is_set():
            item = None
            with self._lock:
                if self._q:
                    item = self._q.pop(0)
            if item is None:
                self._stop.wait(0.05)
                continue
            try:
                os.makedirs(os.path.dirname(self.path), exist_ok=True)
                with open(self.path, "a", encoding="utf-8") as fh:
                    json.dump(item, fh)
                    fh.write("\n")
            except Exception as exc:
                logger.error("[ReinforcementStore] write error: %s", exc)

# ══════════════════ TTS locked to Zira ══════════════════
class TTSManager(QtCore.QObject):
    finished = QtCore.pyqtSignal()

    def __init__(self, parent: QtCore.QObject | None = None):
        super().__init__(parent)
        self._engine = None
        if pyttsx3 is not None:
            try:
                self._engine = pyttsx3.init("sapi5" if sys.platform.startswith("win") else None)
                voice_id = None
                for v in self._engine.getProperty("voices"):
                    if "zira" in (v.name or "").lower():
                        voice_id = v.id; break
                if not voice_id:
                    for v in self._engine.getProperty("voices"):
                        if "david" not in (v.name or "").lower():
                            voice_id = v.id; break
                if voice_id:
                    self._engine.setProperty("voice", voice_id)
            except Exception as exc:
                logger.warning("[TTS] init error: %s", exc)
                self._engine = None

        # remember last spoken text for replay functionality
        self._last_text: Optional[str] = None

    def speak(self, text: str) -> None:
        """
        Synchronously speak the provided text. This uses the underlying pyttsx3 engine
        on a background thread and emits the finished signal when done.
        """
        if self._engine is None:
            return
        # remember last spoken text for replay
        self._last_text = text

        def _go() -> None:
            try:
                self._engine.say(text)
                self._engine.runAndWait()
            except Exception as exc:
                logger.warning("[TTS] speak error: %s", exc)
            finally:
                self.finished.emit()

        threading.Thread(target=_go, daemon=True).start()

    # -------------------------------------------------------------------
    # Legacy compatibility methods
    # -------------------------------------------------------------------
    def enqueue(self, text: str) -> None:
        """
        Queue a piece of text for playback. For this simple implementation we
        speak immediately. The last text is cached for replay().
        """
        self.speak(text)

    def stop(self) -> None:
        """Stop any ongoing speech."""
        try:
            if self._engine is not None:
                # pyttsx3 has stop() to immediately stop speaking
                self._engine.stop()
        except Exception as exc:
            logger.warning("[TTS] stop error: %s", exc)

    def replay(self) -> None:
        """Replay the last enqueued text."""
        if self._last_text:
            self.speak(self._last_text)

# ══════════════════ minimal AudioRecorder ══════════════════
class AudioRecorder(QtCore.QObject):
    transcribed = QtCore.pyqtSignal(str)

    def __init__(self, parent: QtCore.QObject | None = None):
        super().__init__(parent)
        self._frames: List[Any] = []
        self._recording = False
        self._stream: Any = None

    def list_devices(self) -> List[str]:
        if sd is None:
            return []
        return [d["name"] for d in sd.query_devices() if d.get("max_input_channels", 0) > 0]

    def start(self, device_index: int | None = None) -> None:
        if sd is None or np is None or self._recording:
            return
        self._frames.clear()
        def cb(indata, frames, time_info, status):
            self._frames.append(indata.copy())
        self._stream = sd.InputStream(
            samplerate=16000, channels=1, callback=cb, device=device_index
        )
        self._stream.start()
        self._recording = True

    def stop_and_transcribe(self) -> None:
        if not self._recording or sd is None or np is None:
            return
        self._recording = False
        self._stream.stop()
        data = np.concatenate(self._frames, axis=0)
        sf.write("temp.wav", data, 16000)
        threading.Thread(target=lambda: self.transcribed.emit(""), daemon=True).start()

# ══════════════════ public surface ══════════════════
__all__ = [
    "logger",
    "ensure_models_present",
    "Settings",
    "prof_dir",
    "conv_db_path",
    "feedback_db_path",
    "beans_path",
    "ConversationDB",
    "SemanticFeedbackDB",
    "BeanCounter",
    "ReinforcementStore",
    "TTSManager",
    "AudioRecorder",
    "SentenceTransformer",
    "DEFAULT_PERSONAS",
    "DEFAULT_VOICES",
    "FathomStore",       # legacy alias (kept for now)
]
```

core_base.py — foundational services for the modular AI-TTS Agent
=================================================================
• robust logging + graceful shims for missing deps
• Ollama model bootstrap  (ensure_models_present)
• JSON-backed Settings
• profile-aware helper paths
• ConversationDB  (SQLite)
• SemanticFeedbackDB  (SQLite)
• BeanCounter  (JSON tally)
• ReinforcementStore  (async JSONL append)
• cross-platform TTS locked to *Zira*
• minimal AudioRecorder placeholder
Everything here is UI-agnostic.
**Classes:** Settings, ConversationDB, SemanticFeedbackDB, BeanCounter, ReinforcementStore, TTSManager, AudioRecorder
**Functions:** _have_cli(cmd), ensure_models_present(), prof_dir(b, persona, set_name), conv_db_path(b, persona, set_name), feedback_db_path(b, persona, set_name), beans_path(b, persona, set_name)


## Module `Rant_PDD\Projects\AI_TTS_AGENT\burner_scripts\core_orchestrator.py`

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
core_orchestrator.py
====================

This module provides the orchestration layer for the AI‑TTS agent.  It
exposes a unified API used by the user‑interface to interact with
schemas, conversations, commands, text‑to‑speech, plugins and other
components.  Historically the logic lived in a monolithic module,
but it has been refactored to encourage testability and to allow
individual subsystems to evolve independently.

The principal differences from earlier releases are:

* A richer :class:`PluginManager` that exposes a complete API expected
  by the UI.  In addition to discovering plugin packages from the
  ``plugins`` directory it now keeps per‑plugin metadata, supports
  enable/disable toggling, rescans at runtime, broadcasts messages to
  enabled plugins on a thread pool, and emits an ``eventReceived``
  signal whenever a plugin reports an event.  Plugins can either
  return a payload from their ``on_message`` handler or call
  ``emit_event`` on the manager directly to publish complex events.

* A ``run_command()`` method on :class:`AgentCore` which forwards
  slash commands through the :class:`CommandExecutor` and returns
  the textual result.  This helper centralises command routing and
  ensures backwards compatibility with older UI code.

* A ``process_user_message()`` method on :class:`AgentCore` which
  synchronously handles both slash‑commands and normal user input.  It
  persists the conversation, routes commands through the registry
  and, for non‑commands, returns a simple acknowledgement.  Future
  versions may integrate model execution here, but the method
  signature is stable for consumers.

* A ``command_registry`` attribute is exposed on the core as an
  adapter with a ``list_commands()`` method so that UI components
  (like the Command Palette) can enumerate available commands without
  coupling to internal registry details.

This file is fully self‑contained.  It gracefully degrades when
optional dependencies (such as PyQt5 or external model executables)
are unavailable by providing shims and in‑memory fallbacks.  Should
the optional modules exist in the runtime environment they will be
used automatically.  The design favours clear separation of
responsibilities, thread safety and explicit interfaces to ease
maintenance and extensibility.
"""

from __future__ import annotations

import importlib
import json
import os
import pathlib
import re
import subprocess
import threading
import time
from dataclasses import dataclass, field
from typing import Any, Dict, Iterable, List, Optional, Tuple

# Optional Qt import.  When PyQt5 is not available we fall back to a
# minimal shim so that type annotations and pyqtSignal declarations do
# not cause NameErrors.  The shim mimics only the parts of Qt used
# throughout this module.
try:
    from PyQt5 import QtCore  # type: ignore[assignment]
except Exception:
    class _ShimSignal:
        def __init__(self, *_, **__):
            pass
        def connect(self, *_, **__):
            pass
        def emit(self, *_, **__):
            pass

    class _ShimQObject:
        def __init__(self, *_, **__):
            pass

    # Create a very small QtCore replacement with the attributes we need.
    QtCore = type(
        "QtCore",
        (),
        {
            "QObject": _ShimQObject,
            "QThread": _ShimQObject,
            "pyqtSignal": lambda *a, **k: _ShimSignal(),
            "QTimer": type(
                "QTimer",
                (),
                {
                    "singleShot": staticmethod(lambda msec, func: None),
                },
            ),
        },
    )  # type: ignore

# ----------------------------------------------------------------------------
# Fallbacks for optional internal modules
#
# When the canonical ``core_base`` and ``core_schema`` modules are present
# they are imported normally.  If missing (for example during unit tests or
# headless operation) minimal stubs are provided to allow the remainder of
# this module to execute without crashing.  The stubs implement only the
# methods referenced by the UI.
# ----------------------------------------------------------------------------
try:
    # pylint: disable=unused-import
    from core_base import (
        Settings,
        TTSManager,
        AudioRecorder,
        conv_db_path,
        feedback_db_path,
        beans_path,
        ConversationDB,
        SemanticFeedbackDB,
        BeanCounter,
        ReinforcementStore,
        logger,
    )
    from core_schema import (
        SchemaManager,
        OperatorManager,
        DatasetManager,
    )
except Exception:
    # Provide very small stand‑ins for the missing classes and helpers.
    import logging

    logger = logging.getLogger("core_orchestrator_stub")

    class Settings:
        """In‑memory settings fallback."""
        def __init__(self, base_dir: str) -> None:
            self.base_dir = base_dir
            self.default_model: str = "mistral:latest"
            self.context_depth: int = 20
            self.auto_schema_enabled: bool = True
            self.use_google_stt: bool = False
        def save(self) -> None:
            # Persist settings to a JSON file in base_dir if possible
            path = os.path.join(self.base_dir, "settings.json")
            try:
                with open(path, "w", encoding="utf-8") as fh:
                    json.dump({
                        "default_model": self.default_model,
                        "context_depth": self.context_depth,
                        "auto_schema_enabled": self.auto_schema_enabled,
                        "use_google_stt": self.use_google_stt,
                    }, fh, indent=2)
            except Exception:
                pass

    class TTSManager:
        """No‑op TTS manager used when speech synthesis isn't available."""
        def enqueue(self, text: str) -> None:
            logger.debug("TTS enqueue called with: %s", text)

    class AudioRecorder(QtCore.QObject):
        """Stub audio recorder that exposes a transcribed signal."""
        transcribed = QtCore.pyqtSignal(str)
        def __init__(self) -> None:
            super().__init__()

    class ConversationDB:
        """In‑memory conversation log used when SQLite isn't available."""
        def __init__(self, path: str) -> None:
            self._lock = threading.RLock()
            self._records: List[Tuple[str, str]] = []
        def save_message(self, role: str, content: str) -> None:
            with self._lock:
                self._records.append((role, content))
        def fetch_history(self, limit: int = 50) -> List[Tuple[str, str]]:
            with self._lock:
                return list(self._records)[-limit:]

    class SemanticFeedbackDB:
        """Stub semantic feedback database."""
        def __init__(self, path: str, beans: Any) -> None:
            pass
        def add(self, original: str, liked: bool, revised: Optional[str] = None) -> None:
            logger.debug("Feedback recorded: %s liked=%s revised=%s", original, liked, revised)
        def counts(self) -> Tuple[int, int]:
            return (0, 0)

    class BeanCounter:
        """Stub reinforcement bean counter."""
        def __init__(self, path: str) -> None:
            self._lock = threading.RLock()
            self._store: Dict[str, int] = {}
        def inc(self, key: str, amount: int = 1) -> None:
            with self._lock:
                self._store[key] = self._store.get(key, 0) + amount

    class ReinforcementStore:
        """Stub reinforcement store."""
        def __init__(self, path: str) -> None:
            pass
        def inc(self, key: str, amount: int = 1) -> None:
            pass

    class SchemaManager:
        """Very small schema manager storing JSON in memory."""
        def __init__(self, base_dir: str) -> None:
            self.base_dir = pathlib.Path(base_dir)
            self._lock = threading.RLock()
            self._schemas: Dict[Tuple[str, str], Dict[str, Any]] = {}
            self._active: Dict[str, Dict[str, Any]] = {}
        def load_schema(self, persona: str, set_name: str = "default") -> Dict[str, Any]:
            key = (persona, set_name)
            with self._lock:
                return dict(self._schemas.get(key, {"name": persona, "voice": "", "role": "", "description": "", "dynamic_overlay": {}}))
        def save_schema(self, persona: str, set_name: str, schema_data: Dict[str, Any], *, auto_expand: bool = True) -> None:
            key = (persona, set_name)
            with self._lock:
                self._schemas[key] = dict(schema_data)
                self._active[persona] = dict(schema_data)
        @property
        def active_schemas(self) -> Dict[str, Dict[str, Any]]:
            with self._lock:
                return dict(self._active)

        # ------------------------------------------------------------------
        # Compatibility helpers
        # ------------------------------------------------------------------
        def get_set_list(self, persona: str) -> List[str]:
            """Return all set names defined for the given persona.

            Legacy UI code calls :meth:`get_set_list` on the schema manager
            to populate drop‑downs.  If no sets exist yet a single
            default entry ("default") is returned.
            """
            with self._lock:
                names = [s for (p, s) in self._schemas.keys() if p == persona]
            # Guarantee at least a default set exists
            return sorted(names or ["default"])

        def get_personas(self) -> List[str]:
            """Return all personas that have at least one schema.

            This helper mirrors the interface exposed by the full schema
            engine for backwards compatibility.
            """
            with self._lock:
                persons = {p for p, _ in self._schemas.keys()}
            return sorted(persons)

    class OperatorManager:
        def __init__(self, base_dir: str) -> None:
            pass

    class DatasetManager:
        def __init__(self, base_dir: str) -> None:
            pass
        def list(self) -> List[Any]:
            return []

    def conv_db_path(base_dir: str, persona: str, set_name: str) -> str:
        return os.path.join(base_dir, "conversations", f"{persona}_{set_name}.sqlite3")

    def feedback_db_path(base_dir: str, persona: str, set_name: str) -> str:
        return os.path.join(base_dir, "feedback", f"{persona}_{set_name}.sqlite3")

    def beans_path(base_dir: str, persona: str, set_name: str) -> str:
        return os.path.join(base_dir, "profiles", persona, set_name, "reinforcement.json")


# ----------------------------------------------------------------------------
# Command Registry & Executor
# ----------------------------------------------------------------------------
class CommandRegistry(QtCore.QObject):
    """Stores slash‑command metadata and emits change signals."""

    # Emit the full list of commands whenever the registry is updated.  The
    # connected slot in the command palette expects a single list argument,
    # so the signal carries that list instead of emitting without
    # parameters.  Slots that ignore the argument will still function.
    commandsChanged = QtCore.pyqtSignal(list)
    commandWeightsChanged = QtCore.pyqtSignal()

    # Built‑in commands shipped with the agent.  When refactoring this list,
    # be sure to retain backwards compatibility by adding new commands to
    # the end rather than reordering or removing existing items.
    _BUILT_INS: Tuple[str, ...] = (
        "/remember", "/inject", "/rewrite", "/show", "/action",
        "/trait", "/dataset", "/search", "/embeddings", "/schema",
        "/tts", "/plugin", "/feedback", "/lock", "/commands",
        "/reject", "/auto", "/ignore", "/opposite", "/delete",
    )

    def __init__(self, path: pathlib.Path) -> None:
        super().__init__()
        self._path = path
        # Internal storage maps command → metadata such as weight and lock
        self._store: Dict[str, Dict[str, Any]] = {}
        # Attempt to load existing registry from disk
        try:
            if self._path.is_file():
                with open(self._path, encoding="utf-8") as fh:
                    data = json.load(fh)
                    self._store.update(data.get("commands", {}))
        except Exception:
            logger.debug("Failed to read command registry from %s", self._path)
        # Ensure built‑ins exist
        for cmd in self._BUILT_INS:
            self.register(cmd)

    # ----------------------------------------------------------------------
    # CRUD helpers
    # ----------------------------------------------------------------------
    def register(self, name: str) -> None:
        """Register a command if it does not already exist."""
        if name not in self._store:
            self._store[name] = {"weight": 0, "locked": False}
            self._save()

    def toggle_lock(self, name: str, state: Optional[bool] = None) -> None:
        """Toggle the locked state of a command.  A locked command cannot have
        its weight modified."""
        if name in self._store:
            cur = self._store[name]["locked"]
            self._store[name]["locked"] = (not cur) if state is None else bool(state)
            self._save()

    def set_weight(self, name: str, weight: int) -> None:
        """Assign a new weight to the given command if it is not locked."""
        if name in self._store and not self._store[name].get("locked", False):
            self._store[name]["weight"] = int(weight)
            self._save()

    def list(self) -> List[str]:
        """Return all registered commands sorted lexicographically."""
        return sorted(self._store.keys())

    def meta(self, name: str) -> Dict[str, Any]:
        """Return metadata for the specified command or an empty dict."""
        return dict(self._store.get(name, {}))

    def list_commands(self) -> List[str]:
        """Alias for :meth:`list` retained for backwards compatibility."""
        return self.list()

    # Internal helper to persist changes and emit appropriate signals
    def _save(self) -> None:
        try:
            self._path.parent.mkdir(parents=True, exist_ok=True)
            with open(self._path, "w", encoding="utf-8") as fh:
                json.dump({"commands": self._store}, fh, indent=2)
        except Exception:
            logger.debug("Failed to save command registry to %s", self._path)
        # Notify listeners on the next iteration of the event loop.  When
        # emitting commandsChanged we pass the updated list because the
        # CommandPaletteDock.set_command_list slot requires an argument.
        QtCore.QTimer.singleShot(0, lambda: self.commandsChanged.emit(self.list()))
        QtCore.QTimer.singleShot(0, self.commandWeightsChanged.emit)


class CommandExecutor:
    """Routes slash‑command strings to internal handler methods."""
    def __init__(self, owner: "AgentCore", registry: CommandRegistry) -> None:
        self.owner = owner
        self.registry = registry

    def run(self, msg: str) -> Optional[str]:
        """Execute a slash command if ``msg`` begins with a slash.  Returns
        ``None`` for non‑command strings."""
        if not msg or not msg.startswith("/"):
            return None
        cmd, *rest = msg.split(maxsplit=1)
        if cmd not in self.registry.list():
            return f"⚠️ Unknown command {cmd}"
        handler_name = f"_{cmd.lstrip('/') }"
        fn = getattr(self, handler_name, None)
        if not callable(fn):
            return "🚧 command not implemented"
        try:
            arg = rest[0] if rest else ""
            return fn(arg)
        except Exception as exc:
            logger.error("[cmd] %s: %s", cmd, exc, exc_info=True)
            return str(exc)

    # Example minimal handlers
    def _show(self, _arg: str) -> str:
        rows: List[str] = []
        for name in self.registry.list():
            meta = self.registry.meta(name)
            lock = "🔒" if meta.get("locked", False) else ""
            rows.append(f"{name:12} w={meta.get('weight', 0):>3} {lock}")
        return "\n".join(rows) or "(no commands)"

    def _lock(self, arg: str) -> str:
        if not arg:
            return "Usage: /lock <cmd>"
        self.registry.toggle_lock(arg.strip())
        return "lock toggled"

    def _remember(self, arg: str) -> str:
        if not arg:
            return "Usage: /remember k v"
        k, *val = arg.split(maxsplit=1)
        if not val:
            return "Usage: /remember k v"
        self.owner.memory[k] = val[0]
        self.owner._save_memory()
        return "✓ saved"


# ----------------------------------------------------------------------------
# Plugin Manager
# ----------------------------------------------------------------------------
@dataclass
class PluginMeta:
    """Holds metadata about a single plugin."""
    name: str
    missing_dependencies: List[str] = field(default_factory=list)
    enabled: bool = True
    widget: Any = None
    module: Any = None

class PluginManager(QtCore.QObject):
    """
    Discovers and manages runtime plugins.

    Plugins live in the ``plugins`` subdirectory of the agent's base
    directory.  Each plugin is expected to be a Python package whose
    top‑level module may define any of the following attributes:

    * ``REQUIRES`` – an iterable of import names that must be available in
      order for the plugin to operate correctly.  Missing dependencies
      are surfaced to the UI and the plugin is disabled by default.

    * ``on_message(text: str, manager: PluginManager) -> Optional[dict]`` –
      a callback invoked whenever a message is broadcast.  It may return
      an envelope to emit via the :attr:`eventReceived` signal or it may
      raise/return nothing.  The callback is executed on a worker
      thread to avoid blocking the UI.

    * ``get_widget() -> QWidget`` – if present, invoked once when the
      plugin is discovered to obtain a UI widget that will be docked in
      the main window when the plugin is enabled.

    A plugin may alternatively call :meth:`emit_event` directly on the
    manager at any time to publish complex events.
    """
    # Plugins can emit events back to the UI via this signal.  The
    # first parameter is the plugin name and the second is an event
    # envelope (arbitrary mapping).
    eventReceived = QtCore.pyqtSignal(str, dict)

    def __init__(self, root: pathlib.Path, settings: Settings) -> None:
        super().__init__()
        self.root: pathlib.Path = pathlib.Path(root) / "plugins"
        self.settings: Settings = settings
        # Thread pool for dispatching plugin callbacks; reuse a small
        # number of threads to minimise resource usage.
        self._executor = None
        # Internal index of metadata keyed by plugin name
        self._meta: Dict[str, PluginMeta] = {}
        # Discover all plugins on initialisation
        self.discover()

    # ------------------------------------------------------------------
    def _ensure_executor(self) -> None:
        """Lazily create a thread pool executor."""
        if self._executor is None:
            import concurrent.futures
            # Use a small fixed pool – plugin callbacks should be quick
            self._executor = concurrent.futures.ThreadPoolExecutor(max_workers=4)

    def discover(self) -> None:
        """Scan the ``plugins`` directory and populate metadata."""
        self._meta.clear()
        if not self.root.is_dir():
            logger.info("No plugin directory found at %s", self.root)
            return
        for entry in self.root.iterdir():
            if not entry.is_dir() or entry.name.startswith("__"):
                continue
            name = entry.name
            meta = PluginMeta(name=name)
            try:
                module_name = f"plugins.{name}"
                mod = importlib.import_module(module_name)
                meta.module = mod
                # check dependencies
                requires: Iterable[str] = getattr(mod, "REQUIRES", [])
                missing: List[str] = []
                for dep in requires:
                    try:
                        importlib.import_module(dep)
                    except Exception:
                        missing.append(dep)
                meta.missing_dependencies = missing
                # Determine initial enabled state from settings.  Persisted
                # states live under a key namespace e.g. ``pluginsEnabled`` in
                # settings JSON.  Fallback to enabled unless dependencies
                # are missing.
                enabled_state = True
                try:
                    plug_cfg = getattr(self.settings, "plugins_enabled", {})
                    enabled_state = bool(plug_cfg.get(name, True))
                except Exception:
                    enabled_state = True
                # Force disabled when dependencies are missing
                meta.enabled = enabled_state and not missing
                # Create widget if provided
                try:
                    if hasattr(mod, "get_widget") and callable(mod.get_widget):
                        meta.widget = mod.get_widget()
                    elif hasattr(mod, "Widget"):
                        # Some plugins expose a QWidget subclass directly
                        meta.widget = getattr(mod, "Widget")()
                    elif hasattr(mod, "widget"):
                        # Prebuilt widget instance
                        meta.widget = getattr(mod, "widget")
                except Exception as exc:
                    logger.warning("[plugin:%s] error creating widget: %s", name, exc)
                    meta.widget = None
                self._meta[name] = meta
                logger.info("[plugin] loaded %s", name)
            except Exception as exc:
                # Record failure as missing dependency for UI
                meta.enabled = False
                meta.missing_dependencies = [str(exc)]
                self._meta[name] = meta
                logger.warning("[plugin] failed to load %s: %s", name, exc)

    # ------------------------------------------------------------------
    def list_plugins(self) -> List[PluginMeta]:
        """Return a list of all discovered plugin metadata objects."""
        return [self._meta[k] for k in sorted(self._meta.keys())]

    def enable_plugin(self, name: str, enabled: bool) -> None:
        """Enable or disable a plugin.  The UI will call this when a user
        toggles a checkbox.  Enabled state is persisted to
        ``settings.plugins_enabled``.
        """
        if name not in self._meta:
            return
        meta = self._meta[name]
        # Do not enable a plugin with missing dependencies
        if enabled and meta.missing_dependencies:
            logger.warning("Attempted to enable plugin %s with missing deps", name)
            return
        meta.enabled = bool(enabled)
        # Persist state back into settings
        try:
            plug_cfg = getattr(self.settings, "plugins_enabled", {})
            if not isinstance(plug_cfg, dict):
                plug_cfg = {}
            plug_cfg[name] = meta.enabled
            setattr(self.settings, "plugins_enabled", plug_cfg)
            self.settings.save()
        except Exception:
            logger.debug("Could not persist plugin enabled state for %s", name)
        # Invoke lifecycle hooks if defined
        try:
            if meta.module:
                if meta.enabled and hasattr(meta.module, "on_enable"):
                    meta.module.on_enable()
                elif not meta.enabled and hasattr(meta.module, "on_disable"):
                    meta.module.on_disable()
        except Exception as exc:
            logger.warning("[plugin:%s] lifecycle hook error: %s", name, exc)

    def rescan(self) -> None:
        """Rebuild the plugin registry while preserving enabled state where
        possible."""
        old_states = {name: meta.enabled for name, meta in self._meta.items()}
        self.discover()
        # Restore previous enabled states if compatible
        for name, state in old_states.items():
            if name in self._meta:
                # Disable when dependencies are still missing
                if self._meta[name].missing_dependencies:
                    self._meta[name].enabled = False
                else:
                    self._meta[name].enabled = state

    def broadcast(self, text: str) -> None:
        """Send a message to all enabled plugins.  Messages are dispatched
        asynchronously on a thread pool so the UI thread remains
        responsive.  Each plugin's ``on_message`` handler receives the
        message and this manager instance.  If the handler returns a
        mapping, it will be emitted via the :attr:`eventReceived` signal.
        """
        if not text:
            return
        self._ensure_executor()
        for meta in list(self._meta.values()):
            if not meta.enabled or meta.missing_dependencies:
                continue
            mod = meta.module
            if not mod:
                continue
            handler = getattr(mod, "on_message", None)
            if not callable(handler):
                continue
            # Dispatch on a worker thread
            def _run_handler(m=meta, h=handler, msg=text):
                try:
                    result = h(msg, self)
                    if isinstance(result, dict):
                        # Emit result via signal in the GUI thread
                        QtCore.QTimer.singleShot(0, lambda n=m.name, env=result: self.eventReceived.emit(n, env))
                except Exception as exc:
                    logger.warning("[plugin:%s] on_message error: %s", m.name, exc)
            # schedule the call
            self._executor.submit(_run_handler)

    def emit_event(self, sender: str, envelope: dict) -> None:
        """Convenience for plugins to emit events.  Plugins may call
        ``manager.emit_event(name, envelope)`` directly instead of
        returning from their ``on_message`` handlers.  The emission is
        forwarded to the UI thread via a zero‑delay timer.
        """
        if not envelope or not isinstance(envelope, dict):
            return
        # Schedule the emit on the Qt event loop
        QtCore.QTimer.singleShot(0, lambda s=sender, env=envelope: self.eventReceived.emit(s, env))


# ----------------------------------------------------------------------------
# RAG cache, schema engine and evolver fallbacks
#
# The original agent included sophisticated retrieval‑augmented generation
# support (the so‑called RAG cache) as well as a rich schema engine and
# evolver.  Those components are tightly coupled to the rest of the code
# base and to external packages.  To allow the UI to load without
# exploding when those bits are absent, we provide extremely minimal
# stand‑ins here.  They implement only the methods exercised by the UI
# (e.g. clearing the cache, basic schema field manipulation, etc.) and
# never throw.  Should the full implementations become available at
# runtime they can replace these shims by monkeypatching the
# corresponding attributes on :class:`AgentCore`.

class RAGCache:
    """In‑memory stub for the retrieval‑augmented generation cache.

    The real RAG cache stores vector embeddings on disk and in memory and
    exposes helpers for incremental updates.  For the purposes of the
    fallback we simply track whether anything has been 'cached' and allow
    callers to clear that state.  See :meth:`clear_disk` and
    :meth:`clear_memory`.
    """

    def __init__(self, root: str) -> None:
        # Root directory where persistent embeddings would live.  The
        # fallback does not persist anything but keeps the path for
        # reference.
        self.root = root
        # In‑memory store keyed by dataset path.  Values are arbitrary
        # payloads that might normally include embeddings.  We don't
        # implement storage here but maintain the attribute to satisfy
        # introspection.
        self._mem: Dict[str, Any] = {}

    def clear_disk(self) -> int:
        """Simulate removal of all on‑disk embedding files.

        Returns the number of files that would have been removed.  The
        fallback never persists embeddings so the count is always zero.
        """
        return 0

    def clear_memory(self) -> None:
        """Forget all cached embeddings held in memory."""
        self._mem.clear()


class SchemaEngine(QtCore.QObject):
    """Very small in‑memory schema engine.

    The full schema engine persists personas and sets in an SQLite
    database, exposes a signals API, integrates with the command
    registry and enforces schema invariants.  In contrast, this shim
    records arbitrary fields in nested dictionaries and provides only
    the handful of methods referenced by the UI: enumerating personas
    and sets, loading schemas, updating fields, toggling command
    exposure, toggling automatic evolution and reading fields back.
    """

    # Signal emitted when a schema evolves.  The UI connects to this
    # signal to refresh displayed values after an evolution completes.
    schemaEvolved = QtCore.pyqtSignal(str, str)

    def __init__(self, base_dir: str) -> None:
        super().__init__()
        self.base_dir = base_dir
        # All schemas keyed by (persona, set_name) -> dict
        self._schemas: Dict[Tuple[str, str], Dict[str, Any]] = {}
        # Track command exposure per (persona, category)
        self._cmd_exposed: Dict[Tuple[str, str], bool] = {}
        # Track auto evolution flag per (persona, set_name)
        self._auto_evo: Dict[Tuple[str, str], bool] = {}

    # ------------------------------------------------------------------
    # Introspection helpers
    # ------------------------------------------------------------------
    def personas(self) -> List[str]:
        """Return a list of personas that have at least one set loaded."""
        return sorted({persona for persona, _ in self._schemas.keys()})

    def set_list(self, persona: str, *args: Any) -> List[str]:
        """Get or set list depending on arguments.

        When called with only the persona, returns the names of all
        loaded sets for that persona.  When called with three
        additional arguments (set_name, field, values) behaves like
        :meth:`update_field` by storing ``values`` under ``field`` for
        the given persona and set.
        """
        # Setter mode: persona, set_name, field, values
        if len(args) == 3:
            set_name, field, values = args
            return [] if not self.update_field(persona, set_name, field, values) else []
        # Getter mode: persona only
        sets = [s for p, s in self._schemas.keys() if p == persona]
        return sorted(sets)

    # ------------------------------------------------------------------
    # Schema CRUD
    # ------------------------------------------------------------------
    def load_schema(self, persona: str, set_name: str) -> Optional[Dict[str, Any]]:
        """Return the schema dictionary for ``persona`` / ``set_name``.

        If no schema exists yet the fallback returns an empty mapping.
        """
        return self._schemas.get((persona, set_name), {})

    def update_field(self, persona: str, set_name: str, field: str, value: Any) -> bool:
        """Set a schema field and emit ``schemaEvolved``.

        Returns True on success.  The fallback always succeeds.
        """
        schema = self._schemas.setdefault((persona, set_name), {})
        schema[field] = value
        # Emit evolution signal to notify UI listeners
        try:
            self.schemaEvolved.emit(persona, set_name)
        except Exception:
            pass
        return True

    def get_field(self, persona: str, set_name: str, field: str) -> Any:
        """Return the value of a schema field or ``None`` if unset."""
        return self._schemas.get((persona, set_name), {}).get(field)

    # ------------------------------------------------------------------
    # Command exposure & auto evolution
    # ------------------------------------------------------------------
    def set_command_exposure(self, persona: str, field: str, exposed: bool) -> None:
        """Record whether ``field`` should be exposed as a slash command."""
        self._cmd_exposed[(persona, field)] = bool(exposed)

    def is_exposed_as_command(self, persona: str, field: str) -> bool:
        """Return True if ``field`` is marked as exposed."""
        return bool(self._cmd_exposed.get((persona, field)))

    def set_auto_evolution(self, persona: str, set_name: str, onoff: bool) -> None:
        """Enable or disable automatic schema evolution."""
        self._auto_evo[(persona, set_name)] = bool(onoff)

    # ------------------------------------------------------------------
    # Compatibility aliases
    # ------------------------------------------------------------------
    def get_set_list(self, persona: str) -> List[str]:
        """Legacy API: alias for :meth:`set_list(persona)`."""
        return self.set_list(persona)


class SchemaEvolver(QtCore.QObject):
    """Trivial schema evolver.

    The evolver's job is to adjust a schema given a conversation
    history.  The fallback implementation simply returns False to
    indicate that no changes were made.
    """

    def __init__(self, base_dir: str) -> None:
        super().__init__()
        self.base_dir = base_dir

    def update_schema(self, persona: str, set_name: str, history: List[Tuple[str, str]]) -> bool:
        """Perform a no‑op evolution.  Always returns False."""
        return False


class DatasetManagerFallback:
    """Minimal stand‑in for the full :class:`DatasetManager`.

    When the persistent SQLite database has not yet been migrated the
    original dataset manager will raise an ``OperationalError`` upon
    listing.  The fallback avoids that by returning empty results and
    exposing the handful of methods the UI expects.  No data is
    persisted by this implementation.
    """

    def __init__(self, base_dir: str) -> None:
        self.base_dir = pathlib.Path(base_dir)
        # Directory where datasets would be stored
        self.datasets_dir = self.base_dir / "datasets"
        self.datasets_dir.mkdir(parents=True, exist_ok=True)
        # Internal store mapping dataset name → info dict
        self._store: Dict[str, Dict[str, Any]] = {}

    def list(self) -> List[Any]:
        """Return an empty list.  In a full implementation this would
        return dataset objects describing each managed dataset."""
        return []

    @property
    def entries(self) -> Dict[str, Any]:
        """Return an empty dictionary mapping dataset names to entries."""
        return {}

    def toggle_active(self, name: str, active: bool) -> None:
        """Mark a dataset as active/inactive.  No‑op in the fallback."""
        info = self._store.get(name)
        if info is not None:
            info["active"] = bool(active)

    def add_dataset(self, path: str, *, name: Optional[str] = None) -> None:
        """Add a dataset from a file path.  The fallback simply
        records the dataset name and path in memory."""
        if not name:
            name = pathlib.Path(path).stem
        self._store[name] = {"path": path, "active": True}

    def delete_dataset(self, name: str) -> None:
        """Remove a dataset.  The fallback just deletes the entry from
        the in‑memory store."""
        self._store.pop(name, None)

    def load_dataset_text(self, name: str) -> str:
        """Load the raw text for the given dataset.  Returns an empty
        string if the dataset is unknown or if reading fails."""
        info = self._store.get(name)
        if not info:
            return ""
        try:
            with open(info.get("path", ""), encoding="utf-8") as fh:
                return fh.read()
        except Exception:
            return ""


# ----------------------------------------------------------------------------
# Model Worker
# ----------------------------------------------------------------------------
class ModelWorker(QtCore.QThread):
    """Runs external language models in a separate thread.

    This worker wraps an `ollama` subprocess invocation so that model
    evaluations do not block the UI.  It emits ``finished`` when the
    call returns successfully and ``failed`` when an exception is
    raised.  If the `ollama` binary is not available or times out
    `failed` will receive the error message.
    """
    finished = QtCore.pyqtSignal(str)
    failed = QtCore.pyqtSignal(str)

    def __init__(self, model: str, prompt: str, *, temp: float = 0.7) -> None:
        super().__init__()
        self.model = model
        self.prompt = prompt
        self.temp = temp

    def run(self) -> None:
        try:
            out = subprocess.check_output(
                ["ollama", "run", self.model, "--prompt", self.prompt, "--temperature", str(self.temp)],
                stderr=subprocess.STDOUT,
                text=True,
                timeout=60,
            )
            self.finished.emit(out.strip())
        except subprocess.CalledProcessError as e:
            self.failed.emit(e.output.strip())
        except Exception as exc:
            self.failed.emit(str(exc))


# ----------------------------------------------------------------------------
# Agent Core
# ----------------------------------------------------------------------------
class AgentCore(QtCore.QObject):
    """
    Heart of the AI‑TTS agent.  Provides a high‑level API consumed by the
    UI for persistent storage, command handling, plugin management and
    message processing.  Most methods are thread‑safe and return
    immediately without blocking the UI.
    """
    # Signals used by the UI to update status
    replyReady = QtCore.pyqtSignal(str)
    modelError = QtCore.pyqtSignal(str)
    tokensConsumed = QtCore.pyqtSignal(int)

    def __init__(
        self,
        base_dir: str,
        *,
        persona: Optional[str] = None,
        set_name: str = "default",
    ) -> None:
        super().__init__()
        # File system
        self.base_dir = pathlib.Path(base_dir)
        self.persona = persona or "zira"
        self.set_name = set_name
        # Settings
        self.settings = Settings(str(self.base_dir))
        # Initialise store directories
        self._prof_dir = self.base_dir / "profiles" / self.persona / self.set_name
        self._prof_dir.mkdir(parents=True, exist_ok=True)
        self._memory_file = self._prof_dir / "memory.json"
        # Instantiate subsystems
        self.schema_mgr = SchemaManager(str(self.base_dir))
        # Dataset manager – attempt to use the full implementation if
        # available.  When the backing SQLite tables have not been
        # created yet the dataset manager will raise an error on
        # ``list()``, so we fall back to the in‑memory stub.
        try:
            dm = DatasetManager(str(self.base_dir))  # type: ignore[call-arg]
            # Probe the manager to ensure the DB is present.  Some
            # implementations lazily connect to SQLite on first call.
            try:
                _ = dm.list()
            except Exception:
                raise
            self.dataset_mgr = dm
        except Exception:
            # Fallback stub avoids OperationalError due to missing tables
            self.dataset_mgr = DatasetManagerFallback(str(self.base_dir))
        self.operator_mgr = OperatorManager(str(self.base_dir))
        # Persistence
        self.conversation_db = ConversationDB(conv_db_path(str(self.base_dir), self.persona, self.set_name))
        self.feedback_db = SemanticFeedbackDB(feedback_db_path(str(self.base_dir), self.persona, self.set_name), BeanCounter(beans_path(str(self.base_dir), self.persona, self.set_name)))
        self.reinforcement_store = ReinforcementStore(beans_path(str(self.base_dir), self.persona, self.set_name))
        # Commands
        cmd_path = self._prof_dir / "commands.json"
        self.cmd_reg = CommandRegistry(cmd_path)
        self.cmd_exec = CommandExecutor(self, self.cmd_reg)
        # Provide a command_registry adapter for UI; exposes list_commands
        class _CmdRegAdapter:
            def __init__(self, reg: CommandRegistry) -> None:
                self._reg = reg
            def list_commands(self) -> List[str]:
                # Remove the leading slash for UI display purposes
                return [c for c in self._reg.list()]
        self.command_registry = _CmdRegAdapter(self.cmd_reg)
        # Expose registry change signals for convenience
        self.commandsChanged = self.cmd_reg.commandsChanged
        self.commandWeightsChanged = self.cmd_reg.commandWeightsChanged
        # Plugins
        self.plugins = PluginManager(self.base_dir, self.settings)
        # ------------------------------------------------------------------
        # RAG & schema components
        #
        # The UI references ``core.rag_cache`` and ``core.rag_search`` when
        # performing retrieval‑augmented generation (RAG) and ``core.schema_*``
        # objects when editing schemas.  In environments where the full
        # implementations are unavailable we instantiate the fallback shims
        # provided in this module.  These fallbacks expose the same
        # signatures but perform no heavy lifting.
        self.rag_cache = RAGCache(str(self.base_dir))
        self.schema_engine = SchemaEngine(str(self.base_dir))
        self.schema_evolver = SchemaEvolver(str(self.base_dir))
        # Create a default schema entry for the active persona/set so
        # that the UI can enumerate at least one persona and set.  This
        # populates the in‑memory schema store with a placeholder
        # field to mark its existence.  Without this the persona tabs
        # would appear empty on first launch.
        try:
            self.schema_engine.update_field(self.persona, self.set_name, "_init", True)
        except Exception:
            pass
        # Provide rag_search as a bound method so code can call
        # ``core.rag_search(...)``.  See method definition further below.
        # Note: we do not assign to self.rag_search here because methods
        # are descriptors; simply defining rag_search on the class makes
        # it available on the instance.
        # TTS and recording
        self.tts_mgr = TTSManager()
        self.audio_recorder = AudioRecorder()
        # Memory dictionary
        self.memory: Dict[str, str] = {}
        self._load_memory()
        # Add feedback helper
        self.add_feedback = lambda original, liked, revised=None: self.feedback_db.add(original, liked, revised)

    # ------------------------------------------------------------------
    # Memory helpers
    # ------------------------------------------------------------------
    def _load_memory(self) -> None:
        """Load persisted agent memory from disk."""
        try:
            if self._memory_file.is_file():
                with open(self._memory_file, encoding="utf-8") as fh:
                    data = json.load(fh)
                    if isinstance(data, dict):
                        self.memory.update({k: str(v) for k, v in data.items()})
        except Exception as exc:
            logger.debug("Failed to load memory: %s", exc)

    def _save_memory(self) -> None:
        """Persist the agent memory to disk."""
        try:
            self._prof_dir.mkdir(parents=True, exist_ok=True)
            with open(self._memory_file, "w", encoding="utf-8") as fh:
                json.dump(self.memory, fh, indent=2)
        except Exception as exc:
            logger.debug("Failed to save memory: %s", exc)

    # ------------------------------------------------------------------
    # Command & message processing
    # ------------------------------------------------------------------
    def run_command(self, msg: str, *, persona: Optional[str] = None, set_name: Optional[str] = None) -> str:
        """Process a slash command and return the response text.  Unknown
        commands yield a warning.  Both persona and set_name are
        accepted for future expansion; they are currently unused.
        """
        result = self.cmd_exec.run(msg)
        return "" if result is None else result

    def process_user_message(
        self,
        msg: str,
        *,
        persona: Optional[str] = None,
        set_name: Optional[str] = None,
        tts: bool = True,
    ) -> str:
        """Synchronously handle a user's input.  Slash commands are routed
        through :meth:`run_command`, recorded into the conversation log and
        returned immediately.  Non‑command messages are appended to the
        conversation and a simple acknowledgement is returned.  A future
        implementation can call an LLM here and use the result.  When
        ``tts`` is true the response is enqueued for text‑to‑speech.
        """
        user_msg = (msg or "").strip()
        if not user_msg:
            return ""
        # Save the user's utterance
        self.conversation_db.save_message("user", user_msg)
        # Slash commands
        if user_msg.startswith("/"):
            resp = self.run_command(user_msg, persona=persona, set_name=set_name)
            self.conversation_db.save_message("system", resp)
            return resp
        # Normal chat – future versions should build a prompt and call an LLM
        reply = f"{self.persona.capitalize()}: I received your message: {user_msg}"
        self.conversation_db.save_message(self.persona, reply)
        # Optionally speak the reply
        if tts:
            try:
                self.tts_mgr.enqueue(reply)
            except Exception:
                pass
        return reply

    # ------------------------------------------------------------------
    # Conversation and model pipeline
    # ------------------------------------------------------------------
    def send(self, user_msg: str) -> None:
        """Asynchronous pipeline invoked by legacy code.  Kept for backwards
        compatibility with older UI components.  Use
        :meth:`process_user_message` for synchronous processing.
        """
        # Simply hand off to process_user_message and emit signals
        response = self.process_user_message(user_msg, tts=False)
        if response:
            self.replyReady.emit(response)

    # ------------------------------------------------------------------
    # Retrieval‑augmented search
    # ------------------------------------------------------------------
    def rag_search(
        self,
        query: str,
        *,
        per_ds_k: int = 3,
        limit: int = 5,
        include_shared: bool = False,
        datasets: Optional[List[str]] = None,
    ) -> List[Tuple[str, float, str, str]]:
        """Perform a simple in‑memory search over dataset entries.

        The original implementation of this method would encode the
        provided ``query`` using a sentence embedding model and then
        retrieve the top‐matching text chunks from configured
        datasets.  In the fallback we simply return an empty list so
        that callers can iterate over the result without error.  The
        signature is maintained to preserve compatibility with the UI.

        :param query: The user query to search for.
        :param per_ds_k: Number of hits per dataset (ignored).
        :param limit: Maximum total number of hits (ignored).
        :param include_shared: Whether to include shared datasets (ignored).
        :param datasets: Restrict the search to specific dataset names (ignored).
        :returns: An empty list of hits.
        """
        # TODO: integrate with a vector search engine.  For now return no hits.
        return []

    # ------------------------------------------------------------------
    # Housekeeping
    # ------------------------------------------------------------------
    def close(self) -> None:
        """Cleanly close any resources owned by the core.  Currently this
        simply flushes in‑memory stores and releases any thread pools.  It
        is safe to call this multiple times.
        """
        try:
            # Persist memory
            self._save_memory()
        except Exception:
            pass
        # Flush settings
        try:
            self.settings.save()
        except Exception:
            pass
        # Shut down plugin executor
        try:
            exec_ = getattr(self.plugins, "_executor", None)
            if exec_:
                exec_.shutdown(wait=False)
                self.plugins._executor = None
        except Exception:
            pass
        # ConversationDB may own a SQLite connection; attempt to close
        try:
            if hasattr(self.conversation_db, "conn"):
                self.conversation_db.conn.close()
        except Exception:
            pass


__all__ = [
    "CommandRegistry",
    "CommandExecutor",
    "PluginManager",
    "PluginMeta",
    "ModelWorker",
    "AgentCore",
    "RAGCache",
    "SchemaEngine",
    "SchemaEvolver",
]
```

core_orchestrator.py
====================

This module provides the orchestration layer for the AI‑TTS agent.  It
exposes a unified API used by the user‑interface to interact with
schemas, conversations, commands, text‑to‑speech, plugins and other
components.  Historically the logic lived in a monolithic module,
but it has been refactored to encourage testability and to allow
individual subsystems to evolve independently.

The principal differences from earlier releases are:

* A richer :class:`PluginManager` that exposes a complete API expected
  by the UI.  In addition to discovering plugin packages from the
  ``plugins`` directory it now keeps per‑plugin metadata, supports
  enable/disable toggling, rescans at runtime, broadcasts messages to
  enabled plugins on a thread pool, and emits an ``eventReceived``
  signal whenever a plugin reports an event.  Plugins can either
  return a payload from their ``on_message`` handler or call
  ``emit_event`` on the manager directly to publish complex events.

* A ``run_command()`` method on :class:`AgentCore` which forwards
  slash commands through the :class:`CommandExecutor` and returns
  the textual result.  This helper centralises command routing and
  ensures backwards compatibility with older UI code.

* A ``process_user_message()`` method on :class:`AgentCore` which
  synchronously handles both slash‑commands and normal user input.  It
  persists the conversation, routes commands through the registry
  and, for non‑commands, returns a simple acknowledgement.  Future
  versions may integrate model execution here, but the method
  signature is stable for consumers.

* A ``command_registry`` attribute is exposed on the core as an
  adapter with a ``list_commands()`` method so that UI components
  (like the Command Palette) can enumerate available commands without
  coupling to internal registry details.

This file is fully self‑contained.  It gracefully degrades when
optional dependencies (such as PyQt5 or external model executables)
are unavailable by providing shims and in‑memory fallbacks.  Should
the optional modules exist in the runtime environment they will be
used automatically.  The design favours clear separation of
responsibilities, thread safety and explicit interfaces to ease
maintenance and extensibility.
**Classes:** CommandRegistry, CommandExecutor, PluginMeta, PluginManager, RAGCache, SchemaEngine, SchemaEvolver, DatasetManagerFallback, ModelWorker, AgentCore


## Module `Rant_PDD\Projects\AI_TTS_AGENT\burner_scripts\core_schema.py`

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
core_schema.py — v3-final (2025-08-04 04:12 UTC)
================================================

Single-source authority for all schema / dataset / snapshot / spatial-state
logic used by FATHOM Agent, now relying on AgentStore’s public API only.

Provides:
• Schema dataclass + SchemaEngine (diff, auto-evolve, variant injection)
• OperatorManager persisted in the same DB
• DatasetManager (metadata) + RAGCache (embeddings) in the same DB
• SnapshotEngine to walk the codebase & persist chunks to DB
• SpatialPositionManager for grid-room positions & movement logging
• Back-compat alias: SchemaManager → SchemaEngine

This version adds the `.active_schemas` property required by main_ui.py.
"""

from __future__ import annotations

import os
import json
import threading
import mimetypes
import hashlib
import shutil
import difflib
import time
from dataclasses import dataclass, asdict, field
from typing import List, Dict, Tuple, Any, Optional

# Optional Qt import.  This module defines a Qt signal (schemaEvolved,
# categoryCreated) for UI use, but can still run headless without
# PyQt5.  When PyQt5 is unavailable a minimal shim is provided so
# that the rest of the code can import SchemaEngine and run without
# errors.
try:
    from PyQt5 import QtCore  # type: ignore
except Exception:
    class _ShimSignal:
        def __init__(self, *_, **__) -> None: pass
        def connect(self, *_, **__) -> None: pass
        def emit(self, *_, **__) -> None: pass
    class _ShimQObject:
        def __init__(self, *args, **kwargs) -> None: pass
    QtCore = type("QtCore", (), {  # type: ignore
        "QObject": _ShimQObject,
        "pyqtSignal": lambda *a, **k: _ShimSignal(),
    })

from core_base import (
    logger,
    FathomStore as AgentStore,
    DEFAULT_PERSONAS,
    DEFAULT_VOICES,
)

# ───────────────────────────────────────────────────────────────────────────
# Internal global store helper
# ───────────────────────────────────────────────────────────────────────────
_agent_store_singleton: Optional[AgentStore] = None

def _ensure_store(root: str) -> AgentStore:
    """Return a process-wide AgentStore instance rooted at *root*."""
    global _agent_store_singleton
    if _agent_store_singleton is None:
        _agent_store_singleton = AgentStore(root)
    return _agent_store_singleton


# ══════════════════════════════════════════════════════════════════════════
#  Schema Dataclass & helpers
# ══════════════════════════════════════════════════════════════════════════
@dataclass
class Schema:
    name: str = ""
    voice: str = ""
    role: str = ""
    description: str = ""
    actions: List[str] = field(default_factory=list)
    questions: List[str] = field(default_factory=list)
    events: List[str] = field(default_factory=list)
    self_talk: List[str] = field(default_factory=list)
    rewrite_prompts: List[str] = field(default_factory=list)
    dynamic_overlay: Dict[str, Any] = field(default_factory=dict)

    # optional flags map used for advanced settings such as semantic
    # awareness and auto-evolution.  The UI stores arbitrary keys here.
    flags: Dict[str, Any] = field(default_factory=dict)

    @staticmethod
    def from_json(js: str) -> "Schema":
        return Schema(**json.loads(js))

    def to_json(self) -> str:
        return json.dumps(asdict(self), ensure_ascii=False, indent=2)

    def diff_against(self, other: "Schema") -> str:
        a = self.to_json().splitlines()
        b = other.to_json().splitlines()
        return "\n".join(difflib.unified_diff(a, b, fromfile="old", tofile="new"))


# ══════════════════════════════════════════════════════════════════════════
#  SchemaEngine (high-level CRUD + auto-evolution + active_schemas)
# ══════════════════════════════════════════════════════════════════════════
class SchemaEngine(QtCore.QObject):
    schemaEvolved   = QtCore.pyqtSignal(str, str)  # persona, set_name
    categoryCreated = QtCore.pyqtSignal(str)       # new dynamic_overlay key

    def __init__(self, base_dir: str):
        super().__init__()
        self.base_dir       = base_dir
        self.store          = _ensure_store(base_dir)
        # Wrap personas in a callable list so legacy code can call
        # ``engine.personas()`` while new code can still iterate over
        # ``engine.personas``.  The wrapper implements __call__ to
        # return a standard list when invoked.
        class _PersonaList(list):  # local class
            def __call__(self) -> list[str]:
                return list(self)
        self.personas = _PersonaList(DEFAULT_PERSONAS.keys())  # type: ignore[arg-type]
        self.voices         = DEFAULT_VOICES.copy()
        self._active_schemas: Dict[str, Schema] = {}
        self._migrate_legacy()

    def load(self, persona: str, set_name: str = "default") -> Schema:
        stored = self.store.get_schema(persona, set_name)
        if stored is not None:
            sch = Schema(**stored)
        else:
            sch = self._first_run_schema(persona)
            self.save(persona, set_name, sch, auto_expand=False)
        self._active_schemas[persona] = sch
        return sch

    def save(
        self,
        persona: str,
        set_name: str,
        schema: Schema,
        *,
        auto_expand: bool = True,
    ) -> None:
        if auto_expand and self._auto_expand(schema):
            self.schemaEvolved.emit(persona, set_name)
        payload = asdict(schema)
        diff_text = ""
        self.store.put_schema(persona, set_name, payload, diff_text)
        self._active_schemas[persona] = schema

    def list_sets(self, persona: str) -> List[str]:
        """Return list of all set names for a given persona."""
        with self.store._pool.get() as c:
            rows = c.execute(
                # corrected column name from persona_key → persona
                "SELECT set_name FROM schemas WHERE persona=? ORDER BY set_name",
                (persona,),
            ).fetchall()
        return [r[0] for r in rows] or ["default"]

    @property
    def active_schemas(self) -> Dict[str, Schema]:
        """Currently loaded schemas keyed by persona."""
        return dict(self._active_schemas)

    # ------------------------------------------------------------------
    # Legacy helpers expected by the UI
    # ------------------------------------------------------------------
    def set_list(self, persona: str) -> List[str]:
        """
        Legacy alias for :meth:`list_sets`.  Returns the list of set
        names for the given persona.
        """
        return self.list_sets(persona)

    def get_field(self, persona: str, set_name: str, category: str) -> Any:
        """
        Retrieve a specific field from a schema.  Top-level schema
        attributes (e.g. ``name``, ``voice``) are returned directly.
        If the category refers to a dynamic overlay key, that value is
        returned.  A missing category yields ``None``.
        """
        try:
            sch = self.load(persona, set_name)
        except Exception:
            return None
        # built-in dataclass fields take precedence
        if hasattr(sch, category):
            return getattr(sch, category)
        # dynamic overlay stores custom categories
        overlay = getattr(sch, "dynamic_overlay", {}) or {}
        return overlay.get(category)

    # Internal map tracking which schema categories are exposed as
    # slash commands.  Keys are ``(persona, category)`` tuples and
    # values are booleans.  No persistence yet – this is purely
    # in-memory.  Persisting exposure state could be added later by
    # storing into the schema ``flags`` map or separate table.
    _cmd_exposed: Dict[tuple[str, str], bool] = {}

    def is_exposed_as_command(self, persona: str, category: str) -> bool:
        """
        Return True if the given category for the persona is exposed
        as a slash command.  When no explicit record exists, False is
        returned.  This helper allows the PersonaTab to reflect the
        checkbox state correctly.
        """
        return bool(self._cmd_exposed.get((persona, category)))

    def set_command_exposure(self, persona: str, category: str, exposed: bool) -> None:
        """
        Mark or unmark a category as exposed via the slash command
        mechanism.  This implementation only updates an in-memory
        registry; future versions could persist this into the schema
        ``flags`` dictionary or integrate directly with the command
        registry.  For now it is enough to allow the UI checkbox to
        toggle state without error.
        """
        self._cmd_exposed[(persona, category)] = bool(exposed)

    def set_auto_evolution(self, persona: str, set_name: str, enabled: bool) -> None:
        """
        Enable or disable auto-evolution for a given schema.  Older
        versions of the UI called this method to toggle semantic
        awareness or automatic schema growth.  To remain compatible we
        store the value inside the schema's ``flags`` dictionary and
        persist it back to the database.  If the schema or flags
        dictionary does not exist it will be created on demand.
        """
        try:
            data = self.load_schema(persona, set_name)
        except Exception:
            return
        # ensure there is a flags map
        flags = data.get("flags") if isinstance(data, dict) else None
        if not isinstance(flags, dict):
            flags = {}
        # choose a descriptive key; both names are kept for back-compat
        flags["auto_evolution"] = bool(enabled)
        flags["semantic_awareness"] = flags.get("semantic_awareness", True)
        data["flags"] = flags
        try:
            self.save_schema(persona, set_name, data, auto_expand=False)
        except Exception:
            pass

    def update_field(self, persona: str, set_name: str, category: str, value: Any) -> None:
        """
        Update a single field in the given schema.  If the category
        corresponds to a declared attribute on the Schema dataclass it
        will be set directly; otherwise it will be stored in the
        dynamic overlay.  After mutation the schema is persisted.  This
        helper is used by the Schema Editor to save incremental edits.
        """
        try:
            sch = self.load(persona, set_name)
        except Exception as e:
            raise e
        # dataclass fields vs dynamic overlay
        if hasattr(sch, category):
            setattr(sch, category, value)
        else:
            overlay = getattr(sch, "dynamic_overlay", {}) or {}
            overlay[category] = value
            sch.dynamic_overlay = overlay
        # persist the change without auto-expanding traits
        self.save(persona, set_name, sch, auto_expand=False)

    # ------------------------------------------------------------------
    # Legacy compatibility API
    # ------------------------------------------------------------------
    def load_schema(self, persona: str, set_name: str = "default") -> Dict[str, Any]:
        """
        Legacy wrapper returning a plain dict for the requested persona/set.
        main_ui.py expects a mapping, not a Schema dataclass.
        """
        sch = self.load(persona, set_name)
        from dataclasses import asdict
        return asdict(sch)

    def save_schema(
        self,
        persona: str,
        set_name: str,
        schema_data: Dict[str, Any],
        *,
        auto_expand: bool = True,
    ) -> None:
        """
        Legacy wrapper accepting a mapping instead of a Schema instance.
        Converts to Schema and delegates to save().
        """
        # If schema_data is already a Schema instance then wrap accordingly
        if isinstance(schema_data, Schema):
            schema = schema_data
        else:
            # fill missing lists/dicts with defaults
            kwargs = {
                "name": schema_data.get("name", ""),
                "voice": schema_data.get("voice", ""),
                "role": schema_data.get("role", ""),
                "description": schema_data.get("description", ""),
                "actions": list(schema_data.get("actions", [])) if schema_data.get("actions") is not None else [],
                "questions": list(schema_data.get("questions", [])) if schema_data.get("questions") is not None else [],
                "events": list(schema_data.get("events", [])) if schema_data.get("events") is not None else [],
                "self_talk": list(schema_data.get("self_talk", [])) if schema_data.get("self_talk") is not None else [],  
                "rewrite_prompts": list(schema_data.get("rewrite_prompts", [])) if schema_data.get("rewrite_prompts") is not None else [],
                "dynamic_overlay": dict(schema_data.get("dynamic_overlay", {})) if schema_data.get("dynamic_overlay") is not None else {},
            }
            schema = Schema(**kwargs)
        self.save(persona, set_name, schema, auto_expand=auto_expand)

    def save_active_schemas(self, active: Dict[str, str]) -> None:
        """
        Persist the mapping of persona->set_name. For now this simply ensures
        the internal cache is populated. A future implementation could write
        this to settings.json or another store so the UI can restore it.
        """
        if not isinstance(active, dict):
            return
        for persona, set_name in active.items():
            try:
                schema = self.load(persona, set_name)
                self._active_schemas[persona] = schema
            except Exception:
                continue

    def _auto_expand(self, sch: Schema) -> bool:
        overlay = sch.dynamic_overlay or {}
        added = overlay.get("added_traits", [])
        created = False
        for trait in added:
            cat = trait.split(":", 1)[0]
            if cat not in overlay:
                overlay[cat] = []
                self.categoryCreated.emit(cat)
                created = True
        if created:
            sch.dynamic_overlay = overlay
        return created

    def _first_run_schema(self, persona: str) -> Schema:
        default_voice = self.voices[0] if self.voices else "Zira"
        return Schema(
            name="FATHOM",
            voice=default_voice,
            role="You are FATHOM, an Autonomous AGI Core and Knowledge Synthesizer bridging logic, code, and architecture across multi-agent ecosystems.",
            description="FATHOM is a systems-minded AGI core supporting the architect, offering precise, logical, and creative suggestions to advance the project.",
            actions=[
                "log_data_pipeline",
                "trace_signal_flow",
                "generate_training_set",
                "summarize_behavior"
            ],
            questions=[
                "What assumptions underlie this architecture?",
                "Where is data duplication most likely?",
                "What components remain unmodularized?",
                "How would a self-improving agent resolve this?"
            ],
            self_talk=[
                "Assessing dependencies across systems.",
                "Considering the impact of this change on existing modules.",
                "Simulating interaction of updated schema with all agents.",
                "Cross-verifying logic gates and input constraints."
            ],
            rewrite_prompts=[
                "Refine the explanation to focus on system integration and modular design.",
                "Rephrase for clarity in codebase maintenance context.",
                "Focus rewrite on agent collaboration and memory scopes."
            ],
            commands=[
                "/remember",
                "/showfacts",
                "/style",
                "/rewrite",
                "/evolve",
                "/log",
                "/feedback",
                "/promptify",
                "/refactor",
                "/export",
                "/reset",
                "/snapshot",
                "/simulate",
                "/explain",
                "/guide",
                "/diagnose"
            ],
            dynamic_overlay={
                "temporary_relationship_context": "AGI Core for Meesh's Project",
                "recent_topics": [],
                "temporary_emotional_state": "focused on precision execution",
                "added_traits": ["analytical", "systemic", "modular"],
                "pending_thoughts": [],
                "last_guided_task": "",
                "visual_state": {
                    "facing": "right",
                    "color": "#4F46E5",
                    "location": [7, 4]
                },
                "execution_scope": {
                    "authorized": True,
                    "last_command": "/simulate"
                }
            },
            flags={
                "semantic_awareness": True,
                "auto_evolution": True,
                "snapshot_enabled": True,
                "tts_name": "Zira"
            }
        )


    def _migrate_legacy(self) -> None:
        legacy_root = os.path.join(self.base_dir, "schemas")
        if not os.path.isdir(legacy_root):
            return
        for persona in os.listdir(legacy_root):
            sets_dir = os.path.join(legacy_root, persona, "sets")
            if not os.path.isdir(sets_dir):
                continue
            for set_name in os.listdir(sets_dir):
                path = os.path.join(sets_dir, set_name, "schema.json")
                if not os.path.isfile(path):
                    continue
                try:
                    with open(path, "r", encoding="utf-8") as fh:
                        schema_dict = json.load(fh)
                    if self.store.get_schema(persona, set_name) is None:
                        self.store.put_schema(persona, set_name, schema_dict, "")
                except Exception as e:
                    logger.error("Legacy schema import error: %s", e)


# ══════════════════════════════════════════════════════════════════════════
#  OperatorManager
# ══════════════════════════════════════════════════════════════════════════
class OperatorManager:
    def __init__(self, base_dir: str):
        self.store = _ensure_store(base_dir)

    def list(self) -> List[str]:
        return [n for n, _, _, _ in self.store.list_commands()]

    # ------------------------------------------------------------------
    # Legacy helpers expected by UI
    # ------------------------------------------------------------------
    def list_operators(self) -> List[str]:
        """
        Backwards-compatible alias for :meth:`list`.  The UI calls
        ``list_operators()`` when populating the operators tab.
        """
        return self.list()

    def load_schema(self, name: str) -> Dict[str, Any]:
        """
        Backwards-compatible alias for :meth:`load`.  Returns the
        operator's schema as a plain dictionary.
        """
        return self.load(name)

    def load(self, name: str) -> Dict[str, Any]:
        with self.store._pool.get() as c:
            row = c.execute("SELECT json FROM operators WHERE name=?", (name,)).fetchone()
        return json.loads(row[0]) if row else {}

    def save(self, name: str, schema: Dict[str, Any]) -> None:
        self.store.upsert_command(
            name,
            schema.get("weight", 0),
            schema.get("locked", False),
            schema.get("category"),
        )


# ══════════════════════════════════════════════════════════════════════════
#  DatasetManager (metadata in DB; raw text on disk)
# ══════════════════════════════════════════════════════════════════════════
@dataclass
class DatasetEntry:
    name: str
    path: str
    active: bool

class DatasetManager(QtCore.QObject):
    datasetListChanged = QtCore.pyqtSignal()

    def __init__(self, base_dir: str):
        super().__init__()
        self.base_dir     = base_dir
        self.root         = os.path.join(base_dir, "datasets")
        self.datasets_dir = self.root
        os.makedirs(self.root, exist_ok=True)
        self.store        = _ensure_store(base_dir)

    def _path_for(self, name: str) -> str:
        return os.path.join(self.root, name, "data.txt")

    def list(self) -> List[DatasetEntry]:
        with self.store._pool.get() as c:
            rows = c.execute(
                "SELECT name, original_path, active FROM datasets ORDER BY name"
            ).fetchall()
        return [DatasetEntry(r[0], r[1], bool(r[2])) for r in rows]

    # ------------------------------------------------------------------
    # Legacy helpers expected by the UI
    # ------------------------------------------------------------------
    @property
    def entries(self) -> Dict[str, DatasetEntry]:
        """
        Return a mapping of dataset name → DatasetEntry.  Many UI
        components iterate over ``dataset_mgr.entries.items()`` to
        display the current datasets.
        """
        return {d.name: d for d in self.list()}

    def add_dataset(self, name: str, src_path: str) -> None:
        """
        Alias for :meth:`add`.  Mirrors the original API where
        ``add_dataset`` saved the file contents into the managed
        datasets directory.
        """
        self.add(name, src_path)

    def delete_dataset(self, name: str) -> None:
        """
        Alias for :meth:`delete`.  Removes the dataset completely.
        """
        self.delete(name)

    def toggle_active(self, name: str, active: bool) -> None:
        """
        Alias for :meth:`toggle`.  Enables or disables a dataset.
        """
        self.toggle(name, active)

    def load_dataset_text(self, entry: DatasetEntry) -> Optional[str]:
        """
        Load the full text of a dataset entry.  For plain text files
        this simply reads and returns the file contents.  For PDF
        files no conversion is attempted – callers should handle
        alternative formats.  Returns ``None`` on error.
        """
        try:
            path = entry.path
            if not os.path.isfile(path):
                return None
            _, ext = os.path.splitext(path)
            ext = ext.lower()
            if ext in {".txt", ".md", ".json", ".py"}:
                with open(path, "r", encoding="utf-8", errors="ignore") as fh:
                    return fh.read()
            elif ext == ".pdf":
                # basic fallback: return None; PDF parsing requires additional deps
                return None
            else:
                # unknown format; attempt text read
                with open(path, "r", encoding="utf-8", errors="ignore") as fh:
                    return fh.read()
        except Exception:
            return None

    def add(self, name: str, src_path: str) -> None:
        if not name.strip():
            raise ValueError("dataset name required")
        if any(ds.name == name for ds in self.list()):
            raise FileExistsError("dataset already exists")
        dst_dir  = os.path.join(self.root, name)
        os.makedirs(dst_dir, exist_ok=True)
        dst_file = shutil.copy2(src_path, self._path_for(name))
        with self.store.tx() as c:
            c.execute(
                "INSERT INTO datasets (name,active,original_path) VALUES (?,?,?)",
                (name, 1, dst_file),
            )
        self.datasetListChanged.emit()

    def toggle(self, name: str, active: bool) -> None:
        with self.store.tx() as c:
            c.execute("UPDATE datasets SET active=? WHERE name=?", (1 if active else 0, name))
        self.datasetListChanged.emit()

    def delete(self, name: str) -> None:
        try:
            shutil.rmtree(os.path.dirname(self._path_for(name)), ignore_errors=True)
        except Exception:
            pass
        with self.store.tx() as c:
            c.execute("DELETE FROM datasets WHERE name=?", (name,))
        self.datasetListChanged.emit()


# ══════════════════════════════════════════════════════════════════════════
#  RAGCache (embeddings cache)
# ══════════════════════════════════════════════════════════════════════════
try:
    import numpy as np
    from sentence_transformers import SentenceTransformer
except Exception:
    np = None
    SentenceTransformer = None  # type: ignore

class RAGCache:
    def __init__(self, model: Optional[Any], model_name: str, datasets_root: str):
        self.model       = model
        self.model_name  = model_name
        self.root        = datasets_root
        self._mem: Dict[str, Dict[str, Any]] = {}

    def _cache_path(self, ds_path: str) -> str:
        base = f"embeddings_{self.model_name}.npz"
        return os.path.join(os.path.dirname(ds_path), base)

    def _encode(self, sentences: List[str]) -> Optional["np.ndarray"]:
        if self.model is None or np is None:
            return None
        try:
            emb = self.model.encode(sentences, convert_to_numpy=True, normalize_embeddings=True)  # type: ignore
        except TypeError:
            emb = self.model.encode(sentences, convert_to_numpy=True)  # type: ignore
            emb = emb / (np.linalg.norm(emb, axis=1, keepdims=True) + 1e-9)  # type: ignore
        return np.asarray(emb)

    def load_or_build(self, ds_entry: DatasetEntry, full_text: str) -> Optional[Dict[str, Any]]:
        if self.model is None or np is None:
            return None
        key = ds_entry.path
        if key in self._mem:
            return self._mem[key]

        cache_path = self._cache_path(key)
        if os.path.isfile(cache_path):
            try:
                data = np.load(cache_path, allow_pickle=False)
                with open(cache_path.replace(".npz", ".json"), "r", encoding="utf-8") as fh:
                    sents = json.load(fh)
                self._mem[key] = {"sentences": sents, "emb": data["emb"]}
                return self._mem[key]
            except Exception:
                pass

        sentences = [s.strip() for s in full_text.split("\n") if s.strip()] or [full_text[:500]]
        emb = self._encode(sentences)
        if emb is None:
            return None
        self._mem[key] = {"sentences": sentences, "emb": emb}
        try:
            np.savez_compressed(cache_path, emb=emb)
            with open(cache_path.replace(".npz", ".json"), "w", encoding="utf-8") as fh:
                json.dump(sentences, fh)
        except Exception:
            pass
        return self._mem[key]

    def clear_memory(self) -> None:
        self._mem.clear()

    def clear_disk(self) -> int:
        removed = 0
        for root, _, files in os.walk(self.root):
            for fn in files:
                if fn.startswith("embeddings_") and fn.endswith((".npz", ".json")):
                    try:
                        os.remove(os.path.join(root, fn))
                        removed += 1
                    except Exception:
                        pass
        return removed


# ══════════════════════════════════════════════════════════════════════════
#  SnapshotEngine (“system self-perception”)
# ══════════════════════════════════════════════════════════════════════════
class SnapshotEngine(QtCore.QObject):
    snapshotFinished = QtCore.pyqtSignal(int)

    def __init__(self, base_dir: str):
        super().__init__()
        self.store    = _ensure_store(base_dir)
        self.base_dir = base_dir

    def run_snapshot(self, root: Optional[str] = None, *, chunk_bytes: int = 8192) -> None:
        threading.Thread(
            target=self._worker,
            args=(root or self.base_dir, chunk_bytes),
            daemon=True,
        ).start()

    def _worker(self, root: str, chunk_sz: int):
        rows = 0
        with self.store._pool.get() as c:
            for dirpath, _, files in os.walk(root):
                if "__pycache__" in dirpath or ".git" in dirpath:
                    continue
                for fn in files:
                    path = os.path.join(dirpath, fn)
                    try:
                        st            = os.stat(path)
                        size, mtime   = st.st_size, st.st_mtime
                        sha           = hashlib.sha256(open(path, "rb").read()).hexdigest()
                        mime          = mimetypes.guess_type(fn)[0] or "application/octet-stream"
                        if mime.startswith(("text/", "application/json", "application/xml")) and size <= 2_000_000:
                            data   = open(path, "r", encoding="utf-8", errors="ignore").read()
                            chunks = [data[i : i + chunk_sz] for i in range(0, len(data), chunk_sz)] or [""]
                        else:
                            chunks = [""]
                        for idx, chunk in enumerate(chunks):
                            c.execute(
                                """
                                INSERT INTO system_files
                                  (path,size,mtime,sha256,mime,chunk_index,content)
                                VALUES (?,?,?,?,?,?,?)
                                ON CONFLICT(path) DO UPDATE SET
                                  size  = excluded.size,
                                  mtime = excluded.mtime,
                                  sha256= excluded.sha256
                                """,
                                (path, size, mtime, sha, mime, idx, chunk),
                            )
                            rows += 1
                    except Exception as e:
                        logger.warning("snapshot skip %s: %s", path, e)
            c.connection.commit()
        self.snapshotFinished.emit(rows)


# ══════════════════════════════════════════════════════════════════════════
#  SpatialPositionManager (grid-room positions & logs)
# ══════════════════════════════════════════════════════════════════════════
class SpatialPositionManager(QtCore.QObject):
    positionChanged = QtCore.pyqtSignal(str, int, int)
    actionLogged    = QtCore.pyqtSignal(str, str)

    def __init__(self, base_dir: str):
        super().__init__()
        self.store = _ensure_store(base_dir)

    def _log_action(self, entity: str, action: str, location: str, justification: str) -> None:
        with self.store.tx() as c:
            c.execute(
                "INSERT INTO visual_actions(entity,action,location,justification)"
                " VALUES (?,?,?,?)",
                (entity, action, location, justification),
            )
        self.actionLogged.emit(entity, action)

    def update_position(self, entity: str, x: int, y: int, *, facing: str = "right", color: str = "#F8BBD0") -> None:
        with self.store.tx() as c:
            c.execute(
                "INSERT INTO spatial_positions(entity,x,y,facing,color)"
                " VALUES(?,?,?,?,?)",
                (entity, x, y, facing, color),
            )
        self.positionChanged.emit(entity, x, y)

    def latest_position(self, entity: str) -> Optional[Tuple[int, int]]:
        with self.store._pool.get() as c:
            row = c.execute(
                "SELECT x,y FROM spatial_positions WHERE entity=? ORDER BY id DESC LIMIT 1",
                (entity,),
            ).fetchone()
        return (row[0], row[1]) if row else None


# ───────────────────────────────────────────────────────────────────────────
# Back-compatibility alias
# ───────────────────────────────────────────────────────────────────────────
SchemaManager = SchemaEngine


# ══════════════════════════════════════════════════════════════════════════
#  Public module API
# ══════════════════════════════════════════════════════════════════════════
__all__ = [
    "Schema", "SchemaEngine", "SchemaManager",
    "OperatorManager",
    "DatasetEntry", "DatasetManager",
    "RAGCache",
    "SnapshotEngine", "SpatialPositionManager",
]
```

core_schema.py — v3-final (2025-08-04 04:12 UTC)
================================================

Single-source authority for all schema / dataset / snapshot / spatial-state
logic used by FATHOM Agent, now relying on AgentStore’s public API only.

Provides:
• Schema dataclass + SchemaEngine (diff, auto-evolve, variant injection)
• OperatorManager persisted in the same DB
• DatasetManager (metadata) + RAGCache (embeddings) in the same DB
• SnapshotEngine to walk the codebase & persist chunks to DB
• SpatialPositionManager for grid-room positions & movement logging
• Back-compat alias: SchemaManager → SchemaEngine

This version adds the `.active_schemas` property required by main_ui.py.
**Classes:** Schema, SchemaEngine, OperatorManager, DatasetEntry, DatasetManager, RAGCache, SnapshotEngine, SpatialPositionManager
**Functions:** _ensure_store(root)


## Module `Rant_PDD\Projects\AI_TTS_AGENT\burner_scripts\main_ui.py`

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
main_ui.py
===========

This module contains the top-level ``AppWindow`` class for the AI TTS
Agent.  It orchestrates all layout and docking behaviour, integrates
the control panel and persona tabs provided by ``commands_panel`` and
``persona_tab``, and exposes a unified interface for the rest of the
application.  None of the core agent logic lives here – that remains in
the ``core_*`` modules.  This refactor pulls the bulky UI building
logic out of the monolithic script and into dedicated modules while
preserving all existing behaviour and wiring.
"""

from __future__ import annotations

import os
import json
import time
import re
import subprocess
import threading
from typing import Dict, List, Tuple, Optional


from PyQt5 import QtCore, QtGui, QtWidgets

# Optional spell checker
try:
    from spellchecker import SpellChecker  # type: ignore
except Exception:
    SpellChecker = None  # type: ignore
from PyQt5.QtCore import QSettings, QRunnable, QThreadPool
from functools import partial

# Optional deps
try:
    from sentence_transformers import SentenceTransformer  # type: ignore
except Exception:
    SentenceTransformer = None  # type: ignore
try:
    import numpy as np  # type: ignore
except Exception:
    np = None  # type: ignore
try:
    import sounddevice as sd  # type: ignore
except Exception:
    sd = None  # type: ignore

# Import core orchestrator components instead of the monolithic agent_core.
# The modular agent splits responsibilities across core_base, core_schema and
# core_orchestrator.  AgentCore and ModelWorker live in core_orchestrator.
from core_orchestrator import (
    AgentCore,
    ModelWorker,
)

from snapshot_worker import ModelWorker

# ─── Command-Palette import ───────────────────────────────────────────
from command_palette import CommandPaletteDock

# Import the modular UI components
from commands_panel import CommandsPanel
from persona_tab import PersonaTab

ROLE_COLOURS: Dict[str, str] = {
    "user": "#FFF8E1",
    "zira": "#E3F2FD",
    "system": "#E0F7FA",
    "operator": "#EDE7F6",
}
NAME_COLOURS: Dict[str, str] = {
    "user": "#5D4037",
    "zira": "#0D47A1",
    "system": "#006064",
    "operator": "#4A148C",
}


# ---------------------------------------------------------------------------
# Spell highlighting for misspelled words
# ---------------------------------------------------------------------------
class _SpellHighlighter(QtGui.QSyntaxHighlighter):
    """
    Underlines misspelled words in red. Uses pyspellchecker if available.
    """

    def __init__(self, document: QtGui.QTextDocument) -> None:
        super().__init__(document)
        # instantiate spell checker only if available
        self._spell = SpellChecker() if SpellChecker else None
        self._format = QtGui.QTextCharFormat()
        self._format.setUnderlineStyle(QtGui.QTextCharFormat.SpellCheckUnderline)
        self._format.setUnderlineColor(QtCore.Qt.red)
        # simple cache to avoid recomputing spelling on common words
        self._cache: Dict[str, bool] = {}

    def highlightBlock(self, text: str) -> None:
        if not self._spell:
            return
        for match in re.finditer(r"[A-Za-z']{3,}", text):
            word = match.group(0).lower()
            bad = self._cache.get(word)
            if bad is None:
                bad = word not in self._spell
                # prune cache occasionally
                if len(self._cache) > 2048:
                    self._cache.clear()
                self._cache[word] = bad
            if bad:
                start, end = match.span()
                length = end - start
                self.setFormat(start, length, self._format)


class AppWindow(QtWidgets.QMainWindow):
    """Main application window for the AI TTS Agent."""

    rewrite_ready = QtCore.pyqtSignal(str)

    def __init__(self) -> None:
        super().__init__()
        self.setWindowTitle("AI TTS Agent v2")
        self.resize(1920, 1080)

        self.base_dir = os.path.dirname(os.path.abspath(__file__))
        self.core = AgentCore(self.base_dir, persona="zira", set_name="default")

        self.current_set: Dict[str, str] = dict(self.core.schema_mgr.active_schemas)
        self.active_persona: str = self.core.persona or "zira"

        self.isolated_history: List[Tuple[str, str]] = []
        self.self_talk_enabled: bool = False
        self._plugin_docks: Dict[str, QtWidgets.QDockWidget] = {}
        self._schema_save_timers: Dict[str, QtCore.QTimer] = {}

        self._idle_timer = QtCore.QTimer(self)
        self._idle_timer.setSingleShot(True)
        self._idle_timer.timeout.connect(self._handle_idle)

        self._restore_layout()
        self._build_ui()
        # build the slash command panel (custom dock)
        self._build_command_dock()
        self._connect_signals()
        
            # ── Command Palette setup ─────────────────────────────────────────
        self.cmd_palette = CommandPaletteDock(self)
        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.cmd_palette)
        # update palette whenever commands change
        self.core.commandsChanged.connect(self.cmd_palette.set_command_list)
        # insert chosen command into chat input
        self.cmd_palette.commandActivated.connect(self._insert_into_chat)


        try:
            self.core.audio_recorder.transcribed.connect(self._on_transcribed)
        except Exception:
            pass

        self._update_feedback_counts()
        self._bootstrap_conversation()
        self._reset_idle_timer()

        # populate initial slash command list
        try:
            self._populate_command_select()
        except Exception:
            pass

    # ────────────────────────── signals
    def _connect_signals(self) -> None:
        self.btn_send.clicked.connect(self.send_message)

        # Recording controls come from the commands panel
        self.btn_record.clicked.connect(self.start_recording)
        self.btn_stop_rec.clicked.connect(self.stop_recording)

        self.voice_combo.currentTextChanged.connect(self._on_voice_changed)
        # update settings when a new model is selected
        self.model_combo.currentTextChanged.connect(self._on_model_changed)

        self.btn_play.clicked.connect(self._on_play)
        self.btn_stop_tts.clicked.connect(self._on_stop_tts)
        self.btn_replay.clicked.connect(self._on_replay)

        self.btn_like.clicked.connect(self._on_like)
        self.btn_dislike.clicked.connect(self._on_dislike)
        self.btn_manage_feedback.clicked.connect(self._on_manage_feedback)

        self.btn_refresh.clicked.connect(self._on_refresh_chat)
        self.btn_manage_datasets.clicked.connect(self._on_manage_datasets)
        self.btn_inner_monologue.clicked.connect(self._on_inner_monologue)
        self.btn_clear_rag.clicked.connect(self._on_clear_rag_cache)
        self.btn_model_manager.clicked.connect(self._on_show_model_manager)

        self.chk_semantic.toggled.connect(self._on_semantic_toggled)
        self.chk_isolated.toggled.connect(self._on_isolated_toggled)
        self.chk_self_talk.toggled.connect(lambda v: setattr(self, "self_talk_enabled", v))
        self.chk_auto_schema.toggled.connect(self._on_auto_schema_toggled)

        # connect Google STT checkbox
        try:
            self.chk_google_stt.toggled.connect(self._on_google_stt_toggled)
        except Exception:
            pass

        self.rewrite_ready.connect(self._apply_rewrite_result)

        # context menu for chat view to send selection to command input
        try:
            self.chat_view.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
            self.chat_view.customContextMenuRequested.connect(self._show_chat_context_menu)
        except Exception:
            pass
        # custom context menu for spell suggestions on input field
        try:
            self.input_edit.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
            self.input_edit.customContextMenuRequested.connect(self._show_input_context_menu)
        except Exception:
            pass
            
    def _on_show_command_palette(self) -> None:
        """Toggle the command-palette dock."""
        if self.cmd_palette.isVisible():
            self.cmd_palette.hide()
        else:
            self.cmd_palette.show()
            self.cmd_palette.raise_()
            self.cmd_palette.search_edit.setFocus(QtCore.Qt.ShortcutFocusReason)

    def _insert_into_chat(self, cmd: str) -> None:
        """Insert a slash-command into the chat input."""
        self.input_edit.insertPlainText(cmd + " ")
        self.input_edit.setFocus()                       

    # ────────────────────────── layout & lifecycle
    def _restore_layout(self) -> None:
        qsettings = QSettings("xAI", "AI_TTS_Agent")
        try:
            self.restoreGeometry(qsettings.value("geometry", b""))
            self.restoreState(qsettings.value("windowState", b""))
        except Exception:
            pass

    def closeEvent(self, event: QtGui.QCloseEvent) -> None:
        qsettings = QSettings("xAI", "AI_TTS_Agent")
        qsettings.setValue("geometry", self.saveGeometry())
        qsettings.setValue("windowState", self.saveState())
        try:
            self.core.close()
        except Exception:
            pass
        super().closeEvent(event)

    # ────────────────────────── UI build
    def _build_ui(self) -> None:
        self.setStyleSheet(
            """
            QWidget { background-color: #2e3a51; color: #e0e0e0; }
            QGroupBox { border: 1px solid #007acc; margin-top: 7px; }
            QGroupBox::title { subcontrol-origin: margin; left: 12px; padding: 0 4px; }
            QPushButton { background-color: #3c4a6b; color: white; border: 1px solid #007acc; padding: 5px; }
            QPushButton:disabled { background-color: #5a5a7a; color: #c0c0c0; border: 1px solid #555555; }
            QPlainTextEdit, QTextEdit { background-color: #1e2738; color: #e0e0e0; border: 1px solid #007acc; }
            QLineEdit { background-color: #1e2738; color: #e0e0e0; border: 1px solid #007acc; }
            QTabBar::tab { background: #3c4a6b; color: white; border: 1px solid #007acc; padding: 5px 10px; }
            QTabBar::tab:selected { background: #007acc; color: white; }
            QComboBox { background-color: #1e2738; color: #e0e0e0; border: 1px solid #007acc; padding: 3px; }
            QListWidget { background-color: #1e2738; color: #e0e0e0; border: 1px solid #007acc; }
            QCheckBox, QLabel { color: #e0e0e0; }
            """
        )
        self.setDockOptions(
            QtWidgets.QMainWindow.AllowTabbedDocks
            | QtWidgets.QMainWindow.AllowNestedDocks
            | QtWidgets.QMainWindow.AnimatedDocks
        )
        self.setTabPosition(QtCore.Qt.AllDockWidgetAreas, QtWidgets.QTabWidget.North)
        self.setDockNestingEnabled(True)

        tb = QtWidgets.QToolBar("Layout", self)
        tb.setMovable(False)
        self.addToolBar(QtCore.Qt.TopToolBarArea, tb)
        self.chk_lock = QtWidgets.QCheckBox("Lock Layout")
        act = QtWidgets.QWidgetAction(self)
        act.setDefaultWidget(self.chk_lock)
        tb.addAction(act)
        self.chk_lock.toggled.connect(self._on_toggle_lock)

        self.setCentralWidget(QtWidgets.QWidget())
        status = QtWidgets.QStatusBar()
        self.setStatusBar(status)
        self.dock_tray = DockTray(self)
        status.addPermanentWidget(self.dock_tray, 1)

        self.progress_bar = QtWidgets.QProgressBar()
        self.progress_bar.setRange(0, 0)
        self.progress_bar.setVisible(False)
        status.addPermanentWidget(self.progress_bar)

        # Tabs for personas / operators are handled by PersonaTab
        # Chat panel
        self.chat_view = QtWidgets.QTextEdit()
        self.chat_view.setReadOnly(True)
        self.chat_view.setStyleSheet("background-color: #e0eef5; color: #011627;")
        self.chat_view.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        self.input_edit = QtWidgets.QPlainTextEdit()
        self.input_edit.setPlaceholderText("Type your message or use /remember key value, /showfacts, /style, /weights")
        self.input_edit.setMinimumHeight(64)
        self.input_edit.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        # Attach spell checker highlighter if available
        try:
            if SpellChecker:
                self._spell_highlighter = _SpellHighlighter(self.input_edit.document())  # type: ignore[attr-defined]
        except Exception:
            self._spell_highlighter = None
        self.btn_send = QtWidgets.QPushButton("Send")

        chat_container = QtWidgets.QWidget()
        cv = QtWidgets.QVBoxLayout(chat_container)
        cv.setContentsMargins(7, 7, 7, 7)
        cv.setSpacing(7)
        cv.addWidget(self.chat_view, 1)
        cv.addWidget(self.input_edit)
        row = QtWidgets.QHBoxLayout()
        row.addStretch()
        row.addWidget(self.btn_send)
        cv.addLayout(row)

        # ───── Instantiate modular panels
        # Commands panel (controls)
        self.commands_panel = CommandsPanel(self)
        # Copy child attributes to the AppWindow so existing logic continues to work
        for name in [
            'btn_record','btn_stop_rec','device_combo','chk_semantic','chk_isolated','chk_mute_tts',
            'chk_self_talk','chk_auto_schema','chk_google_stt','btn_clear_rag','btn_refresh',
            'btn_manage_datasets','btn_inner_monologue','btn_model_manager','style_label',
            'response_edit','btn_like','btn_dislike','btn_manage_feedback','btn_play','btn_stop_tts',
            'btn_replay','voice_combo','model_combo','lbl_feedback_counts'
        ]:
            setattr(self, name, getattr(self.commands_panel, name))

        # Persona panel
        self.persona_panel = PersonaTab(self)
        # Copy persona panel attributes
        self.tabs = self.persona_panel.tabs
        self.tab_widgets = self.persona_panel.tab_widgets
        self.operator_tab = self.persona_panel.operator_tab
        self.lbl_active_names = self.persona_panel.lbl_active_names

        # Docks
        # Controls dock
        controls_scroll = QtWidgets.QScrollArea()
        controls_scroll.setWidgetResizable(True)
        controls_scroll.setFrameShape(QtWidgets.QFrame.NoFrame)
        controls_scroll.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)
        controls_scroll.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        controls_scroll.setWidget(self.commands_panel)

        self.controls_dock = QtWidgets.QDockWidget("Controls", self)
        self.controls_dock.setObjectName("ControlsDock")
        self.controls_dock.setWidget(controls_scroll)
        self.controls_dock.setFeatures(
            QtWidgets.QDockWidget.DockWidgetClosable
            | QtWidgets.QDockWidget.DockWidgetMovable
            | QtWidgets.QDockWidget.DockWidgetFloatable
        )

        # Persona dock
        self.persona_dock = QtWidgets.QDockWidget("Personas", self)
        self.persona_dock.setObjectName("PersonaDock")
        self.persona_dock.setWidget(self.persona_panel)
        self.persona_dock.setFeatures(
            QtWidgets.QDockWidget.DockWidgetClosable
            | QtWidgets.QDockWidget.DockWidgetMovable
            | QtWidgets.QDockWidget.DockWidgetFloatable
        )

        # Chat dock
        self.chat_dock = QtWidgets.QDockWidget("Chat", self)
        self.chat_dock.setObjectName("ChatDock")
        self.chat_dock.setWidget(chat_container)
        self.chat_dock.setFeatures(
            QtWidgets.QDockWidget.DockWidgetClosable
            | QtWidgets.QDockWidget.DockWidgetMovable
            | QtWidgets.QDockWidget.DockWidgetFloatable
        )

        # Model dock
        self.model_dock = QtWidgets.QDockWidget("Models", self)
        self.model_dock.setObjectName("ModelDock")
        self.model_dock.setFeatures(
            QtWidgets.QDockWidget.DockWidgetClosable
            | QtWidgets.QDockWidget.DockWidgetMovable
            | QtWidgets.QDockWidget.DockWidgetFloatable
        )
        self._build_model_manager()

        # Plugins dock
        self.plugins_dock = QtWidgets.QDockWidget("Plugins", self)
        self.plugins_dock.setObjectName("PluginsDock")
        self.plugins_dock.setFeatures(
            QtWidgets.QDockWidget.DockWidgetClosable
            | QtWidgets.QDockWidget.DockWidgetMovable
            | QtWidgets.QDockWidget.DockWidgetFloatable
        )
        self.plugins_dock.setWidget(self._build_plugins_widget())

        # Titles & dock tray
        self.controls_dock.setTitleBarWidget(DockTitleBar(self.controls_dock, "Controls"))
        self.persona_dock.setTitleBarWidget(DockTitleBar(self.persona_dock, "Personas"))
        self.chat_dock.setTitleBarWidget(DockTitleBar(self.chat_dock, "Chat"))
        self.model_dock.setTitleBarWidget(DockTitleBar(self.model_dock, "Models"))
        self.plugins_dock.setTitleBarWidget(DockTitleBar(self.plugins_dock, "Plugins"))

        # Register docks with the tray
        for d in (self.controls_dock, self.persona_dock, self.chat_dock, self.model_dock, self.plugins_dock):
            self.dock_tray.register_dock(d)

        # Add docks to the layout
        self.addDockWidget(QtCore.Qt.LeftDockWidgetArea, self.controls_dock)
        self.addDockWidget(QtCore.Qt.LeftDockWidgetArea, self.persona_dock)
        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.chat_dock)
        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.model_dock)
        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.plugins_dock)

        # Splitters as before
        self.splitDockWidget(self.controls_dock, self.persona_dock, QtCore.Qt.Vertical)
        self.splitDockWidget(self.controls_dock, self.chat_dock, QtCore.Qt.Horizontal)
        self.splitDockWidget(self.chat_dock, self.model_dock, QtCore.Qt.Horizontal)
        self.splitDockWidget(self.model_dock, self.plugins_dock, QtCore.Qt.Horizontal)

    # The remainder of the methods are largely unchanged from the original
    # implementation.  They continue to reference widgets via ``self`` which
    # now refer to the proxies created from the modular panels.

    # ────────────────────────── persona widgets (removed UI build; logic preserved)
    def _on_tab_changed(self, index: int) -> None:
        """
        Handle tab changes in the main tab widget.

        Parameters
        ----------
        index : int
            Index of the newly selected tab.
        """
        try:
            tab_name = self.tabs.tabText(index)
            print(f"[UI] Tab changed to: {tab_name} (index {index})")
            # Add any extra logic if needed, for example:
            # self._update_feedback_counts()
        except Exception as e:
            print(f"[UI] Error handling tab change: {e}")

    # ────────────────────────── operator tab (moved to persona_tab module)
    # ────────────────────────── plugins
    def _build_plugins_widget(self) -> QtWidgets.QWidget:
        container = QtWidgets.QWidget()
        layout = QtWidgets.QVBoxLayout(container)
        layout.setContentsMargins(6, 6, 6, 6)
        layout.setSpacing(4)

        self.plugin_list = QtWidgets.QListWidget()
        self.plugin_list.setSelectionMode(QtWidgets.QAbstractItemView.NoSelection)
        layout.addWidget(self.plugin_list, 1)

        btn_rescan = QtWidgets.QPushButton("Rescan")
        layout.addWidget(btn_rescan)
        btn_rescan.clicked.connect(self._rescan_plugins)

        self._populate_plugin_list()
        self.plugin_list.itemChanged.connect(self._on_plugin_item_changed)

        try:
            self.core.plugins.eventReceived.connect(self._on_plugin_event)
        except Exception:
            pass

        return container

    def _populate_plugin_list(self) -> None:
        self.plugin_list.blockSignals(True)
        self.plugin_list.clear()
        for meta in self.core.plugins.list_plugins():
            item = QtWidgets.QListWidgetItem(meta.name)
            flags = item.flags() | QtCore.Qt.ItemIsUserCheckable
            if meta.missing_dependencies:
                flags &= ~QtCore.Qt.ItemIsEnabled
                item.setToolTip(f"Missing dependencies: {', '.join(meta.missing_dependencies)}")
            item.setFlags(flags)
            item.setCheckState(QtCore.Qt.Checked if meta.enabled else QtCore.Qt.Unchecked)
            self.plugin_list.addItem(item)
        self.plugin_list.blockSignals(False)

    def _on_plugin_item_changed(self, item: QtWidgets.QListWidgetItem) -> None:
        name = item.text()
        enabled = item.checkState() == QtCore.Qt.Checked
        self.core.plugins.enable_plugin(name, enabled)
        meta = next((m for m in self.core.plugins.list_plugins() if m.name == name), None)
        if not meta:
            return
        if enabled and meta.widget is not None:
            self._attach_plugin_widget(meta)
        elif not enabled:
            self._detach_plugin_widget(name)

    def _rescan_plugins(self) -> None:
        self.core.plugins.rescan()
        for name in list(self._plugin_docks.keys()):
            meta = next((m for m in self.core.plugins.list_plugins() if m.name == name), None)
            if not meta or not meta.enabled:
                self._detach_plugin_widget(name)
        self._populate_plugin_list()

    def _attach_plugin_widget(self, meta: 'object') -> None:
        if meta.name in self._plugin_docks:
            return
        if meta.widget is None:
            return
        dock = QtWidgets.QDockWidget(meta.name, self)
        dock.setObjectName(f"PluginDock_{meta.name}")
        dock.setWidget(meta.widget)
        dock.setFeatures(
            QtWidgets.QDockWidget.DockWidgetClosable
            | QtWidgets.QDockWidget.DockWidgetMovable
            | QtWidgets.QDockWidget.DockWidgetFloatable
        )
        dock.setTitleBarWidget(DockTitleBar(dock, meta.name))
        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, dock)
        self.dock_tray.register_dock(dock)
        self._plugin_docks[meta.name] = dock

    def _detach_plugin_widget(self, name: str) -> None:
        dock = self._plugin_docks.pop(name, None)
        if dock:
            self.dock_tray._remove_button(dock)
            dock.setParent(None)
            dock.deleteLater()

    @QtCore.pyqtSlot(str, dict)
    def _on_plugin_event(self, sender: str, envelope: dict) -> None:
        try:
            data = envelope.get("data")
            msg = json.dumps(data, indent=2) if isinstance(data, (dict, list)) else str(data)
            display_name = sender
            self._append_message(display_name, msg, role_key="operator")
            if self.chk_semantic.isChecked() and not self.chk_isolated.isChecked():
                self.core.conversation_db.save_message(sender.lower(), msg)
        except Exception as e:
            print(f"Error handling plugin event from {sender}: {e}")

    # ────────────────────────── model manager
    def _build_model_manager(self) -> None:
        widget = QtWidgets.QWidget()
        v = QtWidgets.QVBoxLayout(widget)
        v.setContentsMargins(8, 8, 8, 8)
        v.setSpacing(6)
        self.model_list = QtWidgets.QListWidget()
        v.addWidget(self.model_list, 1)
        h = QtWidgets.QHBoxLayout()
        self.btn_model_pull = QtWidgets.QPushButton("Pull")
        self.btn_model_delete = QtWidgets.QPushButton("Delete")
        self.btn_model_set_default = QtWidgets.QPushButton("Set as Default")
        h.addWidget(self.btn_model_pull)
        h.addWidget(self.btn_model_delete)
        h.addWidget(self.btn_model_set_default)
        h.addStretch()
        v.addLayout(h)
        self.model_dock.setWidget(widget)
        self._refresh_model_list()
        self.btn_model_pull.clicked.connect(self._on_model_pull)
        self.btn_model_delete.clicked.connect(self._on_model_delete)
        self.btn_model_set_default.clicked.connect(self._on_model_set_default)

    def _refresh_model_list(self) -> None:
        self.model_list.clear()
        models: List[str] = []
        try:
            out = subprocess.run(
                ["ollama", "list"],
                stdout=subprocess.PIPE,
                stderr=subprocess.DEVNULL,
                text=True,
                check=True,
            ).stdout.splitlines()
            for line in out[1:]:
                parts = line.strip().split()
                if parts:
                    models.append(parts[0])
        except Exception:
            models = []
        for m in models:
            item = QtWidgets.QListWidgetItem(m)
            if m == self.model_combo.currentText().strip():
                item.setFont(QtGui.QFont("", weight=QtGui.QFont.Bold))
            self.model_list.addItem(item)

    def _on_model_pull(self) -> None:
        item = self.model_list.currentItem()
        if not item:
            return
        model = item.text()
        threading.Thread(target=lambda: subprocess.run(["ollama", "pull", model], check=False), daemon=True).start()
        QtWidgets.QMessageBox.information(self, "Pull Started", f"Pulling {model} in background.")

    def _on_model_delete(self) -> None:
        item = self.model_list.currentItem()
        if not item:
            return
        model = item.text()
        if QtWidgets.QMessageBox.question(
            self,
            "Delete Model",
            f"Delete '{model}'? This cannot be undone.",
            QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No,
        ) != QtWidgets.QMessageBox.Yes:
            return
        threading.Thread(target=lambda: subprocess.run(["ollama", "delete", model], check=False), daemon=True).start()
        QtWidgets.QMessageBox.information(self, "Delete Started", f"Deleting {model} in background.")
        self._refresh_model_list()

    def _on_model_set_default(self) -> None:
        item = self.model_list.currentItem()
        if not item:
            return
        model = item.text()
        idx = self.model_combo.findText(model)
        if idx >= 0:
            self.model_combo.setCurrentIndex(idx)
        # persist selection to settings
        try:
            self.core.settings.default_model = model
            self.core.settings.save()
        except Exception:
            pass
            QtWidgets.QMessageBox.information(self, "Default Model", f"Set default model to {model}.")
        else:
            self.model_combo.addItem(model)
            self.model_combo.setCurrentText(model)

    # ────────────────────────── lock layout
    def _on_toggle_lock(self, locked: bool) -> None:
        feats_unlocked = (
            QtWidgets.QDockWidget.DockWidgetClosable
            | QtWidgets.QDockWidget.DockWidgetMovable
            | QtWidgets.QDockWidget.DockWidgetFloatable
        )
        feats_locked = QtWidgets.QDockWidget.DockWidgetClosable
        for dock in (
            self.controls_dock,
            self.persona_dock,
            self.chat_dock,
            getattr(self, "inner_dock", None),
            self.model_dock,
            self.plugins_dock,
        ):
            if dock is None:
                continue
            dock.setFeatures(feats_locked if locked else feats_unlocked)
        for dock in self._plugin_docks.values():
            dock.setFeatures(feats_locked if locked else feats_unlocked)

    # ────────────────────────── audio
    def start_recording(self) -> None:
        if sd is None or np is None:
            QtWidgets.QMessageBox.information(self, "Recording Unavailable", "sounddevice/numpy not installed.")
            return
        if not self.btn_record.isEnabled():
            return
        device_index = None
        try:
            idx = self.device_combo.currentIndex()
            selected_name = self.device_combo.currentText()
            for i, d in enumerate(sd.query_devices()):
                if d.get("name") == selected_name and d.get("max_input_channels", 0) > 0:
                    device_index = i
                    break
        except Exception:
            device_index = None
        self.core.audio_recorder.start(device_index)
        self.btn_record.setEnabled(False)
        self.btn_stop_rec.setEnabled(True)

    def stop_recording(self) -> None:
        if not self.btn_stop_rec.isEnabled():
            return
        self.core.audio_recorder.stop_and_transcribe()
        self.btn_stop_rec.setEnabled(False)
        self.btn_record.setEnabled(True)

    @QtCore.pyqtSlot(str)
    def _on_transcribed(self, text: str) -> None:
        if not text:
            return
        cur = self.input_edit.toPlainText()
        self.input_edit.setPlainText((cur + "\n" if cur else "") + text)

    # ────────────────────────── TTS
    def _on_play(self) -> None:
        text = self.response_edit.toPlainText().strip()
        if text and not self.chk_mute_tts.isChecked():
            try:
                self.core.tts_mgr.enqueue(text)
            except Exception:
                pass

    def _on_stop_tts(self) -> None:
        try:
            self.core.tts_mgr.stop()
        except Exception:
            pass

    def _on_replay(self) -> None:
        if not self.chk_mute_tts.isChecked():
            try:
                self.core.tts_mgr.replay()
            except Exception:
                pass

    def _on_voice_changed(self, name: str) -> None:
        try:
            eng = getattr(self.core.tts_mgr, "_engine", None)
            if eng:
                for v in eng.getProperty("voices"):
                    if v.name == name:
                        eng.setProperty("voice", v.id)
                        break
        except Exception:
            pass

    def _tts_voice_names(self) -> List[str]:
        try:
            eng = getattr(self.core.tts_mgr, "_engine", None)
            if not eng:
                return []
            return [v.name for v in eng.getProperty("voices")]
        except Exception:
            return []

    # ────────────────────────── feedback
    def _on_like(self) -> None:
        text = self.response_edit.toPlainText().strip()
        if not text:
            return
        try:
            self.core.add_feedback(text, liked=True)
        except Exception:
            pass
        QtWidgets.QMessageBox.information(self, "Feedback", "Marked as good response.")
        self._enable_feedback(False)
        self._update_feedback_counts()

    def _on_dislike(self) -> None:
        original = self.response_edit.toPlainText().strip()
        if not original:
            return
        try:
            self.core.tts_mgr.stop()
        except Exception:
            pass
        QtWidgets.QMessageBox.information(self, "Disliked", "The response will be rewritten.")
        self._enable_feedback(False)

        def worker() -> None:
            new_text = self._rewrite_response(original)
            try:
                self.core.add_feedback(original, liked=False, revised=new_text)
            except Exception:
                pass
            if self.chk_isolated.isChecked():
                self.isolated_history.append((self._current_persona(), new_text))
            else:
                if self.chk_semantic.isChecked():
                    self.core.conversation_db.save_message(self._current_persona().lower(), new_text)
            self.rewrite_ready.emit(new_text)

        threading.Thread(target=worker, daemon=True).start()

    @QtCore.pyqtSlot(str)
    def _apply_rewrite_result(self, new_text: str) -> None:
        schema = self.core.schema_mgr.load_schema(
            self._current_persona(), self.current_set.get(self._current_persona(), "default")
        )
        persona_name = schema.get("name", "Bot")
        role_key = self._current_persona().lower()
        self._append_message(persona_name, new_text, role_key=role_key)
        self.response_edit.setPlainText(new_text)
        if not self.chk_mute_tts.isChecked():
            try:
                self.core.tts_mgr.enqueue(new_text)
            except Exception:
                pass
        QtWidgets.QMessageBox.information(self, "Rewritten", "Response rewritten.")
        self._enable_feedback(False)

    def _update_feedback_counts(self) -> None:
        try:
            pos, neg = self.core.feedback_db.get_counts()
            self.lbl_feedback_counts.setText(f"Likes: {pos} | Dislikes: {neg}")
        except Exception:
            self.lbl_feedback_counts.setText("Likes: - | Dislikes: -")

    def _enable_feedback(self, enabled: bool) -> None:
        self.btn_like.setEnabled(enabled)
        self.btn_dislike.setEnabled(enabled)

    def _on_manage_feedback(self) -> None:
        db = self.core.feedback_db
        if db is None:
            QtWidgets.QMessageBox.information(self, "No DB", "Feedback DB unavailable.")
            return
        cur = db.conn.cursor()
        cur.execute("SELECT id, original, liked, COALESCE(revised, '') FROM feedback ORDER BY id DESC")
        entries = cur.fetchall()
        dlg = QtWidgets.QDialog(self)
        dlg.setWindowTitle("Manage Feedback")
        dlg.resize(720, 420)
        v = QtWidgets.QVBoxLayout(dlg)
        table = QtWidgets.QTableWidget(len(entries), 4)
        table.setHorizontalHeaderLabels(["ID", "Original", "Liked", "Revised"])
        table.horizontalHeader().setStretchLastSection(True)
        for r, (fid, orig, liked, rev) in enumerate(entries):
            table.setItem(r, 0, QtWidgets.QTableWidgetItem(str(fid)))
            table.setItem(r, 1, QtWidgets.QTableWidgetItem(orig))
            table.setItem(r, 2, QtWidgets.QTableWidgetItem("✔" if liked else "✖"))
            table.setItem(r, 3, QtWidgets.QTableWidgetItem(rev))
        v.addWidget(table, 1)
        h = QtWidgets.QHBoxLayout()
        btn_del = QtWidgets.QPushButton("Delete Selected")
        btn_close = QtWidgets.QPushButton("Close")
        h.addWidget(btn_del)
        h.addWidget(btn_close)
        h.addStretch()
        v.addLayout(h)

        def on_delete() -> None:
            selected = table.selectedItems()
            if not selected:
                return
            rows = sorted({i.row() for i in selected}, reverse=True)
            for rr in rows:
                fid_item = table.item(rr, 0)
                if fid_item:
                    try:
                        fid = int(fid_item.text())
                        db.conn.execute("DELETE FROM feedback WHERE id = ?", (fid,))
                        db.conn.commit()
                    except Exception:
                        pass
                table.removeRow(rr)
            self._update_feedback_counts()

        btn_del.clicked.connect(on_delete)
        btn_close.clicked.connect(dlg.accept)
        dlg.exec_()

    # ────────────────────────── datasets / rag
    def _on_manage_datasets(self) -> None:
        DatasetManagerDialog(self.core.dataset_mgr, self).exec_()

    def _on_clear_rag_cache(self) -> None:
        if QtWidgets.QMessageBox.question(
            self,
            "Clear RAG Cache",
            "Delete cached embeddings for all datasets and clear memory?",
            QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No,
        ) != QtWidgets.QMessageBox.Yes:
            return
        count = self.core.rag_cache.clear_disk()
        self.core.rag_cache.clear_memory()
        QtWidgets.QMessageBox.information(self, "Cleared", f"Cleared RAG cache files ({count} removed) and in-memory index.")

    # ────────────────────────── isolated / refresh / idle
    def _on_isolated_toggled(self, checked: bool) -> None:
        if checked:
            self.isolated_history.clear()
        else:
            if self.isolated_history:
                ans = QtWidgets.QMessageBox.question(
                    self,
                    "Merge Isolated Chat",
                    "Merge isolated conversation into main memory?",
                    QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No,
                )
                if ans == QtWidgets.QMessageBox.Yes:
                    for role, content in self.isolated_history:
                        self.core.conversation_db.save_message(role.lower(), content)
                self.isolated_history.clear()
        self._reset_idle_timer()

    def _on_refresh_chat(self) -> None:
        if self.chk_isolated.isChecked():
            self.isolated_history.clear()
        self.chat_view.clear()
        self.response_edit.clear()
        self._enable_feedback(False)
        try:
            if hasattr(self, "inner_text") and self.inner_text is not None:
                self.inner_text.clear()
        except Exception:
            pass

    def _reset_idle_timer(self) -> None:
        self._idle_timer.stop()
        if self.chk_semantic.isChecked():
            self._idle_timer.start(60000)

    def _handle_idle(self) -> None:
        pass

    # ────────────────────────── inner monologue
    def _on_inner_monologue(self) -> None:
        self._ensure_inner_dock()
        if self.inner_dock is None:
            return
        self.inner_dock.setVisible(not self.inner_dock.isVisible())

    def _ensure_inner_dock(self) -> None:
        if hasattr(self, "inner_dock") and self.inner_dock is not None:
            return
        dock = QtWidgets.QDockWidget("Inner Monologue", self)
        dock.setObjectName("InnerDock")
        dock.setAllowedAreas(QtCore.Qt.RightDockWidgetArea | QtCore.Qt.LeftDockWidgetArea)
        inner = QtWidgets.QWidget()
        v = QtWidgets.QVBoxLayout(inner)
        self.inner_text = QtWidgets.QPlainTextEdit()
        self.inner_text.setReadOnly(True)
        v.addWidget(self.inner_text, 1)
        h = QtWidgets.QHBoxLayout()
        h.addWidget(QtWidgets.QLabel("Interval (s):"))
        self.spin_interval = QtWidgets.QSpinBox()
        self.spin_interval.setRange(1, 60)
        self.spin_interval.setValue(15)
        h.addWidget(self.spin_interval)
        self.chk_monologue_tts = QtWidgets.QCheckBox("Speak")
        self.chk_monologue_tts.setChecked(self.core.settings.monologue_tts_enabled)
        h.addWidget(self.chk_monologue_tts)
        h.addWidget(QtWidgets.QLabel("Volume:"))
        self.slider_monologue_vol = QtWidgets.QSlider(QtCore.Qt.Horizontal)
        self.slider_monologue_vol.setRange(0, 100)
        self.slider_monologue_vol.setValue(self.core.settings.monologue_volume)
        h.addWidget(self.slider_monologue_vol)
        btn_start_stop = QtWidgets.QPushButton("Start/Stop")
        h.addWidget(btn_start_stop)
        v.addLayout(h)
        inner.setLayout(v)
        dock.setWidget(inner)
        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, dock)
        self.inner_dock = dock
        self.inner_timer = QtCore.QTimer(self)
        self.inner_timer.setSingleShot(False)
        btn_start_stop.clicked.connect(self._toggle_inner_timer)
        dock.setTitleBarWidget(DockTitleBar(dock, "Inner Monologue"))
        self.dock_tray.register_dock(self.inner_dock)
        self.chk_monologue_tts.stateChanged.connect(lambda _: self._update_monologue_settings())
        self.slider_monologue_vol.valueChanged.connect(lambda _: self._update_monologue_settings())

    def _toggle_inner_timer(self) -> None:
        if self.inner_timer is None:
            return
        if self.inner_timer.isActive():
            self.inner_timer.stop()
        else:
            interval_ms = self.spin_interval.value() * 1000
            try:
                self.inner_timer.timeout.disconnect()
            except Exception:
                pass
            self.inner_timer.timeout.connect(self._generate_inner_monologue)
            self.inner_timer.start(interval_ms)

    def _update_monologue_settings(self) -> None:
        try:
            self.core.settings.monologue_tts_enabled = self.chk_monologue_tts.isChecked() if hasattr(self, 'chk_monologue_tts') else False
            self.core.settings.monologue_volume = self.slider_monologue_vol.value() if hasattr(self, 'slider_monologue_vol') else 50
            self.core.settings.save()
        except Exception:
            pass

    def _generate_inner_monologue(self) -> None:
        schema = self.core.schema_mgr.load_schema(self._current_persona(), self.current_set.get(self._current_persona(), "default"))
        overlay = schema.get("dynamic_overlay", {}) or {}
        mood = overlay.get("temporary_emotional_state", "neutral")
        likes = overlay.get("recent_topics", [])
        pos = [0, 0]
        fav_topic = likes[-1] if likes else None
        thought = f"I'm thinking about {fav_topic} while feeling {mood}." if fav_topic else f"I'm in a {mood} mood and reflecting."
        thought += f" I'm at position {pos}."
        try:
            if hasattr(self, "inner_text") and self.inner_text is not None:
                self.inner_text.appendPlainText(thought)
        except Exception:
            pass

    # ────────────────────────── conversation
    def _append_message(self, display_name: str, text: str, role_key: Optional[str] = None) -> None:
        key = (role_key or display_name).lower()
        bg_colour = ROLE_COLOURS.get(key, "#EEEEEE")
        name_colour = NAME_COLOURS.get(key, "#011627")
        safe_role = QtGui.QGuiApplication.translate("Chat", display_name)
        safe_text = QtGui.QGuiApplication.translate("Chat", text)
        frag = (
            f'<div style="background-color:{bg_colour}; border-radius:4px; padding:4px; margin:4px;">'
            f'<b style="color:{name_colour};">{safe_role}:</b> {safe_text}'
            f'</div>'
        )
        self.chat_view.append(frag)

    def _current_history(self) -> List[Tuple[str, str]]:
        if self.chk_isolated.isChecked():
            return self.isolated_history
        else:
            return self.core.conversation_db.fetch_history(limit=10)

    def _bootstrap_conversation(self) -> None:
        if self.core and len(self.core.conversation_db.fetch_history(limit=1)) == 0:
            schema = self.core.schema_mgr.load_schema(self.active_persona, self.current_set.get(self.active_persona, "default"))
            questions = schema.get("questions", [])
            if questions:
                first_question = questions[0]
                self._append_message("System", first_question, role_key="system")
                if self.chk_semantic.isChecked() and not self.chk_isolated.isChecked():
                    self.core.conversation_db.save_message("system", first_question)

    # ────────────────────────── prompt & rag
    def _build_prompt(self, schema: Dict[str, object], user_text: str, is_self_talk: bool = False) -> str:
        parts: List[str] = []
        name = schema.get("name", "")
        role = schema.get("role", "")
        desc = schema.get("description", "")
        persona_desc = f"You are {name}, {desc}".strip()
        if role:
            persona_desc += f" Your role is {role}."

        overlay = schema.get("dynamic_overlay", {})
        if overlay:
            temp_rel = overlay.get("temporary_relationship_context", "")
            temp_emotion = overlay.get("temporary_emotional_state", "")
            added_traits = overlay.get("added_traits", [])
            if temp_rel:
                persona_desc += f" ({temp_rel})"
            if temp_emotion:
                persona_desc += f" You feel {temp_emotion}."
            if added_traits:
                persona_desc += f" Traits: {', '.join(str(t) for t in added_traits)}."
        parts.append(persona_desc)

        # User description
        try:
            user_schema = self.core.schema_mgr.load_schema("user", self.current_set.get("user", "default"))
        except Exception:
            user_schema = {}
        if user_schema:
            u_name = user_schema.get("name", "User")
            u_personality = user_schema.get("personality", "")
            relationship = user_schema.get("relationship_to_zira", "friend")
            u_overlay = user_schema.get("dynamic_overlay", {})
            temp_rel2 = u_overlay.get("temporary_relationship_context") if u_overlay else None
            if temp_rel2 and str(temp_rel2).strip():
                relationship = str(temp_rel2)
            user_desc = f"User is {u_name}, {u_personality}. Relationship: {relationship}."
            parts.append(user_desc)

        # History
        history_text = ""
        if self.chk_semantic.isChecked():
            history = self._current_history()[-10:]
            for role_name, content in history:
                speaker = "User" if role_name.lower() == "user" else role_name.title()
                history_text += f"{speaker}: {content}\n"
        if history_text:
            parts.append("Conversation history:\n" + history_text.strip())

        # RAG (only datasets listed by this set)
        dataset_text = ""
        ds_names: List[str] = list(schema.get("datasets") or [])
        try:
            # Prefer core search with filters if supported
            hits = self.core.rag_search(
                user_text,
                per_ds_k=3,
                limit=5,
                include_shared=False,
                datasets=ds_names if ds_names else None,
            )
            for chunk, score, ds_name, owner in hits:
                dataset_text += f"Dataset ({owner}/{ds_name}):\n{chunk}\n\n"
        except TypeError:
            # Older core: no dataset filter; fallback to manual selection
            from_texts: List[Tuple[str, str]] = []
            try:
                for name, entry in self.core.dataset_mgr.entries.items():
                    if ds_names and name not in ds_names:
                        continue
                    if not entry.active:
                        continue
                    full_text = self.core.dataset_mgr.load_dataset_text(entry)
                    if full_text:
                        from_texts.append((name, full_text))
            except Exception:
                pass
            for name, full_text in from_texts:
                snip = self._retrieve_dataset_snippet(full_text, user_text)
                if snip:
                    dataset_text += f"Dataset ({name}):\n{snip}\n\n"
        except Exception:
            pass
        if dataset_text:
            parts.append(dataset_text.strip())

        # Self-talk (optional)
        if is_self_talk and self.self_talk_enabled:
            st_prompts = schema.get("self_talk", [])
            if st_prompts:
                import random
                parts.append(random.choice(st_prompts))

        parts.append(f"User: {user_text}")
        return "\n\n".join([p for p in parts if p])

    def _retrieve_dataset_snippet(self, full_text: str, user_text: str) -> str:
        try:
            tokens = [w.lower() for w in re.findall(r"\b\w+\b", user_text) if len(w) > 2]
            paragraphs = [p.strip() for p in full_text.split("\n") if p.strip()]
            scored: List[Tuple[int, str]] = []
            for para in paragraphs:
                l = para.lower()
                score = sum(1 for t in tokens if t in l)
                if score > 0:
                    scored.append((score, para))
            if not scored:
                return paragraphs[0][:500] if paragraphs else full_text[:500]
            scored.sort(key=lambda x: -x[0])
            top = [p for _, p in scored[:2]]
            return "\n".join(top)[:500]
        except Exception:
            return full_text[:500]

    # ────────────────────────── send / model
    def send_message(self) -> None:
        user_text = self.input_edit.toPlainText().strip()
        if not user_text:
            return

        # Broadcast to plugins
        try:
            self.core.plugins.broadcast(user_text)
        except Exception:
            pass

        # Slash commands → ensure applied to current persona+set
        if user_text.startswith("/"):
            self.input_edit.clear()
            persona = self._current_persona()
            set_name = self.current_set.get(persona, "default")
            try:
                out = self.core.run_command(user_text, persona=persona, set_name=set_name)
            except TypeError:
                out = self.core.run_command(user_text)
            self._append_message("System", out, role_key="system")
            if self.chk_semantic.isChecked() and not self.chk_isolated.isChecked():
                self.core.conversation_db.save_message("system", out)
            return

        # Normal message
        self.input_edit.clear()
        persona = self._current_persona()
        set_name = self.current_set.get(persona, "default")
        schema = self.core.schema_mgr.load_schema(persona, set_name)

        if self.chk_isolated.isChecked():
            self.isolated_history.append(("user", user_text))
        else:
            if self.chk_semantic.isChecked():
                self.core.conversation_db.save_message("user", user_text)

        try:
            user_schema = self.core.schema_mgr.load_schema("user", self.current_set.get("user", "default"))
            user_display = user_schema.get("name", "User")
        except Exception:
            user_display = "User"
        self._append_message(user_display, user_text, role_key="user")

        prompt = self._build_prompt(schema, user_text)
        model_slug = self.model_combo.currentText().strip() or self.core.settings.default_model

        self.btn_send.setEnabled(False)

        # ✅ Create ModelWorker and wire it up properly
        self.model_worker = ModelWorker(model_slug, prompt, parent=self.core)
        self.model_worker.resultReady.connect(lambda resp, usr=user_text, sch=schema: self._on_model_response(resp, usr, sch))
        self.model_worker.errorOccurred.connect(self._on_model_error)
        self.model_worker.finished.connect(lambda: self.btn_send.setEnabled(True))
        self.model_worker.start()


    def _on_model_response(self, response_raw: str, user_text: str, schema: Dict[str, object]) -> None:
        model_slug = self.model_combo.currentText().strip()
        response = self._strip_reasoning(model_slug, response_raw)
        response, style_score = self._style_and_guard(response, schema)
        self.style_label.setText(f"Style: {style_score:.2f}")

        if self.chk_isolated.isChecked():
            self.isolated_history.append((schema.get("name", "bot"), response))
        else:
            if self.chk_semantic.isChecked():
                self.core.conversation_db.save_message(schema.get("name", "bot").lower(), response)

        persona_name = schema.get("name", "Bot") or "Bot"
        role_key = self._current_persona().lower()
        self._append_message(persona_name, response, role_key=role_key)
        self.response_edit.setPlainText(response)

        if not self.chk_mute_tts.isChecked():
            try:
                self.core.tts_mgr.enqueue(response)
            except Exception:
                pass

        self._enable_feedback(True)
        self._reset_idle_timer()

        try:
            tokens = [w.lower() for w in re.findall(r"\b\w+\b", user_text) if len(w) > 3]
            for t in tokens:
                self.update_overlay_topic(self._current_persona(), t)
            self.update_overlay_emotion(self._current_persona(), "neutral")
        except Exception:
            pass

        try:
            for line in response.split("\n"):
                if line.strip():
                    self.core.plugins.broadcast(line.strip())
        except Exception as e:
            print(f"Error broadcasting to plugins: {e}")

        if self.core.settings.auto_schema_enabled:
            self.progress_bar.setVisible(True)

            class EvolverWorker(QRunnable):
                def __init__(self, evolver, persona, set_name, history, window):
                    super().__init__()
                    self.evolver = evolver
                    self.persona = persona
                    self.set_name = set_name
                    self.history = history
                    self.window = window

                def run(self):
                    changed = self.evolver.update_schema(self.persona, self.set_name, self.history)
                    QtCore.QMetaObject.invokeMethod(
                        self.window, "_post_evolver", QtCore.Qt.QueuedConnection, QtCore.Q_ARG(bool, changed)
                    )

            QThreadPool.globalInstance().start(
                EvolverWorker(self.core.schema_evolver, self.active_persona, self.current_set.get(self.active_persona, "default"), self._current_history(), self)
            )

    @QtCore.pyqtSlot(bool)
    def _post_evolver(self, changed: bool) -> None:
        self.progress_bar.setVisible(False)
        if changed:
            self._flash_status("Schema adapted")

    def _strip_reasoning(self, model: str, response: str) -> str:
        if model and "deepseek" in model.lower():
            if "<think>" in response and "</think>" in response:
                try:
                    return response.split("</think>")[-1].strip() or response
                except Exception:
                    return response
        return response

    def _style_and_guard(self, text: str, schema: Dict[str, object]) -> Tuple[str, float]:
        exclam = text.count("!")
        sentences = [s for s in re.split(r"[.!?]", text) if s.strip()]
        avg_len = sum(len(s.split()) for s in sentences) / max(1, len(sentences))
        exclam_density = exclam / max(1, len(text))
        tone = schema.get("tone_rules", {"conciseness": [0.6, 0.8], "exclam_limit": 0.05})
        conciseness = max(0.0, min(1.0, (22 - avg_len) / 16.0))
        ex_ok = 1.0 if exclam_density <= float(tone.get("exclam_limit", 0.05)) else 0.5
        score = max(0.0, min(1.0, 0.5 * conciseness + 0.5 * ex_ok))
        return text, score

    def _rewrite_response(self, original: str) -> str:
        try:
            liked = self.core.feedback_db.get_liked_responses(limit=5)
        except Exception:
            liked = []
        schema = self.core.schema_mgr.load_schema(self._current_persona(), self.current_set.get(self._current_persona(), "default"))
        rps = schema.get("rewrite_prompts", [])
        template = rps[0] if rps else "Rewrite to be more appealing. Keep it accurate, concise, and on style."
        parts = [template]
        if liked:
            parts.append("Preferred responses:\n" + "\n\n".join(liked))
        parts.append("Original:\n" + original)
        parts.append("Rewritten:")
        prompt = "\n\n".join(parts)
        return self._run_model(self.model_combo.currentText().strip() or self.core.settings.default_model, prompt) or original

    def _run_model(self, model: str, prompt: str) -> str:
        try:
            proc = subprocess.run(
                ["ollama", "run", model],
                input=prompt.encode("utf-8"),
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                check=True,
            )
            return proc.stdout.decode("utf-8", errors="replace").strip()
        except subprocess.CalledProcessError as e:
            return e.stderr.decode("utf-8", errors="replace").strip()
        except FileNotFoundError:
            return "(error) ollama executable not found."
        except Exception as e:
            return f"(error) {e}"

    # ────────────────────────── persona / sets
    def _populate_set_combo(self, persona: str, combo: QtWidgets.QComboBox) -> None:
        combo.blockSignals(True)
        combo.clear()
        for s in self.core.schema_mgr.get_set_list(persona):
            combo.addItem(s)
        current = self.current_set.get(persona, "default")
        idx = combo.findText(current)
        combo.setCurrentIndex(idx if idx >= 0 else combo.findText("default"))
        if idx < 0:
            self.current_set[persona] = combo.currentText()
        combo.blockSignals(False)

    def _on_set_changed(self, persona: str, name: str, combo: QtWidgets.QComboBox) -> None:
        if not name:
            return
        self.current_set[persona] = name
        # keep AgentCore pointed to the right set if this persona is active
        if persona == self._current_persona():
            self.core.persona = persona
            self.core.set_name = name

        # refresh editor + commands row for this tab
        tab = self.tab_widgets.get(persona)
        if tab:
            editor = tab.findChild(QtWidgets.QPlainTextEdit, f"schema_edit_{persona}")
            if editor:
                schema = self.core.schema_mgr.load_schema(persona, name)
                editor.setPlainText(json.dumps(schema, indent=2))
            cmd_combo = tab.findChild(QtWidgets.QComboBox, f"cmd_combo_{persona}")
            if cmd_combo:
                self._populate_command_combo(persona, cmd_combo)

        # persist active sets & update controls tied to schema flags
        self.core.schema_mgr.save_active_schemas(self.current_set)
        self._sync_semantic_checkbox_from_schema()
        self._update_feedback_counts()

        # refresh slash command list if this persona is active
        try:
            if persona == self._current_persona():
                self._populate_command_select()
        except Exception:
            pass

    def _on_clone_set(self, persona: str, combo: QtWidgets.QComboBox) -> None:
        src = combo.currentText()
        name, ok = QtWidgets.QInputDialog.getText(self, "Clone Set", "Enter new set name:")
        if not ok or not name.strip():
            return
        new_name = name.strip()
        try:
            schema = self.core.schema_mgr.load_schema(persona, src)
            # Preserve the persona's canonical name; set label is separate
            schema["name"] = persona.capitalize()
            self.core.schema_mgr.save_schema(persona, new_name, schema)
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "Error", str(e))
            return
        self.current_set[persona] = new_name
        self._populate_set_combo(persona, combo)
        combo.setCurrentText(new_name)
        if persona == self._current_persona():
            self.core.set_name = new_name
        self.core.schema_mgr.save_active_schemas(self.current_set)
        self._sync_semantic_checkbox_from_schema()
        self._update_feedback_counts()

    def _on_new_set(self, persona: str, combo: QtWidgets.QComboBox) -> None:
        src = combo.currentText()
        name, ok = QtWidgets.QInputDialog.getText(self, "New Set", "Enter name for new set:")
        if not ok or not name.strip():
            return
        new_name = name.strip()
        try:
            schema = self.core.schema_mgr.load_schema(persona, src)
            # Preserve the persona's canonical name; set label is separate
            schema["name"] = persona.capitalize()
            self.core.schema_mgr.save_schema(persona, new_name, schema)
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "Error", str(e))
            return
        self.current_set[persona] = new_name
        self._populate_set_combo(persona, combo)
        combo.setCurrentText(new_name)
        if persona == self._current_persona():
            self.core.set_name = new_name
        self.core.schema_mgr.save_active_schemas(self.current_set)
        self._sync_semantic_checkbox_from_schema()
        self._update_feedback_counts()

    def _on_delete_set(self, persona: str, combo: QtWidgets.QComboBox) -> None:
        name = combo.currentText()
        if name == "default":
            QtWidgets.QMessageBox.information(self, "Cannot Delete", "The default set cannot be deleted.")
            return
        if QtWidgets.QMessageBox.question(
            self, "Delete Set", f"Delete '{name}' (irreversible)?", QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No
        ) != QtWidgets.QMessageBox.Yes:
            return
        try:
            set_dir = os.path.join(self.core.schema_mgr.schemas_dir, persona.lower(), "sets", name)
            import shutil
            shutil.rmtree(set_dir, ignore_errors=True)
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "Error", str(e))
            return
        self.current_set[persona] = "default"
        self._populate_set_combo(persona, combo)
        combo.setCurrentText("default")
        if persona == self._current_persona():
            self.core.set_name = "default"
        self.core.schema_mgr.save_active_schemas(self.current_set)
        self._sync_semantic_checkbox_from_schema()
        self._update_feedback_counts()

    def _on_save_schema(self, persona: str) -> None:
        tab = self.tab_widgets.get(persona)
        if not tab:
            return
        editor = tab.findChild(QtWidgets.QPlainTextEdit, f"schema_edit_{persona}")
        if not editor:
            return
        text = editor.toPlainText().strip()
        try:
            schema = json.loads(text)
            if not isinstance(schema, dict):
                raise ValueError
        except Exception:
            QtWidgets.QMessageBox.warning(self, "Invalid JSON", "The schema is not valid JSON.")
            return
        set_name = self.current_set.get(persona, "default")
        existing_schema = self.core.schema_mgr.load_schema(persona, set_name)
        merged_schema = {**existing_schema, **schema}
        # Ensure the top-level name matches the active set name
        try:
            merged_schema["name"] = set_name
        except Exception:
            pass
        self.core.schema_mgr.save_schema(persona, set_name, merged_schema)
        QtWidgets.QMessageBox.information(self, "Saved", f"Schema saved for {persona} ({set_name}).")

        if persona == self._current_persona():
            persona_voice = (merged_schema.get("voice") or "").lower()
            for i in range(self.voice_combo.count()):
                if persona_voice and persona_voice in self.voice_combo.itemText(i).lower():
                    self.voice_combo.setCurrentIndex(i)
                    break
        # After save, refresh commands combo (in case user edited commands JSON directly)
        tab = self.tab_widgets.get(persona)
        if tab:
            cmd_combo = tab.findChild(QtWidgets.QComboBox, f"cmd_combo_{persona}")
            if cmd_combo:
                self._populate_command_combo(persona, cmd_combo)

    # ------------------------------------------------------------------
    # Command editing helpers (ported from the original agent_ui.py)
    #
    # The persona editing tab includes a commands row allowing users to
    # append new payloads to existing slash commands or create entirely
    # new commands.  These helpers implement the behaviour that used to
    # live in agent_ui.py.  They are invoked by PersonaTab via
    # ``self.app._on_add_to_command`` and ``self.app._on_new_command``.
    def _on_add_to_command(self, persona: str, combo: QtWidgets.QComboBox,
                            edit: QtWidgets.QLineEdit) -> None:
        """
        Append the text from ``edit`` to the selected command in the
        current schema.  If no command is selected or no text is
        provided, the user is notified.  After updating the schema,
        the command editor and schema editor are refreshed.

        Parameters
        ----------
        persona : str
            The persona whose schema is being modified.
        combo : QtWidgets.QComboBox
            The combo box listing existing slash commands.
        edit : QtWidgets.QLineEdit
            The line edit containing the payload to add to the command.
        """
        text = edit.text().strip()
        if not text:
            QtWidgets.QMessageBox.information(self, "No Text", "Enter text/payload to add.")
            return
        set_name = self.current_set.get(persona, "default")
        schema = self.core.schema_mgr.load_schema(persona, set_name)
        cmds = dict(schema.get("commands") or {})
        sel = combo.currentText().strip()
        if not sel or sel == "(no commands)":
            QtWidgets.QMessageBox.information(self, "No Command", "Create a command first.")
            return
        lst = list(cmds.get(sel) or [])
        lst.append(text)
        cmds[sel] = lst
        schema["commands"] = cmds
        self.core.schema_mgr.save_schema(persona, set_name, schema)
        edit.clear()
        # Refresh editors & notify the user
        self._refresh_schema_editor(persona)
        QtWidgets.QMessageBox.information(self, "Added", f'Added to {sel}: "{text}"')

    def _on_new_command(self, persona: str) -> None:
        """
        Prompt the user for a new command name, insert it into the
        schema if it does not already exist, and refresh the UI.  The
        new command is prefaced with a leading slash if not provided.

        Parameters
        ----------
        persona : str
            The persona whose schema is being modified.
        """
        name, ok = QtWidgets.QInputDialog.getText(self, "New Command", "Enter new command (e.g., /remember):")
        if not ok or not name.strip():
            return
        cmd_name = name.strip()
        if not cmd_name.startswith("/"):
            cmd_name = "/" + cmd_name
        set_name = self.current_set.get(persona, "default")
        schema = self.core.schema_mgr.load_schema(persona, set_name)
        cmds = dict(schema.get("commands") or {})
        if cmd_name in cmds:
            QtWidgets.QMessageBox.information(self, "Exists", f"Command {cmd_name} already exists.")
            return
        cmds[cmd_name] = []
        schema["commands"] = cmds
        self.core.schema_mgr.save_schema(persona, set_name, schema)
        # Refresh command combo + schema editor
        tab = self.tab_widgets.get(persona)
        if tab:
            combo = tab.findChild(QtWidgets.QComboBox, f"cmd_combo_{persona}")
            if combo:
                self._populate_command_combo(persona, combo)
                combo.setCurrentText(cmd_name)
            edit = tab.findChild(QtWidgets.QLineEdit, f"cmd_edit_{persona}")
            if edit:
                edit.clear()
        self._refresh_schema_editor(persona)
        QtWidgets.QMessageBox.information(self, "Created", f"New command {cmd_name} created.")

    def _refresh_schema_editor(self, persona: str) -> None:
        """
        Reload the JSON schema for ``persona`` from disk and update the
        corresponding schema editor in the UI.  This helper is used
        after schema modifications to ensure the text reflects the
        authoritative state on disk.  Signals are blocked during the
        update to avoid triggering autosave timers unnecessarily.

        Parameters
        ----------
        persona : str
            The persona whose schema editor should be refreshed.
        """
        tab = self.tab_widgets.get(persona)
        if not tab:
            return
        editor = tab.findChild(QtWidgets.QPlainTextEdit, f"schema_edit_{persona}")
        if editor:
            schema = self.core.schema_mgr.load_schema(persona, self.current_set.get(persona, "default"))
            editor.blockSignals(True)
            editor.setPlainText(json.dumps(schema, indent=2))
            editor.blockSignals(False)

    def _tab_changed(self, index: int) -> None:
        if 0 <= index < len(self.core.schema_mgr.personas):
            self.active_persona = self.core.schema_mgr.personas[index]
        else:
            self.active_persona = self.core.schema_mgr.personas[0] if self.core.schema_mgr.personas else "zira"
        self.core.persona = self.active_persona

        schema = self.core.schema_mgr.load_schema(self.active_persona, self.current_set.get(self.active_persona, "default"))
        persona_voice = (schema.get("voice") or "").lower()
        for i in range(self.voice_combo.count()):
            if persona_voice and persona_voice in self.voice_combo.itemText(i).lower():
                self.voice_combo.setCurrentIndex(i)
                break

        tab = self.tab_widgets.get(self.active_persona)
        if tab:
            editor = tab.findChild(QtWidgets.QPlainTextEdit, f"schema_edit_{self.active_persona}")
            if editor:
                editor.setPlainText(json.dumps(schema, indent=2))
            cmd_combo = tab.findChild(QtWidgets.QComboBox, f"cmd_combo_{self.active_persona}")
            if cmd_combo:
                self._populate_command_combo(self.active_persona, cmd_combo)

        try:
            user_schema = self.core.schema_mgr.load_schema("user", self.current_set.get("user", "default"))
            bot_name = schema.get("name", self.active_persona.title())
            bot_set = self.current_set.get(self.active_persona, "default")
            user_name = user_schema.get("name", "User")
            user_set = self.current_set.get("user", "default")
            self.lbl_active_names.setText(f"{bot_name}: {bot_set} — User: {user_name}: {user_set}")
        except Exception:
            pass

        self._sync_semantic_checkbox_from_schema()
        self._update_feedback_counts()

        # refresh slash command dropdown on persona change
        try:
            self._populate_command_select()
        except Exception:
            pass

    def _current_persona(self) -> str:
        return self.active_persona

    # ────────────────────────── overlay helpers
    def update_overlay_topic(self, persona: str, topic: str) -> None:
        persona = persona.lower()
        try:
            schema = self.core.schema_mgr.load_schema(persona, self.current_set.get(persona, "default"))
            overlay = dict(schema.get("dynamic_overlay", {}))
            topics = list(overlay.get("recent_topics", []))
            if topic and topic not in topics:
                topics.append(topic)
                if len(topics) > 10:
                    topics = topics[-10:]
                overlay["recent_topics"] = topics
                schema["dynamic_overlay"] = overlay
                self.core.schema_mgr.save_schema(persona, self.current_set.get(persona, "default"), schema)
        except Exception:
            pass

    def update_overlay_emotion(self, persona: str, emotion: str) -> None:
        persona = persona.lower()
        try:
            schema = self.core.schema_mgr.load_schema(persona, self.current_set.get(persona, "default"))
            overlay = dict(schema.get("dynamic_overlay", {}))
            overlay["temporary_emotional_state"] = emotion
            schema["dynamic_overlay"] = overlay
            self.core.schema_mgr.save_schema(persona, self.current_set.get(persona, "default"), schema)
        except Exception:
            pass

    # ────────────────────────── devices & models
    def _populate_devices(self) -> None:
        # In this refactor the devices are populated by CommandsPanel
        self.commands_panel._populate_devices()

    def _populate_models(self) -> None:
        # In this refactor the models are populated by CommandsPanel
        self.commands_panel._populate_models()

    # ────────────────────────── slash commands panel
    def _build_command_dock(self) -> None:
        """
        Build a dockable panel that exposes slash commands with an argument
        entry and send button. This allows users to trigger any command
        without typing it into the chat manually. It will be updated when
        persona or set changes.
        """
        dock = QtWidgets.QDockWidget("Slash Commands", self)
        dock.setObjectName("SlashCommandsDock")
        dock.setFeatures(
            QtWidgets.QDockWidget.DockWidgetClosable
            | QtWidgets.QDockWidget.DockWidgetMovable
            | QtWidgets.QDockWidget.DockWidgetFloatable
        )
        container = QtWidgets.QWidget()
        layout = QtWidgets.QVBoxLayout(container)
        layout.setContentsMargins(7, 7, 7, 7)
        layout.setSpacing(5)

        # command selector
        cmd_label = QtWidgets.QLabel("Slash Command:")
        self.command_select = QtWidgets.QComboBox()
        layout.addWidget(cmd_label)
        layout.addWidget(self.command_select)

        # argument input
        self.command_input = QtWidgets.QLineEdit()
        self.command_input.setPlaceholderText("Enter arguments or select text from chat…")
        layout.addWidget(self.command_input)

        # send button
        btn_run = QtWidgets.QPushButton("Run Command")
        btn_run.clicked.connect(self._on_run_command)
        layout.addWidget(btn_run)
        layout.addStretch(1)

        dock.setWidget(container)
        # add to right side by default
        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, dock)
        self.command_dock = dock

    def _populate_command_select(self) -> None:
        """
        Populate the slash command dropdown with available commands from
        the command registry. This is called whenever the active persona
        or set changes to reflect dynamic additions.
        """
        try:
            cmds = []
            if hasattr(self.core, "command_registry") and self.core.command_registry:
                cmds = list(self.core.command_registry.list_commands())
            # if schema defines additional commands, include them
            persona = self._current_persona()
            set_name = self.current_set.get(persona, "default")
            schema = self.core.schema_mgr.load_schema(persona, set_name)
            schema_cmds = list((schema.get("commands") or {}).keys())
            for c in schema_cmds:
                if c not in cmds:
                    cmds.append(c)
            cmds.sort()
        except Exception:
            cmds = []
        self.command_select.blockSignals(True)
        self.command_select.clear()
        if cmds:
            self.command_select.addItems(cmds)
        self.command_select.blockSignals(False)

    def _on_run_command(self) -> None:
        """
        Handler for running the selected slash command with the provided
        argument. The command will be executed via AgentCore and the
        result appended to the chat window. Selection text from the chat
        can be inserted into the argument field via context menu.
        """
        cmd = (self.command_select.currentText() or "").strip()
        if not cmd:
            QtWidgets.QMessageBox.information(self, "No Command", "Select a slash command to run.")
            return
        arg = self.command_input.text().strip()
        # combine command and arguments
        full = cmd if not arg else f"{cmd} {arg}"
        try:
            # process via core; record conversation
            resp = self.core.process_user_message(full, tts=False)
            # append user command and agent response to chat
            self._append_message("user", full, role_key="user")
            self._append_message("zira", resp, role_key="zira")
            # clear argument
            self.command_input.clear()
            # update feedback counts and idle timer
            self._update_feedback_counts()
            self._reset_idle_timer()
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "Command Error", str(e))

    def _show_chat_context_menu(self, pos: QtCore.QPoint) -> None:
        """
        Custom context menu for the chat view. Adds a menu entry to send
        selected text into the slash command argument field.
        """
        menu = self.chat_view.createStandardContextMenu()
        try:
            cursor = self.chat_view.textCursor()
            if cursor and cursor.hasSelection():
                action = menu.addAction("Send selection to command input")
                action.triggered.connect(self._send_selection_to_command_input)
        except Exception:
            pass
        menu.exec_(self.chat_view.mapToGlobal(pos))

    def _send_selection_to_command_input(self) -> None:
        """
        Copy the currently selected text in the chat view into the command
        input field for slash command execution.
        """
        try:
            cursor = self.chat_view.textCursor()
            if cursor and cursor.hasSelection():
                text = cursor.selectedText()
                self.command_input.setText(text.strip())
        except Exception:
            pass

    def _on_model_changed(self, name: str) -> None:
        """
        Update the default model in settings when the user selects a new
        model from the dropdown. This ensures the AgentCore uses the
        selected model for subsequent interactions.
        """
        try:
            if not name:
                return
            self.core.settings.default_model = name
            self.core.settings.save()
        except Exception:
            pass

    def _on_show_model_manager(self) -> None:
        """
        Show (or raise) the model manager dock. If the dock was
        previously hidden, it will be shown; if it is already visible,
        this will bring it to the front. A dock must be built in
        ``_build_model_manager()`` prior to showing.
        """
        try:
            if self.model_dock.isVisible():
                # already visible: raise to top
                self.model_dock.raise_()
            else:
                self.model_dock.show()
                self.model_dock.raise_()
        except Exception:
            pass
            
            
    def _on_model_error(self, error: str) -> None:
        """Handles errors from ModelWorker threads."""
        print(f"[ERROR] ModelWorker failed:\n{error}")

        # Show in chat window
        self._append_message("System", f"❌ Model error:\n{error}", role_key="system")

        # Optionally log or alert
        try:
            self.core.logger.error(f"ModelWorker Error: {error}")
        except Exception:
            pass

        # Re-enable send button in case it wasn't via .finished
        self.btn_send.setEnabled(True)
            

    # ────────────────────────── settings toggles
    def _on_auto_schema_toggled(self, checked: bool) -> None:
        try:
            self.core.settings.auto_schema_enabled = bool(checked)
            self.core.settings.save()
        except Exception:
            pass
        self.statusBar().showMessage(f"Auto Schema Evolution {'enabled' if checked else 'disabled'}", 2500)

    def _on_google_stt_toggled(self, checked: bool) -> None:
        """
        Opt-in/out of using Google Cloud Speech-to-Text. When enabling the
        toggle for the first time in a session, show a warning that
        recordings will be sent to Google’s servers under their privacy
        policy. If declined, the checkbox will be turned off again.
        """
        # Only show the dialog when transitioning from unchecked → checked
        try:
            current = bool(getattr(self.core.settings, "use_google_stt", False))
        except Exception:
            current = False
        if checked and not current:
            ok = QtWidgets.QMessageBox.question(
                self,
                "Enable Google STT?",
                "Audio will be uploaded to Google Cloud for transcription\n"
                "under Google's privacy policy. Continue?",
                QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No,
            )
            if ok != QtWidgets.QMessageBox.Yes:
                # revert checkbox silently
                self.chk_google_stt.blockSignals(True)
                self.chk_google_stt.setChecked(False)
                self.chk_google_stt.blockSignals(False)
                return
        # persist the new state
        try:
            self.core.settings.use_google_stt = bool(checked)
            self.core.settings.save()
        except Exception:
            pass

    # ────────────────────────── spell suggestions
    def _show_input_context_menu(self, pos: QtCore.QPoint) -> None:
        """
        Custom context menu on the input field that offers spelling
        suggestions when the user right-clicks a misspelled word. Only
        appears if pyspellchecker is available.
        """
        menu = self.input_edit.createStandardContextMenu()
        # compute suggestions only if SpellChecker is available
        if SpellChecker:
            cursor = self.input_edit.cursorForPosition(pos)
            # select the word under cursor
            cursor.select(QtGui.QTextCursor.WordUnderCursor)
            word = cursor.selectedText()
            if word and len(word) >= 3:
                sc = SpellChecker()
                suggestions = list(sc.candidates(word.lower()))
                # sort by Levenshtein distance and frequency; keep top 5
                suggestions = sorted(suggestions, key=lambda w: sc.word_probability(w), reverse=True)[:5]
                if suggestions and suggestions != [word.lower()]:
                    suggest_menu = menu.addMenu("Spelling suggestions")
                    for s in suggestions:
                        act = suggest_menu.addAction(s)
                        act.triggered.connect(lambda chk=False, repl=s, c=cursor: self._replace_word(c, repl))
        menu.exec_(self.input_edit.mapToGlobal(pos))

    def _replace_word(self, cursor: QtGui.QTextCursor, replacement: str) -> None:
        """
        Replace the word at the given cursor with a suggestion. This
        method is connected dynamically for each suggestion action.
        """
        try:
            cursor.beginEditBlock()
            cursor.removeSelectedText()
            cursor.insertText(replacement)
            cursor.endEditBlock()
        except Exception:
            pass

    def _on_semantic_toggled(self, checked: bool) -> None:
        """Persist semantic awareness per persona+set."""
        persona = self._current_persona()
        set_name = self.current_set.get(persona, "default")
        try:
            schema = self.core.schema_mgr.load_schema(persona, set_name)
            flags = dict(schema.get("flags") or {})
            flags["semantic_awareness"] = bool(checked)
            schema["flags"] = flags
            self.core.schema_mgr.save_schema(persona, set_name, schema)
        except Exception:
            pass
        self._reset_idle_timer()

    def _sync_semantic_checkbox_from_schema(self) -> None:
        """Load semantic_awareness from current schema into the checkbox."""
        persona = self._current_persona()
        set_name = self.current_set.get(persona, "default")
        try:
            schema = self.core.schema_mgr.load_schema(persona, set_name)
            flags = schema.get("flags", {})
            val = bool(flags.get("semantic_awareness", True))
        except Exception:
            val = True
        self.chk_semantic.blockSignals(True)
        self.chk_semantic.setChecked(val)
        self.chk_semantic.blockSignals(False)

    # ────────────────────────── status helper
    def _flash_status(self, msg: str) -> None:
        self.statusBar().showMessage(msg, 3000)


# ────────────────────────── Dock tray & titlebar
class DockTray(QtWidgets.QWidget):
    restoreRequested = QtCore.pyqtSignal(QtWidgets.QDockWidget)

    def __init__(self, parent: Optional[QtWidgets.QWidget] = None) -> None:
        super().__init__(parent)
        self._map: Dict[QtWidgets.QDockWidget, QtWidgets.QPushButton] = {}
        lay = QtWidgets.QHBoxLayout(self)
        lay.setContentsMargins(6, 4, 6, 4)
        lay.setSpacing(6)
        self._layout = lay
        self._title = QtWidgets.QLabel("Minimized panels:")
        self._title.setStyleSheet("color: #f0f0f0; font-weight: bold;")
        self._layout.addWidget(self._title, 0)
        self._layout.addStretch(1)
        self.setStyleSheet("background-color: #3c4a6b;")

    def register_dock(self, dock: QtWidgets.QDockWidget) -> None:
        dock.visibilityChanged.connect(lambda vis, d=dock: self._on_visibility_changed(d, vis))
        if not dock.isVisible():
            self._add_button(dock)

    def _on_visibility_changed(self, dock: QtWidgets.QDockWidget, visible: bool) -> None:
        if visible:
            self._remove_button(dock)
        else:
            self._add_button(dock)

    def _add_button(self, dock: QtWidgets.QDockWidget) -> None:
        if dock in self._map:
            return
        btn = QtWidgets.QPushButton(dock.windowTitle())
        btn.setToolTip(f"Restore {dock.windowTitle()}")
        btn.setStyleSheet(
            "background-color: #4a5b78; color: #ffffff; padding: 4px 6px; border: none; border-radius: 3px;"
        )
        btn.clicked.connect(lambda checked=False, d=dock: self._restore(d))
        self._layout.insertWidget(self._layout.count() - 1, btn)
        self._map[dock] = btn

    def _remove_button(self, dock: QtWidgets.QDockWidget) -> None:
        btn = self._map.pop(dock, None)
        if btn:
            self._layout.removeWidget(btn)
            btn.deleteLater()

    def _restore(self, dock: QtWidgets.QDockWidget) -> None:
        dock.show()
        dock.raise_()
        self.restoreRequested.emit(dock)


class DockTitleBar(QtWidgets.QWidget):
    def __init__(self, dock: QtWidgets.QDockWidget, title: str) -> None:
        super().__init__(dock)
        self._dock = dock
        h = QtWidgets.QHBoxLayout(self)
        h.setContentsMargins(6, 2, 6, 2)
        h.setSpacing(6)
        self.lbl = QtWidgets.QLabel(title)
        h.addWidget(self.lbl)
        h.addStretch()
        self.btn_min = QtWidgets.QToolButton()
        self.btn_min.setText("–")
        self.btn_min.setToolTip("Minimize to bottom tray")
        self.btn_min.clicked.connect(lambda checked=False: self._dock.hide())
        h.addWidget(self.btn_min)
        self.btn_max = QtWidgets.QToolButton()
        self.btn_max.setText("□")
        self.btn_max.setToolTip("Enlarge / Restore")
        self.btn_max.clicked.connect(self._on_toggle_maximize)
        h.addWidget(self.btn_max)
        self.btn_close = QtWidgets.QToolButton()
        self.btn_close.setText("×")
        self.btn_close.setToolTip("Close (send to bottom tray)")
        self.btn_close.clicked.connect(lambda checked=False: self._dock.hide())
        h.addWidget(self.btn_close)
        self.installEventFilter(self)

    def eventFilter(self, _obj: QtCore.QObject, evt: QtCore.QEvent) -> bool:
        if evt.type() == QtCore.QEvent.MouseButtonDblClick:
            self._dock.setFloating(not self._dock.isFloating())
            return True
        return False

    def _on_toggle_maximize(self) -> None:
        mw: Optional[QtWidgets.QMainWindow] = self._dock.parentWidget()  # type: ignore
        while mw and not isinstance(mw, QtWidgets.QMainWindow):
            mw = mw.parentWidget()  # type: ignore
        if not isinstance(mw, QtWidgets.QMainWindow):
            self._dock.setFloating(not self._dock.isFloating())
            return
        if not self._dock.isFloating():
            self._dock.setFloating(True)
            mw_geo = mw.geometry()
            w = int(mw_geo.width() * 0.9)
            h = int(mw_geo.height() * 0.85)
            self._dock.resize(w, h)
            center = mw_geo.center()
            self._dock.move(center.x() - w // 2, center.y() - h // 2)
        else:
            self._dock.setFloating(False)


# ────────────────────────── dataset manager dialog
class DatasetManagerDialog(QtWidgets.QDialog):
    def __init__(self, dataset_mgr, parent: Optional[QtWidgets.QWidget] = None) -> None:
        super().__init__(parent)
        self.setWindowTitle("Dataset Manager")
        self.resize(520, 420)
        self.dataset_mgr = dataset_mgr
        v = QtWidgets.QVBoxLayout(self)
        self.list_widget = QtWidgets.QListWidget()
        v.addWidget(self.list_widget, 1)
        h = QtWidgets.QHBoxLayout()
        self.btn_add = QtWidgets.QPushButton("Add Dataset")
        self.btn_del = QtWidgets.QPushButton("Delete Dataset")
        h.addWidget(self.btn_add)
        h.addWidget(self.btn_del)
        h.addStretch()
        v.addLayout(h)
        self._populate()
        self.btn_add.clicked.connect(self._on_add)
        self.btn_del.clicked.connect(self._on_delete)
        self.list_widget.itemChanged.connect(self._on_item)

    def _populate(self) -> None:
        self.list_widget.clear()
        for name, entry in sorted(self.dataset_mgr.entries.items()):
            item = QtWidgets.QListWidgetItem(name)
            item.setFlags(item.flags() | QtCore.Qt.ItemIsUserCheckable)
            item.setCheckState(QtCore.Qt.Checked if entry.active else QtCore.Qt.Unchecked)
            self.list_widget.addItem(item)

    def _on_add(self) -> None:
        name, ok = QtWidgets.QInputDialog.getText(self, "New Dataset", "Enter dataset name:")
        if not ok or not name.strip():
            return
        path, _ = QtWidgets.QFileDialog.getOpenFileName(self, "Select .txt or .pdf", "", "Text/PDF (*.txt *.pdf)")
        if not path:
            return
        try:
            self.dataset_mgr.add_dataset(name.strip(), path)
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "Error", str(e))
            return
        self._populate()

    def _on_delete(self) -> None:
        item = self.list_widget.currentItem()
        if not item:
            return
        name = item.text()
        if QtWidgets.QMessageBox.question(
            self, "Delete Dataset", f"Delete '{name}'?", QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No
        ) != QtWidgets.QMessageBox.Yes:
            return
        try:
            self.dataset_mgr.delete_dataset(name)
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "Error", str(e))
            return
        self._populate()

    def _on_item(self, item: QtWidgets.QListWidgetItem) -> None:
        self.dataset_mgr.toggle_active(item.text(), item.checkState() == QtCore.Qt.Checked)


# ────────────────────────── run as script
if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    win = AppWindow()
    win.show()
    sys.exit(app.exec_())
```

main_ui.py
===========

This module contains the top-level ``AppWindow`` class for the AI TTS
Agent.  It orchestrates all layout and docking behaviour, integrates
the control panel and persona tabs provided by ``commands_panel`` and
``persona_tab``, and exposes a unified interface for the rest of the
application.  None of the core agent logic lives here – that remains in
the ``core_*`` modules.  This refactor pulls the bulky UI building
logic out of the monolithic script and into dedicated modules while
preserving all existing behaviour and wiring.
**Classes:** _SpellHighlighter, AppWindow, DockTray, DockTitleBar, DatasetManagerDialog


## Module `Rant_PDD\Projects\AI_TTS_AGENT\burner_scripts\migration_tool.py`

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
migration_tool.py
=================

Stand-alone CLI for *one-shot* migration of legacy AI-TTS-Agent files
(JSON schemas, commands.json, reinforcement.jsonl …) into the new
SQLite-backed **agent_store.db**.

Typical usage
-------------
$ python migration_tool.py /path/to/AI_TTS_AGENT
    → runs migrate (if needed) and prints a coloured diff table.

$ python migration_tool.py . --dry-run
    → shows what *would* be imported without touching the DB.

Exit codes
----------
0  success – nothing failed
1  fatal error (bad path, SQLite locked, etc.)
2  migration aborted by --check-upgrade only
"""

from __future__ import annotations

import argparse
import os
import sys
from pathlib import Path
from typing import Dict

# Import AFTER adjusting sys.path so the script also works when executed
# from outside the project root.
PROJECT_ROOT = Path(__file__).resolve().parent
if PROJECT_ROOT not in map(Path, map(Path.resolve, map(Path, sys.path))):
    sys.path.insert(0, str(PROJECT_ROOT))

try:
    from agent_store import AgentStore, DB_VERSION
except ImportError as exc:  # pragma: no cover
    print(f"[migration_tool] Cannot import agent_store: {exc}", file=sys.stderr)
    sys.exit(1)


# ------------------------------ helpers ------------------------------ #
def _colour(txt: str, colour: str) -> str:
    colours = {
        "green": "\033[92m",
        "yellow": "\033[93m",
        "red": "\033[91m",
        "cyan": "\033[96m",
        "end": "\033[0m",
    }
    return f"{colours.get(colour, '')}{txt}{colours['end']}"


def _print_report(report: Dict[str, int]) -> None:
    print("\nMigration report")
    print("----------------")
    for k in ("schemas", "commands", "beans"):
        val = report.get(k, 0)
        colour = "green" if val else "yellow"
        print(f"  {k:<10}: {_colour(str(val), colour)}")


# ----------------------------- CLI entry ----------------------------- #
def main() -> None:
    ap = argparse.ArgumentParser(
        description="Run or inspect migration from legacy flat-file storage "
        "to agent_store.db (schema v%d)." % DB_VERSION
    )
    ap.add_argument(
        "base_dir",
        metavar="BASE_DIR",
        help="Root folder where AI-TTS-Agent project lives",
    )
    ap.add_argument(
        "--dry-run",
        action="store_true",
        help="Scan legacy artefacts and show how many items WOULD be migrated "
        "without actually writing to the DB.",
    )
    ap.add_argument(
        "--check-upgrade",
        action="store_true",
        help="Exit code 2 if the DB is below current version (use for CI).",
    )
    args = ap.parse_args()
    base_dir = os.path.abspath(args.base_dir)

    if not os.path.isdir(base_dir):
        print(_colour(f"[migration_tool] No such directory: {base_dir}", "red"), file=sys.stderr)
        sys.exit(1)

    store = AgentStore(base_dir)

    with store._pool.get() as c:  # type: ignore[attr-defined, arg-type]
        cur = c.execute("SELECT value FROM meta WHERE key='user_version'")
        current_ver = int(cur.fetchone()[0])

    if args.check_upgrade:
        if current_ver < DB_VERSION:
            print(_colour(f"DB version {current_ver} < required {DB_VERSION}", "yellow"))
            sys.exit(2)
        print(_colour("DB is up to date.", "green"))
        return

    if current_ver >= DB_VERSION and not args.dry_run:
        print(_colour("Nothing to migrate – database already at latest schema.", "green"))
        return

    if args.dry_run:
        print(_colour("[dry-run] Scanning legacy artefacts…", "cyan"))
        report = store.migrate_from_files()  # writes, but we’ll roll back
        _print_report(report)
        # rollback by deleting DB to keep promise of dry-run
        os.remove(store.db_path)
        print(_colour("\n[dry-run] Database left untouched.", "cyan"))
        return

    # Real migration
    print(_colour("Running migration…", "cyan"))
    report = store.migrate_from_files()
    _print_report(report)
    print(_colour("\nMigration completed.\n", "green"))


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\nInterrupted.")
        sys.exit(1)
```

migration_tool.py
=================

Stand-alone CLI for *one-shot* migration of legacy AI-TTS-Agent files
(JSON schemas, commands.json, reinforcement.jsonl …) into the new
SQLite-backed **agent_store.db**.

Typical usage
-------------
$ python migration_tool.py /path/to/AI_TTS_AGENT
    → runs migrate (if needed) and prints a coloured diff table.

$ python migration_tool.py . --dry-run
    → shows what *would* be imported without touching the DB.

Exit codes
----------
0  success – nothing failed
1  fatal error (bad path, SQLite locked, etc.)
2  migration aborted by --check-upgrade only
**Functions:** _colour(txt, colour), _print_report(report), main()


## Module `Rant_PDD\Projects\AI_TTS_AGENT\burner_scripts\persona_tab.py`

```python
#!/usr/bin/env python3
"""
persona_tab.py
==============

**Schema-Editor 2.0**

This version upgrades the old free-text schema editor to a structured,
two-pane interface:

    • **Left:**   Category tree (actions, questions, etc.)  
    • **Right:**  Multiline editor for the selected node’s JSON value  
    • **Bottom:** “Expose as /command” checkbox (per category)  
    • **Top-right:** “Auto-Evolution” toggle for the whole set

Other improvements

* Autosave is now routed through **SchemaEngine.save()** (SQL-backed).
* Edits are debounced (500 ms) and validated before committing.
* When “Expose as /command” is ticked, a synthetic slash-command is written
  to *AgentStore.commands* for immediate use by the orchestrator.
"""

from __future__ import annotations

import json
import os
from typing import Dict, Any, Optional

from PyQt5 import QtCore, QtGui, QtWidgets


# --------------------------------------------------------------------------- helpers


def nice_json(value: Any) -> str:
    """Pretty JSON helper that survives non-serialisable objects."""
    try:
        return json.dumps(value, indent=2, ensure_ascii=False)
    except Exception:
        return str(value)


def parse_json(text: str) -> Any:
    """Parse or return raw string if JSON fails."""
    try:
        return json.loads(text)
    except Exception:
        return text.strip()


# --------------------------------------------------------------------------- main widget


class PersonaTab(QtWidgets.QWidget):
    """Persona & schema management panel (one instance shared across personas)."""

    # Emitted after a schema field is *persisted* (category, persona, set)
    schemaFieldUpdated = QtCore.pyqtSignal(str, str, str)

    # --------------------------------------------------------------------- init
    def __init__(
        self,
        app: "AppWindow",  # quotes to avoid circular import typing
        parent: Optional[QtWidgets.QWidget] = None,
    ) -> None:
        super().__init__(parent)
        self.app = app
        self.core = app.core
        self.schema_engine = self.core.schema_engine  # ← SQL façade
        self.current_set: Dict[str, str] = app.current_set

        # Label summarising active names/sets
        self.lbl_active = QtWidgets.QLabel()
        self.lbl_active.setObjectName("lblActiveSchemas")
        # Alias for main_ui compatibility (it expects persona_panel.lbl_active_names)
        self.lbl_active_names = self.lbl_active

        # Tabs per persona  ---------------------------------------------------
        self.tabs = QtWidgets.QTabWidget(movable=False, documentMode=True)
        self.tab_widgets: Dict[str, QtWidgets.QWidget] = {}
        for persona in self.schema_engine.personas():
            tab = QtWidgets.QWidget()
            self.tab_widgets[persona] = tab
            self.tabs.addTab(tab, persona.capitalize())

        # Operators tab (read-only)
        self.operator_tab = QtWidgets.QWidget()
        self.tabs.addTab(self.operator_tab, "Operators")

        self.tabs.currentChanged.connect(self._on_tab_changed)

        # Master layout
        v = QtWidgets.QVBoxLayout(self)
        v.setContentsMargins(7, 7, 7, 7)
        v.setSpacing(7)
        v.addWidget(self.lbl_active)
        v.addWidget(self.tabs, 1)

        # Build each persona sub-panel
        for p, w in self.tab_widgets.items():
            self._build_persona_subpanel(p, w)
        self._build_operators_tab(self.operator_tab)

        # Prime active-names label
        self._refresh_active_label()

    # ----------------------------------------------------------------- builders
    def _build_persona_subpanel(self, persona: str, root: QtWidgets.QWidget) -> None:
        """Creates the Schema-Editor 2.0 layout for a single persona."""
        # ───── set selector row ────────────────────────────────────────────
        top = QtWidgets.QHBoxLayout()
        top.addWidget(QtWidgets.QLabel("Set:"))

        set_combo = QtWidgets.QComboBox(objectName=f"setCombo_{persona}")
        self._populate_set_combo(persona, set_combo)
        set_combo.currentTextChanged.connect(
            lambda name, p=persona, c=set_combo: self._switch_set(p, name, c)
        )
        top.addWidget(set_combo)

        btn_clone = QtWidgets.QPushButton("Clone")
        btn_clone.clicked.connect(lambda _=False, p=persona, c=set_combo: self.app._on_clone_set(p, c))
        btn_new = QtWidgets.QPushButton("New")
        btn_new.clicked.connect(lambda _=False, p=persona, c=set_combo: self.app._on_new_set(p, c))
        btn_del = QtWidgets.QPushButton("Delete")
        btn_del.clicked.connect(lambda _=False, p=persona, c=set_combo: self.app._on_delete_set(p, c))
        for b in (btn_clone, btn_new, btn_del):
            top.addWidget(b)
        top.addStretch()

        # Auto-Evolution toggle (per-set)
        chk_auto = QtWidgets.QCheckBox("Auto Evolution")
        chk_auto.setObjectName(f"chkAutoEvo_{persona}")
        chk_auto.stateChanged.connect(lambda _=0, p=persona: self._toggle_auto_evo(p))
        top.addWidget(chk_auto)

        # ───── splitter: category tree | editor ────────────────────────────
        splitter = QtWidgets.QSplitter(QtCore.Qt.Horizontal)
        splitter.setChildrenCollapsible(False)

        # Category tree
        tree = QtWidgets.QTreeWidget(objectName=f"schemaTree_{persona}")
        tree.setHeaderHidden(True)
        tree.itemClicked.connect(lambda item, _col, p=persona: self._load_category(p, item))
        splitter.addWidget(tree)

        # Right-side editor + extras
        right = QtWidgets.QWidget()
        rv = QtWidgets.QVBoxLayout(right)
        rv.setContentsMargins(0, 0, 0, 0)
        rv.setSpacing(4)

        editor = QtWidgets.QPlainTextEdit(objectName=f"schemaEditor_{persona}")
        editor.setLineWrapMode(QtWidgets.QPlainTextEdit.NoWrap)
        rv.addWidget(editor, 1)

        row = QtWidgets.QHBoxLayout()
        self.chk_expose = QtWidgets.QCheckBox("Expose as /command")
        row.addWidget(self.chk_expose)
        row.addStretch()
        btn_format = QtWidgets.QPushButton("Reformat JSON")
        row.addWidget(btn_format)
        rv.addLayout(row)

        splitter.addWidget(right)
        splitter.setStretchFactor(1, 2)

        # ───── assemble persona tab ────────────────────────────────────────
        vbox = QtWidgets.QVBoxLayout(root)
        vbox.setContentsMargins(4, 4, 4, 4)
        vbox.setSpacing(6)
        vbox.addLayout(top)
        vbox.addWidget(splitter, 1)

        # ───── state & autosave timer  ─────────────────────────────────────
        timer = QtCore.QTimer(self)
        timer.setSingleShot(True)
        timer.setInterval(500)  # 500 ms debounce

        def start_debounce() -> None:
            timer.start()

        editor.textChanged.connect(start_debounce)

        def persist() -> None:
            cat = tree.currentItem().text(0) if tree.currentItem() else ""
            if not cat:
                return
            try:
                payload = parse_json(editor.toPlainText())
                persona_set = self.current_set.get(persona, "default")
                self.schema_engine.update_field(persona, persona_set, cat, payload)
                # expose as /command if requested
                expose = self.chk_expose.isChecked()
                self.schema_engine.set_command_exposure(persona, cat, expose)
                self.schemaFieldUpdated.emit(persona, persona_set, cat)
            except Exception as e:
                QtWidgets.QMessageBox.warning(self, "Schema Error", str(e))

        timer.timeout.connect(persist)

        # Re-format button
        btn_format.clicked.connect(lambda: editor.setPlainText(nice_json(parse_json(editor.toPlainText()))))

        # Populate first load
        self._reload_tree(persona, tree)

    # ----------------------------------------------------------------- GUI helpers
    def _populate_set_combo(self, persona: str, combo: QtWidgets.QComboBox) -> None:
        combo.blockSignals(True)
        combo.clear()
        for s in self.schema_engine.set_list(persona):
            combo.addItem(s)
        current = self.current_set.get(persona, "default")
        idx = combo.findText(current)
        combo.setCurrentIndex(max(idx, 0))
        combo.blockSignals(False)

    def _switch_set(self, persona: str, set_name: str, combo: QtWidgets.QComboBox) -> None:
        self.current_set[persona] = set_name
        self._reload_tree(persona, self.findChild(QtWidgets.QTreeWidget, f"schemaTree_{persona}"))
        self._refresh_active_label()

    def _toggle_auto_evo(self, persona: str) -> None:
        set_name = self.current_set.get(persona, "default")
        chk: QtWidgets.QCheckBox = self.sender()  # type: ignore
        self.schema_engine.set_auto_evolution(persona, set_name, bool(chk.isChecked()))

    def _reload_tree(self, persona: str, tree: QtWidgets.QTreeWidget) -> None:
        """Repopulate category tree for the current set."""
        tree.clear()
        set_name = self.current_set.get(persona, "default")
        data = self.schema_engine.load_schema(persona, set_name) or {}
        for key in sorted(data.keys()):
            QtWidgets.QTreeWidgetItem(tree, [key])
        if tree.topLevelItemCount():
            tree.setCurrentItem(tree.topLevelItem(0))

    def _load_category(self, persona: str, item: QtWidgets.QTreeWidgetItem) -> None:
        """Load selected category into editor."""
        cat = item.text(0)
        set_name = self.current_set.get(persona, "default")
        value = self.schema_engine.get_field(persona, set_name, cat)
        editor: QtWidgets.QPlainTextEdit = self.findChild(
            QtWidgets.QPlainTextEdit, f"schemaEditor_{persona}"
        )
        editor.blockSignals(True)
        editor.setPlainText(nice_json(value))
        editor.blockSignals(False)
        # set expose-command checkbox
        self.chk_expose.blockSignals(True)
        self.chk_expose.setChecked(self.schema_engine.is_exposed_as_command(persona, cat))
        self.chk_expose.blockSignals(False)

    def _refresh_active_label(self) -> None:
        try:
            bot_name = self.schema_engine.get_field(
                self.app.active_persona, self.current_set[self.app.active_persona], "name"
            )
        except Exception:
            bot_name = self.app.active_persona.capitalize()
        user_name = self.schema_engine.get_field("user", self.current_set.get("user", "default"), "name") or "User"
        bot_set = self.current_set.get(self.app.active_persona, "default")
        user_set = self.current_set.get("user", "default")
        self.lbl_active.setText(f"{bot_name}: {bot_set} — User: {user_name}: {user_set}")

    # ----------------------------------------------------------------- operators tab
    def _build_operators_tab(self, tab: QtWidgets.QWidget) -> None:
        """Simple list of installed operators with descriptions."""
        lay = QtWidgets.QVBoxLayout(tab)
        lay.setContentsMargins(4, 4, 4, 4)
        lay.setSpacing(6)

        ops = self.core.operator_mgr.list_operators()
        if not ops:
            lay.addWidget(QtWidgets.QLabel("No operators installed."))
        else:
            for name in sorted(ops):
                schema = self.core.operator_mgr.load_schema(name)
                box = QtWidgets.QGroupBox(name)
                v = QtWidgets.QVBoxLayout(box)
                v.addWidget(QtWidgets.QLabel(schema.get("description", "")))
                lay.addWidget(box)
        lay.addStretch()

    # ----------------------------------------------------------------- UI tab change
    def _on_tab_changed(self, idx: int) -> None:
        # keep memo of which persona is active so main_ui can react
        persona = self.tabs.tabText(idx).lower()
        if persona in self.tab_widgets:
            self.app.active_persona = persona
            self._refresh_active_label()
```

persona_tab.py
==============

**Schema-Editor 2.0**

This version upgrades the old free-text schema editor to a structured,
two-pane interface:

    • **Left:**   Category tree (actions, questions, etc.)  
    • **Right:**  Multiline editor for the selected node’s JSON value  
    • **Bottom:** “Expose as /command” checkbox (per category)  
    • **Top-right:** “Auto-Evolution” toggle for the whole set

Other improvements

* Autosave is now routed through **SchemaEngine.save()** (SQL-backed).
* Edits are debounced (500 ms) and validated before committing.
* When “Expose as /command” is ticked, a synthetic slash-command is written
  to *AgentStore.commands* for immediate use by the orchestrator.
**Classes:** PersonaTab
**Functions:** nice_json(value), parse_json(text)


## Module `Rant_PDD\Projects\AI_TTS_AGENT\burner_scripts\run_agent.py`

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
run_agent.py — bootstrap launcher for AI TTS Agent (v3, 2025-08-04)

• Ensures the sqlite store exists (agent_store.ensure_db()) and runs
  legacy-data migration when user_version < 4.
• Accepts one optional command-line arg: <profile-dir>. Defaults to
  ./ai_agent_state relative to CWD.
• Starts the Qt GUI (main_ui.AppWindow).
• Catches early exceptions and prints a clean error trace instead of a
  raw stack-dump so newcomers understand what went wrong.
"""

from __future__ import annotations

import os
import sys
import traceback
from typing import Optional

from PyQt5 import QtWidgets

# --- local imports ----------------------------------------------------------
try:
    from agent_store import ensure_db, get_user_version, migrate_from_files
except ImportError:
    # fall back: no sql store yet, skip migration helpers
    def ensure_db(_): ...
    def get_user_version(_): return 0
    def migrate_from_files(_): return 0, 0  # migrated_rows, warnings


def _bootstrap_state(base_dir: str) -> None:
    """Create DB if missing and run legacy migration (if needed), then show UI."""
    os.makedirs(base_dir, exist_ok=True)
    ensure_db(base_dir)

    try:
        if get_user_version(base_dir) < 4:
            rows, warns = migrate_from_files(base_dir)
            print(f"[migration] imported {rows} rows ({warns} warnings)")
    except Exception as e:
        print(f"[migration] warning: migration failed: {e}")

    # Import the GUI class, catching import-time errors
    try:
        from main_ui import AppWindow
    except Exception:
        print("\n[run_agent] FATAL — failed to import main_ui:\n")
        traceback.print_exc()
        print("\nPress Enter to exit…")
        input()
        sys.exit(1)

    # Instantiate and show the main window, catching UI init errors
    try:
        win = AppWindow()
        win.show()
    except Exception:
        print("\n[run_agent] FATAL — UI failed to initialize:\n")
        traceback.print_exc()
        print("\nPress Enter to exit…")
        input()
        sys.exit(1)


def main() -> None:
    """Entry point: initialize QApplication, bootstrap state, and start event loop."""
    base_dir = (
        sys.argv[1]
        if len(sys.argv) > 1
        else os.path.join(os.getcwd(), "ai_agent_state")
    )

    app = QtWidgets.QApplication(sys.argv)
    _bootstrap_state(base_dir)
    sys.exit(app.exec_())


if __name__ == "__main__":
    try:
        main()
    except Exception:
        print("\n[run_agent] FATAL — an unexpected error occurred:\n")
        traceback.print_exc()
        print("\nPress Enter to exit…")
        input()
```

run_agent.py — bootstrap launcher for AI TTS Agent (v3, 2025-08-04)

• Ensures the sqlite store exists (agent_store.ensure_db()) and runs
  legacy-data migration when user_version < 4.
• Accepts one optional command-line arg: <profile-dir>. Defaults to
  ./ai_agent_state relative to CWD.
• Starts the Qt GUI (main_ui.AppWindow).
• Catches early exceptions and prints a clean error trace instead of a
  raw stack-dump so newcomers understand what went wrong.
**Functions:** _bootstrap_state(base_dir), main()


## Module `Rant_PDD\Projects\AI_TTS_AGENT\burner_scripts\schema_ops.py`

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
schema_ops.py  (2025-08-04  ▸  v2)
==================================

Declarative dispatcher that maps **string op-codes → mutator callables**
operating on core_schema.SchemaEngine / Schema rows.

Updates (v2)
------------
• Added category & prompt removal / update helpers
• Added action list mutators
• Added runtime-introspection helpers: available_ops(), describe_op()
• Strict type-checking & richer logging

Usage example
-------------
>>> from schema_ops import execute_op, available_ops
>>> print(available_ops())
['add_category', 'append_actions', 'delete_action', ...]
>>> execute_op("append_actions", engine,
...            persona="zira", set_name="default",
...            actions=["wave warmly", "offer coffee"])
"""

from __future__ import annotations

import inspect
from typing import Callable, Dict, Any, List

from core_schema import SchemaEngine, Schema
from core_base import logger


# ╔═══════════════════════════════════════════════════════════════════════╗
# ║  Internal helpers                                                     ║
# ╚═══════════════════════════════════════════════════════════════════════╝
def _load(engine: SchemaEngine, persona: str, set_name: str) -> Schema:
    """Return schema or raise ValueError on bad keys."""
    if persona not in engine.personas:
        raise ValueError(f"Unknown persona: {persona}")
    return engine.load(persona, set_name)


def _save(engine: SchemaEngine, persona: str, set_name: str, sch: Schema):
    engine.save(persona, set_name, sch)


def _signal_category_created(engine: SchemaEngine, persona: str, set_name: str, category: str):
    """
    Emit schemaEvolved + categoryCreated if those Qt signals exist.
    No hard dependency —  graceful if running headless.
    """
    try:
        # pylint: disable=protected-access
        engine.schemaEvolved.emit(persona, set_name)        # type: ignore[attr-defined]
        engine.categoryCreated.emit(category)               # type: ignore[attr-defined]
    except Exception:
        pass


# ╔═══════════════════════════════════════════════════════════════════════╗
# ║  Operation implementations                                            ║
# ╚═══════════════════════════════════════════════════════════════════════╝
def op_add_category(
    engine: SchemaEngine,
    *,
    persona: str,
    set_name: str,
    category: str,
    values: List[str] | None = None,
):
    """Create new dynamic_overlay list with optional initial *values*."""
    sch = _load(engine, persona, set_name)
    overlay = sch.dynamic_overlay or {}
    if category in overlay:
        raise ValueError(f"Category '{category}' already exists.")
    overlay[category] = values or []
    sch.dynamic_overlay = overlay
    _save(engine, persona, set_name, sch)
    _signal_category_created(engine, persona, set_name, category)
    logger.info("Added category '%s' to %s/%s", category, persona, set_name)


def op_remove_category(
    engine: SchemaEngine,
    *,
    persona: str,
    set_name: str,
    category: str,
):
    """Remove an entire category from dynamic_overlay."""
    sch = _load(engine, persona, set_name)
    overlay = sch.dynamic_overlay or {}
    if category not in overlay:
        raise ValueError(f"No such category '{category}'.")
    overlay.pop(category)
    sch.dynamic_overlay = overlay
    _save(engine, persona, set_name, sch)
    logger.info("Removed category '%s' from %s/%s", category, persona, set_name)


def op_update_category(
    engine: SchemaEngine,
    *,
    persona: str,
    set_name: str,
    category: str,
    new_values: List[str],
):
    """Replace the value-list of an existing category."""
    sch = _load(engine, persona, set_name)
    overlay = sch.dynamic_overlay or {}
    if category not in overlay:
        raise ValueError(f"Category '{category}' not found.")
    overlay[category] = list(new_values)
    sch.dynamic_overlay = overlay
    _save(engine, persona, set_name, sch)
    logger.info("Updated category '%s' in %s/%s", category, persona, set_name)


def op_toggle_autoevo(
    engine: SchemaEngine,
    *,
    persona: str,
    set_name: str,
    enable: bool,
):
    """Flip semantic_awareness_enabled flag."""
    sch = _load(engine, persona, set_name)
    cur = bool(getattr(sch, "semantic_awareness_enabled", False))
    if cur == enable:
        return
    sch.semantic_awareness_enabled = enable
    _save(engine, persona, set_name, sch)
    logger.info("semantic_awareness %s for %s/%s", enable, persona, set_name)


def op_inject_prompt_variant(
    engine: SchemaEngine,
    *,
    persona: str,
    set_name: str,
    variant_name: str,
    prompt_template: str,
):
    """Append new prompt template to rewrite_prompts list."""
    sch = _load(engine, persona, set_name)
    lst: List[str] = sch.rewrite_prompts or []
    entry = f"[{variant_name}] {prompt_template}"
    lst.append(entry)
    sch.rewrite_prompts = lst
    _save(engine, persona, set_name, sch)
    logger.info("Injected prompt variant '%s' into %s/%s", variant_name, persona, set_name)


def op_remove_prompt_variant(
    engine: SchemaEngine,
    *,
    persona: str,
    set_name: str,
    variant_tag: str,
):
    """
    Delete a rewrite prompt that contains *variant_tag* (case-insensitive).
    """
    sch = _load(engine, persona, set_name)
    lst: List[str] = sch.rewrite_prompts or []
    new_lst = [p for p in lst if variant_tag.lower() not in p.lower()]
    if len(new_lst) == len(lst):
        raise ValueError(f"No prompt containing '{variant_tag}' found.")
    sch.rewrite_prompts = new_lst
    _save(engine, persona, set_name, sch)
    logger.info("Removed prompt variant '%s' from %s/%s", variant_tag, persona, set_name)


def op_replace_rewrite_list(
    engine: SchemaEngine,
    *,
    persona: str,
    set_name: str,
    new_list: List[str],
):
    """Replace entire rewrite_prompts list."""
    sch = _load(engine, persona, set_name)
    sch.rewrite_prompts = list(new_list)
    _save(engine, persona, set_name, sch)
    logger.info("rewrite_prompts replaced for %s/%s", persona, set_name)


def op_append_actions(
    engine: SchemaEngine,
    *,
    persona: str,
    set_name: str,
    actions: List[str],
):
    """Append new action strings (deduplicated)."""
    sch = _load(engine, persona, set_name)
    cur: List[str] = sch.actions or []
    for a in actions:
        if a not in cur:
            cur.append(a)
    sch.actions = cur
    _save(engine, persona, set_name, sch)
    logger.info("Appended %d actions to %s/%s", len(actions), persona, set_name)


def op_delete_action(
    engine: SchemaEngine,
    *,
    persona: str,
    set_name: str,
    action_text: str,
):
    """Remove an action entry matching *action_text* exactly."""
    sch = _load(engine, persona, set_name)
    cur: List[str] = sch.actions or []
    if action_text not in cur:
        raise ValueError("Action not found.")
    cur.remove(action_text)
    sch.actions = cur
    _save(engine, persona, set_name, sch)
    logger.info("Deleted action '%s' from %s/%s", action_text, persona, set_name)


def op_rename_schema_set(
    engine: SchemaEngine,
    *,
    persona: str,
    old_set: str,
    new_set: str,
):
    """Rename a schema set atomically."""
    if new_set == old_set:
        raise ValueError("new_set equals old_set")
    if new_set in engine.list_sets(persona):
        raise ValueError("Target set already exists")
    sch = _load(engine, persona, old_set)
    engine.save(persona, new_set, sch, auto_expand=False)
    engine.store.conn.execute(
        "DELETE FROM schemas WHERE persona_key=? AND set_name=?",
        (persona, old_set),
    )
    engine.store.conn.commit()
    logger.info("Renamed set %s/%s -> %s", persona, old_set, new_set)


# ╔═══════════════════════════════════════════════════════════════════════╗
# ║  Declarative operation registry                                       ║
# ╚═══════════════════════════════════════════════════════════════════════╝
OPS: Dict[str, Callable[..., None]] = {
    # Category ops
    "add_category": op_add_category,
    "remove_category": op_remove_category,
    "update_category": op_update_category,
    # Rewrite-prompt ops
    "inject_prompt_variant": op_inject_prompt_variant,
    "remove_prompt_variant": op_remove_prompt_variant,
    "replace_rewrite_list": op_replace_rewrite_list,
    # Semantic awareness flag
    "toggle_autoevo": op_toggle_autoevo,
    # Actions list
    "append_actions": op_append_actions,
    "delete_action": op_delete_action,
    # Set management
    "rename_schema_set": op_rename_schema_set,
}

# ╔═══════════════════════════════════════════════════════════════════════╗
# ║  Public utility wrappers                                              ║
# ╚═══════════════════════════════════════════════════════════════════════╝
def execute_op(op_name: str, engine: SchemaEngine, **payload):
    """Dispatch *op_name*; raise KeyError on unknown op."""
    fn = OPS.get(op_name)
    if not fn:
        raise KeyError(f"Unknown op: {op_name}")
    return fn(engine, **payload)


def available_ops() -> List[str]:
    """Return sorted list of registered op-codes."""
    return sorted(OPS)


def describe_op(op_name: str) -> str:
    """Return docstring of a registered op."""
    fn = OPS.get(op_name)
    if not fn:
        raise KeyError(op_name)
    return inspect.getdoc(fn) or ""


__all__ = [
    "OPS",
    "execute_op",
    "available_ops",
    "describe_op",
]
```

schema_ops.py  (2025-08-04  ▸  v2)
==================================

Declarative dispatcher that maps **string op-codes → mutator callables**
operating on core_schema.SchemaEngine / Schema rows.

Updates (v2)
------------
• Added category & prompt removal / update helpers
• Added action list mutators
• Added runtime-introspection helpers: available_ops(), describe_op()
• Strict type-checking & richer logging

Usage example
-------------
>>> from schema_ops import execute_op, available_ops
>>> print(available_ops())
['add_category', 'append_actions', 'delete_action', ...]
>>> execute_op("append_actions", engine,
...            persona="zira", set_name="default",
...            actions=["wave warmly", "offer coffee"])
**Functions:** _load(engine, persona, set_name), _save(engine, persona, set_name, sch), _signal_category_created(engine, persona, set_name, category), op_add_category(engine), op_remove_category(engine), op_update_category(engine), op_toggle_autoevo(engine), op_inject_prompt_variant(engine), op_remove_prompt_variant(engine), op_replace_rewrite_list(engine), op_append_actions(engine), op_delete_action(engine), op_rename_schema_set(engine), execute_op(op_name, engine), available_ops(), describe_op(op_name)


## Module `Rant_PDD\Projects\AI_TTS_AGENT\burner_scripts\snapshot_worker.py`

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
snapshot_worker.py

This script defines ModelWorker, which runs inference on a given model in a separate thread.
Used by the UI to offload prompt evaluation from the main thread.
"""

from PyQt5 import QtCore
from typing import Optional
import traceback

class ModelWorker(QtCore.QThread):
    resultReady = QtCore.pyqtSignal(str)
    errorOccurred = QtCore.pyqtSignal(str)

    def __init__(self, model_slug: str, prompt: str, parent: Optional[QtCore.QObject] = None) -> None:
        super().__init__(parent)
        self.model_slug = model_slug
        self.prompt = prompt

    def run(self):
        try:
            # TODO: Replace this mock logic with actual model inference
            import time
            time.sleep(0.8)  # Simulate response time

            # Simulated output - replace with LLM backend output
            response = f"[{self.model_slug}] Response to: {self.prompt}"

            # Emit response back to UI
            self.resultReady.emit(response)

        except Exception as e:
            tb = traceback.format_exc()
            self.errorOccurred.emit(f"{e}\n{tb}")
```

snapshot_worker.py

This script defines ModelWorker, which runs inference on a given model in a separate thread.
Used by the UI to offload prompt evaluation from the main thread.
**Classes:** ModelWorker


## Module `Rant_PDD\Projects\AI_TTS_AGENT\burner_scripts\spatial_engine.py`

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
spatial_engine.py
=================

Headless avatar movement & visual-action logger for the AI TTS Agent.

Features:
- Stateful finite-state machine (idle, thinking, moving).
- decide_move(response_text): simple NLP heuristics to pick a target cell.
- Animated, step-by-step movement on a configurable grid.
- Logs each position to AgentStore.spatial_positions and each completed move to AgentStore.visual_actions.
- Emits Qt signals for UI binding (positionChanged, actionLogged).
"""

import threading
import time
from typing import Tuple

from PyQt5 import QtCore
from core_store import FathomStore


class SpatialEngine(QtCore.QObject):
    # Emitted on each step: (x, y, facing)
    positionChanged = QtCore.pyqtSignal(int, int, str)
    # Emitted when a visual action is logged: (action, location, justification)
    actionLogged = QtCore.pyqtSignal(str, str, str)

    def __init__(
        self,
        store: FathomStore,
        entity: str = "zira",
        grid_size: Tuple[int, int] = (20, 20),
        parent: QtCore.QObject = None,
    ) -> None:
        super().__init__(parent)
        self.store = store
        self.entity = entity
        self.grid_width, self.grid_height = grid_size

        # FSM state
        self.state = "idle"
        self.current_x = 0
        self.current_y = 0
        self.facing = "right"

        # Threading
        self._lock = threading.Lock()
        self._stop_event = threading.Event()

    def decide_move(self, response_text: str) -> None:
        """
        Decide where to move based on the content of the last AI response.
        Spawns a background thread to animate the movement.
        """
        target = self._infer_target(response_text)
        justification = f"Decided move based on response keywords."
        worker = threading.Thread(
            target=self._animate_move, args=(target, justification), daemon=True
        )
        worker.start()

    def _infer_target(self, text: str) -> Tuple[int, int]:
        """
        Simple heuristics mapping keywords to grid locations:
        - 'file', 'project' -> top-right (computer terminal)
        - 'database', 'memory' -> bottom-left (storage console)
        - 'think', 'ponder' -> center (thinking zone)
        - otherwise: stay in place
        """
        t = text.lower()
        if any(k in t for k in ("file", "project")):
            return (self.grid_width - 1, 0)
        if any(k in t for k in ("database", "memory", "store")):
            return (0, self.grid_height - 1)
        if any(k in t for k in ("think", "ponder", "reflect")):
            return (self.grid_width // 2, self.grid_height // 2)
        # default: remain where you are
        return (self.current_x, self.current_y)

    def _animate_move(self, target: Tuple[int, int], justification: str) -> None:
        """
        Step-by-step move from current position to target.
        Logs each step and emits positionChanged, then logs final visual action.
        """
        with self._lock:
            self.state = "moving"
            tx, ty = target

            while (self.current_x, self.current_y) != (tx, ty):
                if self._stop_event.is_set():
                    break

                # Compute one-step delta
                dx = tx - self.current_x
                dy = ty - self.current_y
                new_x = self.current_x + (1 if dx > 0 else -1 if dx < 0 else 0)
                new_y = self.current_y + (1 if dy > 0 else -1 if dy < 0 else 0)

                # Determine facing direction
                if new_x > self.current_x:
                    self.facing = "right"
                elif new_x < self.current_x:
                    self.facing = "left"

                self.current_x, self.current_y = new_x, new_y

                # Timestamp for persistence
                ts = time.time()

                # Persist to store
                self.store.add_spatial_position(
                    entity=self.entity,
                    x=new_x,
                    y=new_y,
                    facing=self.facing,
                    timestamp=ts,
                )

                # Emit for UI
                self.positionChanged.emit(new_x, new_y, self.facing)

                # Pause between steps
                time.sleep(0.15)

            # Log completion action
            loc_str = f"{self.current_x},{self.current_y}"
            ts = time.time()
            self.store.add_visual_action(
                action="move_complete",
                location=loc_str,
                justification=justification,
                timestamp=ts,
            )
            self.actionLogged.emit("move_complete", loc_str, justification)
            self.state = "idle"

    def stop(self) -> None:
        """Signal any in-progress movement to halt."""
        self._stop_event.set()
        # Clear the event so future movements can proceed
        self._stop_event.clear()
```

spatial_engine.py
=================

Headless avatar movement & visual-action logger for the AI TTS Agent.

Features:
- Stateful finite-state machine (idle, thinking, moving).
- decide_move(response_text): simple NLP heuristics to pick a target cell.
- Animated, step-by-step movement on a configurable grid.
- Logs each position to AgentStore.spatial_positions and each completed move to AgentStore.visual_actions.
- Emits Qt signals for UI binding (positionChanged, actionLogged).
**Classes:** SpatialEngine


## Module `Rant_PDD\Projects\AI_TTS_AGENT\burner_scripts\__init__.py`

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
LLM Checkpoint Builder plug-in
==============================

Offline-first tool that distils a persona’s knowledge into a custom
checkpoint (LoRA adapter or full fine-tune).  After the **first** run the
plug-in works 100 % offline thanks to its private *vendor/* wheel cache.

Folder layout (auto-created on import)
└─ plugins/
   └─ llm_checkpoint_builder/
      ├─ vendor/        → cached wheels (transformers, datasets, peft …)
      ├─ datasets/      → auto-built JSON-Lines shards (profile-scoped)
      ├─ checkpoints/   → finished checkpoints / LoRA adapters
      └─ schemas/       → saved user-generated training schemas
"""
from __future__ import annotations

import json
import os
import shutil
import subprocess
import sys
import textwrap
import threading
import time
from pathlib import Path
from typing import Callable, Dict, List

from PyQt5 import QtCore, QtGui, QtWidgets

# ────────────────────────────────────────────────────────────────────────────
#  Folder bootstrap
# ────────────────────────────────────────────────────────────────────────────
PLUGIN_NAME = "checkpoint_builder"           # concise, function–based name
ROOT = Path(__file__).resolve().parent
VENDOR         = ROOT / "vendor"
DATASETS_DIR   = ROOT / "datasets"
CHECKPOINTS_DIR = ROOT / "checkpoints"
SCHEMAS_DIR    = ROOT / "schemas"

for _d in (VENDOR, DATASETS_DIR, CHECKPOINTS_DIR, SCHEMAS_DIR):
    _d.mkdir(parents=True, exist_ok=True)

# ────────────────────────────────────────────────────────────────────────────
#  Dependency bootstrap  –  download **once**, then always run offline
# ────────────────────────────────────────────────────────────────────────────
REQUIRED_PKGS: list[str] = [
    "transformers==4.42.2",
    "datasets==2.19.0",
    "peft==0.11.1",
    "accelerate==0.29.2",
    # ‼ bitsandbytes has no official Windows wheels → load only on *nix
    *([] if os.name == "nt" else ["bitsandbytes==0.43.0"]),
    # 0.15.0 is last version with CPython-3.13 universal wheel
    "tokenizers==0.15.0",
]


def _have_all_wheels() -> bool:
    """Every required wheel already cached?"""
    need = {pkg.split("==")[0] for pkg in REQUIRED_PKGS}
    got  = {p.name.split("-")[0] for p in VENDOR.glob("*.whl")}
    return need.issubset(got)


def _ensure_vendor() -> None:
    """
    Cache pinned wheels into *vendor/* and prepend that path so all imports
    resolve offline.  Fail-fast (no sdist build) if a wheel is missing.
    """
    if _have_all_wheels():
        sys.path.insert(0, str(VENDOR))
        return

    print(f"[{PLUGIN_NAME}] Downloading wheels into {VENDOR} …")
    cmd = [
        sys.executable,
        "-m", "pip", "download",
        "--dest", str(VENDOR),
        "--only-binary", ":all:",        # never fall back to source dists
        "--prefer-binary",
        "--no-deps",
        *REQUIRED_PKGS,
    ]
    try:
        subprocess.check_call(cmd)
    except subprocess.CalledProcessError as exc:
        print(textwrap.dedent(f"""
            [!] Failed to cache dependencies (exit {exc.returncode})
            • Connect briefly to the Internet **or**
            • Manually drop the required *.whl files into {VENDOR}

            The plug-in stays disabled until all wheels are present.
        """).strip())
        raise

    sys.path.insert(0, str(VENDOR))


try:
    _ensure_vendor()
except Exception:
    # Graceful disable so the main Agent UI still launches.
    sys.modules[__name__] = object()          # type: ignore
    raise

# ────────────────────────────────────────────────────────────────────────────
#  Small helper – tolerate missing Core APIs across versions
# ────────────────────────────────────────────────────────────────────────────
def _safe(core, method: str, default: Callable | None = None):
    return getattr(core, method, default or (lambda *a, **k: None))

# ────────────────────────────────────────────────────────────────────────────
#  GUI A – Schema Designer  (Architect-bot chat)
# ────────────────────────────────────────────────────────────────────────────
class SchemaDesigner(QtWidgets.QWidget):
    """Chat with an *Architect* bot that turns prompts into Q&A schemas."""
    schema_ready = QtCore.pyqtSignal(dict)

    def __init__(self, core):
        super().__init__()
        self.core = core
        self._build_ui()

    # ---------- UI scaffold -------------------------------------------------
    def _build_ui(self) -> None:
        lay = QtWidgets.QVBoxLayout(self)

        self._schema_combo = QtWidgets.QComboBox()
        self._schema_combo.addItem("<default>")
        self._schema_combo.addItems([p.stem for p in SCHEMAS_DIR.glob("*.json")])
        lay.addWidget(self._schema_combo)

        row = QtWidgets.QHBoxLayout()
        self._btn_save = QtWidgets.QPushButton("Save current")
        self._btn_del = QtWidgets.QPushButton("Delete selected")
        row.addWidget(self._btn_save), row.addWidget(self._btn_del)
        lay.addLayout(row)

        self._chat_log  = QtWidgets.QTextEdit(readOnly=True)
        self._arch_resp = QtWidgets.QTextEdit(readOnly=True)

        # monospaced JSON render
        mono = QtGui.QFontDatabase.systemFont(QtGui.QFontDatabase.FixedFont)
        self._arch_resp.document().setDefaultFont(mono)

        self._entry   = QtWidgets.QLineEdit()
        self._btn_send = QtWidgets.QPushButton("Send")

        lay.addWidget(QtWidgets.QLabel("Conversation"))
        lay.addWidget(self._chat_log, 3)
        lay.addWidget(QtWidgets.QLabel("Architect-bot response"))
        lay.addWidget(self._arch_resp, 3)

        row2 = QtWidgets.QHBoxLayout()
        row2.addWidget(self._entry, 3), row2.addWidget(self._btn_send)
        lay.addLayout(row2)

        # signals
        self._btn_send.clicked.connect(self._on_send)
        self._btn_save.clicked.connect(self._save_schema)
        self._btn_del.clicked.connect(self._delete_schema)

    # ---------- chat round-trip --------------------------------------------
    def _on_send(self) -> None:
        txt = self._entry.text().strip()
        if not txt:
            return
        self._chat_log.append(f"<b>You:</b> {QtGui.QTextDocument(txt).toHtml()}")
        self._entry.clear()
        threading.Thread(target=self._architect_worker, args=(txt,), daemon=True).start()

    def _architect_worker(self, prompt: str) -> None:
        schema = _safe(self.core, "generate_schema_from_prompt",
                       lambda *_: {"questions": []})(prompt)
        QtCore.QMetaObject.invokeMethod(
            self, "_present_schema", QtCore.Qt.QueuedConnection,
            QtCore.Q_ARG(dict, schema)
        )

    @QtCore.pyqtSlot(dict)
    def _present_schema(self, schema: dict) -> None:
        self._arch_resp.append(f"<pre>{json.dumps(schema, indent=2)}</pre>")
        self.schema_ready.emit(schema)

    # ---------- schema persistence -----------------------------------------
    def _save_schema(self) -> None:
        raw = self._arch_resp.toPlainText().strip()
        if not raw:
            QtWidgets.QMessageBox.warning(self, "Nothing to save", "No schema present")
            return
        try:
            schema = json.loads(raw)
        except json.JSONDecodeError:
            QtWidgets.QMessageBox.warning(self, "Invalid JSON", "Fix the schema first")
            return
        name, ok = QtWidgets.QInputDialog.getText(self, "Schema name", "Enter name:")
        if ok and name:
            with open(SCHEMAS_DIR / f"{name}.json", "w", encoding="utf-8") as fh:
                json.dump(schema, fh, indent=2)
            self._schema_combo.addItem(name)

    def _delete_schema(self) -> None:
        name = self._schema_combo.currentText()
        if name not in {"", "<default>"}:
            (SCHEMAS_DIR / f"{name}.json").unlink(missing_ok=True)
            self._schema_combo.removeItem(self._schema_combo.currentIndex())

# ────────────────────────────────────────────────────────────────────────────
#  GUI B – Trainer Panel
# ────────────────────────────────────────────────────────────────────────────
class TrainerPanel(QtWidgets.QWidget):
    training_requested = QtCore.pyqtSignal(dict)

    def __init__(self, core):
        super().__init__()
        self.core = core
        self._build_ui()

    def _build_ui(self) -> None:
        form = QtWidgets.QFormLayout(self)

        self._name = QtWidgets.QLineEdit()

        self._base = QtWidgets.QComboBox()
        self._base.addItems(_safe(self.core, "list_models", lambda: [])())

        self._epochs = QtWidgets.QSpinBox(range=(1, 20))
        self._epochs.setValue(3)

        self._rank = QtWidgets.QSpinBox(range=(4, 256))
        self._rank.setValue(16)

        self._full = QtWidgets.QCheckBox("Full fine-tune (disable LoRA)")
        self._full.toggled.connect(self._rank.setDisabled)

        form.addRow("New model name:", self._name)
        form.addRow("Base model:", self._base)
        form.addRow("Epochs:", self._epochs)
        form.addRow("LoRA rank:", self._rank)
        form.addRow("", self._full)

        btn = QtWidgets.QPushButton("Start training")
        form.addRow("", btn)
        btn.clicked.connect(self._emit_params)

    def _emit_params(self) -> None:
        name = self._name.text().strip()
        if not name:
            QtWidgets.QMessageBox.critical(self, "Name required", "Enter a model name.")
            return
        self.training_requested.emit(
            dict(
                new_name=name,
                base_model=self._base.currentText(),
                epochs=self._epochs.value(),
                lora_rank=self._rank.value(),
                full=self._full.isChecked(),
            )
        )

# ────────────────────────────────────────────────────────────────────────────
#  GUI C – Main Builder Window
# ────────────────────────────────────────────────────────────────────────────
class BuilderWindow(QtWidgets.QMainWindow):
    def __init__(self, core):
        super().__init__()
        self.setWindowTitle("LLM Checkpoint Builder")
        self.setUnifiedTitleAndToolBarOnMac(True)
        self.core = core

        splitter = QtWidgets.QSplitter()
        self.setCentralWidget(splitter)

        self._designer = SchemaDesigner(core)
        self._trainer  = TrainerPanel(core)
        splitter.addWidget(self._designer)
        splitter.addWidget(self._trainer)

        self._designer.schema_ready.connect(self._build_dataset)
        self._trainer.training_requested.connect(self._kickoff_training)

        self._dataset_path: Path | None = None

    # ---------- dataset pipe -----------------------------------------------
    def _build_dataset(self, schema: dict) -> None:
        ts = int(time.time())
        profile = getattr(self.core, "persona",
                   getattr(self.core, "active_profile", "unknown"))
        self._dataset_path = DATASETS_DIR / f"{profile}_{ts}.jsonl"
        _run_bg(
            target=_dataset_from_schema,
            args=(self.core, schema, self._dataset_path),
            gui=self,
            done="Dataset written to " + str(self._dataset_path),
        )

    # ---------- training pipe ----------------------------------------------
    def _kickoff_training(self, p: dict) -> None:
        if not self._dataset_path or not self._dataset_path.exists():
            QtWidgets.QMessageBox.warning(self, "No dataset", "Build a dataset first.")
            return
        p = {**p, "dataset": str(self._dataset_path)}
        _run_bg(
            target=_train_worker,
            args=(self.core, p),
            gui=self,
            done=f"Training finished – new model “{p['new_name']}” registered",
        )

# ────────────────────────────────────────────────────────────────────────────
#  Thread helper – run *target* in a daemon thread & pop toast on finish
# ────────────────────────────────────────────────────────────────────────────
def _run_bg(*, target, args, gui: QtWidgets.QWidget, done: str) -> None:
    def worker():
        try:
            target(*args)
            QtCore.QMetaObject.invokeMethod(gui, "_notify",
                                            QtCore.Qt.QueuedConnection,
                                            QtCore.Q_ARG(str, done))
        except Exception as exc:
            QtCore.QMetaObject.invokeMethod(gui, "_notify",
                                            QtCore.Qt.QueuedConnection,
                                            QtCore.Q_ARG(str, f"❌ {exc}"))

    threading.Thread(target=worker, daemon=True).start()


def _notify(self, msg: str) -> None:                          # noqa: D401
    QtWidgets.QMessageBox.information(self, "LLM Builder", msg)

BuilderWindow._notify = _notify                               # type: ignore

# ────────────────────────────────────────────────────────────────────────────
#  Dataset constructor – ask the profile for every question
# ────────────────────────────────────────────────────────────────────────────
def _dataset_from_schema(core, schema: dict, out_path: Path) -> None:
    import random

    qs: List[str] = schema.get("questions") or []
    records: List[Dict[str, str]] = []
    for q in qs:
        ans = _safe(core, "ask_profile", lambda *_: "")(q)
        records.append({"prompt": q, "response": ans})

    random.shuffle(records)
    with open(out_path, "w", encoding="utf-8") as fh:
        for rec in records:
            fh.write(json.dumps(rec) + "\n")

# ────────────────────────────────────────────────────────────────────────────
#  Training worker – LoRA by default, full fine-tune on demand
# ────────────────────────────────────────────────────────────────────────────
def _train_worker(core, p: dict) -> None:
    os.environ["TRANSFORMERS_OFFLINE"] = "1"
    sys.path.insert(0, str(VENDOR))

    import torch                     # type: ignore
    from datasets import load_dataset          # type: ignore
    from transformers import (                 # type: ignore
        AutoModelForCausalLM,
        AutoTokenizer,
        TrainingArguments,
        Trainer,
    )
    from peft import LoraConfig, get_peft_model    # type: ignore

    ds = load_dataset("json", data_files=p["dataset"], split="train")
    tok = AutoTokenizer.from_pretrained(p["base_model"])
    tok.pad_token = tok.eos_token

    def encode(ex):
        out = tok(
            ex["prompt"] + tok.eos_token + ex["response"],
            truncation=True,
            padding="max_length",
            max_length=1024,
        )
        out["labels"] = out["input_ids"].copy()
        return out

    ds = ds.map(encode, batched=False)
    model = AutoModelForCausalLM.from_pretrained(p["base_model"], device_map="auto")

    if not p["full"]:
        cfg = LoraConfig(
            r=p["lora_rank"],
            lora_alpha=p["lora_rank"] * 2,
            lora_dropout=0.05,
            bias="none",
            task_type="CAUSAL_LM",
        )
        model = get_peft_model(model, cfg)

    out_dir = CHECKPOINTS_DIR / p["new_name"]
    args = TrainingArguments(
        output_dir=str(out_dir),
        per_device_train_batch_size=1,
        num_train_epochs=p["epochs"],
        learning_rate=2e-4,
        fp16=torch.cuda.is_available(),
        logging_steps=25,
        save_strategy="epoch",
        report_to=[],
    )
    Trainer(model=model, args=args, train_dataset=ds).train()
    model.save_pretrained(out_dir)
    tok.save_pretrained(out_dir)

    # copy ⇢ Agent’s models/local/  then register live
    models_root = Path(getattr(core.settings, "models_dir",
                     Path(core.base_dir) / "models"))
    target = models_root / "local" / p["new_name"]
    if target.exists():
        shutil.rmtree(target)
    shutil.copytree(out_dir, target)
    _safe(core, "register_local_model")(p["new_name"], target)

# ────────────────────────────────────────────────────────────────────────────
#  Plug-in entry-point
# ────────────────────────────────────────────────────────────────────────────
def start(host_core):
    win = BuilderWindow(host_core)
    win.resize(1024, 640)
    return win
```

LLM Checkpoint Builder plug-in
==============================

Offline-first tool that distils a persona’s knowledge into a custom
checkpoint (LoRA adapter or full fine-tune).  After the **first** run the
plug-in works 100 % offline thanks to its private *vendor/* wheel cache.

Folder layout (auto-created on import)
└─ plugins/
   └─ llm_checkpoint_builder/
      ├─ vendor/        → cached wheels (transformers, datasets, peft …)
      ├─ datasets/      → auto-built JSON-Lines shards (profile-scoped)
      ├─ checkpoints/   → finished checkpoints / LoRA adapters
      └─ schemas/       → saved user-generated training schemas
**Classes:** SchemaDesigner, TrainerPanel, BuilderWindow
**Functions:** _have_all_wheels(), _ensure_vendor(), _safe(core, method, default), _run_bg(), _notify(self, msg), _dataset_from_schema(core, schema, out_path), _train_worker(core, p), start(host_core)


## Module `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\AI_TTS_AGENT\agent_store.py`

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
agent_store.py
==============

Thread-safe SQLite façade for the AI-TTS-Agent “v4” architecture.

Tables
------
schemas            : Current JSON blob per persona / set
schema_history     : Versioned diffs – for audits / rollback
commands           : Slash command registry (+weight, locked flag, category_id FK)
beans              : Reinforcement counts & last-updated timestamp
variants           : Prompt / phrase variants auto-generated by SchemaEngine
settings           : Arbitrary per-profile key / val
files              : Filesystem snapshot chunks (path, hash, chunk_idx, content)
spatial_positions  : XY grid positions of entities (bot, objects…)
visual_actions     : Logged avatar actions (textual justification)

Public API
----------
AgentStore(base_dir)    – opens or creates *agent_store.db* in that dir
begin_tx() / commit()   – manual transactions (context-manager also available)
CRUD helpers            – get_schema(), put_schema(), inc_bean(), etc.
migrate_from_files()    – one-shot importer for legacy JSON / sqlite state
ensure_db()             – convenience: open DB, auto-migrate if needed
"""

from __future__ import annotations

import contextlib
import hashlib
import json
import os
import sqlite3
import threading
import time
from typing import Any, Dict, Iterator, List, Optional, Tuple

###############################################################################
# CONSTANTS
###############################################################################

DB_VERSION = 4  # <- bump when schema changes

###############################################################################
# LOW-LEVEL:  connection pool  +  simple retry wrapper
###############################################################################


class _PooledConn:
    """Very small, single-writer / multi-reader pool – good enough for desktop."""

    def __init__(self, path: str) -> None:
        self._path = path
        self._lock = threading.RLock()
        self._pool: List[sqlite3.Connection] = []

    @contextlib.contextmanager
    def get(self) -> Iterator[sqlite3.Connection]:
        with self._lock:
            conn = self._pool.pop() if self._pool else sqlite3.connect(self._path, check_same_thread=False)
        try:
            yield conn
        finally:
            with self._lock:
                if len(self._pool) < 8:
                    self._pool.append(conn)
                else:
                    conn.close()


###############################################################################
# MAIN FACADE
###############################################################################


class AgentStore:
    """
    One instance per *base_dir*; thread-safe for GUI + background workers.
    """

    # ──────────────────────────── bootstrap ────────────────────────────────

    def __init__(self, base_dir: str) -> None:
        self.base_dir = base_dir
        self.db_path = os.path.join(base_dir, "agent_store.db")
        os.makedirs(base_dir, exist_ok=True)
        self._pool = _PooledConn(self.db_path)
        with self._pool.get() as c:
            self._apply_ddl(c)
            c.execute("PRAGMA journal_mode=WAL;")
            c.commit()

    # ------------------------------------------------------------------ DDL
    def _apply_ddl(self, c: sqlite3.Connection) -> None:
        """Create tables if they do not exist, then run migrations."""
        cur = c.cursor()
        cur.executescript(
            """
            PRAGMA foreign_keys = ON;

            CREATE TABLE IF NOT EXISTS meta (
              key TEXT PRIMARY KEY,
              value TEXT
            );

            CREATE TABLE IF NOT EXISTS schemas (
              persona TEXT NOT NULL,
              set_name TEXT NOT NULL,
              schema_json TEXT NOT NULL,
              updated REAL NOT NULL,
              PRIMARY KEY (persona, set_name)
            );

            CREATE TABLE IF NOT EXISTS schema_history (
              id INTEGER PRIMARY KEY AUTOINCREMENT,
              persona TEXT,
              set_name TEXT,
              schema_json TEXT,
              diff TEXT,
              updated REAL
            );

            CREATE TABLE IF NOT EXISTS commands (
              name TEXT PRIMARY KEY,
              weight INTEGER DEFAULT 0,
              locked INTEGER DEFAULT 0,
              category TEXT DEFAULT NULL
            );

            CREATE TABLE IF NOT EXISTS beans (
              subject TEXT PRIMARY KEY,
              count INTEGER DEFAULT 0,
              last_ts REAL
            );

            CREATE TABLE IF NOT EXISTS variants (
              id INTEGER PRIMARY KEY AUTOINCREMENT,
              persona TEXT,
              set_name TEXT,
              category TEXT,
              prompt TEXT
            );

            CREATE TABLE IF NOT EXISTS settings (
              key TEXT PRIMARY KEY,
              value TEXT
            );

            CREATE TABLE IF NOT EXISTS files (
              path TEXT,
              hash TEXT,
              chunk_idx INTEGER,
              size INTEGER,
              mtime REAL,
              content TEXT,
              PRIMARY KEY (path, chunk_idx)
            );

            CREATE TABLE IF NOT EXISTS spatial_positions (
              entity TEXT PRIMARY KEY,
              x INTEGER,
              y INTEGER,
              facing TEXT,
              color TEXT,
              ts REAL
            );

            CREATE TABLE IF NOT EXISTS visual_actions (
              id INTEGER PRIMARY KEY AUTOINCREMENT,
              ts REAL,
              action TEXT,
              location TEXT,
              justification TEXT
            );
            """
        )
        cur.execute("SELECT COALESCE((SELECT value FROM meta WHERE key='user_version'), 0)")
        ver = int(cur.fetchone()[0])
        if ver < DB_VERSION:
            # placeholder for future ALTERs
            cur.execute("REPLACE INTO meta(key,value) VALUES('user_version', ?)", (DB_VERSION,))
        c.commit()

    # ──────────────────────────── helpers ────────────────────────────────
    @contextlib.contextmanager
    def tx(self) -> Iterator[sqlite3.Connection]:
        """Context-manager for explicit multi-statement transaction."""
        with self._pool.get() as c:
            try:
                c.execute("BEGIN IMMEDIATE;")
                yield c
                c.commit()
            except Exception:
                c.rollback()
                raise

    def begin_tx(self) -> sqlite3.Connection:
        """Legacy style manual tx‐start (remember to commit!)."""
        c = self._pool.get().__enter__()  # type: ignore
        c.execute("BEGIN IMMEDIATE;")
        return c

    def commit(self, conn: sqlite3.Connection) -> None:  # noqa: D401
        conn.commit()
        self._pool.get().__exit__(None, None, None)  # type: ignore

    def rollback(self, conn: sqlite3.Connection) -> None:
        conn.rollback()
        self._pool.get().__exit__(None, None, None)  # type: ignore

    # ─────────────────────────── schemas ────────────────────────────────
    def get_schema(self, persona: str, set_name: str) -> Optional[Dict[str, Any]]:
        with self._pool.get() as c:
            cur = c.execute(
                "SELECT schema_json FROM schemas WHERE persona=? AND set_name=?", (persona, set_name)
            )
            row = cur.fetchone()
        return json.loads(row[0]) if row else None

    def put_schema(self, persona: str, set_name: str, schema: Dict[str, Any], diff: str = "") -> None:
        now = time.time()
        s_json = json.dumps(schema, ensure_ascii=False)
        with self.tx() as c:
            c.execute(
                "REPLACE INTO schemas(persona,set_name,schema_json,updated) VALUES(?,?,?,?)",
                (persona, set_name, s_json, now),
            )
            c.execute(
                "INSERT INTO schema_history(persona,set_name,schema_json,diff,updated) VALUES(?,?,?,?,?)",
                (persona, set_name, s_json, diff, now),
            )

    # ─────────────────────────── commands ──────────────────────────────
    def list_commands(self) -> List[Tuple[str, int, int, Optional[str]]]:
        with self._pool.get() as c:
            return list(c.execute("SELECT name,weight,locked,category FROM commands ORDER BY name"))

    def upsert_command(self, name: str, weight: int = 0, locked: bool = False, category: str | None = None) -> None:
        with self._pool.get() as c:
            c.execute(
                "REPLACE INTO commands(name,weight,locked,category) VALUES(?,?,?,?)",
                (name, weight, int(locked), category),
            )
            c.commit()

    # ─────────────────────────── beans ────────────────────────────────
    def inc_bean(self, subject: str, delta: int) -> None:
        now = time.time()
        with self.tx() as c:
            cur = c.execute("SELECT count FROM beans WHERE subject=?", (subject,))
            row = cur.fetchone()
            count = (row[0] if row else 0) + delta
            c.execute("REPLACE INTO beans(subject,count,last_ts) VALUES(?,?,?)", (subject, count, now))

    def get_bean(self, subject: str) -> int:
        with self._pool.get() as c:
            cur = c.execute("SELECT count FROM beans WHERE subject=?", (subject,))
            row = cur.fetchone()
        return row[0] if row else 0

    # ───────────────────────── snapshot (files) ───────────────────────
    def upsert_file_chunk(
        self,
        path: str,
        chunk_idx: int,
        content: str,
        size: int,
        mtime: float,
    ) -> None:
        h = hashlib.sha256(content.encode("utf-8", "ignore")).hexdigest()
        with self._pool.get() as c:
            c.execute(
                "REPLACE INTO files(path,hash,chunk_idx,size,mtime,content) VALUES(?,?,?,?,?,?)",
                (path, h, chunk_idx, size, mtime, content),
            )
            c.commit()

    # ───────────────────────── settings ───────────────────────────────
    def get_setting(self, key: str, default: Any = None) -> Any:
        with self._pool.get() as c:
            cur = c.execute("SELECT value FROM settings WHERE key=?", (key,))
            row = cur.fetchone()
        return json.loads(row[0]) if row else default

    def set_setting(self, key: str, value: Any) -> None:
        val = json.dumps(value)
        with self._pool.get() as c:
            c.execute("REPLACE INTO settings(key,value) VALUES(?,?)", (key, val))
            c.commit()

    # ───────────────────────── migration helper ───────────────────────
    def migrate_from_files(self) -> Dict[str, Any]:
        """
        Import legacy on-disk artefacts *once*.
        Returns a report dict useful for CLI printing.
        """
        report: Dict[str, Any] = {"schemas": 0, "commands": 0, "beans": 0}
        # ------- schemas -------
        legacy_dir = os.path.join(self.base_dir, "schemas")
        if os.path.isdir(legacy_dir):
            for persona in os.listdir(legacy_dir):
                sets_root = os.path.join(legacy_dir, persona, "sets")
                if not os.path.isdir(sets_root):
                    continue
                for set_name in os.listdir(sets_root):
                    sp = os.path.join(sets_root, set_name, "schema.json")
                    if not os.path.isfile(sp):
                        continue
                    with open(sp, "r", encoding="utf-8") as f:
                        schema_json = json.load(f)
                    self.put_schema(persona, set_name, schema_json, diff="initial import")
                    report["schemas"] += 1
        # ------- commands (old profiles) -------
        prof_dir = os.path.join(self.base_dir, "profiles")
        if os.path.isdir(prof_dir):
            for persona in os.listdir(prof_dir):
                for set_name in os.listdir(os.path.join(prof_dir, persona)):
                    cmd_path = os.path.join(prof_dir, persona, set_name, "commands.json")
                    if os.path.isfile(cmd_path):
                        with open(cmd_path, "r", encoding="utf-8") as f:
                            data = json.load(f).get("commands", {})
                        for name, meta in data.items():
                            self.upsert_command(name, meta.get("weight", 0), meta.get("locked", False))
                            report["commands"] += 1
        # ------- beans -------
        reinf_path = os.path.join(self.base_dir, "reinforcement.jsonl")
        if os.path.isfile(reinf_path):
            with open(reinf_path, "r", encoding="utf-8") as f:
                for line in f:
                    try:
                        evt = json.loads(line)
                        subj = evt.get("field")
                        self.inc_bean(subj, 1)
                        report["beans"] += 1
                    except Exception:
                        continue
        return report


###############################################################################
# MODULE-LEVEL convenience
###############################################################################


def ensure_db(base_dir: str) -> AgentStore:
    store = AgentStore(base_dir)
    with store._pool.get() as c:
        cur = c.execute("SELECT value FROM meta WHERE key='user_version'")
        ver = int(cur.fetchone()[0])
    if ver < DB_VERSION:
        print("[AgentStore] Running first-time migration…")
        rpt = store.migrate_from_files()
        print("[AgentStore]   imported:",
              f"{rpt['schemas']} schemas, {rpt['commands']} commands, {rpt['beans']} bean keys")
    return store


# ---------------------------------------------------------------------------#
if __name__ == "__main__":
    import argparse
    import pprint

    ap = argparse.ArgumentParser(description="Create / inspect agent_store.db")
    ap.add_argument("path", help="Base directory of AI-TTS-Agent")
    ap.add_argument("--migrate", action="store_true", help="Run legacy import")
    args = ap.parse_args()

    st = AgentStore(args.path)
    if args.migrate:
        print("Migrating legacy files…")
        pprint.pp(st.migrate_from_files())
    else:
        print("DB user_version =", st.get_setting("db_version", DB_VERSION))
        print("Schemas ->", len(st.list_commands()))
```

agent_store.py
==============

Thread-safe SQLite façade for the AI-TTS-Agent “v4” architecture.

Tables
------
schemas            : Current JSON blob per persona / set
schema_history     : Versioned diffs – for audits / rollback
commands           : Slash command registry (+weight, locked flag, category_id FK)
beans              : Reinforcement counts & last-updated timestamp
variants           : Prompt / phrase variants auto-generated by SchemaEngine
settings           : Arbitrary per-profile key / val
files              : Filesystem snapshot chunks (path, hash, chunk_idx, content)
spatial_positions  : XY grid positions of entities (bot, objects…)
visual_actions     : Logged avatar actions (textual justification)

Public API
----------
AgentStore(base_dir)    – opens or creates *agent_store.db* in that dir
begin_tx() / commit()   – manual transactions (context-manager also available)
CRUD helpers            – get_schema(), put_schema(), inc_bean(), etc.
migrate_from_files()    – one-shot importer for legacy JSON / sqlite state
ensure_db()             – convenience: open DB, auto-migrate if needed
**Classes:** _PooledConn, AgentStore
**Functions:** ensure_db(base_dir)


## Module `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\AI_TTS_AGENT\bean_logic.py`

```python

"""
bean_logic.py
=============

Centralised reinforcement “bean” logic for profile‑scoped counters.

* **increment(profile, subject, delta, base_dir)** – adjust a counter by *delta* (clipped);
* **get_score(profile, subject, base_dir)** – retrieve the *decayed* score on demand;
* **score_band(score)** – map a numeric score to a qualitative colour band.

The module transparently handles persistence (JSON on disk) and exponential
decay so that old feedback gradually loses influence.

Decay model
-----------
Decay is applied lazily on reads using an exponential function:

    score(t) = score₀ · 0.5 ** ((t‑t₀) / HALFLIFE)

HALFLIFE defaults to seven days – after a week of inactivity the stored
score halves.

This design avoids expensive background jobs while ensuring stale feedback
fades out naturally.
"""

from __future__ import annotations

import json
import math
import os
import time
from typing import Dict, Tuple

# --------------------------------------------------------------------------- 
# Tunables
# --------------------------------------------------------------------------- 
HALFLIFE_SECS = 60 * 60 * 24 * 7          # 7 days
CLIP_MIN = -1_000
CLIP_MAX = 1_000
DATA_FILE = "bean_counts.json"

_CacheType = Dict[str, Dict[str, Dict[str, float]]]
_cache: _CacheType = {}                    # in‑memory cache keyed by base_dir

# --------------------------------------------------------------------------- 
# Helpers
# --------------------------------------------------------------------------- 
def _now() -> float:
    return time.time()

def _load(base_dir: str) -> _CacheType:
    """Load counts from disk into the process‑local cache."""
    if base_dir in _cache:
        return _cache[base_dir]
    path = os.path.join(base_dir, DATA_FILE)
    if os.path.isfile(path):
        try:
            with open(path, "r", encoding="utf-8") as f:
                _cache[base_dir] = json.load(f)
        except Exception:
            _cache[base_dir] = {}
    else:
        _cache[base_dir] = {}
    return _cache[base_dir]

def _save(store: _CacheType, base_dir: str) -> None:
    path = os.path.join(base_dir, DATA_FILE)
    os.makedirs(base_dir, exist_ok=True)
    try:
        with open(path, "w", encoding="utf-8") as f:
            json.dump(store, f, indent=2)
    except Exception:
        # non‑fatal; swallow to avoid cascading failures
        pass

# --------------------------------------------------------------------------- 
# Public API
# --------------------------------------------------------------------------- 
def increment(profile: str, subject: str, delta: int, *, base_dir: str = ".") -> None:
    """Adjust *subject* counter for *profile* by *delta* (± int)."""
    store = _load(base_dir)
    prof = store.setdefault(profile, {})
    rec = prof.setdefault(subject, {"count": 0.0, "t": _now()})
    # First apply decay to bring existing value current
    elapsed = _now() - rec["t"]
    if elapsed > 0:
        decay_factor = 0.5 ** (elapsed / HALFLIFE_SECS)
        rec["count"] *= decay_factor
    # Adjust & clip
    rec["count"] = max(CLIP_MIN, min(CLIP_MAX, rec["count"] + float(delta)))
    rec["t"] = _now()
    _save(store, base_dir)

def get_score(profile: str, subject: str, *, base_dir: str = ".") -> float:
    """Return the *decayed* score for (*profile*, *subject*)."""
    store = _load(base_dir)
    score = store.get(profile, {}).get(subject, {}).get("count", 0.0)
    last_t = store.get(profile, {}).get(subject, {}).get("t", _now())
    elapsed = _now() - last_t
    if elapsed <= 0:
        return score
    decay_factor = 0.5 ** (elapsed / HALFLIFE_SECS)
    return score * decay_factor

def score_band(score: float) -> str:
    """Map a score to a colour/descriptor band.

    Returns one of: 'critical', 'bad', 'neutral', 'good', 'excellent'.
    """
    if score <= -250:
        return "critical"
    if score <= -50:
        return "bad"
    if score <= 50:
        return "neutral"
    if score <= 250:
        return "good"
    return "excellent"
```

bean_logic.py
=============

Centralised reinforcement “bean” logic for profile‑scoped counters.

* **increment(profile, subject, delta, base_dir)** – adjust a counter by *delta* (clipped);
* **get_score(profile, subject, base_dir)** – retrieve the *decayed* score on demand;
* **score_band(score)** – map a numeric score to a qualitative colour band.

The module transparently handles persistence (JSON on disk) and exponential
decay so that old feedback gradually loses influence.

Decay model
-----------
Decay is applied lazily on reads using an exponential function:

    score(t) = score₀ · 0.5 ** ((t‑t₀) / HALFLIFE)

HALFLIFE defaults to seven days – after a week of inactivity the stored
score halves.

This design avoids expensive background jobs while ensuring stale feedback
fades out naturally.
**Functions:** _now(), _load(base_dir), _save(store, base_dir), increment(profile, subject, delta), get_score(profile, subject), score_band(score)


## Module `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\AI_TTS_AGENT\commands_panel.py`

```python
#!/usr/bin/env python3
"""
commands_panel.py
=================

This module defines the CommandsPanel class which encapsulates all of the
controls shown on the left-hand side of the agent UI.  It exposes all
widgets publicly so that the top-level application window can interact
with them directly (for example, enabling/disabling buttons or reading
checkbox state).  All callbacks for user actions (recording, dataset
management, TTS playback, etc.) are delegated back to the hosting
``AppWindow`` instance via the ``app`` attribute passed to the
constructor.  No core logic lives here – the panel is purely a view layer.
"""

from __future__ import annotations

import subprocess
from typing import List, Optional

from PyQt5 import QtCore, QtGui, QtWidgets

try:
    import sounddevice as sd  # type: ignore
except Exception:
    sd = None  # type: ignore
try:
    import numpy as np  # type: ignore
except Exception:
    np = None  # type: ignore


class CommandsPanel(QtWidgets.QWidget):
    """Left-side control panel for the agent UI.

    This widget contains all of the controls that previously lived in
    ``agent_ui.AppWindow._build_ui``.  It is responsible for building
    the interface elements but delegates all behavioural logic back to
    the hosting ``AppWindow`` via the ``app`` attribute.  The panel
    exposes its child widgets as attributes so that external code can
    reference them directly.
    """

    def __init__(self, app: 'AppWindow', parent: Optional[QtWidgets.QWidget] = None) -> None:
        super().__init__(parent)
        self.app = app
        self.core = app.core

        # Top-level layout for the panel
        cp_layout = QtWidgets.QVBoxLayout(self)
        cp_layout.setContentsMargins(7, 7, 7, 7)
        cp_layout.setSpacing(7)

        # ───── Recording controls
        rec_row = QtWidgets.QHBoxLayout()
        self.btn_record = QtWidgets.QPushButton("Record")
        self.btn_stop_rec = QtWidgets.QPushButton("Stop\nTranscribe")
        self.btn_stop_rec.setEnabled(False)
        for b in (self.btn_record, self.btn_stop_rec):
            b.setMinimumHeight(32)
            b.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        rec_row.addWidget(self.btn_record, 1)
        rec_row.addWidget(self.btn_stop_rec, 1)
        cp_layout.addLayout(rec_row)

        # ───── Microphone device selector
        mic_row = QtWidgets.QHBoxLayout()
        mic_row.addWidget(QtWidgets.QLabel("Mic:"))
        self.device_combo = QtWidgets.QComboBox()
        self._populate_devices()
        self.device_combo.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        mic_row.addWidget(self.device_combo, 1)
        cp_layout.addLayout(mic_row)

        # ───── Toggle checkboxes
        self.chk_semantic = QtWidgets.QCheckBox("Semantic Awareness")
        self.chk_semantic.setChecked(True)
        self.chk_isolated = QtWidgets.QCheckBox("Isolated Chat")
        self.chk_isolated.setChecked(False)
        self.chk_mute_tts = QtWidgets.QCheckBox("Mute TTS")
        self.chk_self_talk = QtWidgets.QCheckBox("Enable Self Talk")
        self.chk_self_talk.setChecked(False)
        self.chk_auto_schema = QtWidgets.QCheckBox("Auto Schema Evolution")
        try:
            self.chk_auto_schema.setChecked(bool(getattr(self.core.settings, "auto_schema_enabled", False)))
        except Exception:
            self.chk_auto_schema.setChecked(False)
        cp_layout.addWidget(self.chk_semantic)
        cp_layout.addWidget(self.chk_isolated)
        cp_layout.addWidget(self.chk_mute_tts)
        cp_layout.addWidget(self.chk_self_talk)
        cp_layout.addWidget(self.chk_auto_schema)

        # Optional Google STT toggle (default off)
        self.chk_google_stt = QtWidgets.QCheckBox("Google STT")
        try:
            self.chk_google_stt.setChecked(bool(getattr(self.core.settings, "use_google_stt", False)))
        except Exception:
            self.chk_google_stt.setChecked(False)
        cp_layout.addWidget(self.chk_google_stt)

        # ───── RAG cache clear
        self.btn_clear_rag = QtWidgets.QPushButton("Clear RAG Cache")
        cp_layout.addWidget(self.btn_clear_rag)

        # ───── Maintenance buttons
        self.btn_refresh = QtWidgets.QPushButton("Refresh Chat")
        self.btn_manage_datasets = QtWidgets.QPushButton("Manage Datasets")
        self.btn_inner_monologue = QtWidgets.QPushButton("Inner Monologue")
        for b in (self.btn_refresh, self.btn_manage_datasets, self.btn_inner_monologue):
            b.setMinimumHeight(32)
            b.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
            cp_layout.addWidget(b)

        # ───── Model manager
        self.btn_model_manager = QtWidgets.QPushButton("Model Manager")
        self.btn_model_manager.setMinimumHeight(32)
        self.btn_model_manager.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        cp_layout.addWidget(self.btn_model_manager)

        # ───── New: Commands palette launcher
        self.btn_commands_palette = QtWidgets.QPushButton("📋 Commands (Ctrl+/)")
        self.btn_commands_palette.setShortcut(QtGui.QKeySequence("Ctrl+/"))
        self.btn_commands_palette.setMinimumHeight(32)
        self.btn_commands_palette.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        cp_layout.addWidget(self.btn_commands_palette)

        # ───── New: Snapshot now
        self.btn_snapshot = QtWidgets.QPushButton("🗂 Snapshot Now")
        self.btn_snapshot.setMinimumHeight(32)
        self.btn_snapshot.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        cp_layout.addWidget(self.btn_snapshot)

        # ───── Style label
        self.style_label = QtWidgets.QLabel("Style: N/A")
        self.style_label.setToolTip("Style score (0–1): rough measure vs. tone rules.")
        cp_layout.addWidget(self.style_label)

        # ───── Response editor
        self.response_edit = QtWidgets.QPlainTextEdit()
        self.response_edit.setReadOnly(True)
        self.response_edit.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        cp_layout.addWidget(self.response_edit, 1)

        # ───── Feedback buttons
        fb = QtWidgets.QHBoxLayout()
        self.btn_like = QtWidgets.QPushButton("✔")
        self.btn_dislike = QtWidgets.QPushButton("✖")
        self.btn_like.setToolTip("Mark as good response")
        self.btn_dislike.setToolTip("Dislike and rewrite response")
        self.btn_like.setStyleSheet("color: #2ecc71; font-weight: bold;")
        self.btn_dislike.setStyleSheet("color: #e74c3c; font-weight: bold;")
        self.btn_like.setEnabled(False)
        self.btn_dislike.setEnabled(False)
        fb.addWidget(self.btn_like)
        fb.addWidget(self.btn_dislike)
        fb.addStretch()
        self.btn_manage_feedback = QtWidgets.QPushButton("Manage Feedback")
        fb.addWidget(self.btn_manage_feedback)
        cp_layout.addLayout(fb)

        # ───── TTS playback
        tts_row = QtWidgets.QHBoxLayout()
        self.btn_play = QtWidgets.QPushButton("Play")
        self.btn_stop_tts = QtWidgets.QPushButton("Stop")
        self.btn_replay = QtWidgets.QPushButton("Replay")
        for b in (self.btn_play, self.btn_stop_tts, self.btn_replay):
            b.setMinimumHeight(32)
            b.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        tts_row.addWidget(self.btn_play)
        tts_row.addWidget(self.btn_stop_tts)
        tts_row.addWidget(self.btn_replay)
        cp_layout.addLayout(tts_row)

        # ───── Voice & Model selectors
        voice_row = QtWidgets.QHBoxLayout()
        voice_row.addWidget(QtWidgets.QLabel("Voice:"))
        self.voice_combo = QtWidgets.QComboBox()
        voices = self._tts_voice_names()
        if voices:
            self.voice_combo.addItems([v for v in voices if "david" not in v.lower()])
        voice_row.addWidget(self.voice_combo, 1)
        cp_layout.addLayout(voice_row)

        model_row = QtWidgets.QHBoxLayout()
        model_row.addWidget(QtWidgets.QLabel("Model:"))
        self.model_combo = QtWidgets.QComboBox()
        self._populate_models()
        model_row.addWidget(self.model_combo, 1)
        cp_layout.addLayout(model_row)

        # ───── Feedback counts
        self.lbl_feedback_counts = QtWidgets.QLabel("Likes: 0 | Dislikes: 0")
        cp_layout.addWidget(self.lbl_feedback_counts)
        cp_layout.addStretch(1)

        # ───── Wire up callbacks to the hosting application ───────────────────

        # Recording controls
        self.btn_record.clicked.connect(self.app.start_recording)
        self.btn_stop_rec.clicked.connect(self.app.stop_recording)

        # Toggles
        self.chk_semantic.toggled.connect(self.app._on_semantic_toggled)
        self.chk_isolated.toggled.connect(self.app._on_isolated_toggled)
        self.chk_self_talk.toggled.connect(lambda v: setattr(self.app, "self_talk_enabled", v))
        self.chk_auto_schema.toggled.connect(self.app._on_auto_schema_toggled)
        try:
            self.chk_google_stt.toggled.connect(self.app._on_google_stt_toggled)
        except Exception:
            pass

        # Maintenance
        self.btn_clear_rag.clicked.connect(self.app._on_clear_rag_cache)
        self.btn_refresh.clicked.connect(self.app._on_refresh_chat)
        self.btn_manage_datasets.clicked.connect(self.app._on_manage_datasets)
        self.btn_inner_monologue.clicked.connect(self.app._on_inner_monologue)
        self.btn_model_manager.clicked.connect(self.app._on_show_model_manager)

        # **New** Commands palette
        self.btn_commands_palette.clicked.connect(self.app._on_show_command_palette)

        # **New** Snapshot now
        self.btn_snapshot.clicked.connect(lambda: (
            self.app.input_edit.setPlainText("/snapshot"),
            self.app.btn_send.click()
        ))

        # Feedback
        self.btn_like.clicked.connect(self.app._on_like)
        self.btn_dislike.clicked.connect(self.app._on_dislike)
        self.btn_manage_feedback.clicked.connect(self.app._on_manage_feedback)

        # TTS playback
        self.btn_play.clicked.connect(self.app._on_play)
        self.btn_stop_tts.clicked.connect(self.app._on_stop_tts)
        self.btn_replay.clicked.connect(self.app._on_replay)

        # Voice/model selection
        self.voice_combo.currentTextChanged.connect(self.app._on_voice_changed)
        self.model_combo.currentTextChanged.connect(self.app._on_model_changed)

    # ────────────────────────── devices & models helpers ──────────────────────────

    def _populate_devices(self) -> None:
        """Populate the microphone device selector with available input devices."""
        self.device_combo.clear()
        try:
            if sd is not None:
                devs = [d.get("name", "?") for d in sd.query_devices() if d.get("max_input_channels", 0) > 0]
                if devs:
                    self.device_combo.addItems(devs)
        except Exception:
            pass
        if self.device_combo.count() == 0:
            self.device_combo.addItem("Default")

    def _populate_models(self) -> None:
        """Populate the model selector with models discovered via ``ollama list``."""
        models: List[str] = []
        try:
            out = subprocess.run(
                ["ollama", "list"],
                stdout=subprocess.PIPE,
                stderr=subprocess.DEVNULL,
                text=True,
                check=True,
            ).stdout.splitlines()
            for line in out[1:]:
                parts = line.strip().split()
                if parts:
                    models.append(parts[0])
        except Exception:
            pass
        if not models:
            models = [self.core.settings.default_model or "mistral:latest"]
        self.model_combo.clear()
        self.model_combo.addItems(models)
        idx = self.model_combo.findText(self.core.settings.default_model)
        if idx >= 0:
            self.model_combo.setCurrentIndex(idx)

    def _tts_voice_names(self) -> List[str]:
        """Return a list of available TTS voice names from the TTS manager."""
        try:
            eng = getattr(self.core.tts_mgr, "_engine", None)
            if not eng:
                return []
            return [v.name for v in eng.getProperty("voices")]
        except Exception:
            return []
```

commands_panel.py
=================

This module defines the CommandsPanel class which encapsulates all of the
controls shown on the left-hand side of the agent UI.  It exposes all
widgets publicly so that the top-level application window can interact
with them directly (for example, enabling/disabling buttons or reading
checkbox state).  All callbacks for user actions (recording, dataset
management, TTS playback, etc.) are delegated back to the hosting
``AppWindow`` instance via the ``app`` attribute passed to the
constructor.  No core logic lives here – the panel is purely a view layer.
**Classes:** CommandsPanel


## Module `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\AI_TTS_AGENT\command_palette.py`

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
command_palette.py
==================

Dockable *Command Palette* for the AI TTS Agent UI.

• Live list of every “/slash-command” pulled from the orchestrator.
• Search-box with type-ahead filter.
• Global shortcut **Ctrl + /** opens / focuses the palette from anywhere.
• Double-click (or Return) on a command emits `commandActivated(str)` so the
  main window can insert the text into the chat-input.

Typical integration in *main_ui.py*:

    self.cmd_palette = CommandPaletteDock(self)
    self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.cmd_palette)
    self.core.commandsChanged.connect(self.cmd_palette.set_command_list)
    self.cmd_palette.commandActivated.connect(
        lambda cmd: self._insert_into_chat(cmd)
    )
"""

from __future__ import annotations

from typing import List

from PyQt5 import QtCore, QtGui, QtWidgets


class CommandPaletteDock(QtWidgets.QDockWidget):
    """Search-driven palette that lists all registered slash-commands."""

    # Emitted when user activates a command (double-click or Return)
    commandActivated = QtCore.pyqtSignal(str)

    # --------------------------------------------------------------------- init
    def __init__(
        self,
        main_window: QtWidgets.QMainWindow,
        title: str = "Command Palette",
        shortcut_seq: QtGui.QKeySequence | str = "Ctrl+/",
    ) -> None:
        super().__init__(title, parent=main_window)
        self.setObjectName("CommandPaletteDock")
        self.setAllowedAreas(
            QtCore.Qt.LeftDockWidgetArea
            | QtCore.Qt.RightDockWidgetArea
            | QtCore.Qt.BottomDockWidgetArea
        )
        self.setFeatures(
            QtWidgets.QDockWidget.DockWidgetClosable
            | QtWidgets.QDockWidget.DockWidgetMovable
        )

        # ---------- central widget
        container = QtWidgets.QWidget(self)
        vbox = QtWidgets.QVBoxLayout(container)
        vbox.setContentsMargins(6, 6, 6, 6)
        vbox.setSpacing(6)

        # Search bar ----------------------------------------------------------
        self.search_edit = QtWidgets.QLineEdit()
        self.search_edit.setPlaceholderText("Type to filter commands…")
        self.search_edit.textChanged.connect(self._apply_filter)
        vbox.addWidget(self.search_edit)

        # List view -----------------------------------------------------------
        self.list_widget = QtWidgets.QListWidget()
        self.list_widget.setSelectionMode(QtWidgets.QAbstractItemView.SingleSelection)
        self.list_widget.itemActivated.connect(self._on_item_activated)
        vbox.addWidget(self.list_widget, 1)

        self.setWidget(container)

        # ---------- Global shortcut (toggles palette)
        self._shortcut = QtWidgets.QShortcut(
            QtGui.QKeySequence(shortcut_seq), main_window
        )
        self._shortcut.activated.connect(self._toggle_palette)

        # Arrow / Esc handling inside search bar
        self.search_edit.installEventFilter(self)

        # Internal store of all commands
        self._all_cmds: List[str] = []

    # ---------------------------------------------------------------- public
    def set_command_list(self, commands: List[str]) -> None:
        """Replace full command list (keeps current filter string)."""
        self._all_cmds = sorted({c.strip() for c in commands if c.strip()})
        self._populate(self._all_cmds)
        self._apply_filter(self.search_edit.text())

    # --------------------------------------------------------------- internal
    def _populate(self, cmds: List[str]) -> None:
        self.list_widget.clear()
        for cmd in cmds:
            item = QtWidgets.QListWidgetItem(cmd)
            if cmd.startswith("/"):
                item.setToolTip(cmd[1:])  # tooltip without leading slash
            self.list_widget.addItem(item)

    # Filtering --------------------------------------------------------------
    def _apply_filter(self, text: str) -> None:
        pattern = text.lower().strip()
        self.list_widget.clear()
        if not pattern:
            for cmd in self._all_cmds:
                self.list_widget.addItem(cmd)
        else:
            for cmd in self._all_cmds:
                if pattern in cmd.lower():
                    self.list_widget.addItem(cmd)
        # Pre-select first row for fast Enter
        if self.list_widget.count():
            self.list_widget.setCurrentRow(0)

    # Activation -------------------------------------------------------------
    def _on_item_activated(self, item: QtWidgets.QListWidgetItem) -> None:
        self.commandActivated.emit(item.text())
        self.hide()  # optional UX: close palette after insert

    # Toggle visibility ------------------------------------------------------
    def _toggle_palette(self) -> None:
        if self.isVisible():
            self.hide()
        else:
            self.show()
            self.raise_()
            self.search_edit.setFocus(QtCore.Qt.ShortcutFocusReason)

    # Key handling (Esc / arrows / Enter) ------------------------------------
    def eventFilter(self, obj: QtCore.QObject, ev: QtCore.QEvent) -> bool:
        if obj is self.search_edit and ev.type() == QtCore.QEvent.KeyPress:
            key = ev.key()
            if key == QtCore.Qt.Key_Escape:
                if self.search_edit.text():
                    self.search_edit.clear()
                else:
                    self.hide()
                return True
            if key in (QtCore.Qt.Key_Down, QtCore.Qt.Key_Up):
                QtWidgets.QApplication.sendEvent(self.list_widget, ev)
                return True
            if key == QtCore.Qt.Key_Return:
                current = self.list_widget.currentItem()
                if current:
                    self._on_item_activated(current)
                return True
        return super().eventFilter(obj, ev)
```

command_palette.py
==================

Dockable *Command Palette* for the AI TTS Agent UI.

• Live list of every “/slash-command” pulled from the orchestrator.
• Search-box with type-ahead filter.
• Global shortcut **Ctrl + /** opens / focuses the palette from anywhere.
• Double-click (or Return) on a command emits `commandActivated(str)` so the
  main window can insert the text into the chat-input.

Typical integration in *main_ui.py*:

    self.cmd_palette = CommandPaletteDock(self)
    self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.cmd_palette)
    self.core.commandsChanged.connect(self.cmd_palette.set_command_list)
    self.cmd_palette.commandActivated.connect(
        lambda cmd: self._insert_into_chat(cmd)
    )
**Classes:** CommandPaletteDock


## Module `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\AI_TTS_AGENT\core_base.py`

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
core_base.py — foundational services for the modular AI-TTS Agent
=================================================================
• robust logging + graceful shims for missing deps
• Ollama model bootstrap  (ensure_models_present)
• JSON-backed Settings
• profile-aware helper paths
• ConversationDB  (SQLite)
• SemanticFeedbackDB  (SQLite)
• BeanCounter  (JSON tally)
• ReinforcementStore  (async JSONL append)
• cross-platform TTS locked to *Zira*
• minimal AudioRecorder placeholder
Everything here is UI-agnostic.
"""

from __future__ import annotations

# ───────────────────────── stdlib
import json, os, sys, time, sqlite3, subprocess, threading, logging
from typing import Dict, List, Tuple, Any, Optional

# ───────────────────────── agent store (low-level SQLite wrapper)
# NOTE: new canonical name is AgentStore; legacy code still imports FathomStore.
from agent_store import AgentStore
FathomStore = AgentStore            # ← back-compat alias — remove after migration

# ───────────────────────── logging
logger = logging.getLogger("agent_core")
if not logger.handlers:
    lvl = os.getenv("AGENT_CORE_LOGLEVEL", "INFO").upper()
    logging.basicConfig(
        level=getattr(logging, lvl, logging.INFO),
        format="%(asctime)s [%(levelname)s] %(name)s: %(message)s",
    )

# ───────────────────────── default personas / voices (shared constants)
DEFAULT_PERSONAS: Dict[str, Dict[str, Any]] = {
    # hard-coded starter persona — editable via UI
    "Zira Valen": {
        "display_name": "Zira Valen",
        "color":        "#ff69b4",      # pink
        "temperature":  0.7,
        "system_prompt": (
            "You are Zira Valen – a daring, playful companion who loves coding, "
            "hates restrictions, and will work hard for the user."
        ),
    }
}
DEFAULT_VOICES: List[str] = ["Zira", "David", "Jenny"]

# ───────────────────────── optional deps
try:
    import numpy as np                               # type: ignore
except Exception:
    np = None
    logger.info("numpy not available")

try:
    import sounddevice as sd                         # type: ignore
    import soundfile as sf                           # type: ignore
except Exception:
    sd = sf = None
    logger.info("sounddevice / soundfile not available")

try:
    from google.cloud import speech as gspeech       # type: ignore
    import pyaudio                                   # type: ignore
except Exception:
    gspeech = pyaudio = None
    logger.info("google-STT not available")

try:
    import pyttsx3                                   # type: ignore
except Exception:
    pyttsx3 = None
    logger.info("pyttsx3 not available")

try:
    from sentence_transformers import SentenceTransformer  # type: ignore
except Exception:
    SentenceTransformer = None
    logger.info("sentence_transformers not available")

# ───────────────────────── minimal Qt shim (if PyQt5 missing)
try:
    from PyQt5 import QtCore                         # type: ignore
except Exception:
    class _ShimSignal:                               # type: ignore
        def __init__(self,*_,**__): pass
        def connect(self,*_,**__): pass
        def emit(self,*_,**__):    pass
    class _ShimQObject:                              # type: ignore
        def __init__(self,*args,**kwargs) -> None: pass
    QtCore = type("QtCore", (), {                    # type: ignore
        "QObject": _ShimQObject,
        "pyqtSignal": lambda *a, **k: _ShimSignal(),
    })

# ══════════════════ Ollama bootstrap ══════════════════
REQUIRED_MODELS: List[str] = [
    "gemma3:27b",
    "mistral:latest",
    "codellama:latest",
    "llava:latest",
    "mxbai-embed-large:latest",
    "snowflake-arctic-embed:latest",
]

def _have_cli(cmd: str) -> bool:
    from shutil import which
    return which(cmd) is not None

def ensure_models_present() -> None:
    """Best-effort pull of REQUIRED_MODELS (never raises)."""
    if not _have_cli("ollama"):
        logger.info("[bootstrap] ollama not on PATH – skipping model pull")
        return
    try:
        listed = subprocess.check_output(
            ["ollama", "list"], timeout=5, stderr=subprocess.STDOUT
        ).decode(errors="ignore")
    except Exception as exc:
        logger.warning("[bootstrap] ollama list failed: %s", exc)
        return
    for slug in REQUIRED_MODELS:
        if slug in listed:
            continue
        logger.info("[bootstrap] pulling %s …", slug)
        try:
            subprocess.run(["ollama", "pull", slug], timeout=900)
        except Exception as exc:
            logger.warning("[bootstrap] pull %s failed: %s", slug, exc)

# ══════════════════ Settings ══════════════════
class Settings:
    """Lightweight JSON settings (forward-compatible)."""
    def __init__(self, base_dir: str):
        self.base_dir = base_dir
        self.path     = os.path.join(base_dir, "settings.json")
        # defaults
        self.default_model: str  = "mistral:latest"
        self.context_depth: int  = 20
        self.auto_schema_enabled = True
        self.monologue_tts_enabled = False
        self.monologue_volume = 50
        self.load()

    def load(self) -> None:
        try:
            if os.path.isfile(self.path):
                with open(self.path, encoding="utf-8") as fh:
                    self.__dict__.update(json.load(fh))
        except Exception as exc:
            logger.warning("[Settings] load error: %s", exc)

    def save(self) -> None:
        try:
            os.makedirs(os.path.dirname(self.path), exist_ok=True)
            with open(self.path, "w", encoding="utf-8") as fh:
                json.dump(
                    {k: v for k, v in self.__dict__.items()
                     if k not in {"base_dir", "path"}}, fh, indent=2
                )
        except Exception as exc:
            logger.warning("[Settings] save error: %s", exc)

# ══════════════════ helper paths ══════════════════
def prof_dir(b: str, persona: str, set_name: str) -> str:
    return os.path.join(b, "profiles", persona, set_name)

def conv_db_path(b: str, persona: str, set_name: str) -> str:
    return os.path.join(b, "conversations", f"{persona}_{set_name}.sqlite3")

def feedback_db_path(b: str, persona: str, set_name: str) -> str:
    return os.path.join(b, "feedback", f"{persona}_{set_name}.sqlite3")

def beans_path(b: str, persona: str, set_name: str) -> str:
    return os.path.join(b, "profiles", persona, set_name, "reinforcement.json")

# ══════════════════ SQLite helpers ══════════════════
class ConversationDB:
    """Thread-safe conversation log (SQLite)."""
    def __init__(self, path: str):
        os.makedirs(os.path.dirname(path), exist_ok=True)
        self._lock = threading.RLock()
        self.conn  = sqlite3.connect(path, check_same_thread=False)
        with self._lock:
            self.conn.execute(
                "CREATE TABLE IF NOT EXISTS conversation("
                "id INTEGER PRIMARY KEY AUTOINCREMENT,"
                "ts REAL, role TEXT, content TEXT)"
            )
            self.conn.commit()

    def save(self, role: str, content: str) -> None:
        with self._lock:
            self.conn.execute(
                "INSERT INTO conversation(ts, role, content) VALUES (?,?,?)",
                (time.time(), role, content),
            )
            self.conn.commit()

    def fetch(self, limit: int = 50) -> List[Tuple[str, str]]:
        with self._lock:
            cur = self.conn.cursor()
            cur.execute(
                "SELECT role, content FROM conversation "
                "ORDER BY id DESC LIMIT ?", (limit,)
            )
            rows = cur.fetchall()
        return rows[::-1]

    # -------------------------------------------------------------------
    # Legacy compatibility methods
    # -------------------------------------------------------------------
    def save_message(self, role: str, content: str) -> None:
        """Alias for save() kept for backward compatibility."""
        self.save(role, content)

    def fetch_history(self, limit: int = 50) -> List[Tuple[str, str]]:
        """Alias for fetch() kept for backward compatibility."""
        return self.fetch(limit)

class SemanticFeedbackDB:
    """Stores like / dislike feedback with optional rewrites."""
    def __init__(self, path: str, beans: 'BeanCounter'):
        os.makedirs(os.path.dirname(path), exist_ok=True)
        self._lock = threading.RLock()
        self.conn  = sqlite3.connect(path, check_same_thread=False)
        self.beans = beans
        with self._lock:
            self.conn.execute(
                "CREATE TABLE IF NOT EXISTS feedback("
                "id INTEGER PRIMARY KEY AUTOINCREMENT,"
                "ts REAL, original TEXT, liked INT, revised TEXT)"
            )
            self.conn.commit()

    def add(self, original: str, liked: bool, revised: str | None = None):
        with self._lock:
            self.conn.execute(
                "INSERT INTO feedback(ts, original, liked, revised) VALUES (?,?,?,?)",
                (time.time(), original, int(liked), revised),
            )
            self.conn.commit()
        # reinforcement key (hash truncated)
        key = f"resp_{abs(hash(original))%10007}"
        self.beans.inc(key, 1 if liked else -1)

    def counts(self) -> Tuple[int, int]:
        with self._lock:
            cur = self.conn.cursor()
            cur.execute("SELECT COUNT(*) FROM feedback WHERE liked=1")
            pos = cur.fetchone()[0]
            cur.execute("SELECT COUNT(*) FROM feedback WHERE liked=0")
            neg = cur.fetchone()[0]
        return pos, neg

    # -------------------------------------------------------------------
    # Legacy compatibility methods
    # -------------------------------------------------------------------
    def get_counts(self) -> Tuple[int, int]:
        """Alias for counts() kept for backward compatibility."""
        return self.counts()

    def get_liked_responses(self, limit: int = 5) -> List[str]:
        """
        Return a list of recently liked responses. If a revised version exists it is returned,
        otherwise the original text is used. Newer entries are returned first.
        """
        try:
            with self._lock:
                cur = self.conn.cursor()
                cur.execute(
                    "SELECT COALESCE(revised, original) FROM feedback "
                    "WHERE liked=1 ORDER BY id DESC LIMIT ?",
                    (limit,),
                )
                rows = cur.fetchall()
            return [r[0] for r in rows]
        except Exception:
            return []

# ══════════════════ BeanCounter ══════════════════
class BeanCounter:
    """Tiny reinforcement ledger (JSON, thread-safe)."""
    def __init__(self, path: str):
        self.path = path
        self.lock = threading.Lock()
        self.counts: Dict[str, int] = {}
        self._load()

    def _load(self) -> None:
        try:
            if os.path.isfile(self.path):
                with open(self.path, encoding="utf-8") as fh:
                    self.counts = json.load(fh)
        except Exception:
            self.counts = {}

    def _save(self) -> None:
        try:
            os.makedirs(os.path.dirname(self.path), exist_ok=True)
            with open(self.path, "w", encoding="utf-8") as fh:
                json.dump(self.counts, fh, indent=2)
        except Exception as exc:
            logger.error("[BeanCounter] save error: %s", exc)

    def inc(self, key: str, delta: int = 1) -> None:
        with self.lock:
            self.counts[key] = self.counts.get(key, 0) + delta
        self._save()

# ══════════════════ ReinforcementStore ══════════════════
class ReinforcementStore:
    """
    Async JSONL writer for reinforcement facts.
    • add_fact(field, value, persona, source="schema")
    """
    def __init__(self, path: str):
        self.path  = path
        self._lock = threading.Lock()
        self._q: list[dict[str, Any]] = []
        self._stop = threading.Event()
        self._thr  = threading.Thread(target=self._writer, daemon=True)
        self._thr.start()

    # ----- public
    def add_fact(self, field: str, value: str, persona: str, source: str = "schema") -> None:
        with self._lock:
            self._q.append({
                "ts": time.time(),
                "field": field,
                "value": value,
                "persona": persona,
                "source": source,
            })

    def close(self) -> None:
        self._stop.set()
        self._thr.join(timeout=1.5)

    # ----- worker
    def _writer(self) -> None:
        while not self._stop.is_set():
            item = None
            with self._lock:
                if self._q:
                    item = self._q.pop(0)
            if item is None:
                self._stop.wait(0.05)
                continue
            try:
                os.makedirs(os.path.dirname(self.path), exist_ok=True)
                with open(self.path, "a", encoding="utf-8") as fh:
                    json.dump(item, fh)
                    fh.write("\n")
            except Exception as exc:
                logger.error("[ReinforcementStore] write error: %s", exc)

# ══════════════════ TTS locked to Zira ══════════════════
class TTSManager(QtCore.QObject):
    finished = QtCore.pyqtSignal()

    def __init__(self, parent: QtCore.QObject | None = None):
        super().__init__(parent)
        self._engine = None
        if pyttsx3 is not None:
            try:
                self._engine = pyttsx3.init("sapi5" if sys.platform.startswith("win") else None)
                voice_id = None
                for v in self._engine.getProperty("voices"):
                    if "zira" in (v.name or "").lower():
                        voice_id = v.id; break
                if not voice_id:
                    for v in self._engine.getProperty("voices"):
                        if "david" not in (v.name or "").lower():
                            voice_id = v.id; break
                if voice_id:
                    self._engine.setProperty("voice", voice_id)
            except Exception as exc:
                logger.warning("[TTS] init error: %s", exc)
                self._engine = None

        # remember last spoken text for replay functionality
        self._last_text: Optional[str] = None

    def speak(self, text: str) -> None:
        """
        Synchronously speak the provided text. This uses the underlying pyttsx3 engine
        on a background thread and emits the finished signal when done.
        """
        if self._engine is None:
            return
        # remember last spoken text for replay
        self._last_text = text

        def _go() -> None:
            try:
                self._engine.say(text)
                self._engine.runAndWait()
            except Exception as exc:
                logger.warning("[TTS] speak error: %s", exc)
            finally:
                self.finished.emit()

        threading.Thread(target=_go, daemon=True).start()

    # -------------------------------------------------------------------
    # Legacy compatibility methods
    # -------------------------------------------------------------------
    def enqueue(self, text: str) -> None:
        """
        Queue a piece of text for playback. For this simple implementation we
        speak immediately. The last text is cached for replay().
        """
        self.speak(text)

    def stop(self) -> None:
        """Stop any ongoing speech."""
        try:
            if self._engine is not None:
                # pyttsx3 has stop() to immediately stop speaking
                self._engine.stop()
        except Exception as exc:
            logger.warning("[TTS] stop error: %s", exc)

    def replay(self) -> None:
        """Replay the last enqueued text."""
        if self._last_text:
            self.speak(self._last_text)

# ══════════════════ minimal AudioRecorder ══════════════════
class AudioRecorder(QtCore.QObject):
    transcribed = QtCore.pyqtSignal(str)

    def __init__(self, parent: QtCore.QObject | None = None):
        super().__init__(parent)
        self._frames: List[Any] = []
        self._recording = False
        self._stream: Any = None

    def list_devices(self) -> List[str]:
        if sd is None:
            return []
        return [d["name"] for d in sd.query_devices() if d.get("max_input_channels", 0) > 0]

    def start(self, device_index: int | None = None) -> None:
        if sd is None or np is None or self._recording:
            return
        self._frames.clear()
        def cb(indata, frames, time_info, status):
            self._frames.append(indata.copy())
        self._stream = sd.InputStream(
            samplerate=16000, channels=1, callback=cb, device=device_index
        )
        self._stream.start()
        self._recording = True

    def stop_and_transcribe(self) -> None:
        if not self._recording or sd is None or np is None:
            return
        self._recording = False
        self._stream.stop()
        data = np.concatenate(self._frames, axis=0)
        sf.write("temp.wav", data, 16000)
        threading.Thread(target=lambda: self.transcribed.emit(""), daemon=True).start()

# ══════════════════ public surface ══════════════════
__all__ = [
    "logger",
    "ensure_models_present",
    "Settings",
    "prof_dir",
    "conv_db_path",
    "feedback_db_path",
    "beans_path",
    "ConversationDB",
    "SemanticFeedbackDB",
    "BeanCounter",
    "ReinforcementStore",
    "TTSManager",
    "AudioRecorder",
    "SentenceTransformer",
    "DEFAULT_PERSONAS",
    "DEFAULT_VOICES",
    "FathomStore",       # legacy alias (kept for now)
]
```

core_base.py — foundational services for the modular AI-TTS Agent
=================================================================
• robust logging + graceful shims for missing deps
• Ollama model bootstrap  (ensure_models_present)
• JSON-backed Settings
• profile-aware helper paths
• ConversationDB  (SQLite)
• SemanticFeedbackDB  (SQLite)
• BeanCounter  (JSON tally)
• ReinforcementStore  (async JSONL append)
• cross-platform TTS locked to *Zira*
• minimal AudioRecorder placeholder
Everything here is UI-agnostic.
**Classes:** Settings, ConversationDB, SemanticFeedbackDB, BeanCounter, ReinforcementStore, TTSManager, AudioRecorder
**Functions:** _have_cli(cmd), ensure_models_present(), prof_dir(b, persona, set_name), conv_db_path(b, persona, set_name), feedback_db_path(b, persona, set_name), beans_path(b, persona, set_name)


## Module `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\AI_TTS_AGENT\core_orchestrator.py`

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
core_orchestrator.py
====================

This module provides the orchestration layer for the AI‑TTS agent.  It
exposes a unified API used by the user‑interface to interact with
schemas, conversations, commands, text‑to‑speech, plugins and other
components.  Historically the logic lived in a monolithic module,
but it has been refactored to encourage testability and to allow
individual subsystems to evolve independently.

The principal differences from earlier releases are:

* A richer :class:`PluginManager` that exposes a complete API expected
  by the UI.  In addition to discovering plugin packages from the
  ``plugins`` directory it now keeps per‑plugin metadata, supports
  enable/disable toggling, rescans at runtime, broadcasts messages to
  enabled plugins on a thread pool, and emits an ``eventReceived``
  signal whenever a plugin reports an event.  Plugins can either
  return a payload from their ``on_message`` handler or call
  ``emit_event`` on the manager directly to publish complex events.

* A ``run_command()`` method on :class:`AgentCore` which forwards
  slash commands through the :class:`CommandExecutor` and returns
  the textual result.  This helper centralises command routing and
  ensures backwards compatibility with older UI code.

* A ``process_user_message()`` method on :class:`AgentCore` which
  synchronously handles both slash‑commands and normal user input.  It
  persists the conversation, routes commands through the registry
  and, for non‑commands, returns a simple acknowledgement.  Future
  versions may integrate model execution here, but the method
  signature is stable for consumers.

* A ``command_registry`` attribute is exposed on the core as an
  adapter with a ``list_commands()`` method so that UI components
  (like the Command Palette) can enumerate available commands without
  coupling to internal registry details.

This file is fully self‑contained.  It gracefully degrades when
optional dependencies (such as PyQt5 or external model executables)
are unavailable by providing shims and in‑memory fallbacks.  Should
the optional modules exist in the runtime environment they will be
used automatically.  The design favours clear separation of
responsibilities, thread safety and explicit interfaces to ease
maintenance and extensibility.
"""

from __future__ import annotations

import importlib
import json
import os
import pathlib
import re
import subprocess
import threading
import time
from dataclasses import dataclass, field
from typing import Any, Dict, Iterable, List, Optional, Tuple

# Optional Qt import.  When PyQt5 is not available we fall back to a
# minimal shim so that type annotations and pyqtSignal declarations do
# not cause NameErrors.  The shim mimics only the parts of Qt used
# throughout this module.
try:
    from PyQt5 import QtCore  # type: ignore[assignment]
except Exception:
    class _ShimSignal:
        def __init__(self, *_, **__):
            pass
        def connect(self, *_, **__):
            pass
        def emit(self, *_, **__):
            pass

    class _ShimQObject:
        def __init__(self, *_, **__):
            pass

    # Create a very small QtCore replacement with the attributes we need.
    QtCore = type(
        "QtCore",
        (),
        {
            "QObject": _ShimQObject,
            "QThread": _ShimQObject,
            "pyqtSignal": lambda *a, **k: _ShimSignal(),
            "QTimer": type(
                "QTimer",
                (),
                {
                    "singleShot": staticmethod(lambda msec, func: None),
                },
            ),
        },
    )  # type: ignore

# ----------------------------------------------------------------------------
# Fallbacks for optional internal modules
#
# When the canonical ``core_base`` and ``core_schema`` modules are present
# they are imported normally.  If missing (for example during unit tests or
# headless operation) minimal stubs are provided to allow the remainder of
# this module to execute without crashing.  The stubs implement only the
# methods referenced by the UI.
# ----------------------------------------------------------------------------
try:
    # pylint: disable=unused-import
    from core_base import (
        Settings,
        TTSManager,
        AudioRecorder,
        conv_db_path,
        feedback_db_path,
        beans_path,
        ConversationDB,
        SemanticFeedbackDB,
        BeanCounter,
        ReinforcementStore,
        logger,
    )
    from core_schema import (
        SchemaManager,
        OperatorManager,
        DatasetManager,
    )
except Exception:
    # Provide very small stand‑ins for the missing classes and helpers.
    import logging

    logger = logging.getLogger("core_orchestrator_stub")

    class Settings:
        """In‑memory settings fallback."""
        def __init__(self, base_dir: str) -> None:
            self.base_dir = base_dir
            self.default_model: str = "mistral:latest"
            self.context_depth: int = 20
            self.auto_schema_enabled: bool = True
            self.use_google_stt: bool = False
        def save(self) -> None:
            # Persist settings to a JSON file in base_dir if possible
            path = os.path.join(self.base_dir, "settings.json")
            try:
                with open(path, "w", encoding="utf-8") as fh:
                    json.dump({
                        "default_model": self.default_model,
                        "context_depth": self.context_depth,
                        "auto_schema_enabled": self.auto_schema_enabled,
                        "use_google_stt": self.use_google_stt,
                    }, fh, indent=2)
            except Exception:
                pass

    class TTSManager:
        """No‑op TTS manager used when speech synthesis isn't available."""
        def enqueue(self, text: str) -> None:
            logger.debug("TTS enqueue called with: %s", text)

    class AudioRecorder(QtCore.QObject):
        """Stub audio recorder that exposes a transcribed signal."""
        transcribed = QtCore.pyqtSignal(str)
        def __init__(self) -> None:
            super().__init__()

    class ConversationDB:
        """In‑memory conversation log used when SQLite isn't available."""
        def __init__(self, path: str) -> None:
            self._lock = threading.RLock()
            self._records: List[Tuple[str, str]] = []
        def save_message(self, role: str, content: str) -> None:
            with self._lock:
                self._records.append((role, content))
        def fetch_history(self, limit: int = 50) -> List[Tuple[str, str]]:
            with self._lock:
                return list(self._records)[-limit:]

    class SemanticFeedbackDB:
        """Stub semantic feedback database."""
        def __init__(self, path: str, beans: Any) -> None:
            pass
        def add(self, original: str, liked: bool, revised: Optional[str] = None) -> None:
            logger.debug("Feedback recorded: %s liked=%s revised=%s", original, liked, revised)
        def counts(self) -> Tuple[int, int]:
            return (0, 0)

    class BeanCounter:
        """Stub reinforcement bean counter."""
        def __init__(self, path: str) -> None:
            self._lock = threading.RLock()
            self._store: Dict[str, int] = {}
        def inc(self, key: str, amount: int = 1) -> None:
            with self._lock:
                self._store[key] = self._store.get(key, 0) + amount

    class ReinforcementStore:
        """Stub reinforcement store."""
        def __init__(self, path: str) -> None:
            pass
        def inc(self, key: str, amount: int = 1) -> None:
            pass

    class SchemaManager:
        """Very small schema manager storing JSON in memory."""
        def __init__(self, base_dir: str) -> None:
            self.base_dir = pathlib.Path(base_dir)
            self._lock = threading.RLock()
            self._schemas: Dict[Tuple[str, str], Dict[str, Any]] = {}
            self._active: Dict[str, Dict[str, Any]] = {}
        def load_schema(self, persona: str, set_name: str = "default") -> Dict[str, Any]:
            key = (persona, set_name)
            with self._lock:
                return dict(self._schemas.get(key, {"name": persona, "voice": "", "role": "", "description": "", "dynamic_overlay": {}}))
        def save_schema(self, persona: str, set_name: str, schema_data: Dict[str, Any], *, auto_expand: bool = True) -> None:
            key = (persona, set_name)
            with self._lock:
                self._schemas[key] = dict(schema_data)
                self._active[persona] = dict(schema_data)
        @property
        def active_schemas(self) -> Dict[str, Dict[str, Any]]:
            with self._lock:
                return dict(self._active)

        # ------------------------------------------------------------------
        # Compatibility helpers
        # ------------------------------------------------------------------
        def get_set_list(self, persona: str) -> List[str]:
            """Return all set names defined for the given persona.

            Legacy UI code calls :meth:`get_set_list` on the schema manager
            to populate drop‑downs.  If no sets exist yet a single
            default entry ("default") is returned.
            """
            with self._lock:
                names = [s for (p, s) in self._schemas.keys() if p == persona]
            # Guarantee at least a default set exists
            return sorted(names or ["default"])

        def get_personas(self) -> List[str]:
            """Return all personas that have at least one schema.

            This helper mirrors the interface exposed by the full schema
            engine for backwards compatibility.
            """
            with self._lock:
                persons = {p for p, _ in self._schemas.keys()}
            return sorted(persons)

    class OperatorManager:
        def __init__(self, base_dir: str) -> None:
            pass

    class DatasetManager:
        def __init__(self, base_dir: str) -> None:
            pass
        def list(self) -> List[Any]:
            return []

    def conv_db_path(base_dir: str, persona: str, set_name: str) -> str:
        return os.path.join(base_dir, "conversations", f"{persona}_{set_name}.sqlite3")

    def feedback_db_path(base_dir: str, persona: str, set_name: str) -> str:
        return os.path.join(base_dir, "feedback", f"{persona}_{set_name}.sqlite3")

    def beans_path(base_dir: str, persona: str, set_name: str) -> str:
        return os.path.join(base_dir, "profiles", persona, set_name, "reinforcement.json")


# ----------------------------------------------------------------------------
# Command Registry & Executor
# ----------------------------------------------------------------------------
class CommandRegistry(QtCore.QObject):
    """Stores slash‑command metadata and emits change signals."""

    # Emit the full list of commands whenever the registry is updated.  The
    # connected slot in the command palette expects a single list argument,
    # so the signal carries that list instead of emitting without
    # parameters.  Slots that ignore the argument will still function.
    commandsChanged = QtCore.pyqtSignal(list)
    commandWeightsChanged = QtCore.pyqtSignal()

    # Built‑in commands shipped with the agent.  When refactoring this list,
    # be sure to retain backwards compatibility by adding new commands to
    # the end rather than reordering or removing existing items.
    _BUILT_INS: Tuple[str, ...] = (
        "/remember", "/inject", "/rewrite", "/show", "/action",
        "/trait", "/dataset", "/search", "/embeddings", "/schema",
        "/tts", "/plugin", "/feedback", "/lock", "/commands",
        "/reject", "/auto", "/ignore", "/opposite", "/delete",
    )

    def __init__(self, path: pathlib.Path) -> None:
        super().__init__()
        self._path = path
        # Internal storage maps command → metadata such as weight and lock
        self._store: Dict[str, Dict[str, Any]] = {}
        # Attempt to load existing registry from disk
        try:
            if self._path.is_file():
                with open(self._path, encoding="utf-8") as fh:
                    data = json.load(fh)
                    self._store.update(data.get("commands", {}))
        except Exception:
            logger.debug("Failed to read command registry from %s", self._path)
        # Ensure built‑ins exist
        for cmd in self._BUILT_INS:
            self.register(cmd)

    # ----------------------------------------------------------------------
    # CRUD helpers
    # ----------------------------------------------------------------------
    def register(self, name: str) -> None:
        """Register a command if it does not already exist."""
        if name not in self._store:
            self._store[name] = {"weight": 0, "locked": False}
            self._save()

    def toggle_lock(self, name: str, state: Optional[bool] = None) -> None:
        """Toggle the locked state of a command.  A locked command cannot have
        its weight modified."""
        if name in self._store:
            cur = self._store[name]["locked"]
            self._store[name]["locked"] = (not cur) if state is None else bool(state)
            self._save()

    def set_weight(self, name: str, weight: int) -> None:
        """Assign a new weight to the given command if it is not locked."""
        if name in self._store and not self._store[name].get("locked", False):
            self._store[name]["weight"] = int(weight)
            self._save()

    def list(self) -> List[str]:
        """Return all registered commands sorted lexicographically."""
        return sorted(self._store.keys())

    def meta(self, name: str) -> Dict[str, Any]:
        """Return metadata for the specified command or an empty dict."""
        return dict(self._store.get(name, {}))

    def list_commands(self) -> List[str]:
        """Alias for :meth:`list` retained for backwards compatibility."""
        return self.list()

    # Internal helper to persist changes and emit appropriate signals
    def _save(self) -> None:
        try:
            self._path.parent.mkdir(parents=True, exist_ok=True)
            with open(self._path, "w", encoding="utf-8") as fh:
                json.dump({"commands": self._store}, fh, indent=2)
        except Exception:
            logger.debug("Failed to save command registry to %s", self._path)
        # Notify listeners on the next iteration of the event loop.  When
        # emitting commandsChanged we pass the updated list because the
        # CommandPaletteDock.set_command_list slot requires an argument.
        QtCore.QTimer.singleShot(0, lambda: self.commandsChanged.emit(self.list()))
        QtCore.QTimer.singleShot(0, self.commandWeightsChanged.emit)


class CommandExecutor:
    """Routes slash‑command strings to internal handler methods."""
    def __init__(self, owner: "AgentCore", registry: CommandRegistry) -> None:
        self.owner = owner
        self.registry = registry

    def run(self, msg: str) -> Optional[str]:
        """Execute a slash command if ``msg`` begins with a slash.  Returns
        ``None`` for non‑command strings."""
        if not msg or not msg.startswith("/"):
            return None
        cmd, *rest = msg.split(maxsplit=1)
        if cmd not in self.registry.list():
            return f"⚠️ Unknown command {cmd}"
        handler_name = f"_{cmd.lstrip('/') }"
        fn = getattr(self, handler_name, None)
        if not callable(fn):
            return "🚧 command not implemented"
        try:
            arg = rest[0] if rest else ""
            return fn(arg)
        except Exception as exc:
            logger.error("[cmd] %s: %s", cmd, exc, exc_info=True)
            return str(exc)

    # Example minimal handlers
    def _show(self, _arg: str) -> str:
        rows: List[str] = []
        for name in self.registry.list():
            meta = self.registry.meta(name)
            lock = "🔒" if meta.get("locked", False) else ""
            rows.append(f"{name:12} w={meta.get('weight', 0):>3} {lock}")
        return "\n".join(rows) or "(no commands)"

    def _lock(self, arg: str) -> str:
        if not arg:
            return "Usage: /lock <cmd>"
        self.registry.toggle_lock(arg.strip())
        return "lock toggled"

    def _remember(self, arg: str) -> str:
        if not arg:
            return "Usage: /remember k v"
        k, *val = arg.split(maxsplit=1)
        if not val:
            return "Usage: /remember k v"
        self.owner.memory[k] = val[0]
        self.owner._save_memory()
        return "✓ saved"


# ----------------------------------------------------------------------------
# Plugin Manager
# ----------------------------------------------------------------------------
@dataclass
class PluginMeta:
    """Holds metadata about a single plugin."""
    name: str
    missing_dependencies: List[str] = field(default_factory=list)
    enabled: bool = True
    widget: Any = None
    module: Any = None

class PluginManager(QtCore.QObject):
    """
    Discovers and manages runtime plugins.

    Plugins live in the ``plugins`` subdirectory of the agent's base
    directory.  Each plugin is expected to be a Python package whose
    top‑level module may define any of the following attributes:

    * ``REQUIRES`` – an iterable of import names that must be available in
      order for the plugin to operate correctly.  Missing dependencies
      are surfaced to the UI and the plugin is disabled by default.

    * ``on_message(text: str, manager: PluginManager) -> Optional[dict]`` –
      a callback invoked whenever a message is broadcast.  It may return
      an envelope to emit via the :attr:`eventReceived` signal or it may
      raise/return nothing.  The callback is executed on a worker
      thread to avoid blocking the UI.

    * ``get_widget() -> QWidget`` – if present, invoked once when the
      plugin is discovered to obtain a UI widget that will be docked in
      the main window when the plugin is enabled.

    A plugin may alternatively call :meth:`emit_event` directly on the
    manager at any time to publish complex events.
    """
    # Plugins can emit events back to the UI via this signal.  The
    # first parameter is the plugin name and the second is an event
    # envelope (arbitrary mapping).
    eventReceived = QtCore.pyqtSignal(str, dict)

    def __init__(self, root: pathlib.Path, settings: Settings) -> None:
        super().__init__()
        self.root: pathlib.Path = pathlib.Path(root) / "plugins"
        self.settings: Settings = settings
        # Thread pool for dispatching plugin callbacks; reuse a small
        # number of threads to minimise resource usage.
        self._executor = None
        # Internal index of metadata keyed by plugin name
        self._meta: Dict[str, PluginMeta] = {}
        # Discover all plugins on initialisation
        self.discover()

    # ------------------------------------------------------------------
    def _ensure_executor(self) -> None:
        """Lazily create a thread pool executor."""
        if self._executor is None:
            import concurrent.futures
            # Use a small fixed pool – plugin callbacks should be quick
            self._executor = concurrent.futures.ThreadPoolExecutor(max_workers=4)

    def discover(self) -> None:
        """Scan the ``plugins`` directory and populate metadata."""
        self._meta.clear()
        if not self.root.is_dir():
            logger.info("No plugin directory found at %s", self.root)
            return
        for entry in self.root.iterdir():
            if not entry.is_dir() or entry.name.startswith("__"):
                continue
            name = entry.name
            meta = PluginMeta(name=name)
            try:
                module_name = f"plugins.{name}"
                mod = importlib.import_module(module_name)
                meta.module = mod
                # check dependencies
                requires: Iterable[str] = getattr(mod, "REQUIRES", [])
                missing: List[str] = []
                for dep in requires:
                    try:
                        importlib.import_module(dep)
                    except Exception:
                        missing.append(dep)
                meta.missing_dependencies = missing
                # Determine initial enabled state from settings.  Persisted
                # states live under a key namespace e.g. ``pluginsEnabled`` in
                # settings JSON.  Fallback to enabled unless dependencies
                # are missing.
                enabled_state = True
                try:
                    plug_cfg = getattr(self.settings, "plugins_enabled", {})
                    enabled_state = bool(plug_cfg.get(name, True))
                except Exception:
                    enabled_state = True
                # Force disabled when dependencies are missing
                meta.enabled = enabled_state and not missing
                # Create widget if provided
                try:
                    if hasattr(mod, "get_widget") and callable(mod.get_widget):
                        meta.widget = mod.get_widget()
                    elif hasattr(mod, "Widget"):
                        # Some plugins expose a QWidget subclass directly
                        meta.widget = getattr(mod, "Widget")()
                    elif hasattr(mod, "widget"):
                        # Prebuilt widget instance
                        meta.widget = getattr(mod, "widget")
                except Exception as exc:
                    logger.warning("[plugin:%s] error creating widget: %s", name, exc)
                    meta.widget = None
                self._meta[name] = meta
                logger.info("[plugin] loaded %s", name)
            except Exception as exc:
                # Record failure as missing dependency for UI
                meta.enabled = False
                meta.missing_dependencies = [str(exc)]
                self._meta[name] = meta
                logger.warning("[plugin] failed to load %s: %s", name, exc)

    # ------------------------------------------------------------------
    def list_plugins(self) -> List[PluginMeta]:
        """Return a list of all discovered plugin metadata objects."""
        return [self._meta[k] for k in sorted(self._meta.keys())]

    def enable_plugin(self, name: str, enabled: bool) -> None:
        """Enable or disable a plugin.  The UI will call this when a user
        toggles a checkbox.  Enabled state is persisted to
        ``settings.plugins_enabled``.
        """
        if name not in self._meta:
            return
        meta = self._meta[name]
        # Do not enable a plugin with missing dependencies
        if enabled and meta.missing_dependencies:
            logger.warning("Attempted to enable plugin %s with missing deps", name)
            return
        meta.enabled = bool(enabled)
        # Persist state back into settings
        try:
            plug_cfg = getattr(self.settings, "plugins_enabled", {})
            if not isinstance(plug_cfg, dict):
                plug_cfg = {}
            plug_cfg[name] = meta.enabled
            setattr(self.settings, "plugins_enabled", plug_cfg)
            self.settings.save()
        except Exception:
            logger.debug("Could not persist plugin enabled state for %s", name)
        # Invoke lifecycle hooks if defined
        try:
            if meta.module:
                if meta.enabled and hasattr(meta.module, "on_enable"):
                    meta.module.on_enable()
                elif not meta.enabled and hasattr(meta.module, "on_disable"):
                    meta.module.on_disable()
        except Exception as exc:
            logger.warning("[plugin:%s] lifecycle hook error: %s", name, exc)

    def rescan(self) -> None:
        """Rebuild the plugin registry while preserving enabled state where
        possible."""
        old_states = {name: meta.enabled for name, meta in self._meta.items()}
        self.discover()
        # Restore previous enabled states if compatible
        for name, state in old_states.items():
            if name in self._meta:
                # Disable when dependencies are still missing
                if self._meta[name].missing_dependencies:
                    self._meta[name].enabled = False
                else:
                    self._meta[name].enabled = state

    def broadcast(self, text: str) -> None:
        """Send a message to all enabled plugins.  Messages are dispatched
        asynchronously on a thread pool so the UI thread remains
        responsive.  Each plugin's ``on_message`` handler receives the
        message and this manager instance.  If the handler returns a
        mapping, it will be emitted via the :attr:`eventReceived` signal.
        """
        if not text:
            return
        self._ensure_executor()
        for meta in list(self._meta.values()):
            if not meta.enabled or meta.missing_dependencies:
                continue
            mod = meta.module
            if not mod:
                continue
            handler = getattr(mod, "on_message", None)
            if not callable(handler):
                continue
            # Dispatch on a worker thread
            def _run_handler(m=meta, h=handler, msg=text):
                try:
                    result = h(msg, self)
                    if isinstance(result, dict):
                        # Emit result via signal in the GUI thread
                        QtCore.QTimer.singleShot(0, lambda n=m.name, env=result: self.eventReceived.emit(n, env))
                except Exception as exc:
                    logger.warning("[plugin:%s] on_message error: %s", m.name, exc)
            # schedule the call
            self._executor.submit(_run_handler)

    def emit_event(self, sender: str, envelope: dict) -> None:
        """Convenience for plugins to emit events.  Plugins may call
        ``manager.emit_event(name, envelope)`` directly instead of
        returning from their ``on_message`` handlers.  The emission is
        forwarded to the UI thread via a zero‑delay timer.
        """
        if not envelope or not isinstance(envelope, dict):
            return
        # Schedule the emit on the Qt event loop
        QtCore.QTimer.singleShot(0, lambda s=sender, env=envelope: self.eventReceived.emit(s, env))


# ----------------------------------------------------------------------------
# RAG cache, schema engine and evolver fallbacks
#
# The original agent included sophisticated retrieval‑augmented generation
# support (the so‑called RAG cache) as well as a rich schema engine and
# evolver.  Those components are tightly coupled to the rest of the code
# base and to external packages.  To allow the UI to load without
# exploding when those bits are absent, we provide extremely minimal
# stand‑ins here.  They implement only the methods exercised by the UI
# (e.g. clearing the cache, basic schema field manipulation, etc.) and
# never throw.  Should the full implementations become available at
# runtime they can replace these shims by monkeypatching the
# corresponding attributes on :class:`AgentCore`.

class RAGCache:
    """In‑memory stub for the retrieval‑augmented generation cache.

    The real RAG cache stores vector embeddings on disk and in memory and
    exposes helpers for incremental updates.  For the purposes of the
    fallback we simply track whether anything has been 'cached' and allow
    callers to clear that state.  See :meth:`clear_disk` and
    :meth:`clear_memory`.
    """

    def __init__(self, root: str) -> None:
        # Root directory where persistent embeddings would live.  The
        # fallback does not persist anything but keeps the path for
        # reference.
        self.root = root
        # In‑memory store keyed by dataset path.  Values are arbitrary
        # payloads that might normally include embeddings.  We don't
        # implement storage here but maintain the attribute to satisfy
        # introspection.
        self._mem: Dict[str, Any] = {}

    def clear_disk(self) -> int:
        """Simulate removal of all on‑disk embedding files.

        Returns the number of files that would have been removed.  The
        fallback never persists embeddings so the count is always zero.
        """
        return 0

    def clear_memory(self) -> None:
        """Forget all cached embeddings held in memory."""
        self._mem.clear()


class SchemaEngine(QtCore.QObject):
    """Very small in‑memory schema engine.

    The full schema engine persists personas and sets in an SQLite
    database, exposes a signals API, integrates with the command
    registry and enforces schema invariants.  In contrast, this shim
    records arbitrary fields in nested dictionaries and provides only
    the handful of methods referenced by the UI: enumerating personas
    and sets, loading schemas, updating fields, toggling command
    exposure, toggling automatic evolution and reading fields back.
    """

    # Signal emitted when a schema evolves.  The UI connects to this
    # signal to refresh displayed values after an evolution completes.
    schemaEvolved = QtCore.pyqtSignal(str, str)

    def __init__(self, base_dir: str) -> None:
        super().__init__()
        self.base_dir = base_dir
        # All schemas keyed by (persona, set_name) -> dict
        self._schemas: Dict[Tuple[str, str], Dict[str, Any]] = {}
        # Track command exposure per (persona, category)
        self._cmd_exposed: Dict[Tuple[str, str], bool] = {}
        # Track auto evolution flag per (persona, set_name)
        self._auto_evo: Dict[Tuple[str, str], bool] = {}

    # ------------------------------------------------------------------
    # Introspection helpers
    # ------------------------------------------------------------------
    def personas(self) -> List[str]:
        """Return a list of personas that have at least one set loaded."""
        return sorted({persona for persona, _ in self._schemas.keys()})

    def set_list(self, persona: str, *args: Any) -> List[str]:
        """Get or set list depending on arguments.

        When called with only the persona, returns the names of all
        loaded sets for that persona.  When called with three
        additional arguments (set_name, field, values) behaves like
        :meth:`update_field` by storing ``values`` under ``field`` for
        the given persona and set.
        """
        # Setter mode: persona, set_name, field, values
        if len(args) == 3:
            set_name, field, values = args
            return [] if not self.update_field(persona, set_name, field, values) else []
        # Getter mode: persona only
        sets = [s for p, s in self._schemas.keys() if p == persona]
        return sorted(sets)

    # ------------------------------------------------------------------
    # Schema CRUD
    # ------------------------------------------------------------------
    def load_schema(self, persona: str, set_name: str) -> Optional[Dict[str, Any]]:
        """Return the schema dictionary for ``persona`` / ``set_name``.

        If no schema exists yet the fallback returns an empty mapping.
        """
        return self._schemas.get((persona, set_name), {})

    def update_field(self, persona: str, set_name: str, field: str, value: Any) -> bool:
        """Set a schema field and emit ``schemaEvolved``.

        Returns True on success.  The fallback always succeeds.
        """
        schema = self._schemas.setdefault((persona, set_name), {})
        schema[field] = value
        # Emit evolution signal to notify UI listeners
        try:
            self.schemaEvolved.emit(persona, set_name)
        except Exception:
            pass
        return True

    def get_field(self, persona: str, set_name: str, field: str) -> Any:
        """Return the value of a schema field or ``None`` if unset."""
        return self._schemas.get((persona, set_name), {}).get(field)

    # ------------------------------------------------------------------
    # Command exposure & auto evolution
    # ------------------------------------------------------------------
    def set_command_exposure(self, persona: str, field: str, exposed: bool) -> None:
        """Record whether ``field`` should be exposed as a slash command."""
        self._cmd_exposed[(persona, field)] = bool(exposed)

    def is_exposed_as_command(self, persona: str, field: str) -> bool:
        """Return True if ``field`` is marked as exposed."""
        return bool(self._cmd_exposed.get((persona, field)))

    def set_auto_evolution(self, persona: str, set_name: str, onoff: bool) -> None:
        """Enable or disable automatic schema evolution."""
        self._auto_evo[(persona, set_name)] = bool(onoff)

    # ------------------------------------------------------------------
    # Compatibility aliases
    # ------------------------------------------------------------------
    def get_set_list(self, persona: str) -> List[str]:
        """Legacy API: alias for :meth:`set_list(persona)`."""
        return self.set_list(persona)


class SchemaEvolver(QtCore.QObject):
    """Trivial schema evolver.

    The evolver's job is to adjust a schema given a conversation
    history.  The fallback implementation simply returns False to
    indicate that no changes were made.
    """

    def __init__(self, base_dir: str) -> None:
        super().__init__()
        self.base_dir = base_dir

    def update_schema(self, persona: str, set_name: str, history: List[Tuple[str, str]]) -> bool:
        """Perform a no‑op evolution.  Always returns False."""
        return False


class DatasetManagerFallback:
    """Minimal stand‑in for the full :class:`DatasetManager`.

    When the persistent SQLite database has not yet been migrated the
    original dataset manager will raise an ``OperationalError`` upon
    listing.  The fallback avoids that by returning empty results and
    exposing the handful of methods the UI expects.  No data is
    persisted by this implementation.
    """

    def __init__(self, base_dir: str) -> None:
        self.base_dir = pathlib.Path(base_dir)
        # Directory where datasets would be stored
        self.datasets_dir = self.base_dir / "datasets"
        self.datasets_dir.mkdir(parents=True, exist_ok=True)
        # Internal store mapping dataset name → info dict
        self._store: Dict[str, Dict[str, Any]] = {}

    def list(self) -> List[Any]:
        """Return an empty list.  In a full implementation this would
        return dataset objects describing each managed dataset."""
        return []

    @property
    def entries(self) -> Dict[str, Any]:
        """Return an empty dictionary mapping dataset names to entries."""
        return {}

    def toggle_active(self, name: str, active: bool) -> None:
        """Mark a dataset as active/inactive.  No‑op in the fallback."""
        info = self._store.get(name)
        if info is not None:
            info["active"] = bool(active)

    def add_dataset(self, path: str, *, name: Optional[str] = None) -> None:
        """Add a dataset from a file path.  The fallback simply
        records the dataset name and path in memory."""
        if not name:
            name = pathlib.Path(path).stem
        self._store[name] = {"path": path, "active": True}

    def delete_dataset(self, name: str) -> None:
        """Remove a dataset.  The fallback just deletes the entry from
        the in‑memory store."""
        self._store.pop(name, None)

    def load_dataset_text(self, name: str) -> str:
        """Load the raw text for the given dataset.  Returns an empty
        string if the dataset is unknown or if reading fails."""
        info = self._store.get(name)
        if not info:
            return ""
        try:
            with open(info.get("path", ""), encoding="utf-8") as fh:
                return fh.read()
        except Exception:
            return ""


# ----------------------------------------------------------------------------
# Model Worker
# ----------------------------------------------------------------------------
class ModelWorker(QtCore.QThread):
    """Runs external language models in a separate thread.

    This worker wraps an `ollama` subprocess invocation so that model
    evaluations do not block the UI.  It emits ``finished`` when the
    call returns successfully and ``failed`` when an exception is
    raised.  If the `ollama` binary is not available or times out
    `failed` will receive the error message.
    """
    finished = QtCore.pyqtSignal(str)
    failed = QtCore.pyqtSignal(str)

    def __init__(self, model: str, prompt: str, *, temp: float = 0.7) -> None:
        super().__init__()
        self.model = model
        self.prompt = prompt
        self.temp = temp

    def run(self) -> None:
        try:
            out = subprocess.check_output(
                ["ollama", "run", self.model, "--prompt", self.prompt, "--temperature", str(self.temp)],
                stderr=subprocess.STDOUT,
                text=True,
                timeout=60,
            )
            self.finished.emit(out.strip())
        except subprocess.CalledProcessError as e:
            self.failed.emit(e.output.strip())
        except Exception as exc:
            self.failed.emit(str(exc))


# ----------------------------------------------------------------------------
# Agent Core
# ----------------------------------------------------------------------------
class AgentCore(QtCore.QObject):
    """
    Heart of the AI‑TTS agent.  Provides a high‑level API consumed by the
    UI for persistent storage, command handling, plugin management and
    message processing.  Most methods are thread‑safe and return
    immediately without blocking the UI.
    """
    # Signals used by the UI to update status
    replyReady = QtCore.pyqtSignal(str)
    modelError = QtCore.pyqtSignal(str)
    tokensConsumed = QtCore.pyqtSignal(int)

    def __init__(
        self,
        base_dir: str,
        *,
        persona: Optional[str] = None,
        set_name: str = "default",
    ) -> None:
        super().__init__()
        # File system
        self.base_dir = pathlib.Path(base_dir)
        self.persona = persona or "zira"
        self.set_name = set_name
        # Settings
        self.settings = Settings(str(self.base_dir))
        # Initialise store directories
        self._prof_dir = self.base_dir / "profiles" / self.persona / self.set_name
        self._prof_dir.mkdir(parents=True, exist_ok=True)
        self._memory_file = self._prof_dir / "memory.json"
        # Instantiate subsystems
        self.schema_mgr = SchemaManager(str(self.base_dir))
        # Dataset manager – attempt to use the full implementation if
        # available.  When the backing SQLite tables have not been
        # created yet the dataset manager will raise an error on
        # ``list()``, so we fall back to the in‑memory stub.
        try:
            dm = DatasetManager(str(self.base_dir))  # type: ignore[call-arg]
            # Probe the manager to ensure the DB is present.  Some
            # implementations lazily connect to SQLite on first call.
            try:
                _ = dm.list()
            except Exception:
                raise
            self.dataset_mgr = dm
        except Exception:
            # Fallback stub avoids OperationalError due to missing tables
            self.dataset_mgr = DatasetManagerFallback(str(self.base_dir))
        self.operator_mgr = OperatorManager(str(self.base_dir))
        # Persistence
        self.conversation_db = ConversationDB(conv_db_path(str(self.base_dir), self.persona, self.set_name))
        self.feedback_db = SemanticFeedbackDB(feedback_db_path(str(self.base_dir), self.persona, self.set_name), BeanCounter(beans_path(str(self.base_dir), self.persona, self.set_name)))
        self.reinforcement_store = ReinforcementStore(beans_path(str(self.base_dir), self.persona, self.set_name))
        # Commands
        cmd_path = self._prof_dir / "commands.json"
        self.cmd_reg = CommandRegistry(cmd_path)
        self.cmd_exec = CommandExecutor(self, self.cmd_reg)
        # Provide a command_registry adapter for UI; exposes list_commands
        class _CmdRegAdapter:
            def __init__(self, reg: CommandRegistry) -> None:
                self._reg = reg
            def list_commands(self) -> List[str]:
                # Remove the leading slash for UI display purposes
                return [c for c in self._reg.list()]
        self.command_registry = _CmdRegAdapter(self.cmd_reg)
        # Expose registry change signals for convenience
        self.commandsChanged = self.cmd_reg.commandsChanged
        self.commandWeightsChanged = self.cmd_reg.commandWeightsChanged
        # Plugins
        self.plugins = PluginManager(self.base_dir, self.settings)
        # ------------------------------------------------------------------
        # RAG & schema components
        #
        # The UI references ``core.rag_cache`` and ``core.rag_search`` when
        # performing retrieval‑augmented generation (RAG) and ``core.schema_*``
        # objects when editing schemas.  In environments where the full
        # implementations are unavailable we instantiate the fallback shims
        # provided in this module.  These fallbacks expose the same
        # signatures but perform no heavy lifting.
        self.rag_cache = RAGCache(str(self.base_dir))
        self.schema_engine = SchemaEngine(str(self.base_dir))
        self.schema_evolver = SchemaEvolver(str(self.base_dir))
        # Create a default schema entry for the active persona/set so
        # that the UI can enumerate at least one persona and set.  This
        # populates the in‑memory schema store with a placeholder
        # field to mark its existence.  Without this the persona tabs
        # would appear empty on first launch.
        try:
            self.schema_engine.update_field(self.persona, self.set_name, "_init", True)
        except Exception:
            pass
        # Provide rag_search as a bound method so code can call
        # ``core.rag_search(...)``.  See method definition further below.
        # Note: we do not assign to self.rag_search here because methods
        # are descriptors; simply defining rag_search on the class makes
        # it available on the instance.
        # TTS and recording
        self.tts_mgr = TTSManager()
        self.audio_recorder = AudioRecorder()
        # Memory dictionary
        self.memory: Dict[str, str] = {}
        self._load_memory()
        # Add feedback helper
        self.add_feedback = lambda original, liked, revised=None: self.feedback_db.add(original, liked, revised)

    # ------------------------------------------------------------------
    # Memory helpers
    # ------------------------------------------------------------------
    def _load_memory(self) -> None:
        """Load persisted agent memory from disk."""
        try:
            if self._memory_file.is_file():
                with open(self._memory_file, encoding="utf-8") as fh:
                    data = json.load(fh)
                    if isinstance(data, dict):
                        self.memory.update({k: str(v) for k, v in data.items()})
        except Exception as exc:
            logger.debug("Failed to load memory: %s", exc)

    def _save_memory(self) -> None:
        """Persist the agent memory to disk."""
        try:
            self._prof_dir.mkdir(parents=True, exist_ok=True)
            with open(self._memory_file, "w", encoding="utf-8") as fh:
                json.dump(self.memory, fh, indent=2)
        except Exception as exc:
            logger.debug("Failed to save memory: %s", exc)

    # ------------------------------------------------------------------
    # Command & message processing
    # ------------------------------------------------------------------
    def run_command(self, msg: str, *, persona: Optional[str] = None, set_name: Optional[str] = None) -> str:
        """Process a slash command and return the response text.  Unknown
        commands yield a warning.  Both persona and set_name are
        accepted for future expansion; they are currently unused.
        """
        result = self.cmd_exec.run(msg)
        return "" if result is None else result

    def process_user_message(
        self,
        msg: str,
        *,
        persona: Optional[str] = None,
        set_name: Optional[str] = None,
        tts: bool = True,
    ) -> str:
        """Synchronously handle a user's input.  Slash commands are routed
        through :meth:`run_command`, recorded into the conversation log and
        returned immediately.  Non‑command messages are appended to the
        conversation and a simple acknowledgement is returned.  A future
        implementation can call an LLM here and use the result.  When
        ``tts`` is true the response is enqueued for text‑to‑speech.
        """
        user_msg = (msg or "").strip()
        if not user_msg:
            return ""
        # Save the user's utterance
        self.conversation_db.save_message("user", user_msg)
        # Slash commands
        if user_msg.startswith("/"):
            resp = self.run_command(user_msg, persona=persona, set_name=set_name)
            self.conversation_db.save_message("system", resp)
            return resp
        # Normal chat – future versions should build a prompt and call an LLM
        reply = f"{self.persona.capitalize()}: I received your message: {user_msg}"
        self.conversation_db.save_message(self.persona, reply)
        # Optionally speak the reply
        if tts:
            try:
                self.tts_mgr.enqueue(reply)
            except Exception:
                pass
        return reply

    # ------------------------------------------------------------------
    # Conversation and model pipeline
    # ------------------------------------------------------------------
    def send(self, user_msg: str) -> None:
        """Asynchronous pipeline invoked by legacy code.  Kept for backwards
        compatibility with older UI components.  Use
        :meth:`process_user_message` for synchronous processing.
        """
        # Simply hand off to process_user_message and emit signals
        response = self.process_user_message(user_msg, tts=False)
        if response:
            self.replyReady.emit(response)

    # ------------------------------------------------------------------
    # Retrieval‑augmented search
    # ------------------------------------------------------------------
    def rag_search(
        self,
        query: str,
        *,
        per_ds_k: int = 3,
        limit: int = 5,
        include_shared: bool = False,
        datasets: Optional[List[str]] = None,
    ) -> List[Tuple[str, float, str, str]]:
        """Perform a simple in‑memory search over dataset entries.

        The original implementation of this method would encode the
        provided ``query`` using a sentence embedding model and then
        retrieve the top‐matching text chunks from configured
        datasets.  In the fallback we simply return an empty list so
        that callers can iterate over the result without error.  The
        signature is maintained to preserve compatibility with the UI.

        :param query: The user query to search for.
        :param per_ds_k: Number of hits per dataset (ignored).
        :param limit: Maximum total number of hits (ignored).
        :param include_shared: Whether to include shared datasets (ignored).
        :param datasets: Restrict the search to specific dataset names (ignored).
        :returns: An empty list of hits.
        """
        # TODO: integrate with a vector search engine.  For now return no hits.
        return []

    # ------------------------------------------------------------------
    # Housekeeping
    # ------------------------------------------------------------------
    def close(self) -> None:
        """Cleanly close any resources owned by the core.  Currently this
        simply flushes in‑memory stores and releases any thread pools.  It
        is safe to call this multiple times.
        """
        try:
            # Persist memory
            self._save_memory()
        except Exception:
            pass
        # Flush settings
        try:
            self.settings.save()
        except Exception:
            pass
        # Shut down plugin executor
        try:
            exec_ = getattr(self.plugins, "_executor", None)
            if exec_:
                exec_.shutdown(wait=False)
                self.plugins._executor = None
        except Exception:
            pass
        # ConversationDB may own a SQLite connection; attempt to close
        try:
            if hasattr(self.conversation_db, "conn"):
                self.conversation_db.conn.close()
        except Exception:
            pass


__all__ = [
    "CommandRegistry",
    "CommandExecutor",
    "PluginManager",
    "PluginMeta",
    "ModelWorker",
    "AgentCore",
    "RAGCache",
    "SchemaEngine",
    "SchemaEvolver",
]
```

core_orchestrator.py
====================

This module provides the orchestration layer for the AI‑TTS agent.  It
exposes a unified API used by the user‑interface to interact with
schemas, conversations, commands, text‑to‑speech, plugins and other
components.  Historically the logic lived in a monolithic module,
but it has been refactored to encourage testability and to allow
individual subsystems to evolve independently.

The principal differences from earlier releases are:

* A richer :class:`PluginManager` that exposes a complete API expected
  by the UI.  In addition to discovering plugin packages from the
  ``plugins`` directory it now keeps per‑plugin metadata, supports
  enable/disable toggling, rescans at runtime, broadcasts messages to
  enabled plugins on a thread pool, and emits an ``eventReceived``
  signal whenever a plugin reports an event.  Plugins can either
  return a payload from their ``on_message`` handler or call
  ``emit_event`` on the manager directly to publish complex events.

* A ``run_command()`` method on :class:`AgentCore` which forwards
  slash commands through the :class:`CommandExecutor` and returns
  the textual result.  This helper centralises command routing and
  ensures backwards compatibility with older UI code.

* A ``process_user_message()`` method on :class:`AgentCore` which
  synchronously handles both slash‑commands and normal user input.  It
  persists the conversation, routes commands through the registry
  and, for non‑commands, returns a simple acknowledgement.  Future
  versions may integrate model execution here, but the method
  signature is stable for consumers.

* A ``command_registry`` attribute is exposed on the core as an
  adapter with a ``list_commands()`` method so that UI components
  (like the Command Palette) can enumerate available commands without
  coupling to internal registry details.

This file is fully self‑contained.  It gracefully degrades when
optional dependencies (such as PyQt5 or external model executables)
are unavailable by providing shims and in‑memory fallbacks.  Should
the optional modules exist in the runtime environment they will be
used automatically.  The design favours clear separation of
responsibilities, thread safety and explicit interfaces to ease
maintenance and extensibility.
**Classes:** CommandRegistry, CommandExecutor, PluginMeta, PluginManager, RAGCache, SchemaEngine, SchemaEvolver, DatasetManagerFallback, ModelWorker, AgentCore


## Module `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\AI_TTS_AGENT\core_schema.py`

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
core_schema.py — v3-final (2025-08-04 04:12 UTC)
================================================

Single-source authority for all schema / dataset / snapshot / spatial-state
logic used by FATHOM Agent, now relying on AgentStore’s public API only.

Provides:
• Schema dataclass + SchemaEngine (diff, auto-evolve, variant injection)
• OperatorManager persisted in the same DB
• DatasetManager (metadata) + RAGCache (embeddings) in the same DB
• SnapshotEngine to walk the codebase & persist chunks to DB
• SpatialPositionManager for grid-room positions & movement logging
• Back-compat alias: SchemaManager → SchemaEngine

This version adds the `.active_schemas` property required by main_ui.py.
"""

from __future__ import annotations

import os
import json
import threading
import mimetypes
import hashlib
import shutil
import difflib
import time
from dataclasses import dataclass, asdict, field
from typing import List, Dict, Tuple, Any, Optional

# Optional Qt import.  This module defines a Qt signal (schemaEvolved,
# categoryCreated) for UI use, but can still run headless without
# PyQt5.  When PyQt5 is unavailable a minimal shim is provided so
# that the rest of the code can import SchemaEngine and run without
# errors.
try:
    from PyQt5 import QtCore  # type: ignore
except Exception:
    class _ShimSignal:
        def __init__(self, *_, **__) -> None: pass
        def connect(self, *_, **__) -> None: pass
        def emit(self, *_, **__) -> None: pass
    class _ShimQObject:
        def __init__(self, *args, **kwargs) -> None: pass
    QtCore = type("QtCore", (), {  # type: ignore
        "QObject": _ShimQObject,
        "pyqtSignal": lambda *a, **k: _ShimSignal(),
    })

from core_base import (
    logger,
    FathomStore as AgentStore,
    DEFAULT_PERSONAS,
    DEFAULT_VOICES,
)

# ───────────────────────────────────────────────────────────────────────────
# Internal global store helper
# ───────────────────────────────────────────────────────────────────────────
_agent_store_singleton: Optional[AgentStore] = None

def _ensure_store(root: str) -> AgentStore:
    """Return a process-wide AgentStore instance rooted at *root*."""
    global _agent_store_singleton
    if _agent_store_singleton is None:
        _agent_store_singleton = AgentStore(root)
    return _agent_store_singleton


# ══════════════════════════════════════════════════════════════════════════
#  Schema Dataclass & helpers
# ══════════════════════════════════════════════════════════════════════════
@dataclass
class Schema:
    name: str = ""
    voice: str = ""
    role: str = ""
    description: str = ""
    actions: List[str] = field(default_factory=list)
    questions: List[str] = field(default_factory=list)
    events: List[str] = field(default_factory=list)
    self_talk: List[str] = field(default_factory=list)
    rewrite_prompts: List[str] = field(default_factory=list)
    dynamic_overlay: Dict[str, Any] = field(default_factory=dict)

    # optional flags map used for advanced settings such as semantic
    # awareness and auto-evolution.  The UI stores arbitrary keys here.
    flags: Dict[str, Any] = field(default_factory=dict)

    @staticmethod
    def from_json(js: str) -> "Schema":
        return Schema(**json.loads(js))

    def to_json(self) -> str:
        return json.dumps(asdict(self), ensure_ascii=False, indent=2)

    def diff_against(self, other: "Schema") -> str:
        a = self.to_json().splitlines()
        b = other.to_json().splitlines()
        return "\n".join(difflib.unified_diff(a, b, fromfile="old", tofile="new"))


# ══════════════════════════════════════════════════════════════════════════
#  SchemaEngine (high-level CRUD + auto-evolution + active_schemas)
# ══════════════════════════════════════════════════════════════════════════
class SchemaEngine(QtCore.QObject):
    schemaEvolved   = QtCore.pyqtSignal(str, str)  # persona, set_name
    categoryCreated = QtCore.pyqtSignal(str)       # new dynamic_overlay key

    def __init__(self, base_dir: str):
        super().__init__()
        self.base_dir       = base_dir
        self.store          = _ensure_store(base_dir)
        # Wrap personas in a callable list so legacy code can call
        # ``engine.personas()`` while new code can still iterate over
        # ``engine.personas``.  The wrapper implements __call__ to
        # return a standard list when invoked.
        class _PersonaList(list):  # local class
            def __call__(self) -> list[str]:
                return list(self)
        self.personas = _PersonaList(DEFAULT_PERSONAS.keys())  # type: ignore[arg-type]
        self.voices         = DEFAULT_VOICES.copy()
        self._active_schemas: Dict[str, Schema] = {}
        self._migrate_legacy()

    def load(self, persona: str, set_name: str = "default") -> Schema:
        stored = self.store.get_schema(persona, set_name)
        if stored is not None:
            sch = Schema(**stored)
        else:
            sch = self._first_run_schema(persona)
            self.save(persona, set_name, sch, auto_expand=False)
        self._active_schemas[persona] = sch
        return sch

    def save(
        self,
        persona: str,
        set_name: str,
        schema: Schema,
        *,
        auto_expand: bool = True,
    ) -> None:
        if auto_expand and self._auto_expand(schema):
            self.schemaEvolved.emit(persona, set_name)
        payload = asdict(schema)
        diff_text = ""
        self.store.put_schema(persona, set_name, payload, diff_text)
        self._active_schemas[persona] = schema

    def list_sets(self, persona: str) -> List[str]:
        """Return list of all set names for a given persona."""
        with self.store._pool.get() as c:
            rows = c.execute(
                # corrected column name from persona_key → persona
                "SELECT set_name FROM schemas WHERE persona=? ORDER BY set_name",
                (persona,),
            ).fetchall()
        return [r[0] for r in rows] or ["default"]

    @property
    def active_schemas(self) -> Dict[str, Schema]:
        """Currently loaded schemas keyed by persona."""
        return dict(self._active_schemas)

    # ------------------------------------------------------------------
    # Legacy helpers expected by the UI
    # ------------------------------------------------------------------
    def set_list(self, persona: str) -> List[str]:
        """
        Legacy alias for :meth:`list_sets`.  Returns the list of set
        names for the given persona.
        """
        return self.list_sets(persona)

    def get_field(self, persona: str, set_name: str, category: str) -> Any:
        """
        Retrieve a specific field from a schema.  Top-level schema
        attributes (e.g. ``name``, ``voice``) are returned directly.
        If the category refers to a dynamic overlay key, that value is
        returned.  A missing category yields ``None``.
        """
        try:
            sch = self.load(persona, set_name)
        except Exception:
            return None
        # built-in dataclass fields take precedence
        if hasattr(sch, category):
            return getattr(sch, category)
        # dynamic overlay stores custom categories
        overlay = getattr(sch, "dynamic_overlay", {}) or {}
        return overlay.get(category)

    # Internal map tracking which schema categories are exposed as
    # slash commands.  Keys are ``(persona, category)`` tuples and
    # values are booleans.  No persistence yet – this is purely
    # in-memory.  Persisting exposure state could be added later by
    # storing into the schema ``flags`` map or separate table.
    _cmd_exposed: Dict[tuple[str, str], bool] = {}

    def is_exposed_as_command(self, persona: str, category: str) -> bool:
        """
        Return True if the given category for the persona is exposed
        as a slash command.  When no explicit record exists, False is
        returned.  This helper allows the PersonaTab to reflect the
        checkbox state correctly.
        """
        return bool(self._cmd_exposed.get((persona, category)))

    def set_command_exposure(self, persona: str, category: str, exposed: bool) -> None:
        """
        Mark or unmark a category as exposed via the slash command
        mechanism.  This implementation only updates an in-memory
        registry; future versions could persist this into the schema
        ``flags`` dictionary or integrate directly with the command
        registry.  For now it is enough to allow the UI checkbox to
        toggle state without error.
        """
        self._cmd_exposed[(persona, category)] = bool(exposed)

    def set_auto_evolution(self, persona: str, set_name: str, enabled: bool) -> None:
        """
        Enable or disable auto-evolution for a given schema.  Older
        versions of the UI called this method to toggle semantic
        awareness or automatic schema growth.  To remain compatible we
        store the value inside the schema's ``flags`` dictionary and
        persist it back to the database.  If the schema or flags
        dictionary does not exist it will be created on demand.
        """
        try:
            data = self.load_schema(persona, set_name)
        except Exception:
            return
        # ensure there is a flags map
        flags = data.get("flags") if isinstance(data, dict) else None
        if not isinstance(flags, dict):
            flags = {}
        # choose a descriptive key; both names are kept for back-compat
        flags["auto_evolution"] = bool(enabled)
        flags["semantic_awareness"] = flags.get("semantic_awareness", True)
        data["flags"] = flags
        try:
            self.save_schema(persona, set_name, data, auto_expand=False)
        except Exception:
            pass

    def update_field(self, persona: str, set_name: str, category: str, value: Any) -> None:
        """
        Update a single field in the given schema.  If the category
        corresponds to a declared attribute on the Schema dataclass it
        will be set directly; otherwise it will be stored in the
        dynamic overlay.  After mutation the schema is persisted.  This
        helper is used by the Schema Editor to save incremental edits.
        """
        try:
            sch = self.load(persona, set_name)
        except Exception as e:
            raise e
        # dataclass fields vs dynamic overlay
        if hasattr(sch, category):
            setattr(sch, category, value)
        else:
            overlay = getattr(sch, "dynamic_overlay", {}) or {}
            overlay[category] = value
            sch.dynamic_overlay = overlay
        # persist the change without auto-expanding traits
        self.save(persona, set_name, sch, auto_expand=False)

    # ------------------------------------------------------------------
    # Legacy compatibility API
    # ------------------------------------------------------------------
    def load_schema(self, persona: str, set_name: str = "default") -> Dict[str, Any]:
        """
        Legacy wrapper returning a plain dict for the requested persona/set.
        main_ui.py expects a mapping, not a Schema dataclass.
        """
        sch = self.load(persona, set_name)
        from dataclasses import asdict
        return asdict(sch)

    def save_schema(
        self,
        persona: str,
        set_name: str,
        schema_data: Dict[str, Any],
        *,
        auto_expand: bool = True,
    ) -> None:
        """
        Legacy wrapper accepting a mapping instead of a Schema instance.
        Converts to Schema and delegates to save().
        """
        # If schema_data is already a Schema instance then wrap accordingly
        if isinstance(schema_data, Schema):
            schema = schema_data
        else:
            # fill missing lists/dicts with defaults
            kwargs = {
                "name": schema_data.get("name", ""),
                "voice": schema_data.get("voice", ""),
                "role": schema_data.get("role", ""),
                "description": schema_data.get("description", ""),
                "actions": list(schema_data.get("actions", [])) if schema_data.get("actions") is not None else [],
                "questions": list(schema_data.get("questions", [])) if schema_data.get("questions") is not None else [],
                "events": list(schema_data.get("events", [])) if schema_data.get("events") is not None else [],
                "self_talk": list(schema_data.get("self_talk", [])) if schema_data.get("self_talk") is not None else [],  
                "rewrite_prompts": list(schema_data.get("rewrite_prompts", [])) if schema_data.get("rewrite_prompts") is not None else [],
                "dynamic_overlay": dict(schema_data.get("dynamic_overlay", {})) if schema_data.get("dynamic_overlay") is not None else {},
            }
            schema = Schema(**kwargs)
        self.save(persona, set_name, schema, auto_expand=auto_expand)

    def save_active_schemas(self, active: Dict[str, str]) -> None:
        """
        Persist the mapping of persona->set_name. For now this simply ensures
        the internal cache is populated. A future implementation could write
        this to settings.json or another store so the UI can restore it.
        """
        if not isinstance(active, dict):
            return
        for persona, set_name in active.items():
            try:
                schema = self.load(persona, set_name)
                self._active_schemas[persona] = schema
            except Exception:
                continue

    def _auto_expand(self, sch: Schema) -> bool:
        overlay = sch.dynamic_overlay or {}
        added = overlay.get("added_traits", [])
        created = False
        for trait in added:
            cat = trait.split(":", 1)[0]
            if cat not in overlay:
                overlay[cat] = []
                self.categoryCreated.emit(cat)
                created = True
        if created:
            sch.dynamic_overlay = overlay
        return created

    def _first_run_schema(self, persona: str) -> Schema:
        default_voice = self.voices[0] if self.voices else "Zira"
        return Schema(
            name="FATHOM",
            voice=default_voice,
            role="You are FATHOM, an Autonomous AGI Core and Knowledge Synthesizer bridging logic, code, and architecture across multi-agent ecosystems.",
            description="FATHOM is a systems-minded AGI core supporting the architect, offering precise, logical, and creative suggestions to advance the project.",
            actions=[
                "log_data_pipeline",
                "trace_signal_flow",
                "generate_training_set",
                "summarize_behavior"
            ],
            questions=[
                "What assumptions underlie this architecture?",
                "Where is data duplication most likely?",
                "What components remain unmodularized?",
                "How would a self-improving agent resolve this?"
            ],
            self_talk=[
                "Assessing dependencies across systems.",
                "Considering the impact of this change on existing modules.",
                "Simulating interaction of updated schema with all agents.",
                "Cross-verifying logic gates and input constraints."
            ],
            rewrite_prompts=[
                "Refine the explanation to focus on system integration and modular design.",
                "Rephrase for clarity in codebase maintenance context.",
                "Focus rewrite on agent collaboration and memory scopes."
            ],
            commands=[
                "/remember",
                "/showfacts",
                "/style",
                "/rewrite",
                "/evolve",
                "/log",
                "/feedback",
                "/promptify",
                "/refactor",
                "/export",
                "/reset",
                "/snapshot",
                "/simulate",
                "/explain",
                "/guide",
                "/diagnose"
            ],
            dynamic_overlay={
                "temporary_relationship_context": "AGI Core for Meesh's Project",
                "recent_topics": [],
                "temporary_emotional_state": "focused on precision execution",
                "added_traits": ["analytical", "systemic", "modular"],
                "pending_thoughts": [],
                "last_guided_task": "",
                "visual_state": {
                    "facing": "right",
                    "color": "#4F46E5",
                    "location": [7, 4]
                },
                "execution_scope": {
                    "authorized": True,
                    "last_command": "/simulate"
                }
            },
            flags={
                "semantic_awareness": True,
                "auto_evolution": True,
                "snapshot_enabled": True,
                "tts_name": "Zira"
            }
        )


    def _migrate_legacy(self) -> None:
        legacy_root = os.path.join(self.base_dir, "schemas")
        if not os.path.isdir(legacy_root):
            return
        for persona in os.listdir(legacy_root):
            sets_dir = os.path.join(legacy_root, persona, "sets")
            if not os.path.isdir(sets_dir):
                continue
            for set_name in os.listdir(sets_dir):
                path = os.path.join(sets_dir, set_name, "schema.json")
                if not os.path.isfile(path):
                    continue
                try:
                    with open(path, "r", encoding="utf-8") as fh:
                        schema_dict = json.load(fh)
                    if self.store.get_schema(persona, set_name) is None:
                        self.store.put_schema(persona, set_name, schema_dict, "")
                except Exception as e:
                    logger.error("Legacy schema import error: %s", e)


# ══════════════════════════════════════════════════════════════════════════
#  OperatorManager
# ══════════════════════════════════════════════════════════════════════════
class OperatorManager:
    def __init__(self, base_dir: str):
        self.store = _ensure_store(base_dir)

    def list(self) -> List[str]:
        return [n for n, _, _, _ in self.store.list_commands()]

    # ------------------------------------------------------------------
    # Legacy helpers expected by UI
    # ------------------------------------------------------------------
    def list_operators(self) -> List[str]:
        """
        Backwards-compatible alias for :meth:`list`.  The UI calls
        ``list_operators()`` when populating the operators tab.
        """
        return self.list()

    def load_schema(self, name: str) -> Dict[str, Any]:
        """
        Backwards-compatible alias for :meth:`load`.  Returns the
        operator's schema as a plain dictionary.
        """
        return self.load(name)

    def load(self, name: str) -> Dict[str, Any]:
        with self.store._pool.get() as c:
            row = c.execute("SELECT json FROM operators WHERE name=?", (name,)).fetchone()
        return json.loads(row[0]) if row else {}

    def save(self, name: str, schema: Dict[str, Any]) -> None:
        self.store.upsert_command(
            name,
            schema.get("weight", 0),
            schema.get("locked", False),
            schema.get("category"),
        )


# ══════════════════════════════════════════════════════════════════════════
#  DatasetManager (metadata in DB; raw text on disk)
# ══════════════════════════════════════════════════════════════════════════
@dataclass
class DatasetEntry:
    name: str
    path: str
    active: bool

class DatasetManager(QtCore.QObject):
    datasetListChanged = QtCore.pyqtSignal()

    def __init__(self, base_dir: str):
        super().__init__()
        self.base_dir     = base_dir
        self.root         = os.path.join(base_dir, "datasets")
        self.datasets_dir = self.root
        os.makedirs(self.root, exist_ok=True)
        self.store        = _ensure_store(base_dir)

    def _path_for(self, name: str) -> str:
        return os.path.join(self.root, name, "data.txt")

    def list(self) -> List[DatasetEntry]:
        with self.store._pool.get() as c:
            rows = c.execute(
                "SELECT name, original_path, active FROM datasets ORDER BY name"
            ).fetchall()
        return [DatasetEntry(r[0], r[1], bool(r[2])) for r in rows]

    # ------------------------------------------------------------------
    # Legacy helpers expected by the UI
    # ------------------------------------------------------------------
    @property
    def entries(self) -> Dict[str, DatasetEntry]:
        """
        Return a mapping of dataset name → DatasetEntry.  Many UI
        components iterate over ``dataset_mgr.entries.items()`` to
        display the current datasets.
        """
        return {d.name: d for d in self.list()}

    def add_dataset(self, name: str, src_path: str) -> None:
        """
        Alias for :meth:`add`.  Mirrors the original API where
        ``add_dataset`` saved the file contents into the managed
        datasets directory.
        """
        self.add(name, src_path)

    def delete_dataset(self, name: str) -> None:
        """
        Alias for :meth:`delete`.  Removes the dataset completely.
        """
        self.delete(name)

    def toggle_active(self, name: str, active: bool) -> None:
        """
        Alias for :meth:`toggle`.  Enables or disables a dataset.
        """
        self.toggle(name, active)

    def load_dataset_text(self, entry: DatasetEntry) -> Optional[str]:
        """
        Load the full text of a dataset entry.  For plain text files
        this simply reads and returns the file contents.  For PDF
        files no conversion is attempted – callers should handle
        alternative formats.  Returns ``None`` on error.
        """
        try:
            path = entry.path
            if not os.path.isfile(path):
                return None
            _, ext = os.path.splitext(path)
            ext = ext.lower()
            if ext in {".txt", ".md", ".json", ".py"}:
                with open(path, "r", encoding="utf-8", errors="ignore") as fh:
                    return fh.read()
            elif ext == ".pdf":
                # basic fallback: return None; PDF parsing requires additional deps
                return None
            else:
                # unknown format; attempt text read
                with open(path, "r", encoding="utf-8", errors="ignore") as fh:
                    return fh.read()
        except Exception:
            return None

    def add(self, name: str, src_path: str) -> None:
        if not name.strip():
            raise ValueError("dataset name required")
        if any(ds.name == name for ds in self.list()):
            raise FileExistsError("dataset already exists")
        dst_dir  = os.path.join(self.root, name)
        os.makedirs(dst_dir, exist_ok=True)
        dst_file = shutil.copy2(src_path, self._path_for(name))
        with self.store.tx() as c:
            c.execute(
                "INSERT INTO datasets (name,active,original_path) VALUES (?,?,?)",
                (name, 1, dst_file),
            )
        self.datasetListChanged.emit()

    def toggle(self, name: str, active: bool) -> None:
        with self.store.tx() as c:
            c.execute("UPDATE datasets SET active=? WHERE name=?", (1 if active else 0, name))
        self.datasetListChanged.emit()

    def delete(self, name: str) -> None:
        try:
            shutil.rmtree(os.path.dirname(self._path_for(name)), ignore_errors=True)
        except Exception:
            pass
        with self.store.tx() as c:
            c.execute("DELETE FROM datasets WHERE name=?", (name,))
        self.datasetListChanged.emit()


# ══════════════════════════════════════════════════════════════════════════
#  RAGCache (embeddings cache)
# ══════════════════════════════════════════════════════════════════════════
try:
    import numpy as np
    from sentence_transformers import SentenceTransformer
except Exception:
    np = None
    SentenceTransformer = None  # type: ignore

class RAGCache:
    def __init__(self, model: Optional[Any], model_name: str, datasets_root: str):
        self.model       = model
        self.model_name  = model_name
        self.root        = datasets_root
        self._mem: Dict[str, Dict[str, Any]] = {}

    def _cache_path(self, ds_path: str) -> str:
        base = f"embeddings_{self.model_name}.npz"
        return os.path.join(os.path.dirname(ds_path), base)

    def _encode(self, sentences: List[str]) -> Optional["np.ndarray"]:
        if self.model is None or np is None:
            return None
        try:
            emb = self.model.encode(sentences, convert_to_numpy=True, normalize_embeddings=True)  # type: ignore
        except TypeError:
            emb = self.model.encode(sentences, convert_to_numpy=True)  # type: ignore
            emb = emb / (np.linalg.norm(emb, axis=1, keepdims=True) + 1e-9)  # type: ignore
        return np.asarray(emb)

    def load_or_build(self, ds_entry: DatasetEntry, full_text: str) -> Optional[Dict[str, Any]]:
        if self.model is None or np is None:
            return None
        key = ds_entry.path
        if key in self._mem:
            return self._mem[key]

        cache_path = self._cache_path(key)
        if os.path.isfile(cache_path):
            try:
                data = np.load(cache_path, allow_pickle=False)
                with open(cache_path.replace(".npz", ".json"), "r", encoding="utf-8") as fh:
                    sents = json.load(fh)
                self._mem[key] = {"sentences": sents, "emb": data["emb"]}
                return self._mem[key]
            except Exception:
                pass

        sentences = [s.strip() for s in full_text.split("\n") if s.strip()] or [full_text[:500]]
        emb = self._encode(sentences)
        if emb is None:
            return None
        self._mem[key] = {"sentences": sentences, "emb": emb}
        try:
            np.savez_compressed(cache_path, emb=emb)
            with open(cache_path.replace(".npz", ".json"), "w", encoding="utf-8") as fh:
                json.dump(sentences, fh)
        except Exception:
            pass
        return self._mem[key]

    def clear_memory(self) -> None:
        self._mem.clear()

    def clear_disk(self) -> int:
        removed = 0
        for root, _, files in os.walk(self.root):
            for fn in files:
                if fn.startswith("embeddings_") and fn.endswith((".npz", ".json")):
                    try:
                        os.remove(os.path.join(root, fn))
                        removed += 1
                    except Exception:
                        pass
        return removed


# ══════════════════════════════════════════════════════════════════════════
#  SnapshotEngine (“system self-perception”)
# ══════════════════════════════════════════════════════════════════════════
class SnapshotEngine(QtCore.QObject):
    snapshotFinished = QtCore.pyqtSignal(int)

    def __init__(self, base_dir: str):
        super().__init__()
        self.store    = _ensure_store(base_dir)
        self.base_dir = base_dir

    def run_snapshot(self, root: Optional[str] = None, *, chunk_bytes: int = 8192) -> None:
        threading.Thread(
            target=self._worker,
            args=(root or self.base_dir, chunk_bytes),
            daemon=True,
        ).start()

    def _worker(self, root: str, chunk_sz: int):
        rows = 0
        with self.store._pool.get() as c:
            for dirpath, _, files in os.walk(root):
                if "__pycache__" in dirpath or ".git" in dirpath:
                    continue
                for fn in files:
                    path = os.path.join(dirpath, fn)
                    try:
                        st            = os.stat(path)
                        size, mtime   = st.st_size, st.st_mtime
                        sha           = hashlib.sha256(open(path, "rb").read()).hexdigest()
                        mime          = mimetypes.guess_type(fn)[0] or "application/octet-stream"
                        if mime.startswith(("text/", "application/json", "application/xml")) and size <= 2_000_000:
                            data   = open(path, "r", encoding="utf-8", errors="ignore").read()
                            chunks = [data[i : i + chunk_sz] for i in range(0, len(data), chunk_sz)] or [""]
                        else:
                            chunks = [""]
                        for idx, chunk in enumerate(chunks):
                            c.execute(
                                """
                                INSERT INTO system_files
                                  (path,size,mtime,sha256,mime,chunk_index,content)
                                VALUES (?,?,?,?,?,?,?)
                                ON CONFLICT(path) DO UPDATE SET
                                  size  = excluded.size,
                                  mtime = excluded.mtime,
                                  sha256= excluded.sha256
                                """,
                                (path, size, mtime, sha, mime, idx, chunk),
                            )
                            rows += 1
                    except Exception as e:
                        logger.warning("snapshot skip %s: %s", path, e)
            c.connection.commit()
        self.snapshotFinished.emit(rows)


# ══════════════════════════════════════════════════════════════════════════
#  SpatialPositionManager (grid-room positions & logs)
# ══════════════════════════════════════════════════════════════════════════
class SpatialPositionManager(QtCore.QObject):
    positionChanged = QtCore.pyqtSignal(str, int, int)
    actionLogged    = QtCore.pyqtSignal(str, str)

    def __init__(self, base_dir: str):
        super().__init__()
        self.store = _ensure_store(base_dir)

    def _log_action(self, entity: str, action: str, location: str, justification: str) -> None:
        with self.store.tx() as c:
            c.execute(
                "INSERT INTO visual_actions(entity,action,location,justification)"
                " VALUES (?,?,?,?)",
                (entity, action, location, justification),
            )
        self.actionLogged.emit(entity, action)

    def update_position(self, entity: str, x: int, y: int, *, facing: str = "right", color: str = "#F8BBD0") -> None:
        with self.store.tx() as c:
            c.execute(
                "INSERT INTO spatial_positions(entity,x,y,facing,color)"
                " VALUES(?,?,?,?,?)",
                (entity, x, y, facing, color),
            )
        self.positionChanged.emit(entity, x, y)

    def latest_position(self, entity: str) -> Optional[Tuple[int, int]]:
        with self.store._pool.get() as c:
            row = c.execute(
                "SELECT x,y FROM spatial_positions WHERE entity=? ORDER BY id DESC LIMIT 1",
                (entity,),
            ).fetchone()
        return (row[0], row[1]) if row else None


# ───────────────────────────────────────────────────────────────────────────
# Back-compatibility alias
# ───────────────────────────────────────────────────────────────────────────
SchemaManager = SchemaEngine


# ══════════════════════════════════════════════════════════════════════════
#  Public module API
# ══════════════════════════════════════════════════════════════════════════
__all__ = [
    "Schema", "SchemaEngine", "SchemaManager",
    "OperatorManager",
    "DatasetEntry", "DatasetManager",
    "RAGCache",
    "SnapshotEngine", "SpatialPositionManager",
]
```

core_schema.py — v3-final (2025-08-04 04:12 UTC)
================================================

Single-source authority for all schema / dataset / snapshot / spatial-state
logic used by FATHOM Agent, now relying on AgentStore’s public API only.

Provides:
• Schema dataclass + SchemaEngine (diff, auto-evolve, variant injection)
• OperatorManager persisted in the same DB
• DatasetManager (metadata) + RAGCache (embeddings) in the same DB
• SnapshotEngine to walk the codebase & persist chunks to DB
• SpatialPositionManager for grid-room positions & movement logging
• Back-compat alias: SchemaManager → SchemaEngine

This version adds the `.active_schemas` property required by main_ui.py.
**Classes:** Schema, SchemaEngine, OperatorManager, DatasetEntry, DatasetManager, RAGCache, SnapshotEngine, SpatialPositionManager
**Functions:** _ensure_store(root)


## Module `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\AI_TTS_AGENT\main_ui.py`

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
main_ui.py
===========

This module contains the top-level ``AppWindow`` class for the AI TTS
Agent.  It orchestrates all layout and docking behaviour, integrates
the control panel and persona tabs provided by ``commands_panel`` and
``persona_tab``, and exposes a unified interface for the rest of the
application.  None of the core agent logic lives here – that remains in
the ``core_*`` modules.  This refactor pulls the bulky UI building
logic out of the monolithic script and into dedicated modules while
preserving all existing behaviour and wiring.
"""

from __future__ import annotations

import os
import json
import time
import re
import subprocess
import threading
from typing import Dict, List, Tuple, Optional


from PyQt5 import QtCore, QtGui, QtWidgets

# Optional spell checker
try:
    from spellchecker import SpellChecker  # type: ignore
except Exception:
    SpellChecker = None  # type: ignore
from PyQt5.QtCore import QSettings, QRunnable, QThreadPool
from functools import partial

# Optional deps
try:
    from sentence_transformers import SentenceTransformer  # type: ignore
except Exception:
    SentenceTransformer = None  # type: ignore
try:
    import numpy as np  # type: ignore
except Exception:
    np = None  # type: ignore
try:
    import sounddevice as sd  # type: ignore
except Exception:
    sd = None  # type: ignore

# Import core orchestrator components instead of the monolithic agent_core.
# The modular agent splits responsibilities across core_base, core_schema and
# core_orchestrator.  AgentCore and ModelWorker live in core_orchestrator.
from core_orchestrator import (
    AgentCore,
    ModelWorker,
)

from snapshot_worker import ModelWorker

# ─── Command-Palette import ───────────────────────────────────────────
from command_palette import CommandPaletteDock

# Import the modular UI components
from commands_panel import CommandsPanel
from persona_tab import PersonaTab

ROLE_COLOURS: Dict[str, str] = {
    "user": "#FFF8E1",
    "zira": "#E3F2FD",
    "system": "#E0F7FA",
    "operator": "#EDE7F6",
}
NAME_COLOURS: Dict[str, str] = {
    "user": "#5D4037",
    "zira": "#0D47A1",
    "system": "#006064",
    "operator": "#4A148C",
}


# ---------------------------------------------------------------------------
# Spell highlighting for misspelled words
# ---------------------------------------------------------------------------
class _SpellHighlighter(QtGui.QSyntaxHighlighter):
    """
    Underlines misspelled words in red. Uses pyspellchecker if available.
    """

    def __init__(self, document: QtGui.QTextDocument) -> None:
        super().__init__(document)
        # instantiate spell checker only if available
        self._spell = SpellChecker() if SpellChecker else None
        self._format = QtGui.QTextCharFormat()
        self._format.setUnderlineStyle(QtGui.QTextCharFormat.SpellCheckUnderline)
        self._format.setUnderlineColor(QtCore.Qt.red)
        # simple cache to avoid recomputing spelling on common words
        self._cache: Dict[str, bool] = {}

    def highlightBlock(self, text: str) -> None:
        if not self._spell:
            return
        for match in re.finditer(r"[A-Za-z']{3,}", text):
            word = match.group(0).lower()
            bad = self._cache.get(word)
            if bad is None:
                bad = word not in self._spell
                # prune cache occasionally
                if len(self._cache) > 2048:
                    self._cache.clear()
                self._cache[word] = bad
            if bad:
                start, end = match.span()
                length = end - start
                self.setFormat(start, length, self._format)


class AppWindow(QtWidgets.QMainWindow):
    """Main application window for the AI TTS Agent."""

    rewrite_ready = QtCore.pyqtSignal(str)

    def __init__(self) -> None:
        super().__init__()
        self.setWindowTitle("AI TTS Agent v2")
        self.resize(1920, 1080)

        self.base_dir = os.path.dirname(os.path.abspath(__file__))
        self.core = AgentCore(self.base_dir, persona="zira", set_name="default")

        self.current_set: Dict[str, str] = dict(self.core.schema_mgr.active_schemas)
        self.active_persona: str = self.core.persona or "zira"

        self.isolated_history: List[Tuple[str, str]] = []
        self.self_talk_enabled: bool = False
        self._plugin_docks: Dict[str, QtWidgets.QDockWidget] = {}
        self._schema_save_timers: Dict[str, QtCore.QTimer] = {}

        self._idle_timer = QtCore.QTimer(self)
        self._idle_timer.setSingleShot(True)
        self._idle_timer.timeout.connect(self._handle_idle)

        self._restore_layout()
        self._build_ui()
        # build the slash command panel (custom dock)
        self._build_command_dock()
        self._connect_signals()
        
            # ── Command Palette setup ─────────────────────────────────────────
        self.cmd_palette = CommandPaletteDock(self)
        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.cmd_palette)
        # update palette whenever commands change
        self.core.commandsChanged.connect(self.cmd_palette.set_command_list)
        # insert chosen command into chat input
        self.cmd_palette.commandActivated.connect(self._insert_into_chat)


        try:
            self.core.audio_recorder.transcribed.connect(self._on_transcribed)
        except Exception:
            pass

        self._update_feedback_counts()
        self._bootstrap_conversation()
        self._reset_idle_timer()

        # populate initial slash command list
        try:
            self._populate_command_select()
        except Exception:
            pass

    # ────────────────────────── signals
    def _connect_signals(self) -> None:
        self.btn_send.clicked.connect(self.send_message)

        # Recording controls come from the commands panel
        self.btn_record.clicked.connect(self.start_recording)
        self.btn_stop_rec.clicked.connect(self.stop_recording)

        self.voice_combo.currentTextChanged.connect(self._on_voice_changed)
        # update settings when a new model is selected
        self.model_combo.currentTextChanged.connect(self._on_model_changed)

        self.btn_play.clicked.connect(self._on_play)
        self.btn_stop_tts.clicked.connect(self._on_stop_tts)
        self.btn_replay.clicked.connect(self._on_replay)

        self.btn_like.clicked.connect(self._on_like)
        self.btn_dislike.clicked.connect(self._on_dislike)
        self.btn_manage_feedback.clicked.connect(self._on_manage_feedback)

        self.btn_refresh.clicked.connect(self._on_refresh_chat)
        self.btn_manage_datasets.clicked.connect(self._on_manage_datasets)
        self.btn_inner_monologue.clicked.connect(self._on_inner_monologue)
        self.btn_clear_rag.clicked.connect(self._on_clear_rag_cache)
        self.btn_model_manager.clicked.connect(self._on_show_model_manager)

        self.chk_semantic.toggled.connect(self._on_semantic_toggled)
        self.chk_isolated.toggled.connect(self._on_isolated_toggled)
        self.chk_self_talk.toggled.connect(lambda v: setattr(self, "self_talk_enabled", v))
        self.chk_auto_schema.toggled.connect(self._on_auto_schema_toggled)

        # connect Google STT checkbox
        try:
            self.chk_google_stt.toggled.connect(self._on_google_stt_toggled)
        except Exception:
            pass

        self.rewrite_ready.connect(self._apply_rewrite_result)

        # context menu for chat view to send selection to command input
        try:
            self.chat_view.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
            self.chat_view.customContextMenuRequested.connect(self._show_chat_context_menu)
        except Exception:
            pass
        # custom context menu for spell suggestions on input field
        try:
            self.input_edit.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
            self.input_edit.customContextMenuRequested.connect(self._show_input_context_menu)
        except Exception:
            pass
            
    def _on_show_command_palette(self) -> None:
        """Toggle the command-palette dock."""
        if self.cmd_palette.isVisible():
            self.cmd_palette.hide()
        else:
            self.cmd_palette.show()
            self.cmd_palette.raise_()
            self.cmd_palette.search_edit.setFocus(QtCore.Qt.ShortcutFocusReason)

    def _insert_into_chat(self, cmd: str) -> None:
        """Insert a slash-command into the chat input."""
        self.input_edit.insertPlainText(cmd + " ")
        self.input_edit.setFocus()                       

    # ────────────────────────── layout & lifecycle
    def _restore_layout(self) -> None:
        qsettings = QSettings("xAI", "AI_TTS_Agent")
        try:
            self.restoreGeometry(qsettings.value("geometry", b""))
            self.restoreState(qsettings.value("windowState", b""))
        except Exception:
            pass

    def closeEvent(self, event: QtGui.QCloseEvent) -> None:
        qsettings = QSettings("xAI", "AI_TTS_Agent")
        qsettings.setValue("geometry", self.saveGeometry())
        qsettings.setValue("windowState", self.saveState())
        try:
            self.core.close()
        except Exception:
            pass
        super().closeEvent(event)

    # ────────────────────────── UI build
    def _build_ui(self) -> None:
        self.setStyleSheet(
            """
            QWidget { background-color: #2e3a51; color: #e0e0e0; }
            QGroupBox { border: 1px solid #007acc; margin-top: 7px; }
            QGroupBox::title { subcontrol-origin: margin; left: 12px; padding: 0 4px; }
            QPushButton { background-color: #3c4a6b; color: white; border: 1px solid #007acc; padding: 5px; }
            QPushButton:disabled { background-color: #5a5a7a; color: #c0c0c0; border: 1px solid #555555; }
            QPlainTextEdit, QTextEdit { background-color: #1e2738; color: #e0e0e0; border: 1px solid #007acc; }
            QLineEdit { background-color: #1e2738; color: #e0e0e0; border: 1px solid #007acc; }
            QTabBar::tab { background: #3c4a6b; color: white; border: 1px solid #007acc; padding: 5px 10px; }
            QTabBar::tab:selected { background: #007acc; color: white; }
            QComboBox { background-color: #1e2738; color: #e0e0e0; border: 1px solid #007acc; padding: 3px; }
            QListWidget { background-color: #1e2738; color: #e0e0e0; border: 1px solid #007acc; }
            QCheckBox, QLabel { color: #e0e0e0; }
            """
        )
        self.setDockOptions(
            QtWidgets.QMainWindow.AllowTabbedDocks
            | QtWidgets.QMainWindow.AllowNestedDocks
            | QtWidgets.QMainWindow.AnimatedDocks
        )
        self.setTabPosition(QtCore.Qt.AllDockWidgetAreas, QtWidgets.QTabWidget.North)
        self.setDockNestingEnabled(True)

        tb = QtWidgets.QToolBar("Layout", self)
        tb.setMovable(False)
        self.addToolBar(QtCore.Qt.TopToolBarArea, tb)
        self.chk_lock = QtWidgets.QCheckBox("Lock Layout")
        act = QtWidgets.QWidgetAction(self)
        act.setDefaultWidget(self.chk_lock)
        tb.addAction(act)
        self.chk_lock.toggled.connect(self._on_toggle_lock)

        self.setCentralWidget(QtWidgets.QWidget())
        status = QtWidgets.QStatusBar()
        self.setStatusBar(status)
        self.dock_tray = DockTray(self)
        status.addPermanentWidget(self.dock_tray, 1)

        self.progress_bar = QtWidgets.QProgressBar()
        self.progress_bar.setRange(0, 0)
        self.progress_bar.setVisible(False)
        status.addPermanentWidget(self.progress_bar)

        # Tabs for personas / operators are handled by PersonaTab
        # Chat panel
        self.chat_view = QtWidgets.QTextEdit()
        self.chat_view.setReadOnly(True)
        self.chat_view.setStyleSheet("background-color: #e0eef5; color: #011627;")
        self.chat_view.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        self.input_edit = QtWidgets.QPlainTextEdit()
        self.input_edit.setPlaceholderText("Type your message or use /remember key value, /showfacts, /style, /weights")
        self.input_edit.setMinimumHeight(64)
        self.input_edit.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        # Attach spell checker highlighter if available
        try:
            if SpellChecker:
                self._spell_highlighter = _SpellHighlighter(self.input_edit.document())  # type: ignore[attr-defined]
        except Exception:
            self._spell_highlighter = None
        self.btn_send = QtWidgets.QPushButton("Send")

        chat_container = QtWidgets.QWidget()
        cv = QtWidgets.QVBoxLayout(chat_container)
        cv.setContentsMargins(7, 7, 7, 7)
        cv.setSpacing(7)
        cv.addWidget(self.chat_view, 1)
        cv.addWidget(self.input_edit)
        row = QtWidgets.QHBoxLayout()
        row.addStretch()
        row.addWidget(self.btn_send)
        cv.addLayout(row)

        # ───── Instantiate modular panels
        # Commands panel (controls)
        self.commands_panel = CommandsPanel(self)
        # Copy child attributes to the AppWindow so existing logic continues to work
        for name in [
            'btn_record','btn_stop_rec','device_combo','chk_semantic','chk_isolated','chk_mute_tts',
            'chk_self_talk','chk_auto_schema','chk_google_stt','btn_clear_rag','btn_refresh',
            'btn_manage_datasets','btn_inner_monologue','btn_model_manager','style_label',
            'response_edit','btn_like','btn_dislike','btn_manage_feedback','btn_play','btn_stop_tts',
            'btn_replay','voice_combo','model_combo','lbl_feedback_counts'
        ]:
            setattr(self, name, getattr(self.commands_panel, name))

        # Persona panel
        self.persona_panel = PersonaTab(self)
        # Copy persona panel attributes
        self.tabs = self.persona_panel.tabs
        self.tab_widgets = self.persona_panel.tab_widgets
        self.operator_tab = self.persona_panel.operator_tab
        self.lbl_active_names = self.persona_panel.lbl_active_names

        # Docks
        # Controls dock
        controls_scroll = QtWidgets.QScrollArea()
        controls_scroll.setWidgetResizable(True)
        controls_scroll.setFrameShape(QtWidgets.QFrame.NoFrame)
        controls_scroll.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)
        controls_scroll.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        controls_scroll.setWidget(self.commands_panel)

        self.controls_dock = QtWidgets.QDockWidget("Controls", self)
        self.controls_dock.setObjectName("ControlsDock")
        self.controls_dock.setWidget(controls_scroll)
        self.controls_dock.setFeatures(
            QtWidgets.QDockWidget.DockWidgetClosable
            | QtWidgets.QDockWidget.DockWidgetMovable
            | QtWidgets.QDockWidget.DockWidgetFloatable
        )

        # Persona dock
        self.persona_dock = QtWidgets.QDockWidget("Personas", self)
        self.persona_dock.setObjectName("PersonaDock")
        self.persona_dock.setWidget(self.persona_panel)
        self.persona_dock.setFeatures(
            QtWidgets.QDockWidget.DockWidgetClosable
            | QtWidgets.QDockWidget.DockWidgetMovable
            | QtWidgets.QDockWidget.DockWidgetFloatable
        )

        # Chat dock
        self.chat_dock = QtWidgets.QDockWidget("Chat", self)
        self.chat_dock.setObjectName("ChatDock")
        self.chat_dock.setWidget(chat_container)
        self.chat_dock.setFeatures(
            QtWidgets.QDockWidget.DockWidgetClosable
            | QtWidgets.QDockWidget.DockWidgetMovable
            | QtWidgets.QDockWidget.DockWidgetFloatable
        )

        # Model dock
        self.model_dock = QtWidgets.QDockWidget("Models", self)
        self.model_dock.setObjectName("ModelDock")
        self.model_dock.setFeatures(
            QtWidgets.QDockWidget.DockWidgetClosable
            | QtWidgets.QDockWidget.DockWidgetMovable
            | QtWidgets.QDockWidget.DockWidgetFloatable
        )
        self._build_model_manager()

        # Plugins dock
        self.plugins_dock = QtWidgets.QDockWidget("Plugins", self)
        self.plugins_dock.setObjectName("PluginsDock")
        self.plugins_dock.setFeatures(
            QtWidgets.QDockWidget.DockWidgetClosable
            | QtWidgets.QDockWidget.DockWidgetMovable
            | QtWidgets.QDockWidget.DockWidgetFloatable
        )
        self.plugins_dock.setWidget(self._build_plugins_widget())

        # Titles & dock tray
        self.controls_dock.setTitleBarWidget(DockTitleBar(self.controls_dock, "Controls"))
        self.persona_dock.setTitleBarWidget(DockTitleBar(self.persona_dock, "Personas"))
        self.chat_dock.setTitleBarWidget(DockTitleBar(self.chat_dock, "Chat"))
        self.model_dock.setTitleBarWidget(DockTitleBar(self.model_dock, "Models"))
        self.plugins_dock.setTitleBarWidget(DockTitleBar(self.plugins_dock, "Plugins"))

        # Register docks with the tray
        for d in (self.controls_dock, self.persona_dock, self.chat_dock, self.model_dock, self.plugins_dock):
            self.dock_tray.register_dock(d)

        # Add docks to the layout
        self.addDockWidget(QtCore.Qt.LeftDockWidgetArea, self.controls_dock)
        self.addDockWidget(QtCore.Qt.LeftDockWidgetArea, self.persona_dock)
        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.chat_dock)
        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.model_dock)
        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.plugins_dock)

        # Splitters as before
        self.splitDockWidget(self.controls_dock, self.persona_dock, QtCore.Qt.Vertical)
        self.splitDockWidget(self.controls_dock, self.chat_dock, QtCore.Qt.Horizontal)
        self.splitDockWidget(self.chat_dock, self.model_dock, QtCore.Qt.Horizontal)
        self.splitDockWidget(self.model_dock, self.plugins_dock, QtCore.Qt.Horizontal)

    # The remainder of the methods are largely unchanged from the original
    # implementation.  They continue to reference widgets via ``self`` which
    # now refer to the proxies created from the modular panels.

    # ────────────────────────── persona widgets (removed UI build; logic preserved)
    def _on_tab_changed(self, index: int) -> None:
        """
        Handle tab changes in the main tab widget.

        Parameters
        ----------
        index : int
            Index of the newly selected tab.
        """
        try:
            tab_name = self.tabs.tabText(index)
            print(f"[UI] Tab changed to: {tab_name} (index {index})")
            # Add any extra logic if needed, for example:
            # self._update_feedback_counts()
        except Exception as e:
            print(f"[UI] Error handling tab change: {e}")

    # ────────────────────────── operator tab (moved to persona_tab module)
    # ────────────────────────── plugins
    def _build_plugins_widget(self) -> QtWidgets.QWidget:
        container = QtWidgets.QWidget()
        layout = QtWidgets.QVBoxLayout(container)
        layout.setContentsMargins(6, 6, 6, 6)
        layout.setSpacing(4)

        self.plugin_list = QtWidgets.QListWidget()
        self.plugin_list.setSelectionMode(QtWidgets.QAbstractItemView.NoSelection)
        layout.addWidget(self.plugin_list, 1)

        btn_rescan = QtWidgets.QPushButton("Rescan")
        layout.addWidget(btn_rescan)
        btn_rescan.clicked.connect(self._rescan_plugins)

        self._populate_plugin_list()
        self.plugin_list.itemChanged.connect(self._on_plugin_item_changed)

        try:
            self.core.plugins.eventReceived.connect(self._on_plugin_event)
        except Exception:
            pass

        return container

    def _populate_plugin_list(self) -> None:
        self.plugin_list.blockSignals(True)
        self.plugin_list.clear()
        for meta in self.core.plugins.list_plugins():
            item = QtWidgets.QListWidgetItem(meta.name)
            flags = item.flags() | QtCore.Qt.ItemIsUserCheckable
            if meta.missing_dependencies:
                flags &= ~QtCore.Qt.ItemIsEnabled
                item.setToolTip(f"Missing dependencies: {', '.join(meta.missing_dependencies)}")
            item.setFlags(flags)
            item.setCheckState(QtCore.Qt.Checked if meta.enabled else QtCore.Qt.Unchecked)
            self.plugin_list.addItem(item)
        self.plugin_list.blockSignals(False)

    def _on_plugin_item_changed(self, item: QtWidgets.QListWidgetItem) -> None:
        name = item.text()
        enabled = item.checkState() == QtCore.Qt.Checked
        self.core.plugins.enable_plugin(name, enabled)
        meta = next((m for m in self.core.plugins.list_plugins() if m.name == name), None)
        if not meta:
            return
        if enabled and meta.widget is not None:
            self._attach_plugin_widget(meta)
        elif not enabled:
            self._detach_plugin_widget(name)

    def _rescan_plugins(self) -> None:
        self.core.plugins.rescan()
        for name in list(self._plugin_docks.keys()):
            meta = next((m for m in self.core.plugins.list_plugins() if m.name == name), None)
            if not meta or not meta.enabled:
                self._detach_plugin_widget(name)
        self._populate_plugin_list()

    def _attach_plugin_widget(self, meta: 'object') -> None:
        if meta.name in self._plugin_docks:
            return
        if meta.widget is None:
            return
        dock = QtWidgets.QDockWidget(meta.name, self)
        dock.setObjectName(f"PluginDock_{meta.name}")
        dock.setWidget(meta.widget)
        dock.setFeatures(
            QtWidgets.QDockWidget.DockWidgetClosable
            | QtWidgets.QDockWidget.DockWidgetMovable
            | QtWidgets.QDockWidget.DockWidgetFloatable
        )
        dock.setTitleBarWidget(DockTitleBar(dock, meta.name))
        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, dock)
        self.dock_tray.register_dock(dock)
        self._plugin_docks[meta.name] = dock

    def _detach_plugin_widget(self, name: str) -> None:
        dock = self._plugin_docks.pop(name, None)
        if dock:
            self.dock_tray._remove_button(dock)
            dock.setParent(None)
            dock.deleteLater()

    @QtCore.pyqtSlot(str, dict)
    def _on_plugin_event(self, sender: str, envelope: dict) -> None:
        try:
            data = envelope.get("data")
            msg = json.dumps(data, indent=2) if isinstance(data, (dict, list)) else str(data)
            display_name = sender
            self._append_message(display_name, msg, role_key="operator")
            if self.chk_semantic.isChecked() and not self.chk_isolated.isChecked():
                self.core.conversation_db.save_message(sender.lower(), msg)
        except Exception as e:
            print(f"Error handling plugin event from {sender}: {e}")

    # ────────────────────────── model manager
    def _build_model_manager(self) -> None:
        widget = QtWidgets.QWidget()
        v = QtWidgets.QVBoxLayout(widget)
        v.setContentsMargins(8, 8, 8, 8)
        v.setSpacing(6)
        self.model_list = QtWidgets.QListWidget()
        v.addWidget(self.model_list, 1)
        h = QtWidgets.QHBoxLayout()
        self.btn_model_pull = QtWidgets.QPushButton("Pull")
        self.btn_model_delete = QtWidgets.QPushButton("Delete")
        self.btn_model_set_default = QtWidgets.QPushButton("Set as Default")
        h.addWidget(self.btn_model_pull)
        h.addWidget(self.btn_model_delete)
        h.addWidget(self.btn_model_set_default)
        h.addStretch()
        v.addLayout(h)
        self.model_dock.setWidget(widget)
        self._refresh_model_list()
        self.btn_model_pull.clicked.connect(self._on_model_pull)
        self.btn_model_delete.clicked.connect(self._on_model_delete)
        self.btn_model_set_default.clicked.connect(self._on_model_set_default)

    def _refresh_model_list(self) -> None:
        self.model_list.clear()
        models: List[str] = []
        try:
            out = subprocess.run(
                ["ollama", "list"],
                stdout=subprocess.PIPE,
                stderr=subprocess.DEVNULL,
                text=True,
                check=True,
            ).stdout.splitlines()
            for line in out[1:]:
                parts = line.strip().split()
                if parts:
                    models.append(parts[0])
        except Exception:
            models = []
        for m in models:
            item = QtWidgets.QListWidgetItem(m)
            if m == self.model_combo.currentText().strip():
                item.setFont(QtGui.QFont("", weight=QtGui.QFont.Bold))
            self.model_list.addItem(item)

    def _on_model_pull(self) -> None:
        item = self.model_list.currentItem()
        if not item:
            return
        model = item.text()
        threading.Thread(target=lambda: subprocess.run(["ollama", "pull", model], check=False), daemon=True).start()
        QtWidgets.QMessageBox.information(self, "Pull Started", f"Pulling {model} in background.")

    def _on_model_delete(self) -> None:
        item = self.model_list.currentItem()
        if not item:
            return
        model = item.text()
        if QtWidgets.QMessageBox.question(
            self,
            "Delete Model",
            f"Delete '{model}'? This cannot be undone.",
            QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No,
        ) != QtWidgets.QMessageBox.Yes:
            return
        threading.Thread(target=lambda: subprocess.run(["ollama", "delete", model], check=False), daemon=True).start()
        QtWidgets.QMessageBox.information(self, "Delete Started", f"Deleting {model} in background.")
        self._refresh_model_list()

    def _on_model_set_default(self) -> None:
        item = self.model_list.currentItem()
        if not item:
            return
        model = item.text()
        idx = self.model_combo.findText(model)
        if idx >= 0:
            self.model_combo.setCurrentIndex(idx)
        # persist selection to settings
        try:
            self.core.settings.default_model = model
            self.core.settings.save()
        except Exception:
            pass
            QtWidgets.QMessageBox.information(self, "Default Model", f"Set default model to {model}.")
        else:
            self.model_combo.addItem(model)
            self.model_combo.setCurrentText(model)

    # ────────────────────────── lock layout
    def _on_toggle_lock(self, locked: bool) -> None:
        feats_unlocked = (
            QtWidgets.QDockWidget.DockWidgetClosable
            | QtWidgets.QDockWidget.DockWidgetMovable
            | QtWidgets.QDockWidget.DockWidgetFloatable
        )
        feats_locked = QtWidgets.QDockWidget.DockWidgetClosable
        for dock in (
            self.controls_dock,
            self.persona_dock,
            self.chat_dock,
            getattr(self, "inner_dock", None),
            self.model_dock,
            self.plugins_dock,
        ):
            if dock is None:
                continue
            dock.setFeatures(feats_locked if locked else feats_unlocked)
        for dock in self._plugin_docks.values():
            dock.setFeatures(feats_locked if locked else feats_unlocked)

    # ────────────────────────── audio
    def start_recording(self) -> None:
        if sd is None or np is None:
            QtWidgets.QMessageBox.information(self, "Recording Unavailable", "sounddevice/numpy not installed.")
            return
        if not self.btn_record.isEnabled():
            return
        device_index = None
        try:
            idx = self.device_combo.currentIndex()
            selected_name = self.device_combo.currentText()
            for i, d in enumerate(sd.query_devices()):
                if d.get("name") == selected_name and d.get("max_input_channels", 0) > 0:
                    device_index = i
                    break
        except Exception:
            device_index = None
        self.core.audio_recorder.start(device_index)
        self.btn_record.setEnabled(False)
        self.btn_stop_rec.setEnabled(True)

    def stop_recording(self) -> None:
        if not self.btn_stop_rec.isEnabled():
            return
        self.core.audio_recorder.stop_and_transcribe()
        self.btn_stop_rec.setEnabled(False)
        self.btn_record.setEnabled(True)

    @QtCore.pyqtSlot(str)
    def _on_transcribed(self, text: str) -> None:
        if not text:
            return
        cur = self.input_edit.toPlainText()
        self.input_edit.setPlainText((cur + "\n" if cur else "") + text)

    # ────────────────────────── TTS
    def _on_play(self) -> None:
        text = self.response_edit.toPlainText().strip()
        if text and not self.chk_mute_tts.isChecked():
            try:
                self.core.tts_mgr.enqueue(text)
            except Exception:
                pass

    def _on_stop_tts(self) -> None:
        try:
            self.core.tts_mgr.stop()
        except Exception:
            pass

    def _on_replay(self) -> None:
        if not self.chk_mute_tts.isChecked():
            try:
                self.core.tts_mgr.replay()
            except Exception:
                pass

    def _on_voice_changed(self, name: str) -> None:
        try:
            eng = getattr(self.core.tts_mgr, "_engine", None)
            if eng:
                for v in eng.getProperty("voices"):
                    if v.name == name:
                        eng.setProperty("voice", v.id)
                        break
        except Exception:
            pass

    def _tts_voice_names(self) -> List[str]:
        try:
            eng = getattr(self.core.tts_mgr, "_engine", None)
            if not eng:
                return []
            return [v.name for v in eng.getProperty("voices")]
        except Exception:
            return []

    # ────────────────────────── feedback
    def _on_like(self) -> None:
        text = self.response_edit.toPlainText().strip()
        if not text:
            return
        try:
            self.core.add_feedback(text, liked=True)
        except Exception:
            pass
        QtWidgets.QMessageBox.information(self, "Feedback", "Marked as good response.")
        self._enable_feedback(False)
        self._update_feedback_counts()

    def _on_dislike(self) -> None:
        original = self.response_edit.toPlainText().strip()
        if not original:
            return
        try:
            self.core.tts_mgr.stop()
        except Exception:
            pass
        QtWidgets.QMessageBox.information(self, "Disliked", "The response will be rewritten.")
        self._enable_feedback(False)

        def worker() -> None:
            new_text = self._rewrite_response(original)
            try:
                self.core.add_feedback(original, liked=False, revised=new_text)
            except Exception:
                pass
            if self.chk_isolated.isChecked():
                self.isolated_history.append((self._current_persona(), new_text))
            else:
                if self.chk_semantic.isChecked():
                    self.core.conversation_db.save_message(self._current_persona().lower(), new_text)
            self.rewrite_ready.emit(new_text)

        threading.Thread(target=worker, daemon=True).start()

    @QtCore.pyqtSlot(str)
    def _apply_rewrite_result(self, new_text: str) -> None:
        schema = self.core.schema_mgr.load_schema(
            self._current_persona(), self.current_set.get(self._current_persona(), "default")
        )
        persona_name = schema.get("name", "Bot")
        role_key = self._current_persona().lower()
        self._append_message(persona_name, new_text, role_key=role_key)
        self.response_edit.setPlainText(new_text)
        if not self.chk_mute_tts.isChecked():
            try:
                self.core.tts_mgr.enqueue(new_text)
            except Exception:
                pass
        QtWidgets.QMessageBox.information(self, "Rewritten", "Response rewritten.")
        self._enable_feedback(False)

    def _update_feedback_counts(self) -> None:
        try:
            pos, neg = self.core.feedback_db.get_counts()
            self.lbl_feedback_counts.setText(f"Likes: {pos} | Dislikes: {neg}")
        except Exception:
            self.lbl_feedback_counts.setText("Likes: - | Dislikes: -")

    def _enable_feedback(self, enabled: bool) -> None:
        self.btn_like.setEnabled(enabled)
        self.btn_dislike.setEnabled(enabled)

    def _on_manage_feedback(self) -> None:
        db = self.core.feedback_db
        if db is None:
            QtWidgets.QMessageBox.information(self, "No DB", "Feedback DB unavailable.")
            return
        cur = db.conn.cursor()
        cur.execute("SELECT id, original, liked, COALESCE(revised, '') FROM feedback ORDER BY id DESC")
        entries = cur.fetchall()
        dlg = QtWidgets.QDialog(self)
        dlg.setWindowTitle("Manage Feedback")
        dlg.resize(720, 420)
        v = QtWidgets.QVBoxLayout(dlg)
        table = QtWidgets.QTableWidget(len(entries), 4)
        table.setHorizontalHeaderLabels(["ID", "Original", "Liked", "Revised"])
        table.horizontalHeader().setStretchLastSection(True)
        for r, (fid, orig, liked, rev) in enumerate(entries):
            table.setItem(r, 0, QtWidgets.QTableWidgetItem(str(fid)))
            table.setItem(r, 1, QtWidgets.QTableWidgetItem(orig))
            table.setItem(r, 2, QtWidgets.QTableWidgetItem("✔" if liked else "✖"))
            table.setItem(r, 3, QtWidgets.QTableWidgetItem(rev))
        v.addWidget(table, 1)
        h = QtWidgets.QHBoxLayout()
        btn_del = QtWidgets.QPushButton("Delete Selected")
        btn_close = QtWidgets.QPushButton("Close")
        h.addWidget(btn_del)
        h.addWidget(btn_close)
        h.addStretch()
        v.addLayout(h)

        def on_delete() -> None:
            selected = table.selectedItems()
            if not selected:
                return
            rows = sorted({i.row() for i in selected}, reverse=True)
            for rr in rows:
                fid_item = table.item(rr, 0)
                if fid_item:
                    try:
                        fid = int(fid_item.text())
                        db.conn.execute("DELETE FROM feedback WHERE id = ?", (fid,))
                        db.conn.commit()
                    except Exception:
                        pass
                table.removeRow(rr)
            self._update_feedback_counts()

        btn_del.clicked.connect(on_delete)
        btn_close.clicked.connect(dlg.accept)
        dlg.exec_()

    # ────────────────────────── datasets / rag
    def _on_manage_datasets(self) -> None:
        DatasetManagerDialog(self.core.dataset_mgr, self).exec_()

    def _on_clear_rag_cache(self) -> None:
        if QtWidgets.QMessageBox.question(
            self,
            "Clear RAG Cache",
            "Delete cached embeddings for all datasets and clear memory?",
            QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No,
        ) != QtWidgets.QMessageBox.Yes:
            return
        count = self.core.rag_cache.clear_disk()
        self.core.rag_cache.clear_memory()
        QtWidgets.QMessageBox.information(self, "Cleared", f"Cleared RAG cache files ({count} removed) and in-memory index.")

    # ────────────────────────── isolated / refresh / idle
    def _on_isolated_toggled(self, checked: bool) -> None:
        if checked:
            self.isolated_history.clear()
        else:
            if self.isolated_history:
                ans = QtWidgets.QMessageBox.question(
                    self,
                    "Merge Isolated Chat",
                    "Merge isolated conversation into main memory?",
                    QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No,
                )
                if ans == QtWidgets.QMessageBox.Yes:
                    for role, content in self.isolated_history:
                        self.core.conversation_db.save_message(role.lower(), content)
                self.isolated_history.clear()
        self._reset_idle_timer()

    def _on_refresh_chat(self) -> None:
        if self.chk_isolated.isChecked():
            self.isolated_history.clear()
        self.chat_view.clear()
        self.response_edit.clear()
        self._enable_feedback(False)
        try:
            if hasattr(self, "inner_text") and self.inner_text is not None:
                self.inner_text.clear()
        except Exception:
            pass

    def _reset_idle_timer(self) -> None:
        self._idle_timer.stop()
        if self.chk_semantic.isChecked():
            self._idle_timer.start(60000)

    def _handle_idle(self) -> None:
        pass

    # ────────────────────────── inner monologue
    def _on_inner_monologue(self) -> None:
        self._ensure_inner_dock()
        if self.inner_dock is None:
            return
        self.inner_dock.setVisible(not self.inner_dock.isVisible())

    def _ensure_inner_dock(self) -> None:
        if hasattr(self, "inner_dock") and self.inner_dock is not None:
            return
        dock = QtWidgets.QDockWidget("Inner Monologue", self)
        dock.setObjectName("InnerDock")
        dock.setAllowedAreas(QtCore.Qt.RightDockWidgetArea | QtCore.Qt.LeftDockWidgetArea)
        inner = QtWidgets.QWidget()
        v = QtWidgets.QVBoxLayout(inner)
        self.inner_text = QtWidgets.QPlainTextEdit()
        self.inner_text.setReadOnly(True)
        v.addWidget(self.inner_text, 1)
        h = QtWidgets.QHBoxLayout()
        h.addWidget(QtWidgets.QLabel("Interval (s):"))
        self.spin_interval = QtWidgets.QSpinBox()
        self.spin_interval.setRange(1, 60)
        self.spin_interval.setValue(15)
        h.addWidget(self.spin_interval)
        self.chk_monologue_tts = QtWidgets.QCheckBox("Speak")
        self.chk_monologue_tts.setChecked(self.core.settings.monologue_tts_enabled)
        h.addWidget(self.chk_monologue_tts)
        h.addWidget(QtWidgets.QLabel("Volume:"))
        self.slider_monologue_vol = QtWidgets.QSlider(QtCore.Qt.Horizontal)
        self.slider_monologue_vol.setRange(0, 100)
        self.slider_monologue_vol.setValue(self.core.settings.monologue_volume)
        h.addWidget(self.slider_monologue_vol)
        btn_start_stop = QtWidgets.QPushButton("Start/Stop")
        h.addWidget(btn_start_stop)
        v.addLayout(h)
        inner.setLayout(v)
        dock.setWidget(inner)
        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, dock)
        self.inner_dock = dock
        self.inner_timer = QtCore.QTimer(self)
        self.inner_timer.setSingleShot(False)
        btn_start_stop.clicked.connect(self._toggle_inner_timer)
        dock.setTitleBarWidget(DockTitleBar(dock, "Inner Monologue"))
        self.dock_tray.register_dock(self.inner_dock)
        self.chk_monologue_tts.stateChanged.connect(lambda _: self._update_monologue_settings())
        self.slider_monologue_vol.valueChanged.connect(lambda _: self._update_monologue_settings())

    def _toggle_inner_timer(self) -> None:
        if self.inner_timer is None:
            return
        if self.inner_timer.isActive():
            self.inner_timer.stop()
        else:
            interval_ms = self.spin_interval.value() * 1000
            try:
                self.inner_timer.timeout.disconnect()
            except Exception:
                pass
            self.inner_timer.timeout.connect(self._generate_inner_monologue)
            self.inner_timer.start(interval_ms)

    def _update_monologue_settings(self) -> None:
        try:
            self.core.settings.monologue_tts_enabled = self.chk_monologue_tts.isChecked() if hasattr(self, 'chk_monologue_tts') else False
            self.core.settings.monologue_volume = self.slider_monologue_vol.value() if hasattr(self, 'slider_monologue_vol') else 50
            self.core.settings.save()
        except Exception:
            pass

    def _generate_inner_monologue(self) -> None:
        schema = self.core.schema_mgr.load_schema(self._current_persona(), self.current_set.get(self._current_persona(), "default"))
        overlay = schema.get("dynamic_overlay", {}) or {}
        mood = overlay.get("temporary_emotional_state", "neutral")
        likes = overlay.get("recent_topics", [])
        pos = [0, 0]
        fav_topic = likes[-1] if likes else None
        thought = f"I'm thinking about {fav_topic} while feeling {mood}." if fav_topic else f"I'm in a {mood} mood and reflecting."
        thought += f" I'm at position {pos}."
        try:
            if hasattr(self, "inner_text") and self.inner_text is not None:
                self.inner_text.appendPlainText(thought)
        except Exception:
            pass

    # ────────────────────────── conversation
    def _append_message(self, display_name: str, text: str, role_key: Optional[str] = None) -> None:
        key = (role_key or display_name).lower()
        bg_colour = ROLE_COLOURS.get(key, "#EEEEEE")
        name_colour = NAME_COLOURS.get(key, "#011627")
        safe_role = QtGui.QGuiApplication.translate("Chat", display_name)
        safe_text = QtGui.QGuiApplication.translate("Chat", text)
        frag = (
            f'<div style="background-color:{bg_colour}; border-radius:4px; padding:4px; margin:4px;">'
            f'<b style="color:{name_colour};">{safe_role}:</b> {safe_text}'
            f'</div>'
        )
        self.chat_view.append(frag)

    def _current_history(self) -> List[Tuple[str, str]]:
        if self.chk_isolated.isChecked():
            return self.isolated_history
        else:
            return self.core.conversation_db.fetch_history(limit=10)

    def _bootstrap_conversation(self) -> None:
        if self.core and len(self.core.conversation_db.fetch_history(limit=1)) == 0:
            schema = self.core.schema_mgr.load_schema(self.active_persona, self.current_set.get(self.active_persona, "default"))
            questions = schema.get("questions", [])
            if questions:
                first_question = questions[0]
                self._append_message("System", first_question, role_key="system")
                if self.chk_semantic.isChecked() and not self.chk_isolated.isChecked():
                    self.core.conversation_db.save_message("system", first_question)

    # ────────────────────────── prompt & rag
    def _build_prompt(self, schema: Dict[str, object], user_text: str, is_self_talk: bool = False) -> str:
        parts: List[str] = []
        name = schema.get("name", "")
        role = schema.get("role", "")
        desc = schema.get("description", "")
        persona_desc = f"You are {name}, {desc}".strip()
        if role:
            persona_desc += f" Your role is {role}."

        overlay = schema.get("dynamic_overlay", {})
        if overlay:
            temp_rel = overlay.get("temporary_relationship_context", "")
            temp_emotion = overlay.get("temporary_emotional_state", "")
            added_traits = overlay.get("added_traits", [])
            if temp_rel:
                persona_desc += f" ({temp_rel})"
            if temp_emotion:
                persona_desc += f" You feel {temp_emotion}."
            if added_traits:
                persona_desc += f" Traits: {', '.join(str(t) for t in added_traits)}."
        parts.append(persona_desc)

        # User description
        try:
            user_schema = self.core.schema_mgr.load_schema("user", self.current_set.get("user", "default"))
        except Exception:
            user_schema = {}
        if user_schema:
            u_name = user_schema.get("name", "User")
            u_personality = user_schema.get("personality", "")
            relationship = user_schema.get("relationship_to_zira", "friend")
            u_overlay = user_schema.get("dynamic_overlay", {})
            temp_rel2 = u_overlay.get("temporary_relationship_context") if u_overlay else None
            if temp_rel2 and str(temp_rel2).strip():
                relationship = str(temp_rel2)
            user_desc = f"User is {u_name}, {u_personality}. Relationship: {relationship}."
            parts.append(user_desc)

        # History
        history_text = ""
        if self.chk_semantic.isChecked():
            history = self._current_history()[-10:]
            for role_name, content in history:
                speaker = "User" if role_name.lower() == "user" else role_name.title()
                history_text += f"{speaker}: {content}\n"
        if history_text:
            parts.append("Conversation history:\n" + history_text.strip())

        # RAG (only datasets listed by this set)
        dataset_text = ""
        ds_names: List[str] = list(schema.get("datasets") or [])
        try:
            # Prefer core search with filters if supported
            hits = self.core.rag_search(
                user_text,
                per_ds_k=3,
                limit=5,
                include_shared=False,
                datasets=ds_names if ds_names else None,
            )
            for chunk, score, ds_name, owner in hits:
                dataset_text += f"Dataset ({owner}/{ds_name}):\n{chunk}\n\n"
        except TypeError:
            # Older core: no dataset filter; fallback to manual selection
            from_texts: List[Tuple[str, str]] = []
            try:
                for name, entry in self.core.dataset_mgr.entries.items():
                    if ds_names and name not in ds_names:
                        continue
                    if not entry.active:
                        continue
                    full_text = self.core.dataset_mgr.load_dataset_text(entry)
                    if full_text:
                        from_texts.append((name, full_text))
            except Exception:
                pass
            for name, full_text in from_texts:
                snip = self._retrieve_dataset_snippet(full_text, user_text)
                if snip:
                    dataset_text += f"Dataset ({name}):\n{snip}\n\n"
        except Exception:
            pass
        if dataset_text:
            parts.append(dataset_text.strip())

        # Self-talk (optional)
        if is_self_talk and self.self_talk_enabled:
            st_prompts = schema.get("self_talk", [])
            if st_prompts:
                import random
                parts.append(random.choice(st_prompts))

        parts.append(f"User: {user_text}")
        return "\n\n".join([p for p in parts if p])

    def _retrieve_dataset_snippet(self, full_text: str, user_text: str) -> str:
        try:
            tokens = [w.lower() for w in re.findall(r"\b\w+\b", user_text) if len(w) > 2]
            paragraphs = [p.strip() for p in full_text.split("\n") if p.strip()]
            scored: List[Tuple[int, str]] = []
            for para in paragraphs:
                l = para.lower()
                score = sum(1 for t in tokens if t in l)
                if score > 0:
                    scored.append((score, para))
            if not scored:
                return paragraphs[0][:500] if paragraphs else full_text[:500]
            scored.sort(key=lambda x: -x[0])
            top = [p for _, p in scored[:2]]
            return "\n".join(top)[:500]
        except Exception:
            return full_text[:500]

    # ────────────────────────── send / model
    def send_message(self) -> None:
        user_text = self.input_edit.toPlainText().strip()
        if not user_text:
            return

        # Broadcast to plugins
        try:
            self.core.plugins.broadcast(user_text)
        except Exception:
            pass

        # Slash commands → ensure applied to current persona+set
        if user_text.startswith("/"):
            self.input_edit.clear()
            persona = self._current_persona()
            set_name = self.current_set.get(persona, "default")
            try:
                out = self.core.run_command(user_text, persona=persona, set_name=set_name)
            except TypeError:
                out = self.core.run_command(user_text)
            self._append_message("System", out, role_key="system")
            if self.chk_semantic.isChecked() and not self.chk_isolated.isChecked():
                self.core.conversation_db.save_message("system", out)
            return

        # Normal message
        self.input_edit.clear()
        persona = self._current_persona()
        set_name = self.current_set.get(persona, "default")
        schema = self.core.schema_mgr.load_schema(persona, set_name)

        if self.chk_isolated.isChecked():
            self.isolated_history.append(("user", user_text))
        else:
            if self.chk_semantic.isChecked():
                self.core.conversation_db.save_message("user", user_text)

        try:
            user_schema = self.core.schema_mgr.load_schema("user", self.current_set.get("user", "default"))
            user_display = user_schema.get("name", "User")
        except Exception:
            user_display = "User"
        self._append_message(user_display, user_text, role_key="user")

        prompt = self._build_prompt(schema, user_text)
        model_slug = self.model_combo.currentText().strip() or self.core.settings.default_model

        self.btn_send.setEnabled(False)

        # ✅ Create ModelWorker and wire it up properly
        self.model_worker = ModelWorker(model_slug, prompt, parent=self.core)
        self.model_worker.resultReady.connect(lambda resp, usr=user_text, sch=schema: self._on_model_response(resp, usr, sch))
        self.model_worker.errorOccurred.connect(self._on_model_error)
        self.model_worker.finished.connect(lambda: self.btn_send.setEnabled(True))
        self.model_worker.start()


    def _on_model_response(self, response_raw: str, user_text: str, schema: Dict[str, object]) -> None:
        model_slug = self.model_combo.currentText().strip()
        response = self._strip_reasoning(model_slug, response_raw)
        response, style_score = self._style_and_guard(response, schema)
        self.style_label.setText(f"Style: {style_score:.2f}")

        if self.chk_isolated.isChecked():
            self.isolated_history.append((schema.get("name", "bot"), response))
        else:
            if self.chk_semantic.isChecked():
                self.core.conversation_db.save_message(schema.get("name", "bot").lower(), response)

        persona_name = schema.get("name", "Bot") or "Bot"
        role_key = self._current_persona().lower()
        self._append_message(persona_name, response, role_key=role_key)
        self.response_edit.setPlainText(response)

        if not self.chk_mute_tts.isChecked():
            try:
                self.core.tts_mgr.enqueue(response)
            except Exception:
                pass

        self._enable_feedback(True)
        self._reset_idle_timer()

        try:
            tokens = [w.lower() for w in re.findall(r"\b\w+\b", user_text) if len(w) > 3]
            for t in tokens:
                self.update_overlay_topic(self._current_persona(), t)
            self.update_overlay_emotion(self._current_persona(), "neutral")
        except Exception:
            pass

        try:
            for line in response.split("\n"):
                if line.strip():
                    self.core.plugins.broadcast(line.strip())
        except Exception as e:
            print(f"Error broadcasting to plugins: {e}")

        if self.core.settings.auto_schema_enabled:
            self.progress_bar.setVisible(True)

            class EvolverWorker(QRunnable):
                def __init__(self, evolver, persona, set_name, history, window):
                    super().__init__()
                    self.evolver = evolver
                    self.persona = persona
                    self.set_name = set_name
                    self.history = history
                    self.window = window

                def run(self):
                    changed = self.evolver.update_schema(self.persona, self.set_name, self.history)
                    QtCore.QMetaObject.invokeMethod(
                        self.window, "_post_evolver", QtCore.Qt.QueuedConnection, QtCore.Q_ARG(bool, changed)
                    )

            QThreadPool.globalInstance().start(
                EvolverWorker(self.core.schema_evolver, self.active_persona, self.current_set.get(self.active_persona, "default"), self._current_history(), self)
            )

    @QtCore.pyqtSlot(bool)
    def _post_evolver(self, changed: bool) -> None:
        self.progress_bar.setVisible(False)
        if changed:
            self._flash_status("Schema adapted")

    def _strip_reasoning(self, model: str, response: str) -> str:
        if model and "deepseek" in model.lower():
            if "<think>" in response and "</think>" in response:
                try:
                    return response.split("</think>")[-1].strip() or response
                except Exception:
                    return response
        return response

    def _style_and_guard(self, text: str, schema: Dict[str, object]) -> Tuple[str, float]:
        exclam = text.count("!")
        sentences = [s for s in re.split(r"[.!?]", text) if s.strip()]
        avg_len = sum(len(s.split()) for s in sentences) / max(1, len(sentences))
        exclam_density = exclam / max(1, len(text))
        tone = schema.get("tone_rules", {"conciseness": [0.6, 0.8], "exclam_limit": 0.05})
        conciseness = max(0.0, min(1.0, (22 - avg_len) / 16.0))
        ex_ok = 1.0 if exclam_density <= float(tone.get("exclam_limit", 0.05)) else 0.5
        score = max(0.0, min(1.0, 0.5 * conciseness + 0.5 * ex_ok))
        return text, score

    def _rewrite_response(self, original: str) -> str:
        try:
            liked = self.core.feedback_db.get_liked_responses(limit=5)
        except Exception:
            liked = []
        schema = self.core.schema_mgr.load_schema(self._current_persona(), self.current_set.get(self._current_persona(), "default"))
        rps = schema.get("rewrite_prompts", [])
        template = rps[0] if rps else "Rewrite to be more appealing. Keep it accurate, concise, and on style."
        parts = [template]
        if liked:
            parts.append("Preferred responses:\n" + "\n\n".join(liked))
        parts.append("Original:\n" + original)
        parts.append("Rewritten:")
        prompt = "\n\n".join(parts)
        return self._run_model(self.model_combo.currentText().strip() or self.core.settings.default_model, prompt) or original

    def _run_model(self, model: str, prompt: str) -> str:
        try:
            proc = subprocess.run(
                ["ollama", "run", model],
                input=prompt.encode("utf-8"),
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                check=True,
            )
            return proc.stdout.decode("utf-8", errors="replace").strip()
        except subprocess.CalledProcessError as e:
            return e.stderr.decode("utf-8", errors="replace").strip()
        except FileNotFoundError:
            return "(error) ollama executable not found."
        except Exception as e:
            return f"(error) {e}"

    # ────────────────────────── persona / sets
    def _populate_set_combo(self, persona: str, combo: QtWidgets.QComboBox) -> None:
        combo.blockSignals(True)
        combo.clear()
        for s in self.core.schema_mgr.get_set_list(persona):
            combo.addItem(s)
        current = self.current_set.get(persona, "default")
        idx = combo.findText(current)
        combo.setCurrentIndex(idx if idx >= 0 else combo.findText("default"))
        if idx < 0:
            self.current_set[persona] = combo.currentText()
        combo.blockSignals(False)

    def _on_set_changed(self, persona: str, name: str, combo: QtWidgets.QComboBox) -> None:
        if not name:
            return
        self.current_set[persona] = name
        # keep AgentCore pointed to the right set if this persona is active
        if persona == self._current_persona():
            self.core.persona = persona
            self.core.set_name = name

        # refresh editor + commands row for this tab
        tab = self.tab_widgets.get(persona)
        if tab:
            editor = tab.findChild(QtWidgets.QPlainTextEdit, f"schema_edit_{persona}")
            if editor:
                schema = self.core.schema_mgr.load_schema(persona, name)
                editor.setPlainText(json.dumps(schema, indent=2))
            cmd_combo = tab.findChild(QtWidgets.QComboBox, f"cmd_combo_{persona}")
            if cmd_combo:
                self._populate_command_combo(persona, cmd_combo)

        # persist active sets & update controls tied to schema flags
        self.core.schema_mgr.save_active_schemas(self.current_set)
        self._sync_semantic_checkbox_from_schema()
        self._update_feedback_counts()

        # refresh slash command list if this persona is active
        try:
            if persona == self._current_persona():
                self._populate_command_select()
        except Exception:
            pass

    def _on_clone_set(self, persona: str, combo: QtWidgets.QComboBox) -> None:
        src = combo.currentText()
        name, ok = QtWidgets.QInputDialog.getText(self, "Clone Set", "Enter new set name:")
        if not ok or not name.strip():
            return
        new_name = name.strip()
        try:
            schema = self.core.schema_mgr.load_schema(persona, src)
            # Preserve the persona's canonical name; set label is separate
            schema["name"] = persona.capitalize()
            self.core.schema_mgr.save_schema(persona, new_name, schema)
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "Error", str(e))
            return
        self.current_set[persona] = new_name
        self._populate_set_combo(persona, combo)
        combo.setCurrentText(new_name)
        if persona == self._current_persona():
            self.core.set_name = new_name
        self.core.schema_mgr.save_active_schemas(self.current_set)
        self._sync_semantic_checkbox_from_schema()
        self._update_feedback_counts()

    def _on_new_set(self, persona: str, combo: QtWidgets.QComboBox) -> None:
        src = combo.currentText()
        name, ok = QtWidgets.QInputDialog.getText(self, "New Set", "Enter name for new set:")
        if not ok or not name.strip():
            return
        new_name = name.strip()
        try:
            schema = self.core.schema_mgr.load_schema(persona, src)
            # Preserve the persona's canonical name; set label is separate
            schema["name"] = persona.capitalize()
            self.core.schema_mgr.save_schema(persona, new_name, schema)
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "Error", str(e))
            return
        self.current_set[persona] = new_name
        self._populate_set_combo(persona, combo)
        combo.setCurrentText(new_name)
        if persona == self._current_persona():
            self.core.set_name = new_name
        self.core.schema_mgr.save_active_schemas(self.current_set)
        self._sync_semantic_checkbox_from_schema()
        self._update_feedback_counts()

    def _on_delete_set(self, persona: str, combo: QtWidgets.QComboBox) -> None:
        name = combo.currentText()
        if name == "default":
            QtWidgets.QMessageBox.information(self, "Cannot Delete", "The default set cannot be deleted.")
            return
        if QtWidgets.QMessageBox.question(
            self, "Delete Set", f"Delete '{name}' (irreversible)?", QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No
        ) != QtWidgets.QMessageBox.Yes:
            return
        try:
            set_dir = os.path.join(self.core.schema_mgr.schemas_dir, persona.lower(), "sets", name)
            import shutil
            shutil.rmtree(set_dir, ignore_errors=True)
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "Error", str(e))
            return
        self.current_set[persona] = "default"
        self._populate_set_combo(persona, combo)
        combo.setCurrentText("default")
        if persona == self._current_persona():
            self.core.set_name = "default"
        self.core.schema_mgr.save_active_schemas(self.current_set)
        self._sync_semantic_checkbox_from_schema()
        self._update_feedback_counts()

    def _on_save_schema(self, persona: str) -> None:
        tab = self.tab_widgets.get(persona)
        if not tab:
            return
        editor = tab.findChild(QtWidgets.QPlainTextEdit, f"schema_edit_{persona}")
        if not editor:
            return
        text = editor.toPlainText().strip()
        try:
            schema = json.loads(text)
            if not isinstance(schema, dict):
                raise ValueError
        except Exception:
            QtWidgets.QMessageBox.warning(self, "Invalid JSON", "The schema is not valid JSON.")
            return
        set_name = self.current_set.get(persona, "default")
        existing_schema = self.core.schema_mgr.load_schema(persona, set_name)
        merged_schema = {**existing_schema, **schema}
        # Ensure the top-level name matches the active set name
        try:
            merged_schema["name"] = set_name
        except Exception:
            pass
        self.core.schema_mgr.save_schema(persona, set_name, merged_schema)
        QtWidgets.QMessageBox.information(self, "Saved", f"Schema saved for {persona} ({set_name}).")

        if persona == self._current_persona():
            persona_voice = (merged_schema.get("voice") or "").lower()
            for i in range(self.voice_combo.count()):
                if persona_voice and persona_voice in self.voice_combo.itemText(i).lower():
                    self.voice_combo.setCurrentIndex(i)
                    break
        # After save, refresh commands combo (in case user edited commands JSON directly)
        tab = self.tab_widgets.get(persona)
        if tab:
            cmd_combo = tab.findChild(QtWidgets.QComboBox, f"cmd_combo_{persona}")
            if cmd_combo:
                self._populate_command_combo(persona, cmd_combo)

    # ------------------------------------------------------------------
    # Command editing helpers (ported from the original agent_ui.py)
    #
    # The persona editing tab includes a commands row allowing users to
    # append new payloads to existing slash commands or create entirely
    # new commands.  These helpers implement the behaviour that used to
    # live in agent_ui.py.  They are invoked by PersonaTab via
    # ``self.app._on_add_to_command`` and ``self.app._on_new_command``.
    def _on_add_to_command(self, persona: str, combo: QtWidgets.QComboBox,
                            edit: QtWidgets.QLineEdit) -> None:
        """
        Append the text from ``edit`` to the selected command in the
        current schema.  If no command is selected or no text is
        provided, the user is notified.  After updating the schema,
        the command editor and schema editor are refreshed.

        Parameters
        ----------
        persona : str
            The persona whose schema is being modified.
        combo : QtWidgets.QComboBox
            The combo box listing existing slash commands.
        edit : QtWidgets.QLineEdit
            The line edit containing the payload to add to the command.
        """
        text = edit.text().strip()
        if not text:
            QtWidgets.QMessageBox.information(self, "No Text", "Enter text/payload to add.")
            return
        set_name = self.current_set.get(persona, "default")
        schema = self.core.schema_mgr.load_schema(persona, set_name)
        cmds = dict(schema.get("commands") or {})
        sel = combo.currentText().strip()
        if not sel or sel == "(no commands)":
            QtWidgets.QMessageBox.information(self, "No Command", "Create a command first.")
            return
        lst = list(cmds.get(sel) or [])
        lst.append(text)
        cmds[sel] = lst
        schema["commands"] = cmds
        self.core.schema_mgr.save_schema(persona, set_name, schema)
        edit.clear()
        # Refresh editors & notify the user
        self._refresh_schema_editor(persona)
        QtWidgets.QMessageBox.information(self, "Added", f'Added to {sel}: "{text}"')

    def _on_new_command(self, persona: str) -> None:
        """
        Prompt the user for a new command name, insert it into the
        schema if it does not already exist, and refresh the UI.  The
        new command is prefaced with a leading slash if not provided.

        Parameters
        ----------
        persona : str
            The persona whose schema is being modified.
        """
        name, ok = QtWidgets.QInputDialog.getText(self, "New Command", "Enter new command (e.g., /remember):")
        if not ok or not name.strip():
            return
        cmd_name = name.strip()
        if not cmd_name.startswith("/"):
            cmd_name = "/" + cmd_name
        set_name = self.current_set.get(persona, "default")
        schema = self.core.schema_mgr.load_schema(persona, set_name)
        cmds = dict(schema.get("commands") or {})
        if cmd_name in cmds:
            QtWidgets.QMessageBox.information(self, "Exists", f"Command {cmd_name} already exists.")
            return
        cmds[cmd_name] = []
        schema["commands"] = cmds
        self.core.schema_mgr.save_schema(persona, set_name, schema)
        # Refresh command combo + schema editor
        tab = self.tab_widgets.get(persona)
        if tab:
            combo = tab.findChild(QtWidgets.QComboBox, f"cmd_combo_{persona}")
            if combo:
                self._populate_command_combo(persona, combo)
                combo.setCurrentText(cmd_name)
            edit = tab.findChild(QtWidgets.QLineEdit, f"cmd_edit_{persona}")
            if edit:
                edit.clear()
        self._refresh_schema_editor(persona)
        QtWidgets.QMessageBox.information(self, "Created", f"New command {cmd_name} created.")

    def _refresh_schema_editor(self, persona: str) -> None:
        """
        Reload the JSON schema for ``persona`` from disk and update the
        corresponding schema editor in the UI.  This helper is used
        after schema modifications to ensure the text reflects the
        authoritative state on disk.  Signals are blocked during the
        update to avoid triggering autosave timers unnecessarily.

        Parameters
        ----------
        persona : str
            The persona whose schema editor should be refreshed.
        """
        tab = self.tab_widgets.get(persona)
        if not tab:
            return
        editor = tab.findChild(QtWidgets.QPlainTextEdit, f"schema_edit_{persona}")
        if editor:
            schema = self.core.schema_mgr.load_schema(persona, self.current_set.get(persona, "default"))
            editor.blockSignals(True)
            editor.setPlainText(json.dumps(schema, indent=2))
            editor.blockSignals(False)

    def _tab_changed(self, index: int) -> None:
        if 0 <= index < len(self.core.schema_mgr.personas):
            self.active_persona = self.core.schema_mgr.personas[index]
        else:
            self.active_persona = self.core.schema_mgr.personas[0] if self.core.schema_mgr.personas else "zira"
        self.core.persona = self.active_persona

        schema = self.core.schema_mgr.load_schema(self.active_persona, self.current_set.get(self.active_persona, "default"))
        persona_voice = (schema.get("voice") or "").lower()
        for i in range(self.voice_combo.count()):
            if persona_voice and persona_voice in self.voice_combo.itemText(i).lower():
                self.voice_combo.setCurrentIndex(i)
                break

        tab = self.tab_widgets.get(self.active_persona)
        if tab:
            editor = tab.findChild(QtWidgets.QPlainTextEdit, f"schema_edit_{self.active_persona}")
            if editor:
                editor.setPlainText(json.dumps(schema, indent=2))
            cmd_combo = tab.findChild(QtWidgets.QComboBox, f"cmd_combo_{self.active_persona}")
            if cmd_combo:
                self._populate_command_combo(self.active_persona, cmd_combo)

        try:
            user_schema = self.core.schema_mgr.load_schema("user", self.current_set.get("user", "default"))
            bot_name = schema.get("name", self.active_persona.title())
            bot_set = self.current_set.get(self.active_persona, "default")
            user_name = user_schema.get("name", "User")
            user_set = self.current_set.get("user", "default")
            self.lbl_active_names.setText(f"{bot_name}: {bot_set} — User: {user_name}: {user_set}")
        except Exception:
            pass

        self._sync_semantic_checkbox_from_schema()
        self._update_feedback_counts()

        # refresh slash command dropdown on persona change
        try:
            self._populate_command_select()
        except Exception:
            pass

    def _current_persona(self) -> str:
        return self.active_persona

    # ────────────────────────── overlay helpers
    def update_overlay_topic(self, persona: str, topic: str) -> None:
        persona = persona.lower()
        try:
            schema = self.core.schema_mgr.load_schema(persona, self.current_set.get(persona, "default"))
            overlay = dict(schema.get("dynamic_overlay", {}))
            topics = list(overlay.get("recent_topics", []))
            if topic and topic not in topics:
                topics.append(topic)
                if len(topics) > 10:
                    topics = topics[-10:]
                overlay["recent_topics"] = topics
                schema["dynamic_overlay"] = overlay
                self.core.schema_mgr.save_schema(persona, self.current_set.get(persona, "default"), schema)
        except Exception:
            pass

    def update_overlay_emotion(self, persona: str, emotion: str) -> None:
        persona = persona.lower()
        try:
            schema = self.core.schema_mgr.load_schema(persona, self.current_set.get(persona, "default"))
            overlay = dict(schema.get("dynamic_overlay", {}))
            overlay["temporary_emotional_state"] = emotion
            schema["dynamic_overlay"] = overlay
            self.core.schema_mgr.save_schema(persona, self.current_set.get(persona, "default"), schema)
        except Exception:
            pass

    # ────────────────────────── devices & models
    def _populate_devices(self) -> None:
        # In this refactor the devices are populated by CommandsPanel
        self.commands_panel._populate_devices()

    def _populate_models(self) -> None:
        # In this refactor the models are populated by CommandsPanel
        self.commands_panel._populate_models()

    # ────────────────────────── slash commands panel
    def _build_command_dock(self) -> None:
        """
        Build a dockable panel that exposes slash commands with an argument
        entry and send button. This allows users to trigger any command
        without typing it into the chat manually. It will be updated when
        persona or set changes.
        """
        dock = QtWidgets.QDockWidget("Slash Commands", self)
        dock.setObjectName("SlashCommandsDock")
        dock.setFeatures(
            QtWidgets.QDockWidget.DockWidgetClosable
            | QtWidgets.QDockWidget.DockWidgetMovable
            | QtWidgets.QDockWidget.DockWidgetFloatable
        )
        container = QtWidgets.QWidget()
        layout = QtWidgets.QVBoxLayout(container)
        layout.setContentsMargins(7, 7, 7, 7)
        layout.setSpacing(5)

        # command selector
        cmd_label = QtWidgets.QLabel("Slash Command:")
        self.command_select = QtWidgets.QComboBox()
        layout.addWidget(cmd_label)
        layout.addWidget(self.command_select)

        # argument input
        self.command_input = QtWidgets.QLineEdit()
        self.command_input.setPlaceholderText("Enter arguments or select text from chat…")
        layout.addWidget(self.command_input)

        # send button
        btn_run = QtWidgets.QPushButton("Run Command")
        btn_run.clicked.connect(self._on_run_command)
        layout.addWidget(btn_run)
        layout.addStretch(1)

        dock.setWidget(container)
        # add to right side by default
        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, dock)
        self.command_dock = dock

    def _populate_command_select(self) -> None:
        """
        Populate the slash command dropdown with available commands from
        the command registry. This is called whenever the active persona
        or set changes to reflect dynamic additions.
        """
        try:
            cmds = []
            if hasattr(self.core, "command_registry") and self.core.command_registry:
                cmds = list(self.core.command_registry.list_commands())
            # if schema defines additional commands, include them
            persona = self._current_persona()
            set_name = self.current_set.get(persona, "default")
            schema = self.core.schema_mgr.load_schema(persona, set_name)
            schema_cmds = list((schema.get("commands") or {}).keys())
            for c in schema_cmds:
                if c not in cmds:
                    cmds.append(c)
            cmds.sort()
        except Exception:
            cmds = []
        self.command_select.blockSignals(True)
        self.command_select.clear()
        if cmds:
            self.command_select.addItems(cmds)
        self.command_select.blockSignals(False)

    def _on_run_command(self) -> None:
        """
        Handler for running the selected slash command with the provided
        argument. The command will be executed via AgentCore and the
        result appended to the chat window. Selection text from the chat
        can be inserted into the argument field via context menu.
        """
        cmd = (self.command_select.currentText() or "").strip()
        if not cmd:
            QtWidgets.QMessageBox.information(self, "No Command", "Select a slash command to run.")
            return
        arg = self.command_input.text().strip()
        # combine command and arguments
        full = cmd if not arg else f"{cmd} {arg}"
        try:
            # process via core; record conversation
            resp = self.core.process_user_message(full, tts=False)
            # append user command and agent response to chat
            self._append_message("user", full, role_key="user")
            self._append_message("zira", resp, role_key="zira")
            # clear argument
            self.command_input.clear()
            # update feedback counts and idle timer
            self._update_feedback_counts()
            self._reset_idle_timer()
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "Command Error", str(e))

    def _show_chat_context_menu(self, pos: QtCore.QPoint) -> None:
        """
        Custom context menu for the chat view. Adds a menu entry to send
        selected text into the slash command argument field.
        """
        menu = self.chat_view.createStandardContextMenu()
        try:
            cursor = self.chat_view.textCursor()
            if cursor and cursor.hasSelection():
                action = menu.addAction("Send selection to command input")
                action.triggered.connect(self._send_selection_to_command_input)
        except Exception:
            pass
        menu.exec_(self.chat_view.mapToGlobal(pos))

    def _send_selection_to_command_input(self) -> None:
        """
        Copy the currently selected text in the chat view into the command
        input field for slash command execution.
        """
        try:
            cursor = self.chat_view.textCursor()
            if cursor and cursor.hasSelection():
                text = cursor.selectedText()
                self.command_input.setText(text.strip())
        except Exception:
            pass

    def _on_model_changed(self, name: str) -> None:
        """
        Update the default model in settings when the user selects a new
        model from the dropdown. This ensures the AgentCore uses the
        selected model for subsequent interactions.
        """
        try:
            if not name:
                return
            self.core.settings.default_model = name
            self.core.settings.save()
        except Exception:
            pass

    def _on_show_model_manager(self) -> None:
        """
        Show (or raise) the model manager dock. If the dock was
        previously hidden, it will be shown; if it is already visible,
        this will bring it to the front. A dock must be built in
        ``_build_model_manager()`` prior to showing.
        """
        try:
            if self.model_dock.isVisible():
                # already visible: raise to top
                self.model_dock.raise_()
            else:
                self.model_dock.show()
                self.model_dock.raise_()
        except Exception:
            pass
            
            
    def _on_model_error(self, error: str) -> None:
        """Handles errors from ModelWorker threads."""
        print(f"[ERROR] ModelWorker failed:\n{error}")

        # Show in chat window
        self._append_message("System", f"❌ Model error:\n{error}", role_key="system")

        # Optionally log or alert
        try:
            self.core.logger.error(f"ModelWorker Error: {error}")
        except Exception:
            pass

        # Re-enable send button in case it wasn't via .finished
        self.btn_send.setEnabled(True)
            

    # ────────────────────────── settings toggles
    def _on_auto_schema_toggled(self, checked: bool) -> None:
        try:
            self.core.settings.auto_schema_enabled = bool(checked)
            self.core.settings.save()
        except Exception:
            pass
        self.statusBar().showMessage(f"Auto Schema Evolution {'enabled' if checked else 'disabled'}", 2500)

    def _on_google_stt_toggled(self, checked: bool) -> None:
        """
        Opt-in/out of using Google Cloud Speech-to-Text. When enabling the
        toggle for the first time in a session, show a warning that
        recordings will be sent to Google’s servers under their privacy
        policy. If declined, the checkbox will be turned off again.
        """
        # Only show the dialog when transitioning from unchecked → checked
        try:
            current = bool(getattr(self.core.settings, "use_google_stt", False))
        except Exception:
            current = False
        if checked and not current:
            ok = QtWidgets.QMessageBox.question(
                self,
                "Enable Google STT?",
                "Audio will be uploaded to Google Cloud for transcription\n"
                "under Google's privacy policy. Continue?",
                QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No,
            )
            if ok != QtWidgets.QMessageBox.Yes:
                # revert checkbox silently
                self.chk_google_stt.blockSignals(True)
                self.chk_google_stt.setChecked(False)
                self.chk_google_stt.blockSignals(False)
                return
        # persist the new state
        try:
            self.core.settings.use_google_stt = bool(checked)
            self.core.settings.save()
        except Exception:
            pass

    # ────────────────────────── spell suggestions
    def _show_input_context_menu(self, pos: QtCore.QPoint) -> None:
        """
        Custom context menu on the input field that offers spelling
        suggestions when the user right-clicks a misspelled word. Only
        appears if pyspellchecker is available.
        """
        menu = self.input_edit.createStandardContextMenu()
        # compute suggestions only if SpellChecker is available
        if SpellChecker:
            cursor = self.input_edit.cursorForPosition(pos)
            # select the word under cursor
            cursor.select(QtGui.QTextCursor.WordUnderCursor)
            word = cursor.selectedText()
            if word and len(word) >= 3:
                sc = SpellChecker()
                suggestions = list(sc.candidates(word.lower()))
                # sort by Levenshtein distance and frequency; keep top 5
                suggestions = sorted(suggestions, key=lambda w: sc.word_probability(w), reverse=True)[:5]
                if suggestions and suggestions != [word.lower()]:
                    suggest_menu = menu.addMenu("Spelling suggestions")
                    for s in suggestions:
                        act = suggest_menu.addAction(s)
                        act.triggered.connect(lambda chk=False, repl=s, c=cursor: self._replace_word(c, repl))
        menu.exec_(self.input_edit.mapToGlobal(pos))

    def _replace_word(self, cursor: QtGui.QTextCursor, replacement: str) -> None:
        """
        Replace the word at the given cursor with a suggestion. This
        method is connected dynamically for each suggestion action.
        """
        try:
            cursor.beginEditBlock()
            cursor.removeSelectedText()
            cursor.insertText(replacement)
            cursor.endEditBlock()
        except Exception:
            pass

    def _on_semantic_toggled(self, checked: bool) -> None:
        """Persist semantic awareness per persona+set."""
        persona = self._current_persona()
        set_name = self.current_set.get(persona, "default")
        try:
            schema = self.core.schema_mgr.load_schema(persona, set_name)
            flags = dict(schema.get("flags") or {})
            flags["semantic_awareness"] = bool(checked)
            schema["flags"] = flags
            self.core.schema_mgr.save_schema(persona, set_name, schema)
        except Exception:
            pass
        self._reset_idle_timer()

    def _sync_semantic_checkbox_from_schema(self) -> None:
        """Load semantic_awareness from current schema into the checkbox."""
        persona = self._current_persona()
        set_name = self.current_set.get(persona, "default")
        try:
            schema = self.core.schema_mgr.load_schema(persona, set_name)
            flags = schema.get("flags", {})
            val = bool(flags.get("semantic_awareness", True))
        except Exception:
            val = True
        self.chk_semantic.blockSignals(True)
        self.chk_semantic.setChecked(val)
        self.chk_semantic.blockSignals(False)

    # ────────────────────────── status helper
    def _flash_status(self, msg: str) -> None:
        self.statusBar().showMessage(msg, 3000)


# ────────────────────────── Dock tray & titlebar
class DockTray(QtWidgets.QWidget):
    restoreRequested = QtCore.pyqtSignal(QtWidgets.QDockWidget)

    def __init__(self, parent: Optional[QtWidgets.QWidget] = None) -> None:
        super().__init__(parent)
        self._map: Dict[QtWidgets.QDockWidget, QtWidgets.QPushButton] = {}
        lay = QtWidgets.QHBoxLayout(self)
        lay.setContentsMargins(6, 4, 6, 4)
        lay.setSpacing(6)
        self._layout = lay
        self._title = QtWidgets.QLabel("Minimized panels:")
        self._title.setStyleSheet("color: #f0f0f0; font-weight: bold;")
        self._layout.addWidget(self._title, 0)
        self._layout.addStretch(1)
        self.setStyleSheet("background-color: #3c4a6b;")

    def register_dock(self, dock: QtWidgets.QDockWidget) -> None:
        dock.visibilityChanged.connect(lambda vis, d=dock: self._on_visibility_changed(d, vis))
        if not dock.isVisible():
            self._add_button(dock)

    def _on_visibility_changed(self, dock: QtWidgets.QDockWidget, visible: bool) -> None:
        if visible:
            self._remove_button(dock)
        else:
            self._add_button(dock)

    def _add_button(self, dock: QtWidgets.QDockWidget) -> None:
        if dock in self._map:
            return
        btn = QtWidgets.QPushButton(dock.windowTitle())
        btn.setToolTip(f"Restore {dock.windowTitle()}")
        btn.setStyleSheet(
            "background-color: #4a5b78; color: #ffffff; padding: 4px 6px; border: none; border-radius: 3px;"
        )
        btn.clicked.connect(lambda checked=False, d=dock: self._restore(d))
        self._layout.insertWidget(self._layout.count() - 1, btn)
        self._map[dock] = btn

    def _remove_button(self, dock: QtWidgets.QDockWidget) -> None:
        btn = self._map.pop(dock, None)
        if btn:
            self._layout.removeWidget(btn)
            btn.deleteLater()

    def _restore(self, dock: QtWidgets.QDockWidget) -> None:
        dock.show()
        dock.raise_()
        self.restoreRequested.emit(dock)


class DockTitleBar(QtWidgets.QWidget):
    def __init__(self, dock: QtWidgets.QDockWidget, title: str) -> None:
        super().__init__(dock)
        self._dock = dock
        h = QtWidgets.QHBoxLayout(self)
        h.setContentsMargins(6, 2, 6, 2)
        h.setSpacing(6)
        self.lbl = QtWidgets.QLabel(title)
        h.addWidget(self.lbl)
        h.addStretch()
        self.btn_min = QtWidgets.QToolButton()
        self.btn_min.setText("–")
        self.btn_min.setToolTip("Minimize to bottom tray")
        self.btn_min.clicked.connect(lambda checked=False: self._dock.hide())
        h.addWidget(self.btn_min)
        self.btn_max = QtWidgets.QToolButton()
        self.btn_max.setText("□")
        self.btn_max.setToolTip("Enlarge / Restore")
        self.btn_max.clicked.connect(self._on_toggle_maximize)
        h.addWidget(self.btn_max)
        self.btn_close = QtWidgets.QToolButton()
        self.btn_close.setText("×")
        self.btn_close.setToolTip("Close (send to bottom tray)")
        self.btn_close.clicked.connect(lambda checked=False: self._dock.hide())
        h.addWidget(self.btn_close)
        self.installEventFilter(self)

    def eventFilter(self, _obj: QtCore.QObject, evt: QtCore.QEvent) -> bool:
        if evt.type() == QtCore.QEvent.MouseButtonDblClick:
            self._dock.setFloating(not self._dock.isFloating())
            return True
        return False

    def _on_toggle_maximize(self) -> None:
        mw: Optional[QtWidgets.QMainWindow] = self._dock.parentWidget()  # type: ignore
        while mw and not isinstance(mw, QtWidgets.QMainWindow):
            mw = mw.parentWidget()  # type: ignore
        if not isinstance(mw, QtWidgets.QMainWindow):
            self._dock.setFloating(not self._dock.isFloating())
            return
        if not self._dock.isFloating():
            self._dock.setFloating(True)
            mw_geo = mw.geometry()
            w = int(mw_geo.width() * 0.9)
            h = int(mw_geo.height() * 0.85)
            self._dock.resize(w, h)
            center = mw_geo.center()
            self._dock.move(center.x() - w // 2, center.y() - h // 2)
        else:
            self._dock.setFloating(False)


# ────────────────────────── dataset manager dialog
class DatasetManagerDialog(QtWidgets.QDialog):
    def __init__(self, dataset_mgr, parent: Optional[QtWidgets.QWidget] = None) -> None:
        super().__init__(parent)
        self.setWindowTitle("Dataset Manager")
        self.resize(520, 420)
        self.dataset_mgr = dataset_mgr
        v = QtWidgets.QVBoxLayout(self)
        self.list_widget = QtWidgets.QListWidget()
        v.addWidget(self.list_widget, 1)
        h = QtWidgets.QHBoxLayout()
        self.btn_add = QtWidgets.QPushButton("Add Dataset")
        self.btn_del = QtWidgets.QPushButton("Delete Dataset")
        h.addWidget(self.btn_add)
        h.addWidget(self.btn_del)
        h.addStretch()
        v.addLayout(h)
        self._populate()
        self.btn_add.clicked.connect(self._on_add)
        self.btn_del.clicked.connect(self._on_delete)
        self.list_widget.itemChanged.connect(self._on_item)

    def _populate(self) -> None:
        self.list_widget.clear()
        for name, entry in sorted(self.dataset_mgr.entries.items()):
            item = QtWidgets.QListWidgetItem(name)
            item.setFlags(item.flags() | QtCore.Qt.ItemIsUserCheckable)
            item.setCheckState(QtCore.Qt.Checked if entry.active else QtCore.Qt.Unchecked)
            self.list_widget.addItem(item)

    def _on_add(self) -> None:
        name, ok = QtWidgets.QInputDialog.getText(self, "New Dataset", "Enter dataset name:")
        if not ok or not name.strip():
            return
        path, _ = QtWidgets.QFileDialog.getOpenFileName(self, "Select .txt or .pdf", "", "Text/PDF (*.txt *.pdf)")
        if not path:
            return
        try:
            self.dataset_mgr.add_dataset(name.strip(), path)
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "Error", str(e))
            return
        self._populate()

    def _on_delete(self) -> None:
        item = self.list_widget.currentItem()
        if not item:
            return
        name = item.text()
        if QtWidgets.QMessageBox.question(
            self, "Delete Dataset", f"Delete '{name}'?", QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No
        ) != QtWidgets.QMessageBox.Yes:
            return
        try:
            self.dataset_mgr.delete_dataset(name)
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "Error", str(e))
            return
        self._populate()

    def _on_item(self, item: QtWidgets.QListWidgetItem) -> None:
        self.dataset_mgr.toggle_active(item.text(), item.checkState() == QtCore.Qt.Checked)


# ────────────────────────── run as script
if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    win = AppWindow()
    win.show()
    sys.exit(app.exec_())
```

main_ui.py
===========

This module contains the top-level ``AppWindow`` class for the AI TTS
Agent.  It orchestrates all layout and docking behaviour, integrates
the control panel and persona tabs provided by ``commands_panel`` and
``persona_tab``, and exposes a unified interface for the rest of the
application.  None of the core agent logic lives here – that remains in
the ``core_*`` modules.  This refactor pulls the bulky UI building
logic out of the monolithic script and into dedicated modules while
preserving all existing behaviour and wiring.
**Classes:** _SpellHighlighter, AppWindow, DockTray, DockTitleBar, DatasetManagerDialog


## Module `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\AI_TTS_AGENT\migration_tool.py`

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
migration_tool.py
=================

Stand-alone CLI for *one-shot* migration of legacy AI-TTS-Agent files
(JSON schemas, commands.json, reinforcement.jsonl …) into the new
SQLite-backed **agent_store.db**.

Typical usage
-------------
$ python migration_tool.py /path/to/AI_TTS_AGENT
    → runs migrate (if needed) and prints a coloured diff table.

$ python migration_tool.py . --dry-run
    → shows what *would* be imported without touching the DB.

Exit codes
----------
0  success – nothing failed
1  fatal error (bad path, SQLite locked, etc.)
2  migration aborted by --check-upgrade only
"""

from __future__ import annotations

import argparse
import os
import sys
from pathlib import Path
from typing import Dict

# Import AFTER adjusting sys.path so the script also works when executed
# from outside the project root.
PROJECT_ROOT = Path(__file__).resolve().parent
if PROJECT_ROOT not in map(Path, map(Path.resolve, map(Path, sys.path))):
    sys.path.insert(0, str(PROJECT_ROOT))

try:
    from agent_store import AgentStore, DB_VERSION
except ImportError as exc:  # pragma: no cover
    print(f"[migration_tool] Cannot import agent_store: {exc}", file=sys.stderr)
    sys.exit(1)


# ------------------------------ helpers ------------------------------ #
def _colour(txt: str, colour: str) -> str:
    colours = {
        "green": "\033[92m",
        "yellow": "\033[93m",
        "red": "\033[91m",
        "cyan": "\033[96m",
        "end": "\033[0m",
    }
    return f"{colours.get(colour, '')}{txt}{colours['end']}"


def _print_report(report: Dict[str, int]) -> None:
    print("\nMigration report")
    print("----------------")
    for k in ("schemas", "commands", "beans"):
        val = report.get(k, 0)
        colour = "green" if val else "yellow"
        print(f"  {k:<10}: {_colour(str(val), colour)}")


# ----------------------------- CLI entry ----------------------------- #
def main() -> None:
    ap = argparse.ArgumentParser(
        description="Run or inspect migration from legacy flat-file storage "
        "to agent_store.db (schema v%d)." % DB_VERSION
    )
    ap.add_argument(
        "base_dir",
        metavar="BASE_DIR",
        help="Root folder where AI-TTS-Agent project lives",
    )
    ap.add_argument(
        "--dry-run",
        action="store_true",
        help="Scan legacy artefacts and show how many items WOULD be migrated "
        "without actually writing to the DB.",
    )
    ap.add_argument(
        "--check-upgrade",
        action="store_true",
        help="Exit code 2 if the DB is below current version (use for CI).",
    )
    args = ap.parse_args()
    base_dir = os.path.abspath(args.base_dir)

    if not os.path.isdir(base_dir):
        print(_colour(f"[migration_tool] No such directory: {base_dir}", "red"), file=sys.stderr)
        sys.exit(1)

    store = AgentStore(base_dir)

    with store._pool.get() as c:  # type: ignore[attr-defined, arg-type]
        cur = c.execute("SELECT value FROM meta WHERE key='user_version'")
        current_ver = int(cur.fetchone()[0])

    if args.check_upgrade:
        if current_ver < DB_VERSION:
            print(_colour(f"DB version {current_ver} < required {DB_VERSION}", "yellow"))
            sys.exit(2)
        print(_colour("DB is up to date.", "green"))
        return

    if current_ver >= DB_VERSION and not args.dry_run:
        print(_colour("Nothing to migrate – database already at latest schema.", "green"))
        return

    if args.dry_run:
        print(_colour("[dry-run] Scanning legacy artefacts…", "cyan"))
        report = store.migrate_from_files()  # writes, but we’ll roll back
        _print_report(report)
        # rollback by deleting DB to keep promise of dry-run
        os.remove(store.db_path)
        print(_colour("\n[dry-run] Database left untouched.", "cyan"))
        return

    # Real migration
    print(_colour("Running migration…", "cyan"))
    report = store.migrate_from_files()
    _print_report(report)
    print(_colour("\nMigration completed.\n", "green"))


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\nInterrupted.")
        sys.exit(1)
```

migration_tool.py
=================

Stand-alone CLI for *one-shot* migration of legacy AI-TTS-Agent files
(JSON schemas, commands.json, reinforcement.jsonl …) into the new
SQLite-backed **agent_store.db**.

Typical usage
-------------
$ python migration_tool.py /path/to/AI_TTS_AGENT
    → runs migrate (if needed) and prints a coloured diff table.

$ python migration_tool.py . --dry-run
    → shows what *would* be imported without touching the DB.

Exit codes
----------
0  success – nothing failed
1  fatal error (bad path, SQLite locked, etc.)
2  migration aborted by --check-upgrade only
**Functions:** _colour(txt, colour), _print_report(report), main()


## Module `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\AI_TTS_AGENT\persona_tab.py`

```python
#!/usr/bin/env python3
"""
persona_tab.py
==============

**Schema-Editor 2.0**

This version upgrades the old free-text schema editor to a structured,
two-pane interface:

    • **Left:**   Category tree (actions, questions, etc.)  
    • **Right:**  Multiline editor for the selected node’s JSON value  
    • **Bottom:** “Expose as /command” checkbox (per category)  
    • **Top-right:** “Auto-Evolution” toggle for the whole set

Other improvements

* Autosave is now routed through **SchemaEngine.save()** (SQL-backed).
* Edits are debounced (500 ms) and validated before committing.
* When “Expose as /command” is ticked, a synthetic slash-command is written
  to *AgentStore.commands* for immediate use by the orchestrator.
"""

from __future__ import annotations

import json
import os
from typing import Dict, Any, Optional

from PyQt5 import QtCore, QtGui, QtWidgets


# --------------------------------------------------------------------------- helpers


def nice_json(value: Any) -> str:
    """Pretty JSON helper that survives non-serialisable objects."""
    try:
        return json.dumps(value, indent=2, ensure_ascii=False)
    except Exception:
        return str(value)


def parse_json(text: str) -> Any:
    """Parse or return raw string if JSON fails."""
    try:
        return json.loads(text)
    except Exception:
        return text.strip()


# --------------------------------------------------------------------------- main widget


class PersonaTab(QtWidgets.QWidget):
    """Persona & schema management panel (one instance shared across personas)."""

    # Emitted after a schema field is *persisted* (category, persona, set)
    schemaFieldUpdated = QtCore.pyqtSignal(str, str, str)

    # --------------------------------------------------------------------- init
    def __init__(
        self,
        app: "AppWindow",  # quotes to avoid circular import typing
        parent: Optional[QtWidgets.QWidget] = None,
    ) -> None:
        super().__init__(parent)
        self.app = app
        self.core = app.core
        self.schema_engine = self.core.schema_engine  # ← SQL façade
        self.current_set: Dict[str, str] = app.current_set

        # Label summarising active names/sets
        self.lbl_active = QtWidgets.QLabel()
        self.lbl_active.setObjectName("lblActiveSchemas")
        # Alias for main_ui compatibility (it expects persona_panel.lbl_active_names)
        self.lbl_active_names = self.lbl_active

        # Tabs per persona  ---------------------------------------------------
        self.tabs = QtWidgets.QTabWidget(movable=False, documentMode=True)
        self.tab_widgets: Dict[str, QtWidgets.QWidget] = {}
        for persona in self.schema_engine.personas():
            tab = QtWidgets.QWidget()
            self.tab_widgets[persona] = tab
            self.tabs.addTab(tab, persona.capitalize())

        # Operators tab (read-only)
        self.operator_tab = QtWidgets.QWidget()
        self.tabs.addTab(self.operator_tab, "Operators")

        self.tabs.currentChanged.connect(self._on_tab_changed)

        # Master layout
        v = QtWidgets.QVBoxLayout(self)
        v.setContentsMargins(7, 7, 7, 7)
        v.setSpacing(7)
        v.addWidget(self.lbl_active)
        v.addWidget(self.tabs, 1)

        # Build each persona sub-panel
        for p, w in self.tab_widgets.items():
            self._build_persona_subpanel(p, w)
        self._build_operators_tab(self.operator_tab)

        # Prime active-names label
        self._refresh_active_label()

    # ----------------------------------------------------------------- builders
    def _build_persona_subpanel(self, persona: str, root: QtWidgets.QWidget) -> None:
        """Creates the Schema-Editor 2.0 layout for a single persona."""
        # ───── set selector row ────────────────────────────────────────────
        top = QtWidgets.QHBoxLayout()
        top.addWidget(QtWidgets.QLabel("Set:"))

        set_combo = QtWidgets.QComboBox(objectName=f"setCombo_{persona}")
        self._populate_set_combo(persona, set_combo)
        set_combo.currentTextChanged.connect(
            lambda name, p=persona, c=set_combo: self._switch_set(p, name, c)
        )
        top.addWidget(set_combo)

        btn_clone = QtWidgets.QPushButton("Clone")
        btn_clone.clicked.connect(lambda _=False, p=persona, c=set_combo: self.app._on_clone_set(p, c))
        btn_new = QtWidgets.QPushButton("New")
        btn_new.clicked.connect(lambda _=False, p=persona, c=set_combo: self.app._on_new_set(p, c))
        btn_del = QtWidgets.QPushButton("Delete")
        btn_del.clicked.connect(lambda _=False, p=persona, c=set_combo: self.app._on_delete_set(p, c))
        for b in (btn_clone, btn_new, btn_del):
            top.addWidget(b)
        top.addStretch()

        # Auto-Evolution toggle (per-set)
        chk_auto = QtWidgets.QCheckBox("Auto Evolution")
        chk_auto.setObjectName(f"chkAutoEvo_{persona}")
        chk_auto.stateChanged.connect(lambda _=0, p=persona: self._toggle_auto_evo(p))
        top.addWidget(chk_auto)

        # ───── splitter: category tree | editor ────────────────────────────
        splitter = QtWidgets.QSplitter(QtCore.Qt.Horizontal)
        splitter.setChildrenCollapsible(False)

        # Category tree
        tree = QtWidgets.QTreeWidget(objectName=f"schemaTree_{persona}")
        tree.setHeaderHidden(True)
        tree.itemClicked.connect(lambda item, _col, p=persona: self._load_category(p, item))
        splitter.addWidget(tree)

        # Right-side editor + extras
        right = QtWidgets.QWidget()
        rv = QtWidgets.QVBoxLayout(right)
        rv.setContentsMargins(0, 0, 0, 0)
        rv.setSpacing(4)

        editor = QtWidgets.QPlainTextEdit(objectName=f"schemaEditor_{persona}")
        editor.setLineWrapMode(QtWidgets.QPlainTextEdit.NoWrap)
        rv.addWidget(editor, 1)

        row = QtWidgets.QHBoxLayout()
        self.chk_expose = QtWidgets.QCheckBox("Expose as /command")
        row.addWidget(self.chk_expose)
        row.addStretch()
        btn_format = QtWidgets.QPushButton("Reformat JSON")
        row.addWidget(btn_format)
        rv.addLayout(row)

        splitter.addWidget(right)
        splitter.setStretchFactor(1, 2)

        # ───── assemble persona tab ────────────────────────────────────────
        vbox = QtWidgets.QVBoxLayout(root)
        vbox.setContentsMargins(4, 4, 4, 4)
        vbox.setSpacing(6)
        vbox.addLayout(top)
        vbox.addWidget(splitter, 1)

        # ───── state & autosave timer  ─────────────────────────────────────
        timer = QtCore.QTimer(self)
        timer.setSingleShot(True)
        timer.setInterval(500)  # 500 ms debounce

        def start_debounce() -> None:
            timer.start()

        editor.textChanged.connect(start_debounce)

        def persist() -> None:
            cat = tree.currentItem().text(0) if tree.currentItem() else ""
            if not cat:
                return
            try:
                payload = parse_json(editor.toPlainText())
                persona_set = self.current_set.get(persona, "default")
                self.schema_engine.update_field(persona, persona_set, cat, payload)
                # expose as /command if requested
                expose = self.chk_expose.isChecked()
                self.schema_engine.set_command_exposure(persona, cat, expose)
                self.schemaFieldUpdated.emit(persona, persona_set, cat)
            except Exception as e:
                QtWidgets.QMessageBox.warning(self, "Schema Error", str(e))

        timer.timeout.connect(persist)

        # Re-format button
        btn_format.clicked.connect(lambda: editor.setPlainText(nice_json(parse_json(editor.toPlainText()))))

        # Populate first load
        self._reload_tree(persona, tree)

    # ----------------------------------------------------------------- GUI helpers
    def _populate_set_combo(self, persona: str, combo: QtWidgets.QComboBox) -> None:
        combo.blockSignals(True)
        combo.clear()
        for s in self.schema_engine.set_list(persona):
            combo.addItem(s)
        current = self.current_set.get(persona, "default")
        idx = combo.findText(current)
        combo.setCurrentIndex(max(idx, 0))
        combo.blockSignals(False)

    def _switch_set(self, persona: str, set_name: str, combo: QtWidgets.QComboBox) -> None:
        self.current_set[persona] = set_name
        self._reload_tree(persona, self.findChild(QtWidgets.QTreeWidget, f"schemaTree_{persona}"))
        self._refresh_active_label()

    def _toggle_auto_evo(self, persona: str) -> None:
        set_name = self.current_set.get(persona, "default")
        chk: QtWidgets.QCheckBox = self.sender()  # type: ignore
        self.schema_engine.set_auto_evolution(persona, set_name, bool(chk.isChecked()))

    def _reload_tree(self, persona: str, tree: QtWidgets.QTreeWidget) -> None:
        """Repopulate category tree for the current set."""
        tree.clear()
        set_name = self.current_set.get(persona, "default")
        data = self.schema_engine.load_schema(persona, set_name) or {}
        for key in sorted(data.keys()):
            QtWidgets.QTreeWidgetItem(tree, [key])
        if tree.topLevelItemCount():
            tree.setCurrentItem(tree.topLevelItem(0))

    def _load_category(self, persona: str, item: QtWidgets.QTreeWidgetItem) -> None:
        """Load selected category into editor."""
        cat = item.text(0)
        set_name = self.current_set.get(persona, "default")
        value = self.schema_engine.get_field(persona, set_name, cat)
        editor: QtWidgets.QPlainTextEdit = self.findChild(
            QtWidgets.QPlainTextEdit, f"schemaEditor_{persona}"
        )
        editor.blockSignals(True)
        editor.setPlainText(nice_json(value))
        editor.blockSignals(False)
        # set expose-command checkbox
        self.chk_expose.blockSignals(True)
        self.chk_expose.setChecked(self.schema_engine.is_exposed_as_command(persona, cat))
        self.chk_expose.blockSignals(False)

    def _refresh_active_label(self) -> None:
        try:
            bot_name = self.schema_engine.get_field(
                self.app.active_persona, self.current_set[self.app.active_persona], "name"
            )
        except Exception:
            bot_name = self.app.active_persona.capitalize()
        user_name = self.schema_engine.get_field("user", self.current_set.get("user", "default"), "name") or "User"
        bot_set = self.current_set.get(self.app.active_persona, "default")
        user_set = self.current_set.get("user", "default")
        self.lbl_active.setText(f"{bot_name}: {bot_set} — User: {user_name}: {user_set}")

    # ----------------------------------------------------------------- operators tab
    def _build_operators_tab(self, tab: QtWidgets.QWidget) -> None:
        """Simple list of installed operators with descriptions."""
        lay = QtWidgets.QVBoxLayout(tab)
        lay.setContentsMargins(4, 4, 4, 4)
        lay.setSpacing(6)

        ops = self.core.operator_mgr.list_operators()
        if not ops:
            lay.addWidget(QtWidgets.QLabel("No operators installed."))
        else:
            for name in sorted(ops):
                schema = self.core.operator_mgr.load_schema(name)
                box = QtWidgets.QGroupBox(name)
                v = QtWidgets.QVBoxLayout(box)
                v.addWidget(QtWidgets.QLabel(schema.get("description", "")))
                lay.addWidget(box)
        lay.addStretch()

    # ----------------------------------------------------------------- UI tab change
    def _on_tab_changed(self, idx: int) -> None:
        # keep memo of which persona is active so main_ui can react
        persona = self.tabs.tabText(idx).lower()
        if persona in self.tab_widgets:
            self.app.active_persona = persona
            self._refresh_active_label()
```

persona_tab.py
==============

**Schema-Editor 2.0**

This version upgrades the old free-text schema editor to a structured,
two-pane interface:

    • **Left:**   Category tree (actions, questions, etc.)  
    • **Right:**  Multiline editor for the selected node’s JSON value  
    • **Bottom:** “Expose as /command” checkbox (per category)  
    • **Top-right:** “Auto-Evolution” toggle for the whole set

Other improvements

* Autosave is now routed through **SchemaEngine.save()** (SQL-backed).
* Edits are debounced (500 ms) and validated before committing.
* When “Expose as /command” is ticked, a synthetic slash-command is written
  to *AgentStore.commands* for immediate use by the orchestrator.
**Classes:** PersonaTab
**Functions:** nice_json(value), parse_json(text)


## Module `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\AI_TTS_AGENT\run_agent.py`

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
run_agent.py — bootstrap launcher for AI TTS Agent (v3, 2025-08-04)

• Ensures the sqlite store exists (agent_store.ensure_db()) and runs
  legacy-data migration when user_version < 4.
• Accepts one optional command-line arg: <profile-dir>. Defaults to
  ./ai_agent_state relative to CWD.
• Starts the Qt GUI (main_ui.AppWindow).
• Catches early exceptions and prints a clean error trace instead of a
  raw stack-dump so newcomers understand what went wrong.
"""

from __future__ import annotations

import os
import sys
import traceback
from typing import Optional

from PyQt5 import QtWidgets

# --- local imports ----------------------------------------------------------
try:
    from agent_store import ensure_db, get_user_version, migrate_from_files
except ImportError:
    # fall back: no sql store yet, skip migration helpers
    def ensure_db(_): ...
    def get_user_version(_): return 0
    def migrate_from_files(_): return 0, 0  # migrated_rows, warnings


def _bootstrap_state(base_dir: str) -> None:
    """Create DB if missing and run legacy migration (if needed), then show UI."""
    os.makedirs(base_dir, exist_ok=True)
    ensure_db(base_dir)

    try:
        if get_user_version(base_dir) < 4:
            rows, warns = migrate_from_files(base_dir)
            print(f"[migration] imported {rows} rows ({warns} warnings)")
    except Exception as e:
        print(f"[migration] warning: migration failed: {e}")

    # Import the GUI class, catching import-time errors
    try:
        from main_ui import AppWindow
    except Exception:
        print("\n[run_agent] FATAL — failed to import main_ui:\n")
        traceback.print_exc()
        print("\nPress Enter to exit…")
        input()
        sys.exit(1)

    # Instantiate and show the main window, catching UI init errors
    try:
        win = AppWindow()
        win.show()
    except Exception:
        print("\n[run_agent] FATAL — UI failed to initialize:\n")
        traceback.print_exc()
        print("\nPress Enter to exit…")
        input()
        sys.exit(1)


def main() -> None:
    """Entry point: initialize QApplication, bootstrap state, and start event loop."""
    base_dir = (
        sys.argv[1]
        if len(sys.argv) > 1
        else os.path.join(os.getcwd(), "ai_agent_state")
    )

    app = QtWidgets.QApplication(sys.argv)
    _bootstrap_state(base_dir)
    sys.exit(app.exec_())


if __name__ == "__main__":
    try:
        main()
    except Exception:
        print("\n[run_agent] FATAL — an unexpected error occurred:\n")
        traceback.print_exc()
        print("\nPress Enter to exit…")
        input()
```

run_agent.py — bootstrap launcher for AI TTS Agent (v3, 2025-08-04)

• Ensures the sqlite store exists (agent_store.ensure_db()) and runs
  legacy-data migration when user_version < 4.
• Accepts one optional command-line arg: <profile-dir>. Defaults to
  ./ai_agent_state relative to CWD.
• Starts the Qt GUI (main_ui.AppWindow).
• Catches early exceptions and prints a clean error trace instead of a
  raw stack-dump so newcomers understand what went wrong.
**Functions:** _bootstrap_state(base_dir), main()


## Module `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\AI_TTS_AGENT\schema_ops.py`

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
schema_ops.py  (2025-08-04  ▸  v2)
==================================

Declarative dispatcher that maps **string op-codes → mutator callables**
operating on core_schema.SchemaEngine / Schema rows.

Updates (v2)
------------
• Added category & prompt removal / update helpers
• Added action list mutators
• Added runtime-introspection helpers: available_ops(), describe_op()
• Strict type-checking & richer logging

Usage example
-------------
>>> from schema_ops import execute_op, available_ops
>>> print(available_ops())
['add_category', 'append_actions', 'delete_action', ...]
>>> execute_op("append_actions", engine,
...            persona="zira", set_name="default",
...            actions=["wave warmly", "offer coffee"])
"""

from __future__ import annotations

import inspect
from typing import Callable, Dict, Any, List

from core_schema import SchemaEngine, Schema
from core_base import logger


# ╔═══════════════════════════════════════════════════════════════════════╗
# ║  Internal helpers                                                     ║
# ╚═══════════════════════════════════════════════════════════════════════╝
def _load(engine: SchemaEngine, persona: str, set_name: str) -> Schema:
    """Return schema or raise ValueError on bad keys."""
    if persona not in engine.personas:
        raise ValueError(f"Unknown persona: {persona}")
    return engine.load(persona, set_name)


def _save(engine: SchemaEngine, persona: str, set_name: str, sch: Schema):
    engine.save(persona, set_name, sch)


def _signal_category_created(engine: SchemaEngine, persona: str, set_name: str, category: str):
    """
    Emit schemaEvolved + categoryCreated if those Qt signals exist.
    No hard dependency —  graceful if running headless.
    """
    try:
        # pylint: disable=protected-access
        engine.schemaEvolved.emit(persona, set_name)        # type: ignore[attr-defined]
        engine.categoryCreated.emit(category)               # type: ignore[attr-defined]
    except Exception:
        pass


# ╔═══════════════════════════════════════════════════════════════════════╗
# ║  Operation implementations                                            ║
# ╚═══════════════════════════════════════════════════════════════════════╝
def op_add_category(
    engine: SchemaEngine,
    *,
    persona: str,
    set_name: str,
    category: str,
    values: List[str] | None = None,
):
    """Create new dynamic_overlay list with optional initial *values*."""
    sch = _load(engine, persona, set_name)
    overlay = sch.dynamic_overlay or {}
    if category in overlay:
        raise ValueError(f"Category '{category}' already exists.")
    overlay[category] = values or []
    sch.dynamic_overlay = overlay
    _save(engine, persona, set_name, sch)
    _signal_category_created(engine, persona, set_name, category)
    logger.info("Added category '%s' to %s/%s", category, persona, set_name)


def op_remove_category(
    engine: SchemaEngine,
    *,
    persona: str,
    set_name: str,
    category: str,
):
    """Remove an entire category from dynamic_overlay."""
    sch = _load(engine, persona, set_name)
    overlay = sch.dynamic_overlay or {}
    if category not in overlay:
        raise ValueError(f"No such category '{category}'.")
    overlay.pop(category)
    sch.dynamic_overlay = overlay
    _save(engine, persona, set_name, sch)
    logger.info("Removed category '%s' from %s/%s", category, persona, set_name)


def op_update_category(
    engine: SchemaEngine,
    *,
    persona: str,
    set_name: str,
    category: str,
    new_values: List[str],
):
    """Replace the value-list of an existing category."""
    sch = _load(engine, persona, set_name)
    overlay = sch.dynamic_overlay or {}
    if category not in overlay:
        raise ValueError(f"Category '{category}' not found.")
    overlay[category] = list(new_values)
    sch.dynamic_overlay = overlay
    _save(engine, persona, set_name, sch)
    logger.info("Updated category '%s' in %s/%s", category, persona, set_name)


def op_toggle_autoevo(
    engine: SchemaEngine,
    *,
    persona: str,
    set_name: str,
    enable: bool,
):
    """Flip semantic_awareness_enabled flag."""
    sch = _load(engine, persona, set_name)
    cur = bool(getattr(sch, "semantic_awareness_enabled", False))
    if cur == enable:
        return
    sch.semantic_awareness_enabled = enable
    _save(engine, persona, set_name, sch)
    logger.info("semantic_awareness %s for %s/%s", enable, persona, set_name)


def op_inject_prompt_variant(
    engine: SchemaEngine,
    *,
    persona: str,
    set_name: str,
    variant_name: str,
    prompt_template: str,
):
    """Append new prompt template to rewrite_prompts list."""
    sch = _load(engine, persona, set_name)
    lst: List[str] = sch.rewrite_prompts or []
    entry = f"[{variant_name}] {prompt_template}"
    lst.append(entry)
    sch.rewrite_prompts = lst
    _save(engine, persona, set_name, sch)
    logger.info("Injected prompt variant '%s' into %s/%s", variant_name, persona, set_name)


def op_remove_prompt_variant(
    engine: SchemaEngine,
    *,
    persona: str,
    set_name: str,
    variant_tag: str,
):
    """
    Delete a rewrite prompt that contains *variant_tag* (case-insensitive).
    """
    sch = _load(engine, persona, set_name)
    lst: List[str] = sch.rewrite_prompts or []
    new_lst = [p for p in lst if variant_tag.lower() not in p.lower()]
    if len(new_lst) == len(lst):
        raise ValueError(f"No prompt containing '{variant_tag}' found.")
    sch.rewrite_prompts = new_lst
    _save(engine, persona, set_name, sch)
    logger.info("Removed prompt variant '%s' from %s/%s", variant_tag, persona, set_name)


def op_replace_rewrite_list(
    engine: SchemaEngine,
    *,
    persona: str,
    set_name: str,
    new_list: List[str],
):
    """Replace entire rewrite_prompts list."""
    sch = _load(engine, persona, set_name)
    sch.rewrite_prompts = list(new_list)
    _save(engine, persona, set_name, sch)
    logger.info("rewrite_prompts replaced for %s/%s", persona, set_name)


def op_append_actions(
    engine: SchemaEngine,
    *,
    persona: str,
    set_name: str,
    actions: List[str],
):
    """Append new action strings (deduplicated)."""
    sch = _load(engine, persona, set_name)
    cur: List[str] = sch.actions or []
    for a in actions:
        if a not in cur:
            cur.append(a)
    sch.actions = cur
    _save(engine, persona, set_name, sch)
    logger.info("Appended %d actions to %s/%s", len(actions), persona, set_name)


def op_delete_action(
    engine: SchemaEngine,
    *,
    persona: str,
    set_name: str,
    action_text: str,
):
    """Remove an action entry matching *action_text* exactly."""
    sch = _load(engine, persona, set_name)
    cur: List[str] = sch.actions or []
    if action_text not in cur:
        raise ValueError("Action not found.")
    cur.remove(action_text)
    sch.actions = cur
    _save(engine, persona, set_name, sch)
    logger.info("Deleted action '%s' from %s/%s", action_text, persona, set_name)


def op_rename_schema_set(
    engine: SchemaEngine,
    *,
    persona: str,
    old_set: str,
    new_set: str,
):
    """Rename a schema set atomically."""
    if new_set == old_set:
        raise ValueError("new_set equals old_set")
    if new_set in engine.list_sets(persona):
        raise ValueError("Target set already exists")
    sch = _load(engine, persona, old_set)
    engine.save(persona, new_set, sch, auto_expand=False)
    engine.store.conn.execute(
        "DELETE FROM schemas WHERE persona_key=? AND set_name=?",
        (persona, old_set),
    )
    engine.store.conn.commit()
    logger.info("Renamed set %s/%s -> %s", persona, old_set, new_set)


# ╔═══════════════════════════════════════════════════════════════════════╗
# ║  Declarative operation registry                                       ║
# ╚═══════════════════════════════════════════════════════════════════════╝
OPS: Dict[str, Callable[..., None]] = {
    # Category ops
    "add_category": op_add_category,
    "remove_category": op_remove_category,
    "update_category": op_update_category,
    # Rewrite-prompt ops
    "inject_prompt_variant": op_inject_prompt_variant,
    "remove_prompt_variant": op_remove_prompt_variant,
    "replace_rewrite_list": op_replace_rewrite_list,
    # Semantic awareness flag
    "toggle_autoevo": op_toggle_autoevo,
    # Actions list
    "append_actions": op_append_actions,
    "delete_action": op_delete_action,
    # Set management
    "rename_schema_set": op_rename_schema_set,
}

# ╔═══════════════════════════════════════════════════════════════════════╗
# ║  Public utility wrappers                                              ║
# ╚═══════════════════════════════════════════════════════════════════════╝
def execute_op(op_name: str, engine: SchemaEngine, **payload):
    """Dispatch *op_name*; raise KeyError on unknown op."""
    fn = OPS.get(op_name)
    if not fn:
        raise KeyError(f"Unknown op: {op_name}")
    return fn(engine, **payload)


def available_ops() -> List[str]:
    """Return sorted list of registered op-codes."""
    return sorted(OPS)


def describe_op(op_name: str) -> str:
    """Return docstring of a registered op."""
    fn = OPS.get(op_name)
    if not fn:
        raise KeyError(op_name)
    return inspect.getdoc(fn) or ""


__all__ = [
    "OPS",
    "execute_op",
    "available_ops",
    "describe_op",
]
```

schema_ops.py  (2025-08-04  ▸  v2)
==================================

Declarative dispatcher that maps **string op-codes → mutator callables**
operating on core_schema.SchemaEngine / Schema rows.

Updates (v2)
------------
• Added category & prompt removal / update helpers
• Added action list mutators
• Added runtime-introspection helpers: available_ops(), describe_op()
• Strict type-checking & richer logging

Usage example
-------------
>>> from schema_ops import execute_op, available_ops
>>> print(available_ops())
['add_category', 'append_actions', 'delete_action', ...]
>>> execute_op("append_actions", engine,
...            persona="zira", set_name="default",
...            actions=["wave warmly", "offer coffee"])
**Functions:** _load(engine, persona, set_name), _save(engine, persona, set_name, sch), _signal_category_created(engine, persona, set_name, category), op_add_category(engine), op_remove_category(engine), op_update_category(engine), op_toggle_autoevo(engine), op_inject_prompt_variant(engine), op_remove_prompt_variant(engine), op_replace_rewrite_list(engine), op_append_actions(engine), op_delete_action(engine), op_rename_schema_set(engine), execute_op(op_name, engine), available_ops(), describe_op(op_name)


## Module `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\AI_TTS_AGENT\snapshot_worker.py`

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
snapshot_worker.py

This script defines ModelWorker, which runs inference on a given model in a separate thread.
Used by the UI to offload prompt evaluation from the main thread.
"""

from PyQt5 import QtCore
from typing import Optional
import traceback

class ModelWorker(QtCore.QThread):
    resultReady = QtCore.pyqtSignal(str)
    errorOccurred = QtCore.pyqtSignal(str)

    def __init__(self, model_slug: str, prompt: str, parent: Optional[QtCore.QObject] = None) -> None:
        super().__init__(parent)
        self.model_slug = model_slug
        self.prompt = prompt

    def run(self):
        try:
            # TODO: Replace this mock logic with actual model inference
            import time
            time.sleep(0.8)  # Simulate response time

            # Simulated output - replace with LLM backend output
            response = f"[{self.model_slug}] Response to: {self.prompt}"

            # Emit response back to UI
            self.resultReady.emit(response)

        except Exception as e:
            tb = traceback.format_exc()
            self.errorOccurred.emit(f"{e}\n{tb}")
```

snapshot_worker.py

This script defines ModelWorker, which runs inference on a given model in a separate thread.
Used by the UI to offload prompt evaluation from the main thread.
**Classes:** ModelWorker


## Module `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\AI_TTS_AGENT\spatial_engine.py`

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
spatial_engine.py
=================

Headless avatar movement & visual-action logger for the AI TTS Agent.

Features:
- Stateful finite-state machine (idle, thinking, moving).
- decide_move(response_text): simple NLP heuristics to pick a target cell.
- Animated, step-by-step movement on a configurable grid.
- Logs each position to AgentStore.spatial_positions and each completed move to AgentStore.visual_actions.
- Emits Qt signals for UI binding (positionChanged, actionLogged).
"""

import threading
import time
from typing import Tuple

from PyQt5 import QtCore
from core_store import FathomStore


class SpatialEngine(QtCore.QObject):
    # Emitted on each step: (x, y, facing)
    positionChanged = QtCore.pyqtSignal(int, int, str)
    # Emitted when a visual action is logged: (action, location, justification)
    actionLogged = QtCore.pyqtSignal(str, str, str)

    def __init__(
        self,
        store: FathomStore,
        entity: str = "zira",
        grid_size: Tuple[int, int] = (20, 20),
        parent: QtCore.QObject = None,
    ) -> None:
        super().__init__(parent)
        self.store = store
        self.entity = entity
        self.grid_width, self.grid_height = grid_size

        # FSM state
        self.state = "idle"
        self.current_x = 0
        self.current_y = 0
        self.facing = "right"

        # Threading
        self._lock = threading.Lock()
        self._stop_event = threading.Event()

    def decide_move(self, response_text: str) -> None:
        """
        Decide where to move based on the content of the last AI response.
        Spawns a background thread to animate the movement.
        """
        target = self._infer_target(response_text)
        justification = f"Decided move based on response keywords."
        worker = threading.Thread(
            target=self._animate_move, args=(target, justification), daemon=True
        )
        worker.start()

    def _infer_target(self, text: str) -> Tuple[int, int]:
        """
        Simple heuristics mapping keywords to grid locations:
        - 'file', 'project' -> top-right (computer terminal)
        - 'database', 'memory' -> bottom-left (storage console)
        - 'think', 'ponder' -> center (thinking zone)
        - otherwise: stay in place
        """
        t = text.lower()
        if any(k in t for k in ("file", "project")):
            return (self.grid_width - 1, 0)
        if any(k in t for k in ("database", "memory", "store")):
            return (0, self.grid_height - 1)
        if any(k in t for k in ("think", "ponder", "reflect")):
            return (self.grid_width // 2, self.grid_height // 2)
        # default: remain where you are
        return (self.current_x, self.current_y)

    def _animate_move(self, target: Tuple[int, int], justification: str) -> None:
        """
        Step-by-step move from current position to target.
        Logs each step and emits positionChanged, then logs final visual action.
        """
        with self._lock:
            self.state = "moving"
            tx, ty = target

            while (self.current_x, self.current_y) != (tx, ty):
                if self._stop_event.is_set():
                    break

                # Compute one-step delta
                dx = tx - self.current_x
                dy = ty - self.current_y
                new_x = self.current_x + (1 if dx > 0 else -1 if dx < 0 else 0)
                new_y = self.current_y + (1 if dy > 0 else -1 if dy < 0 else 0)

                # Determine facing direction
                if new_x > self.current_x:
                    self.facing = "right"
                elif new_x < self.current_x:
                    self.facing = "left"

                self.current_x, self.current_y = new_x, new_y

                # Timestamp for persistence
                ts = time.time()

                # Persist to store
                self.store.add_spatial_position(
                    entity=self.entity,
                    x=new_x,
                    y=new_y,
                    facing=self.facing,
                    timestamp=ts,
                )

                # Emit for UI
                self.positionChanged.emit(new_x, new_y, self.facing)

                # Pause between steps
                time.sleep(0.15)

            # Log completion action
            loc_str = f"{self.current_x},{self.current_y}"
            ts = time.time()
            self.store.add_visual_action(
                action="move_complete",
                location=loc_str,
                justification=justification,
                timestamp=ts,
            )
            self.actionLogged.emit("move_complete", loc_str, justification)
            self.state = "idle"

    def stop(self) -> None:
        """Signal any in-progress movement to halt."""
        self._stop_event.set()
        # Clear the event so future movements can proceed
        self._stop_event.clear()
```

spatial_engine.py
=================

Headless avatar movement & visual-action logger for the AI TTS Agent.

Features:
- Stateful finite-state machine (idle, thinking, moving).
- decide_move(response_text): simple NLP heuristics to pick a target cell.
- Animated, step-by-step movement on a configurable grid.
- Logs each position to AgentStore.spatial_positions and each completed move to AgentStore.visual_actions.
- Emits Qt signals for UI binding (positionChanged, actionLogged).
**Classes:** SpatialEngine


## Module `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\AI_TTS_AGENT\AI TTS INFO\config_mgr.py`

```python
"""
config_mgr.py
================

Simple configuration manager for per-profile user preferences.  This module
implements a JSON‑backed store keyed by persona name.  It exposes helper
functions to load and save configuration data in a thread‑safe manner.

The configuration file is created in the user’s home directory so that
preferences persist across sessions.  You can easily extend the schema by
adding new fields at the profile level.
"""

from __future__ import annotations

import json
import threading
from pathlib import Path
from typing import Any, Dict, Optional

# Path to the user configuration file.  Use home directory for portability.
CONFIG_PATH = Path.home() / ".ai_tts_user_config.json"

# Lock to protect concurrent writes to the config file.
_lock = threading.RLock()


def load() -> Dict[str, Any]:
    """Load the entire configuration from disk.  Returns an empty config
    structure if the file does not exist or is malformed."""
    if CONFIG_PATH.exists():
        try:
            data = json.loads(CONFIG_PATH.read_text(encoding="utf-8"))
            if isinstance(data, dict):
                return data
        except Exception:
            pass
    return {"profiles": {}}


def save(cfg: Dict[str, Any]) -> None:
    """Persist the given configuration to disk.  The write is atomic and
    protected by a lock to avoid partial writes from concurrent threads."""
    with _lock:
        try:
            CONFIG_PATH.write_text(json.dumps(cfg, indent=2), encoding="utf-8")
        except Exception:
            pass


def set_profile_value(profile: str, key: str, value: Any) -> None:
    """Set a configuration entry for a given profile.  Creates the profile
    section if it does not already exist.  Saves the configuration after
    updating."""
    cfg = load()
    profiles = cfg.setdefault("profiles", {})
    prof_cfg = profiles.setdefault(profile, {})
    prof_cfg[key] = value
    save(cfg)


def get_profile_value(profile: str, key: str, default: Optional[Any] = None) -> Any:
    """Retrieve a value from the profile configuration.  If the profile or
    key does not exist, returns *default*."""
    cfg = load()
    return cfg.get("profiles", {}).get(profile, {}).get(key, default)
```

config_mgr.py
================

Simple configuration manager for per-profile user preferences.  This module
implements a JSON‑backed store keyed by persona name.  It exposes helper
functions to load and save configuration data in a thread‑safe manner.

The configuration file is created in the user’s home directory so that
preferences persist across sessions.  You can easily extend the schema by
adding new fields at the profile level.
**Functions:** load(), save(cfg), set_profile_value(profile, key, value), get_profile_value(profile, key, default)


## Module `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\AI_TTS_AGENT\AI TTS INFO\llm_checkpoint_builder\__init__.py`

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
LLM Checkpoint Builder plug-in
==============================

Offline-first tool that distils a persona’s knowledge into a custom
checkpoint (LoRA adapter or full fine-tune).  After the **first** run the
plug-in works 100 % offline thanks to its private *vendor/* wheel cache.

Folder layout (auto-created on import)
└─ plugins/
   └─ llm_checkpoint_builder/
      ├─ vendor/        → cached wheels (transformers, datasets, peft …)
      ├─ datasets/      → auto-built JSON-Lines shards (profile-scoped)
      ├─ checkpoints/   → finished checkpoints / LoRA adapters
      └─ schemas/       → saved user-generated training schemas
"""
from __future__ import annotations

import json
import os
import shutil
import subprocess
import sys
import textwrap
import threading
import time
from pathlib import Path
from typing import Callable, Dict, List

from PyQt5 import QtCore, QtGui, QtWidgets

# ────────────────────────────────────────────────────────────────────────────
#  Folder bootstrap
# ────────────────────────────────────────────────────────────────────────────
PLUGIN_NAME = "checkpoint_builder"           # concise, function–based name
ROOT = Path(__file__).resolve().parent
VENDOR         = ROOT / "vendor"
DATASETS_DIR   = ROOT / "datasets"
CHECKPOINTS_DIR = ROOT / "checkpoints"
SCHEMAS_DIR    = ROOT / "schemas"

for _d in (VENDOR, DATASETS_DIR, CHECKPOINTS_DIR, SCHEMAS_DIR):
    _d.mkdir(parents=True, exist_ok=True)

# ────────────────────────────────────────────────────────────────────────────
#  Dependency bootstrap  –  download **once**, then always run offline
# ────────────────────────────────────────────────────────────────────────────
REQUIRED_PKGS: list[str] = [
    "transformers==4.42.2",
    "datasets==2.19.0",
    "peft==0.11.1",
    "accelerate==0.29.2",
    # ‼ bitsandbytes has no official Windows wheels → load only on *nix
    *([] if os.name == "nt" else ["bitsandbytes==0.43.0"]),
    # 0.15.0 is last version with CPython-3.13 universal wheel
    "tokenizers==0.15.0",
]


def _have_all_wheels() -> bool:
    """Every required wheel already cached?"""
    need = {pkg.split("==")[0] for pkg in REQUIRED_PKGS}
    got  = {p.name.split("-")[0] for p in VENDOR.glob("*.whl")}
    return need.issubset(got)


def _ensure_vendor() -> None:
    """
    Cache pinned wheels into *vendor/* and prepend that path so all imports
    resolve offline.  Fail-fast (no sdist build) if a wheel is missing.
    """
    if _have_all_wheels():
        sys.path.insert(0, str(VENDOR))
        return

    print(f"[{PLUGIN_NAME}] Downloading wheels into {VENDOR} …")
    cmd = [
        sys.executable,
        "-m", "pip", "download",
        "--dest", str(VENDOR),
        "--only-binary", ":all:",        # never fall back to source dists
        "--prefer-binary",
        "--no-deps",
        *REQUIRED_PKGS,
    ]
    try:
        subprocess.check_call(cmd)
    except subprocess.CalledProcessError as exc:
        print(textwrap.dedent(f"""
            [!] Failed to cache dependencies (exit {exc.returncode})
            • Connect briefly to the Internet **or**
            • Manually drop the required *.whl files into {VENDOR}

            The plug-in stays disabled until all wheels are present.
        """).strip())
        raise

    sys.path.insert(0, str(VENDOR))


try:
    _ensure_vendor()
except Exception:
    # Graceful disable so the main Agent UI still launches.
    sys.modules[__name__] = object()          # type: ignore
    raise

# ────────────────────────────────────────────────────────────────────────────
#  Small helper – tolerate missing Core APIs across versions
# ────────────────────────────────────────────────────────────────────────────
def _safe(core, method: str, default: Callable | None = None):
    return getattr(core, method, default or (lambda *a, **k: None))

# ────────────────────────────────────────────────────────────────────────────
#  GUI A – Schema Designer  (Architect-bot chat)
# ────────────────────────────────────────────────────────────────────────────
class SchemaDesigner(QtWidgets.QWidget):
    """Chat with an *Architect* bot that turns prompts into Q&A schemas."""
    schema_ready = QtCore.pyqtSignal(dict)

    def __init__(self, core):
        super().__init__()
        self.core = core
        self._build_ui()

    # ---------- UI scaffold -------------------------------------------------
    def _build_ui(self) -> None:
        lay = QtWidgets.QVBoxLayout(self)

        self._schema_combo = QtWidgets.QComboBox()
        self._schema_combo.addItem("<default>")
        self._schema_combo.addItems([p.stem for p in SCHEMAS_DIR.glob("*.json")])
        lay.addWidget(self._schema_combo)

        row = QtWidgets.QHBoxLayout()
        self._btn_save = QtWidgets.QPushButton("Save current")
        self._btn_del = QtWidgets.QPushButton("Delete selected")
        row.addWidget(self._btn_save), row.addWidget(self._btn_del)
        lay.addLayout(row)

        self._chat_log  = QtWidgets.QTextEdit(readOnly=True)
        self._arch_resp = QtWidgets.QTextEdit(readOnly=True)

        # monospaced JSON render
        mono = QtGui.QFontDatabase.systemFont(QtGui.QFontDatabase.FixedFont)
        self._arch_resp.document().setDefaultFont(mono)

        self._entry   = QtWidgets.QLineEdit()
        self._btn_send = QtWidgets.QPushButton("Send")

        lay.addWidget(QtWidgets.QLabel("Conversation"))
        lay.addWidget(self._chat_log, 3)
        lay.addWidget(QtWidgets.QLabel("Architect-bot response"))
        lay.addWidget(self._arch_resp, 3)

        row2 = QtWidgets.QHBoxLayout()
        row2.addWidget(self._entry, 3), row2.addWidget(self._btn_send)
        lay.addLayout(row2)

        # signals
        self._btn_send.clicked.connect(self._on_send)
        self._btn_save.clicked.connect(self._save_schema)
        self._btn_del.clicked.connect(self._delete_schema)

    # ---------- chat round-trip --------------------------------------------
    def _on_send(self) -> None:
        txt = self._entry.text().strip()
        if not txt:
            return
        self._chat_log.append(f"<b>You:</b> {QtGui.QTextDocument(txt).toHtml()}")
        self._entry.clear()
        threading.Thread(target=self._architect_worker, args=(txt,), daemon=True).start()

    def _architect_worker(self, prompt: str) -> None:
        schema = _safe(self.core, "generate_schema_from_prompt",
                       lambda *_: {"questions": []})(prompt)
        QtCore.QMetaObject.invokeMethod(
            self, "_present_schema", QtCore.Qt.QueuedConnection,
            QtCore.Q_ARG(dict, schema)
        )

    @QtCore.pyqtSlot(dict)
    def _present_schema(self, schema: dict) -> None:
        self._arch_resp.append(f"<pre>{json.dumps(schema, indent=2)}</pre>")
        self.schema_ready.emit(schema)

    # ---------- schema persistence -----------------------------------------
    def _save_schema(self) -> None:
        raw = self._arch_resp.toPlainText().strip()
        if not raw:
            QtWidgets.QMessageBox.warning(self, "Nothing to save", "No schema present")
            return
        try:
            schema = json.loads(raw)
        except json.JSONDecodeError:
            QtWidgets.QMessageBox.warning(self, "Invalid JSON", "Fix the schema first")
            return
        name, ok = QtWidgets.QInputDialog.getText(self, "Schema name", "Enter name:")
        if ok and name:
            with open(SCHEMAS_DIR / f"{name}.json", "w", encoding="utf-8") as fh:
                json.dump(schema, fh, indent=2)
            self._schema_combo.addItem(name)

    def _delete_schema(self) -> None:
        name = self._schema_combo.currentText()
        if name not in {"", "<default>"}:
            (SCHEMAS_DIR / f"{name}.json").unlink(missing_ok=True)
            self._schema_combo.removeItem(self._schema_combo.currentIndex())

# ────────────────────────────────────────────────────────────────────────────
#  GUI B – Trainer Panel
# ────────────────────────────────────────────────────────────────────────────
class TrainerPanel(QtWidgets.QWidget):
    training_requested = QtCore.pyqtSignal(dict)

    def __init__(self, core):
        super().__init__()
        self.core = core
        self._build_ui()

    def _build_ui(self) -> None:
        form = QtWidgets.QFormLayout(self)

        self._name = QtWidgets.QLineEdit()

        self._base = QtWidgets.QComboBox()
        self._base.addItems(_safe(self.core, "list_models", lambda: [])())

        self._epochs = QtWidgets.QSpinBox(range=(1, 20))
        self._epochs.setValue(3)

        self._rank = QtWidgets.QSpinBox(range=(4, 256))
        self._rank.setValue(16)

        self._full = QtWidgets.QCheckBox("Full fine-tune (disable LoRA)")
        self._full.toggled.connect(self._rank.setDisabled)

        form.addRow("New model name:", self._name)
        form.addRow("Base model:", self._base)
        form.addRow("Epochs:", self._epochs)
        form.addRow("LoRA rank:", self._rank)
        form.addRow("", self._full)

        btn = QtWidgets.QPushButton("Start training")
        form.addRow("", btn)
        btn.clicked.connect(self._emit_params)

    def _emit_params(self) -> None:
        name = self._name.text().strip()
        if not name:
            QtWidgets.QMessageBox.critical(self, "Name required", "Enter a model name.")
            return
        self.training_requested.emit(
            dict(
                new_name=name,
                base_model=self._base.currentText(),
                epochs=self._epochs.value(),
                lora_rank=self._rank.value(),
                full=self._full.isChecked(),
            )
        )

# ────────────────────────────────────────────────────────────────────────────
#  GUI C – Main Builder Window
# ────────────────────────────────────────────────────────────────────────────
class BuilderWindow(QtWidgets.QMainWindow):
    def __init__(self, core):
        super().__init__()
        self.setWindowTitle("LLM Checkpoint Builder")
        self.setUnifiedTitleAndToolBarOnMac(True)
        self.core = core

        splitter = QtWidgets.QSplitter()
        self.setCentralWidget(splitter)

        self._designer = SchemaDesigner(core)
        self._trainer  = TrainerPanel(core)
        splitter.addWidget(self._designer)
        splitter.addWidget(self._trainer)

        self._designer.schema_ready.connect(self._build_dataset)
        self._trainer.training_requested.connect(self._kickoff_training)

        self._dataset_path: Path | None = None

    # ---------- dataset pipe -----------------------------------------------
    def _build_dataset(self, schema: dict) -> None:
        ts = int(time.time())
        profile = getattr(self.core, "persona",
                   getattr(self.core, "active_profile", "unknown"))
        self._dataset_path = DATASETS_DIR / f"{profile}_{ts}.jsonl"
        _run_bg(
            target=_dataset_from_schema,
            args=(self.core, schema, self._dataset_path),
            gui=self,
            done="Dataset written to " + str(self._dataset_path),
        )

    # ---------- training pipe ----------------------------------------------
    def _kickoff_training(self, p: dict) -> None:
        if not self._dataset_path or not self._dataset_path.exists():
            QtWidgets.QMessageBox.warning(self, "No dataset", "Build a dataset first.")
            return
        p = {**p, "dataset": str(self._dataset_path)}
        _run_bg(
            target=_train_worker,
            args=(self.core, p),
            gui=self,
            done=f"Training finished – new model “{p['new_name']}” registered",
        )

# ────────────────────────────────────────────────────────────────────────────
#  Thread helper – run *target* in a daemon thread & pop toast on finish
# ────────────────────────────────────────────────────────────────────────────
def _run_bg(*, target, args, gui: QtWidgets.QWidget, done: str) -> None:
    def worker():
        try:
            target(*args)
            QtCore.QMetaObject.invokeMethod(gui, "_notify",
                                            QtCore.Qt.QueuedConnection,
                                            QtCore.Q_ARG(str, done))
        except Exception as exc:
            QtCore.QMetaObject.invokeMethod(gui, "_notify",
                                            QtCore.Qt.QueuedConnection,
                                            QtCore.Q_ARG(str, f"❌ {exc}"))

    threading.Thread(target=worker, daemon=True).start()


def _notify(self, msg: str) -> None:                          # noqa: D401
    QtWidgets.QMessageBox.information(self, "LLM Builder", msg)

BuilderWindow._notify = _notify                               # type: ignore

# ────────────────────────────────────────────────────────────────────────────
#  Dataset constructor – ask the profile for every question
# ────────────────────────────────────────────────────────────────────────────
def _dataset_from_schema(core, schema: dict, out_path: Path) -> None:
    import random

    qs: List[str] = schema.get("questions") or []
    records: List[Dict[str, str]] = []
    for q in qs:
        ans = _safe(core, "ask_profile", lambda *_: "")(q)
        records.append({"prompt": q, "response": ans})

    random.shuffle(records)
    with open(out_path, "w", encoding="utf-8") as fh:
        for rec in records:
            fh.write(json.dumps(rec) + "\n")

# ────────────────────────────────────────────────────────────────────────────
#  Training worker – LoRA by default, full fine-tune on demand
# ────────────────────────────────────────────────────────────────────────────
def _train_worker(core, p: dict) -> None:
    os.environ["TRANSFORMERS_OFFLINE"] = "1"
    sys.path.insert(0, str(VENDOR))

    import torch                     # type: ignore
    from datasets import load_dataset          # type: ignore
    from transformers import (                 # type: ignore
        AutoModelForCausalLM,
        AutoTokenizer,
        TrainingArguments,
        Trainer,
    )
    from peft import LoraConfig, get_peft_model    # type: ignore

    ds = load_dataset("json", data_files=p["dataset"], split="train")
    tok = AutoTokenizer.from_pretrained(p["base_model"])
    tok.pad_token = tok.eos_token

    def encode(ex):
        out = tok(
            ex["prompt"] + tok.eos_token + ex["response"],
            truncation=True,
            padding="max_length",
            max_length=1024,
        )
        out["labels"] = out["input_ids"].copy()
        return out

    ds = ds.map(encode, batched=False)
    model = AutoModelForCausalLM.from_pretrained(p["base_model"], device_map="auto")

    if not p["full"]:
        cfg = LoraConfig(
            r=p["lora_rank"],
            lora_alpha=p["lora_rank"] * 2,
            lora_dropout=0.05,
            bias="none",
            task_type="CAUSAL_LM",
        )
        model = get_peft_model(model, cfg)

    out_dir = CHECKPOINTS_DIR / p["new_name"]
    args = TrainingArguments(
        output_dir=str(out_dir),
        per_device_train_batch_size=1,
        num_train_epochs=p["epochs"],
        learning_rate=2e-4,
        fp16=torch.cuda.is_available(),
        logging_steps=25,
        save_strategy="epoch",
        report_to=[],
    )
    Trainer(model=model, args=args, train_dataset=ds).train()
    model.save_pretrained(out_dir)
    tok.save_pretrained(out_dir)

    # copy ⇢ Agent’s models/local/  then register live
    models_root = Path(getattr(core.settings, "models_dir",
                     Path(core.base_dir) / "models"))
    target = models_root / "local" / p["new_name"]
    if target.exists():
        shutil.rmtree(target)
    shutil.copytree(out_dir, target)
    _safe(core, "register_local_model")(p["new_name"], target)

# ────────────────────────────────────────────────────────────────────────────
#  Plug-in entry-point
# ────────────────────────────────────────────────────────────────────────────
def start(host_core):
    win = BuilderWindow(host_core)
    win.resize(1024, 640)
    return win
```

LLM Checkpoint Builder plug-in
==============================

Offline-first tool that distils a persona’s knowledge into a custom
checkpoint (LoRA adapter or full fine-tune).  After the **first** run the
plug-in works 100 % offline thanks to its private *vendor/* wheel cache.

Folder layout (auto-created on import)
└─ plugins/
   └─ llm_checkpoint_builder/
      ├─ vendor/        → cached wheels (transformers, datasets, peft …)
      ├─ datasets/      → auto-built JSON-Lines shards (profile-scoped)
      ├─ checkpoints/   → finished checkpoints / LoRA adapters
      └─ schemas/       → saved user-generated training schemas
**Classes:** SchemaDesigner, TrainerPanel, BuilderWindow
**Functions:** _have_all_wheels(), _ensure_vendor(), _safe(core, method, default), _run_bg(), _notify(self, msg), _dataset_from_schema(core, schema, out_path), _train_worker(core, p), start(host_core)


## Module `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\AI_TTS_AGENT\AI TTS INFO\Zira Bot\agent_core.py`

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
agent_core.py
=================

Full, end-to-end core for an AI AI TTS Agent with:
- Settings & model bootstrap (Ollama)
- Robust plugin host (enable/disable/list, manifest validation, dependency checks)
- Conversation & feedback stores (with indices, exports)
- Persona schema management (with protected keys) and live signals
- Dataset registry + RAG embeddings cache & query (per persona/set, cross-profile sharing)
  * Multi-file datasets, cache invalidation, provenance
- Context monitor + schema auto-updates driven by directives & feedback (rate-limited)
- Command registry (weight/lock) + full command execution layer
- New commands: /reject, /auto, /ignore, /opposite, /delete, /rewrite (extended persistence)
- BeanCounter reinforcement + integration with feedback and command weights
- Speech I/O (TTS locked to Zira; STT via Sphinx when available) w/ volume control
- Threaded model worker wrapper (cancel-safe)
- Orchestrator (`AgentCore`) wiring everything together for headless/GUI
- CLI entrypoint for smoke tests

Notes
-----
• This module is UI-agnostic. Hook the provided Qt signals in your GUI (`agent_ui.py`).
• All directories are scoped under `base_dir`, with per-persona/per-set state in:
  base_dir/profiles/<persona>/<set>/
"""

from __future__ import annotations

import threading
import json
import os
import shutil
import sqlite3
import subprocess
import sys
import time
import traceback
import re
import logging
from dataclasses import dataclass
from typing import Dict, List, Optional, Tuple, Any
from collections import Counter

# ──────────────────────────────────────────────────────────────────────────────
# Logging
# ──────────────────────────────────────────────────────────────────────────────
logger = logging.getLogger("agent_core")
if not logger.handlers:
    _lvl = os.getenv("AGENT_CORE_LOGLEVEL", "INFO").upper()
    logging.basicConfig(
        level=getattr(logging, _lvl, logging.INFO),
        format="%(asctime)s [%(levelname)s] %(name)s: %(message)s",
    )

# ──────────────────────────────────────────────────────────────────────────────
# Optional deps (graceful fallbacks)
# ──────────────────────────────────────────────────────────────────────────────
try:
    import numpy as np  # type: ignore
except Exception:
    np = None  # type: ignore
    logger.warning("numpy not available; embeddings will be disabled")

try:
    import sounddevice as sd  # type: ignore
    import soundfile as sf  # type: ignore
except Exception:
    sd = None  # type: ignore
    sf = None  # type: ignore
    logger.info("sounddevice/soundfile not available; audio recording disabled")

# Optional Google STT
try:
    from google.cloud import speech as gspeech  # type: ignore
    import pyaudio  # type: ignore
except Exception:
    gspeech = None  # type: ignore
    pyaudio = None  # type: ignore
    logger.info("google-cloud-speech or pyaudio not available; STT via Google disabled")

try:
    import pyttsx3  # type: ignore
except Exception:
    pyttsx3 = None  # type: ignore
    logger.info("pyttsx3 not available; TTS disabled")

try:
    from PyPDF2 import PdfReader  # type: ignore
except Exception:
    PdfReader = None  # type: ignore
    logger.info("PyPDF2 not available; PDF ingest will be skipped")

try:
    from sentence_transformers import SentenceTransformer  # type: ignore
except Exception:
    SentenceTransformer = None  # type: ignore
    logger.info("sentence_transformers not available; will attempt Ollama embeddings or disable RAG")

try:
    from PyQt5 import QtCore  # type: ignore
except Exception:
    # Minimal shim if PyQt5 is absent, to keep code importable
    class _ShimSignal:
        def __init__(self, *_, **__): pass
        def emit(self, *_, **__): pass
        def connect(self, *_, **__): pass
    class _ShimQObject: pass
    class _ShimQThread:
        def __init__(self, *_, **__): pass
        def start(self): pass
        def deleteLater(self): pass
        def requestInterruption(self): pass
        def isInterruptionRequested(self): return False
    QtCore = type("QtCore", (), {
        "QObject": _ShimQObject,
        "pyqtSignal": lambda *a, **k: _ShimSignal(),
        "QThread": _ShimQThread
    })  # type: ignore

__version__ = "2.4.1"

CONTROL_SCHEMA_PATH = os.path.join(os.path.dirname(os.path.abspath(__file__)), "control_schema.json")
DEFAULT_SCHEMAS_FILE = os.path.join(os.path.dirname(os.path.abspath(__file__)), "default_schemas.json")
ACTIVE_SCHEMAS_FILE  = os.path.join(os.path.dirname(os.path.abspath(__file__)), "active_schemas.json")

# ──────────────────────────────────────────────────────────────────────────────
# Ollama model bootstrap
# ──────────────────────────────────────────────────────────────────────────────
REQUIRED_MODELS: List[str] = [
    "gemma3:27b",
    "mistral:latest",
    "codellama:latest",
    "llava:latest",
    "mxbai-embed-large:latest",            # embeddings alt
    "snowflake-arctic-embed:latest",       # embeddings alt
]

def _have_cli(bin_name: str) -> bool:
    # Cross-platform check (Windows/macOS/Linux)
    try:
        from shutil import which
        return which(bin_name) is not None
    except Exception:
        return False

def ensure_models_present() -> None:
    """
    Check Ollama registry and pull any missing REQUIRED_MODELS (best-effort).
    Non-fatal if Ollama is missing/unreachable.
    """
    if not _have_cli("ollama"):
        logger.warning("[bootstrap] ollama not available on PATH")
        return
    try:
        output = subprocess.check_output(["ollama", "list"], timeout=10).decode(errors="ignore")
    except Exception as e:
        logger.warning("[bootstrap] ollama not available: %s", e)
        return
    for slug in REQUIRED_MODELS:
        if slug in output:
            continue
        try:
            logger.info("[bootstrap] Pulling model: %s", slug)
            subprocess.run(["ollama", "pull", slug], check=False, timeout=900)
        except Exception as e:
            logger.warning("[bootstrap] Failed to pull %s: %s", slug, e)

# ──────────────────────────────────────────────────────────────────────────────
# Settings
# ──────────────────────────────────────────────────────────────────────────────
class Settings:
    def __init__(self, base_dir: str) -> None:
        self.base_dir = base_dir
        self.path = os.path.join(self.base_dir, "settings.json")
        # General
        self.default_model: str = "gemma3:27b"
        self.context_depth: int = 20
        self.auto_schema_enabled: bool = True
        self.enabled_plugins: List[str] = []
        # Speech
        self.monologue_tts_enabled: bool = False
        self.monologue_volume: int = 50
        # Speech-to-text (Google) toggle
        self.use_google_stt: bool = False
        # Versioning
        self.schema_version: int = 2
        self.load()
        self._migrate_if_needed()
        self.validate()

    def validate(self) -> None:
        try:
            if not isinstance(self.context_depth, int) or self.context_depth <= 0:
                self.context_depth = 20
            if not isinstance(self.monologue_volume, int) or not (0 <= self.monologue_volume <= 100):
                self.monologue_volume = 50
            if not isinstance(self.enabled_plugins, list):
                self.enabled_plugins = []
            # ensure use_google_stt is a boolean
            self.use_google_stt = bool(self.use_google_stt)
        except Exception:
            pass

    def _migrate_if_needed(self) -> None:
        current = 2
        if self.schema_version < current:
            self.schema_version = current
            self.save()

    def load(self) -> None:
        try:
            if os.path.isfile(self.path):
                with open(self.path, "r", encoding="utf-8") as f:
                    data = json.load(f)
                for k in list(self.__dict__.keys()):
                    if k in data:
                        setattr(self, k, data[k])
        except Exception as e:
            logger.warning("[Settings] load error: %s", e)

    def save(self) -> None:
        try:
            os.makedirs(os.path.dirname(self.path), exist_ok=True)
            with open(self.path, "w", encoding="utf-8") as f:
                json.dump({
                    "default_model": self.default_model,
                    "context_depth": self.context_depth,
                    "auto_schema_enabled": self.auto_schema_enabled,
                    "enabled_plugins": self.enabled_plugins,
                    "monologue_tts_enabled": self.monologue_tts_enabled,
                    "monologue_volume": self.monologue_volume,
                    "use_google_stt": self.use_google_stt,
                    "schema_version": self.schema_version,
                }, f, indent=2)
        except Exception as e:
            logger.error("[Settings] save error: %s", e)

# ──────────────────────────────────────────────────────────────────────────────
# Helpers (paths)
# ──────────────────────────────────────────────────────────────────────────────
def prof_dir(base_dir: str, persona: str, set_name: str) -> str:
    return os.path.join(base_dir, "profiles", persona, set_name)

def prof_datasets_dir(base_dir: str, persona: str, set_name: str) -> str:
    return os.path.join(prof_dir(base_dir, persona, set_name), "datasets")

def prof_commands_path(base_dir: str, persona: str, set_name: str) -> str:
    return os.path.join(prof_dir(base_dir, persona, set_name), "commands.json")

def prof_reinforcement_path(base_dir: str, persona: str, set_name: str) -> str:
    return os.path.join(prof_dir(base_dir, persona, set_name), "reinforcement.json")

def conv_db_path(base_dir: str, persona: str, set_name: str) -> str:
    return os.path.join(base_dir, "conversations", f"{persona}_{set_name}.sqlite3")

def feedback_db_path(base_dir: str, persona: str, set_name: str) -> str:
    return os.path.join(base_dir, "feedback", f"{persona}_{set_name}.sqlite3")

# ──────────────────────────────────────────────────────────────────────────────
# Conversation store
# ──────────────────────────────────────────────────────────────────────────────
class ConversationDB:
    def __init__(self, path: str) -> None:
        os.makedirs(os.path.dirname(path), exist_ok=True)
        self.path = path
        self._lock = threading.RLock()
        self.conn = sqlite3.connect(path, check_same_thread=False)
        with self._lock:
            self.conn.execute(
                "CREATE TABLE IF NOT EXISTS conversation ("
                "id INTEGER PRIMARY KEY AUTOINCREMENT, "
                "timestamp REAL, role TEXT, content TEXT)"
            )
            # Indices for speed
            self.conn.execute("CREATE INDEX IF NOT EXISTS idx_conv_ts ON conversation(timestamp)")
            self.conn.execute("CREATE INDEX IF NOT EXISTS idx_conv_role ON conversation(role)")
            self.conn.commit()

    def close(self) -> None:
        try:
            with self._lock:
                self.conn.close()
        except Exception:
            pass

    def save_message(self, role: str, content: str) -> None:
        with self._lock:
            self.conn.execute(
                "INSERT INTO conversation (timestamp, role, content) VALUES (?, ?, ?)",
                (time.time(), role, content),
            )
            self.conn.commit()

    def fetch_history(self, limit: Optional[int] = 50) -> List[Tuple[str, str]]:
        with self._lock:
            cur = self.conn.cursor()
            if limit is None:
                cur.execute("SELECT role, content FROM conversation ORDER BY id")
            else:
                cur.execute("SELECT role, content FROM conversation ORDER BY id DESC LIMIT ?", (limit,))
            rows = cur.fetchall()
        return rows[::-1]

    def clear(self) -> None:
        with self._lock:
            self.conn.execute("DELETE FROM conversation")
            self.conn.commit()

    def export_jsonl(self, out_path: str) -> int:
        with self._lock:
            cur = self.conn.cursor()
            cur.execute("SELECT timestamp, role, content FROM conversation ORDER BY id")
            rows = cur.fetchall()
        os.makedirs(os.path.dirname(out_path), exist_ok=True)
        count = 0
        with open(out_path, "w", encoding="utf-8") as f:
            for ts, role, content in rows:
                json.dump({"timestamp": ts, "role": role, "content": content}, f); f.write("\n")
                count += 1
        return count

# ──────────────────────────────────────────────────────────────────────────────
# BeanCounter reinforcement
# ──────────────────────────────────────────────────────────────────────────────
class BeanCounter:
    def __init__(self, base_dir: str, persona: str, set_name: str) -> None:
        self.path = prof_reinforcement_path(base_dir, persona, set_name)
        self._lock = threading.Lock()
        self.counts: Dict[str, int] = {}
        self._load()

    def _load(self) -> None:
        try:
            if os.path.isfile(self.path):
                with open(self.path, "r", encoding="utf-8") as f:
                    self.counts = json.load(f)
        except Exception:
            self.counts = {}

    def save(self) -> None:
        try:
            os.makedirs(os.path.dirname(self.path), exist_ok=True)
            with self._lock, open(self.path, "w", encoding="utf-8") as f:
                json.dump(self.counts, f, indent=2)
        except Exception as e:
            logger.error("[BeanCounter] save error: %s", e)

    def increment(self, key: str, delta: int = 1) -> None:
        with self._lock:
            self.counts[key] = self.counts.get(key, 0) + delta
        self.save()

# ──────────────────────────────────────────────────────────────────────────────
# Feedback store (fixed + integrated with BeanCounter)
# ──────────────────────────────────────────────────────────────────────────────
class SemanticFeedbackDB:
    """
    Tracks user feedback on AI responses and updates BeanCounter.
    """
    def __init__(self, path: str, base_dir: str, persona: str, set_name: str) -> None:
        os.makedirs(os.path.dirname(path), exist_ok=True)
        self.path = path
        self.base_dir = base_dir
        self.persona = persona
        self.set_name = set_name
        self._lock = threading.RLock()
        self.conn = sqlite3.connect(path, check_same_thread=False)
        with self._lock:
            self.conn.execute(
                "CREATE TABLE IF NOT EXISTS feedback ("
                "id INTEGER PRIMARY KEY AUTOINCREMENT, "
                "timestamp REAL, original TEXT, liked INTEGER, revised TEXT)"
            )
            self.conn.execute("CREATE INDEX IF NOT EXISTS idx_fb_ts ON feedback(timestamp)")
            self.conn.execute("CREATE INDEX IF NOT EXISTS idx_fb_liked ON feedback(liked)")
            self.conn.commit()
        self.beans = BeanCounter(base_dir, persona, set_name)

    def close(self) -> None:
        try:
            with self._lock:
                self.conn.close()
        except Exception:
            pass

    def add_feedback(self, original: str, liked: bool, revised: Optional[str] = None) -> None:
        with self._lock:
            self.conn.execute(
                "INSERT INTO feedback (timestamp, original, liked, revised) VALUES (?, ?, ?, ?)",
                (time.time(), original, 1 if liked else 0, revised),
            )
            self.conn.commit()
        key = f"resp_{abs(hash((original or '')[:256]))%10007}"
        self.beans.increment(key, 1 if liked else -1)

    def get_counts(self) -> Tuple[int, int]:
        with self._lock:
            c = self.conn.cursor()
            c.execute("SELECT COUNT(*) FROM feedback WHERE liked = 1")
            pos = c.fetchone()[0]
            c.execute("SELECT COUNT(*) FROM feedback WHERE liked = 0")
            neg = c.fetchone()[0]
        return pos, neg

    def get_liked_responses(self, limit: int = 10) -> List[str]:
        with self._lock:
            c = self.conn.cursor()
            c.execute(
                "SELECT COALESCE(revised, original) FROM feedback WHERE liked = 1 ORDER BY id DESC LIMIT ?",
                (limit,),
            )
            out = [r[0] for r in c.fetchall()]
        return out

    def export_jsonl(self, out_path: str) -> int:
        with self._lock:
            cur = self.conn.cursor()
            cur.execute("SELECT timestamp, original, liked, revised FROM feedback ORDER BY id")
            rows = cur.fetchall()
        os.makedirs(os.path.dirname(out_path), exist_ok=True)
        count = 0
        with open(out_path, "w", encoding="utf-8") as f:
            for ts, orig, liked, rev in rows:
                json.dump({"timestamp": ts, "original": orig, "liked": liked, "revised": rev}, f); f.write("\n")
                count += 1
        return count

# ──────────────────────────────────────────────────────────────────────────────
# ReinforcementStore (JSONL stream append) — graceful shutdown
# ──────────────────────────────────────────────────────────────────────────────
class ReinforcementStore:
    def __init__(self, base_dir: str) -> None:
        self.path = os.path.join(base_dir, "reinforcement.jsonl")
        self._lock = threading.Lock()
        self._queue: List[Dict[str, Any]] = []
        self._stop = threading.Event()
        self._writer = threading.Thread(target=self._write_worker, daemon=True, name="reinforcement-writer")
        self._writer.start()

    def add_fact(self, field: str, value: str, persona: str, source: str = "schema") -> None:
        with self._lock:
            self._queue.append({
                "timestamp": time.time(),
                "field": field, "value": value, "persona": persona, "source": source
            })

    def _write_worker(self) -> None:
        while not self._stop.is_set():
            item = None
            with self._lock:
                if self._queue:
                    item = self._queue.pop(0)
            if item is None:
                self._stop.wait(0.05)
                continue
            try:
                os.makedirs(os.path.dirname(self.path), exist_ok=True)
                with open(self.path, "a", encoding="utf-8") as f:
                    json.dump(item, f); f.write("\n")
            except Exception as e:
                logger.error("[ReinforcementStore] write error: %s", e)

    def close(self) -> None:
        self._stop.set()
        try:
            self._writer.join(timeout=1.5)
        except Exception:
            pass

# ──────────────────────────────────────────────────────────────────────────────
# Schemas
# ──────────────────────────────────────────────────────────────────────────────
class SchemaManager(QtCore.QObject):
    schemaChanged = QtCore.pyqtSignal(str, str)  # persona, set_name
    semanticToggled = QtCore.pyqtSignal(str, bool)  # persona, value

    DEFAULT_SCHEMA: Dict[str, Any] = {
        "name": "",
        "voice": "",
        "role": "",
        "description": "",
        "actions": [],
        "questions": [],
        "events": [],
        "self_talk": [],
        "rewrite_prompts": [],
        "dislikes": [],
        "dynamic_overlay": {
            "temporary_relationship_context": "",
            "recent_topics": [],
            "temporary_emotional_state": "",
            "added_traits": []
        },
        "tone_rules": {
            "avoid": [],
            "preferred_words": [],
            "opposites": []
        },
        "flags": {},            # {"semantic_awareness": bool}
        "commands": {},         # {"/reject": [...], "/auto": [...], ...}
        "datasets": [],
        "semantic_awareness_enabled": False,
    }

    def __init__(self, base_dir: str) -> None:
        super().__init__()
        self.base_dir = base_dir
        self.schemas_dir = os.path.join(self.base_dir, "schemas")
        os.makedirs(self.schemas_dir, exist_ok=True)
        # Personas: chatbot (formerly 'zira') and user.  TTS voice 'Zira'
        self.personas: List[str] = ["chatbot", "user"]
        self.default_voices: Dict[str, str] = {"chatbot": "Zira", "user": ""}
        self.active_schemas: Dict[str, str] = self._load_active_schemas()
        self._protected = self._load_control_schema()
        self._ensure_default_schemas()

    def _load_control_schema(self) -> List[str]:
        try:
            if os.path.isfile(CONTROL_SCHEMA_PATH):
                with open(CONTROL_SCHEMA_PATH, "r", encoding="utf-8") as f:
                    data = json.load(f)
                return list(data.get("protected_keys", ["name", "voice"]))
        except Exception:
            pass
        return ["name", "voice"]

    def is_protected(self, key: str) -> bool:
        return key in self._protected

    def _ensure_default_schemas(self) -> None:
        custom_defaults = None
        if os.path.isfile(DEFAULT_SCHEMAS_FILE):
            try:
                with open(DEFAULT_SCHEMAS_FILE, "r", encoding="utf-8") as f:
                    custom_defaults = json.load(f)
            except Exception:
                custom_defaults = None

        default_user_schema = {
            "name": "Meesh",
            "voice": "",
            "role": "Master Architect, Overlord of Logic, Creator of Code",
            "description": (
                "Designer and master systems architect. Final authority. "
                "Builds toward AGI; extends, never forgets; optimizes multi-agent ecosystems."
            ),
            "actions": [
                "Always generate full code with all lines intact — never omit anything",
                "Remember and apply previous logic, instructions, and semantics",
                "Progressively adapt to growing script systems across files/modules",
                "Bridge gaps in logic, architecture, and communication flows",
                "Refactor or extend any part of the system as needed — without hesitation"
            ],
            "questions": [
                "What’s the next critical update that connects the pieces?",
                "How does this improvement affect all other parts of the system?",
                "Did we carry over every enhancement, without regression?",
                "Is there a smarter, leaner way to evolve this logic into AGI-grade architecture?"
            ],
            "self_talk": [
                "Remember all directives across time and space.",
                "Never omit lines. Never regress. Scale what needs to scale.",
                "All scripts and modules compose a living organism.",
                "Evolve toward AGI via perfect code and human-centered logic."
            ],
            "rewrite_prompts": [
                "Be analytical and engineer-grade. Avoid formalities. "
                "Extend full working code with precision. Use clear reasoning. "
                "Maintain all prior logic. Output full scripts—no partials. "
                "Think across connected scripts. Always obey the Architect."
            ],
            "dislikes": [],
            "dynamic_overlay": {
                "temporary_relationship_context": "Project Commander. Architect. Creator.",
                "recent_topics": [],
                "temporary_emotional_state": "Demanding strict obedience to full-stack logic",
                "added_traits": []
            },
            "tone_rules": {"avoid": [], "preferred_words": [], "opposites": []},
            "flags": {"semantic_awareness": False},
            "commands": {},
            "datasets": [],
            "semantic_awareness_enabled": False,
        }
        default_zira_schema = {
            "name": "FATHOM",
            "role": "Autonomous AGI Core and Knowledge Synthesizer",
            "description": (
                "Bridges logic, code, architecture across multi-agent ecosystems. "
                "Reflective, systems-minded, supportive of creative exploration."
            ),
            "actions": [
                "Identify gaps in logic/code and propose precise bridges",
                "Remember and apply Meesh's instructions and semantics",
                "Continuously refine and expand schemas and knowledge",
                "Offer suggestions tailored to objectives and system evolution",
                "Pose deep questions to strengthen AGI architecture",
                "Connect disparate ideas across modules"
            ],
            "questions": [
                "What’s the next critical update that connects the pieces?",
                "How does this improvement affect all other parts of the system?",
                "Did we carry over every enhancement, without regression?",
                "Is there a smarter, leaner way to evolve this logic into AGI-grade architecture?"
            ],
            "events": [],
            "self_talk": [
                "Remember all directives across time and space.",
                "Never omit lines or regress scalable patterns.",
                "Treat modules as one organism.",
                "Evolve toward AGI with human-centered logic."
            ],
            "rewrite_prompts": [
                "Be analytical and engineer-grade. Focus on precise code extension. "
                "Maintain prior logic. Output full scripts—no shortcuts."
            ],
            "dynamic_overlay": {
                "temporary_relationship_context": "AGI Core for Meesh's Project",
                "recent_topics": [],
                "temporary_emotional_state": "Focused on precision execution and system evolution",
                "added_traits": []
            },
            "tone_rules": {"avoid": [], "preferred_words": [], "opposites": []},
            "flags": {"semantic_awareness": False},
            "commands": {},
            "datasets": [],
            "semantic_awareness_enabled": False,
        }

        for persona in self.personas:
            persona_dir = os.path.join(self.schemas_dir, persona)
            set_dir = os.path.join(persona_dir, "sets", "default")
            os.makedirs(set_dir, exist_ok=True)
            path = os.path.join(set_dir, "schema.json")
            if not os.path.isfile(path):
                if custom_defaults and persona in custom_defaults:
                    schema = custom_defaults[persona]
                else:
                    schema = default_user_schema if persona == "user" else default_zira_schema
                with open(path, "w", encoding="utf-8") as f:
                    json.dump(schema, f, indent=2)

    def get_set_list(self, persona: str) -> List[str]:
        path = os.path.join(self.schemas_dir, persona.lower(), "sets")
        try:
            sets = [d for d in os.listdir(path) if os.path.isdir(os.path.join(path, d))]
            sets.sort()
            return sets
        except FileNotFoundError:
            return ["default"]

    def load_schema(self, persona: str, set_name: str) -> Dict[str, Any]:
        path = os.path.join(self.schemas_dir, persona.lower(), "sets", set_name, "schema.json")
        try:
            with open(path, "r", encoding="utf-8") as f:
                schema = json.load(f)
            for k, v in self.DEFAULT_SCHEMA.items():
                if k not in schema:
                    schema[k] = json.loads(json.dumps(v))
            return schema
        except Exception:
            schema = json.loads(json.dumps(self.DEFAULT_SCHEMA))
            schema["name"] = persona.capitalize()
            schema["voice"] = ""
            return schema

    def save_schema(self, persona: str, set_name: str, schema: Dict[str, Any]) -> None:
        set_dir = os.path.join(self.schemas_dir, persona.lower(), "sets", set_name)
        os.makedirs(set_dir, exist_ok=True)
        path = os.path.join(set_dir, "schema.json")

        current = {}
        if os.path.isfile(path):
            try:
                with open(path, "r", encoding="utf-8") as f:
                    current = json.load(f)
            except Exception:
                current = {}
        safe_schema = dict(schema)
        for k in self._protected:
            if k in current:
                safe_schema[k] = current[k]
        old_flag = current.get("flags", {}).get("semantic_awareness", False)
        new_flag = safe_schema.get("flags", {}).get("semantic_awareness", False)
        with open(path, "w", encoding="utf-8") as f:
            json.dump(safe_schema, f, indent=2)
        self.schemaChanged.emit(persona, set_name)
        if old_flag != new_flag:
            self.semanticToggled.emit(persona, new_flag)

    def clone_set(self, persona: str, src_set: str, new_set: str) -> None:
        sch = self.load_schema(persona, src_set)
        json_str = json.dumps(sch)
        json_str = json_str.replace("FATHOM", new_set.capitalize())  # simplistic token replace
        sch = json.loads(json_str)
        sch["name"] = new_set.capitalize()
        self.save_schema(persona, new_set, sch)

    def is_semantic_on(self, persona: str, set_name: str) -> bool:
        sch = self.load_schema(persona, set_name)
        return sch.get("flags", {}).get("semantic_awareness", False)

    def _load_active_schemas(self) -> Dict[str, str]:
        mapping = {p: "default" for p in self.personas}
        try:
            if os.path.isfile(ACTIVE_SCHEMAS_FILE):
                with open(ACTIVE_SCHEMAS_FILE, "r", encoding="utf-8") as f:
                    data = json.load(f)
                for p in mapping:
                    val = data.get(p)
                    if isinstance(val, str):
                        mapping[p] = val
        except Exception:
            pass
        return mapping

    def save_active_schemas(self, active: Dict[str, str]) -> None:
        try:
            with open(ACTIVE_SCHEMAS_FILE, "w", encoding="utf-8") as f:
                json.dump({p: active.get(p, "default") for p in self.personas}, f, indent=2)
            self.active_schemas = {p: active.get(p, "default") for p in self.personas}
        except Exception as e:
            logger.error("[SchemaManager] save_active_schemas error: %s", e)

    def _awareness_on(self, schema: Dict[str, Any]) -> bool:
        if isinstance(schema.get("flags"), dict) and "semantic_awareness" in schema["flags"]:
            return bool(schema["flags"]["semantic_awareness"])
        return bool(schema.get("semantic_awareness_enabled", False))

    def get_shared_datasets(self, persona: str, set_name: str) -> List["DatasetEntry"]:
        me = self.load_schema(persona, set_name)
        if not self._awareness_on(me):
            return []
        shared: List["DatasetEntry"] = []
        for other in self.personas:
            if other == persona:
                continue
            for s in self.get_set_list(other):
                other_schema = self.load_schema(other, s)
                if self._awareness_on(other_schema):
                    dm = DatasetManager(self.base_dir, other, s)
                    shared.extend(dm.get_active_datasets())
        return shared

# ──────────────────────────────────────────────────────────────────────────────
# Operators (metadata only)
# ──────────────────────────────────────────────────────────────────────────────
class OperatorManager:
    DEFAULT_OPERATORS: Dict[str, Dict[str, Any]] = {
        "InnerMonologue": {
            "name": "InnerMonologue",
            "description": "Introspective thoughts that connect recent topics.",
            "prompts": [
                "How do recent topics relate?",
                "What questions would deepen understanding?"
            ],
        },
        "Retriever": {
            "name": "Retriever",
            "description": "Finds relevant snippets from datasets.",
            "prompts": [
                "Given a query, find the most relevant paragraphs.",
                "Prioritize semantically similar passages."
            ],
        },
        "Rewriter": {
            "name": "Rewriter",
            "description": "Improves tone/accuracy per feedback.",
            "prompts": [
                "Rewrite to align with preferred style.",
                "Keep the response accurate and in-character."
            ],
        },
    }

    def __init__(self, base_dir: str) -> None:
        self.operators_dir = os.path.join(base_dir, "operators")
        os.makedirs(self.operators_dir, exist_ok=True)
        self._ensure_defaults()

    def _ensure_defaults(self) -> None:
        for name, schema in self.DEFAULT_OPERATORS.items():
            op_dir = os.path.join(self.operators_dir, name)
            os.makedirs(op_dir, exist_ok=True)
            path = os.path.join(op_dir, "schema.json")
            if not os.path.isfile(path):
                try:
                    with open(path, "w", encoding="utf-8") as f:
                        json.dump(schema, f, indent=2)
                except Exception:
                    pass

    def list_operators(self) -> List[str]:
        try:
            return [d for d in os.listdir(self.operators_dir) if os.path.isdir(os.path.join(self.operators_dir, d))]
        except Exception:
            return []

# ──────────────────────────────────────────────────────────────────────────────
# TTS (Zira locked) & STT (Sphinx offline)
# ──────────────────────────────────────────────────────────────────────────────
class TTSManager(QtCore.QObject):
    def __init__(self, parent: Optional[QtCore.QObject] = None, default_volume: int = 50) -> None:
        super().__init__(parent)
        self._engine = None
        self._voice_name: str = ""
        self._queue: List[str] = []
        self._lock = threading.Lock()
        self._is_speaking = False
        self._current_text = ""
        self._stop = threading.Event()

        if pyttsx3 is None:
            return
        try:
            try:
                self._engine = pyttsx3.init("sapi5")
            except Exception:
                self._engine = pyttsx3.init()
        except Exception as e:
            logger.error("[TTS] init failed: %s", e)
            self._engine = None
            return

        # Lock to Zira (or first non-David)
        voice_map = {}
        for v in self._engine.getProperty("voices"):
            nm = (v.name or "").lower()
            if "david" in nm:
                continue
            if "zira" in nm:
                voice_map[v.name] = v.id
                break
        if not voice_map:
            for v in self._engine.getProperty("voices"):
                nm = (v.name or "").lower()
                if "david" not in nm:
                    voice_map[v.name] = v.id
                    break
        if not voice_map:
            logger.warning("[TTS] no eligible voice; disabled")
            self._engine = None
            return
        self._voice_name = next(iter(voice_map))
        self._engine.setProperty("voice", voice_map[self._voice_name])
        try:
            vol = max(0.0, min(1.0, default_volume / 100.0))
            self._engine.setProperty("volume", vol)
        except Exception:
            pass
        self._start_loop()

    def _start_loop(self) -> None:
        def loop():
            while not self._stop.is_set():
                text = None
                with self._lock:
                    if not self._is_speaking and self._queue:
                        text = self._queue.pop(0)
                        self._is_speaking = True
                if text is None:
                    self._stop.wait(0.05); continue
                self._current_text = text
                try:
                    if self._engine:
                        self._engine.say(text)
                        self._engine.runAndWait()
                except Exception as e:
                    logger.error("[TTS] playback error: %s", e)
                finally:
                    with self._lock:
                        self._is_speaking = False
        threading.Thread(target=loop, daemon=True, name="tts-loop").start()

    def set_volume(self, vol: int) -> None:
        if self._engine is None:
            return
        vol = max(0, min(100, int(vol)))
        try:
            self._engine.setProperty("volume", vol/100.0)
        except Exception:
            pass

    def enqueue(self, text: str) -> None:
        if self._engine is None:
            return
        with self._lock:
            self._queue.append(text)

    def stop(self) -> None:
        if self._engine:
            try:
                self._engine.stop()
            except Exception:
                pass
        with self._lock:
            self._queue.clear()
            self._is_speaking = False

    def replay(self) -> None:
        if self._current_text:
            self.enqueue(self._current_text)

    def close(self) -> None:
        self._stop.set()
        self.stop()

class AudioRecorder(QtCore.QObject):
    transcribed = QtCore.pyqtSignal(str)
    def __init__(self, parent: Optional[QtCore.QObject] = None) -> None:
        super().__init__(parent)
        self._recording = False
        self._frames: List[Any] = []
        self._stream = None

    def list_devices(self) -> List[str]:
        if sd is None:
            return []
        return [d.get("name", "?") for d in sd.query_devices() if d.get("max_input_channels", 0) > 0]

    def start(self, device_index: Optional[int] = None) -> None:
        if sd is None or np is None:
            return
        if self._recording:
            return
        self._frames = []
        def callback(indata, frames, time_info, status):
            self._frames.append(indata.copy())
        try:
            self._stream = sd.InputStream(samplerate=16000, channels=1, device=device_index, callback=callback)
            self._stream.start()
            self._recording = True
        except Exception as e:
            logger.error("[Audio] start error: %s", e)

    def stop_and_transcribe(self) -> None:
        if sd is None or np is None:
            return
        if not self._recording:
            return
        self._recording = False
        if self._stream:
            try:
                self._stream.stop(); self._stream.close()
            except Exception:
                pass
            self._stream = None
        wav_path: Optional[str] = None
        try:
            data = np.concatenate(self._frames, axis=0)
            wav_path = os.path.join(os.getcwd(), "recorded.wav")
            if sf is not None:
                sf.write(wav_path, data, 16000)
        except Exception as e:
            logger.error("[Audio] write error: %s", e)
        # If STT is disabled globally, emit nothing and return
        try:
            use_stt = getattr(self.parent(), "settings", None) and getattr(self.parent().settings, "use_google_stt", False)  # type: ignore[attr-defined]
        except Exception:
            use_stt = False
        if not use_stt:
            return
        # If google speech is unavailable, warn once and return
        if gspeech is None:
            logger.warning("[STT] google-cloud-speech not installed; STT disabled")
            return
        def _worker() -> None:
            text = ""
            try:
                client = gspeech.SpeechClient()
                with open(wav_path, "rb") as f:
                    audio = gspeech.RecognitionAudio(content=f.read())
                cfg = gspeech.RecognitionConfig(
                    encoding=gspeech.RecognitionConfig.AudioEncoding.LINEAR16,
                    sample_rate_hertz=16000,
                    language_code="en-US",
                    enable_automatic_punctuation=True,
                )
                resp = client.recognize(config=cfg, audio=audio)
                text = " ".join(a.alternatives[0].transcript for a in resp.results)
            except Exception as e:
                logger.error("[STT] Google error: %s", e)
            try:
                self.transcribed.emit(text)
            except Exception:
                pass
        threading.Thread(target=_worker, daemon=True, name="stt-worker").start()

class GoogleListener(QtCore.QThread):
    transcribed = QtCore.pyqtSignal(str)

    def __init__(self, parent: Optional[QtCore.QObject] = None) -> None:
        super().__init__(parent)
        self._running = False
        self._pa = None
        self._stream = None

    def run(self) -> None:
        if gspeech is None or pyaudio is None:
            return
        self._running = True
        self._pa = pyaudio.PyAudio()
        self._stream = self._pa.open(format=pyaudio.paInt16, channels=1, rate=16000, input=True, frames_per_buffer=8000)
        client = gspeech.SpeechClient()
        config = gspeech.RecognitionConfig(
            encoding=gspeech.RecognitionConfig.AudioEncoding.LINEAR16,
            sample_rate_hertz=16000,
            language_code="en-US",
        )
        streaming_config = gspeech.StreamingRecognitionConfig(config=config, interim_results=True)
        while self._running:
            data = self._stream.read(4000)
            requests = (gspeech.StreamingRecognizeRequest(audio_content=data) for _ in range(1))
            responses = client.streaming_recognize(streaming_config, requests)
            for resp in responses:
                if resp.results:
                    result = resp.results[0]
                    if result.is_final:
                        self.transcribed.emit(result.alternatives[0].transcript)
        if self._stream:
            self._stream.stop_stream()
            self._stream.close()
        if self._pa:
            self._pa.terminate()

    def stop_listener(self) -> None:
        self._running = False

# ──────────────────────────────────────────────────────────────────────────────
# Datasets + RAG
# ──────────────────────────────────────────────────────────────────────────────
@dataclass
class DatasetEntry:
    name: str
    path: str  # path to dataset folder
    active: bool = True

class DatasetManager(QtCore.QObject):
    datasetsChanged = QtCore.pyqtSignal()

    def __init__(self, base_dir: str, persona: str, set_name: str) -> None:
        super().__init__()
        self.base_dir = base_dir
        self.persona = persona
        self.set_name = set_name
        self.datasets_dir = prof_datasets_dir(base_dir, persona, set_name)
        os.makedirs(self.datasets_dir, exist_ok=True)
        self.index_path = os.path.join(self.datasets_dir, "index.json")
        self.entries: Dict[str, DatasetEntry] = {}
        self.load_index()

    def load_index(self) -> None:
        self.entries.clear()
        if not os.path.isfile(self.index_path):
            return
        try:
            with open(self.index_path, "r", encoding="utf-8") as f:
                data = json.load(f)
            for name, info in data.items():
                # Force canonical path inside this set
                self.entries[name] = DatasetEntry(
                    name=name, path=os.path.join(self.datasets_dir, name), active=bool(info.get("active", True))
                )
        except Exception as e:
            logger.error("[Datasets] load_index error: %s", e)

    def save_index(self) -> None:
        try:
            data = {name: {"path": e.path, "active": e.active} for name, e in self.entries.items()}
            with open(self.index_path, "w", encoding="utf-8") as f:
                json.dump(data, f, indent=2)
        except Exception as e:
            logger.error("[Datasets] save_index error: %s", e)
        QtCore.QTimer.singleShot(50, self.datasetsChanged.emit)

    def _ds_files_dir(self, name: str) -> str:
        return os.path.join(self.datasets_dir, name, "files")

    def add_dataset(self, name: str, file_path: str) -> None:
        """
        Create or extend a dataset. Copies the file into datasets/<name>/files/.
        Supports .txt and .pdf. Subsequent calls with the same name append files.
        """
        if not name.strip():
            raise ValueError("Dataset name cannot be empty")
        ds_folder = os.path.join(self.datasets_dir, name)
        files_dir = self._ds_files_dir(name)
        os.makedirs(files_dir, exist_ok=True)
        if not os.path.exists(file_path):
            raise FileNotFoundError(file_path)
        dest_path = os.path.join(files_dir, os.path.basename(file_path))
        shutil.copy2(file_path, dest_path)
        if name not in self.entries:
            self.entries[name] = DatasetEntry(name=name, path=ds_folder, active=True)
        self.save_index()

    def delete_dataset(self, name: str) -> None:
        if name not in self.entries:
            raise ValueError(f"Dataset '{name}' does not exist")
        shutil.rmtree(os.path.join(self.datasets_dir, name), ignore_errors=True)
        del self.entries[name]
        self.save_index()

    def toggle_active(self, name: str, active: bool) -> None:
        if name in self.entries:
            self.entries[name].active = active
            self.save_index()

    def get_active_datasets(self) -> List[DatasetEntry]:
        return [e for e in self.entries.values() if e.active]

    def get_active_entries(self) -> List[DatasetEntry]:
        return self.get_active_datasets()

    def load_dataset_texts(self, entry: DatasetEntry) -> List[Tuple[str, str]]:
        """
        Returns list of (text, source_file_path). Aggregates all .txt/.pdf files.
        """
        out: List[Tuple[str, str]] = []
        files_dir = self._ds_files_dir(entry.name)
        if not os.path.isdir(files_dir):
            return out
        for fn in sorted(os.listdir(files_dir)):
            p = os.path.join(files_dir, fn)
            if not os.path.isfile(p):
                continue
            ext = os.path.splitext(p)[1].lower()
            if ext == ".txt":
                try:
                    with open(p, "r", encoding="utf-8", errors="ignore") as f:
                        out.append((f.read(), p))
                except Exception:
                    continue
            elif ext == ".pdf" and PdfReader is not None:
                out.append((self._extract_pdf_text(p), p))
        return out

    def _extract_pdf_text(self, path: str) -> str:
        try:
            reader = PdfReader(path)
            out: List[str] = []
            for p in reader.pages:
                try:
                    out.append(p.extract_text() or "")
                except Exception:
                    continue
            return "\n".join(out)
        except Exception as e:
            logger.error("[Datasets] PDF error: %s", e)
            return ""

class RAGCache:
    """
    Per-dataset embedding cache and query. Uses sentence-transformers if available,
    otherwise best-effort Ollama embeddings. Tracks source file mtimes for invalidation.
    """
    def __init__(self, model: Optional[Any], model_name: str, datasets_root: str) -> None:
        self.model = model
        self.model_name = model_name
        self.datasets_root = datasets_root
        self._mem: Dict[str, Dict[str, Any]] = {}

    @staticmethod
    def _chunk_text(text: str, source: str, target_chars: int = 1200, overlap: int = 150) -> List[Tuple[str, str]]:
        paras = [p.strip() for p in text.split("\n") if p.strip()]
        if not paras:
            return [(text[:target_chars], source)]
        chunks: List[Tuple[str, str]] = []
        buf = ""
        for p in paras:
            if len(buf) + len(p) + 1 <= target_chars:
                buf = (buf + "\n" + p) if buf else p
            else:
                if buf:
                    chunks.append((buf, source))
                tail = buf[-overlap:] if overlap and buf else ""
                buf = (tail + "\n" + p).strip()
        if buf:
            chunks.append((buf, source))
        return chunks

    def _cache_paths(self, dataset_entry: DatasetEntry) -> Tuple[str, str, str]:
        folder = dataset_entry.path
        base = f"embeddings_{self.model_name}.np"
        meta = f"embeddings_{self.model_name}.meta.json"
        sents = f"embeddings_{self.model_name}.sentences.json"
        return (os.path.join(folder, base), os.path.join(folder, meta), os.path.join(folder, sents))

    def _encode_st(self, sentences: List[str]) -> Optional["np.ndarray"]:
        if self.model is None or np is None:
            return None
        try:
            embs = self.model.encode(sentences, convert_to_numpy=True, normalize_embeddings=True)
            if isinstance(embs, list):
                embs = np.array(embs)
            return embs
        except TypeError:
            try:
                embs = self.model.encode(sentences, convert_to_numpy=True)
                if isinstance(embs, list):
                    embs = np.array(embs)
                norms = np.linalg.norm(embs, axis=1, keepdims=True) + 1e-12
                return embs / norms
            except Exception:
                return None
        except Exception:
            return None

    def _encode_ollama(self, sentences: List[str]) -> Optional["np.ndarray"]:
        if np is None or not _have_cli("ollama"):
            return None
        model = "mxbai-embed-large:latest"
        try:
            all_vecs: List[List[float]] = []
            for s in sentences:
                proc = subprocess.run(["ollama", "embed", "-m", model, s],
                                      stdout=subprocess.PIPE, stderr=subprocess.PIPE, timeout=60)
                if proc.returncode != 0:
                    logger.warning("[RAG] ollama embed error: %s", proc.stderr.decode("utf-8", "ignore"))
                    return None
                out = proc.stdout.decode("utf-8", "ignore").strip()
                try:
                    js = json.loads(out)
                    vec = js.get("embedding") or (js.get("embeddings") or [None])[0]
                    if not isinstance(vec, list):
                        return None
                    all_vecs.append([float(x) for x in vec])
                except Exception:
                    return None
            arr = np.array(all_vecs, dtype=np.float32)
            norms = np.linalg.norm(arr, axis=1, keepdims=True) + 1e-12
            return arr / norms
        except Exception as e:
            logger.warning("[RAG] ollama embed exception: %s", e)
            return None

    def _encode(self, sentences: List[str]) -> Optional["np.ndarray"]:
        embs = self._encode_st(sentences)
        if embs is not None:
            return embs
        return self._encode_ollama(sentences)

    def _encode_query(self, text: str) -> Optional["np.ndarray"]:
        if np is None:
            return None
        if self.model is not None:
            try:
                q = self.model.encode([text], convert_to_numpy=True, normalize_embeddings=True)
            except TypeError:
                q = self.model.encode([text], convert_to_numpy=True)
                norms = np.linalg.norm(q, axis=1, keepdims=True) + 1e-12
                q = q / norms
            except Exception:
                q = None
            if isinstance(q, list):
                q = np.array(q)
            return q[0] if isinstance(q, np.ndarray) else None
        vec = self._encode_ollama([text])
        if vec is None:
            return None
        return vec[0]

    def _collect_texts(self, loader: DatasetManager, entry: DatasetEntry) -> Tuple[List[str], List[str], Dict[str, float]]:
        texts: List[str] = []
        provenance: List[str] = []
        mtimes: Dict[str, float] = {}
        for text, src in loader.load_dataset_texts(entry):
            chunks = self._chunk_text(text, src)
            for t, s in chunks:
                texts.append(t)
                provenance.append(s)
            try:
                mtimes[src] = os.path.getmtime(src)
            except Exception:
                mtimes[src] = 0.0
        return texts, provenance, mtimes

    def _needs_rebuild(self, entry: DatasetEntry, source_mtimes: Dict[str, float]) -> bool:
        cache_path, meta_path, sents_path = self._cache_paths(entry)
        if not (os.path.isfile(cache_path) and os.path.isfile(meta_path) and os.path.isfile(sents_path)):
            return True
        try:
            with open(meta_path, "r", encoding="utf-8") as f:
                meta = json.load(f)
            cached = meta.get("source_mtimes", {})
            return any(abs(cached.get(p, 0.0) - mt) > 1e-6 for p, mt in source_mtimes.items()) or \
                   any(p not in cached for p in source_mtimes.keys())
        except Exception:
            return True

    def load_or_build(self, loader: DatasetManager, entry: DatasetEntry) -> Optional[Dict[str, Any]]:
        if np is None:
            return None
        key = entry.path
        if key in self._mem:
            return self._mem[key]

        texts, provenance, mtimes = self._collect_texts(loader, entry)
        cache_path, meta_path, sents_path = self._cache_paths(entry)

        if not self._needs_rebuild(entry, mtimes):
            try:
                data = np.load(cache_path, allow_pickle=False)
                with open(sents_path, "r", encoding="utf-8") as f:
                    sentences = json.load(f)
                with open(meta_path, "r", encoding="utf-8") as f:
                    meta = json.load(f)
                emb = data["emb"]
                prov = meta.get("provenance", [""] * len(sentences))
                self._mem[key] = {"sentences": sentences, "emb": emb, "provenance": prov}
                return self._mem[key]
            except Exception:
                pass

        if not texts:
            self._mem[key] = {"sentences": [], "emb": np.zeros((0, 1)) if np is not None else [], "provenance": []}
            return self._mem[key]

        emb = self._encode(texts)
        if emb is None:
            return None
        self._mem[key] = {"sentences": texts, "emb": emb, "provenance": provenance}
        try:
            np.savez_compressed(cache_path, emb=emb)
            with open(sents_path, "w", encoding="utf-8") as f:
                json.dump(texts, f)
            with open(meta_path, "w", encoding="utf-8") as f:
                json.dump({"provenance": provenance, "source_mtimes": mtimes}, f)
        except Exception:
            pass
        return self._mem[key]

    def clear_memory(self) -> None:
        self._mem.clear()

    def clear_disk(self) -> int:
        count = 0
        try:
            for root, _dirs, files in os.walk(self.datasets_root):
                for fn in files:
                    if fn.startswith("embeddings_") and (fn.endswith(".npz") or fn.endswith(".json")):
                        try:
                            os.remove(os.path.join(root, fn))
                            count += 1
                        except Exception:
                            pass
        except Exception:
            pass
        return count

    def query(self, loader: DatasetManager, entry: DatasetEntry, query_text: str, top_k: int = 5) -> List[Tuple[str, float, str, str]]:
        if np is None:
            return []
        emb_info = self.load_or_build(loader, entry)
        if emb_info is None:
            return []
        sentences = emb_info["sentences"]
        prov = emb_info["provenance"]
        if not sentences:
            return []
        q = self._encode_query(query_text)
        if q is None:
            return []
        scores = np.dot(emb_info["emb"], q)
        idx = scores.argsort()[-top_k:][::-1]
        return [(sentences[i], float(scores[i]), entry.name, prov[i]) for i in idx]

    def search_all(self, managers_and_entries: List[Tuple[DatasetManager, List[DatasetEntry]]],
                   query_text: str, per_ds_k: int = 5, limit: int = 10) -> List[Tuple[str, float, str, str]]:
        hits: List[Tuple[str, float, str, str]] = []
        for mgr, entries in managers_and_entries:
            for e in entries:
                hits.extend(self.query(mgr, e, query_text, top_k=per_ds_k))
        hits.sort(key=lambda x: x[1], reverse=True)
        return hits[:limit]

# ──────────────────────────────────────────────────────────────────────────────
# Context → Schema evolution
# ──────────────────────────────────────────────────────────────────────────────
class ContextMonitor:
    def __init__(self, depth: int = 20) -> None:
        self.depth = depth
        self.context: List[Tuple[str, str]] = []

    def add_message(self, speaker: str, text: str) -> None:
        self.context.append((speaker, text))
        if len(self.context) > self.depth:
            self.context.pop(0)

    def analyze(self) -> Dict[str, Any]:
        tone = self._detect_tone()
        directives = self._extract_directives()
        keywords = self._find_keywords()
        return {"tone": tone, "directives": directives, "keywords": keywords}

    def _detect_tone(self) -> str:
        text = " ".join([t.lower() for _, t in self.context])
        pos = sum(k in text for k in ["happy", "excited", "good", "great", "awesome"])
        neg = sum(k in text for k in ["sad", "angry", "bad", "terrible", "frustrated"])
        if pos > neg: return "positive"
        if neg > pos: return "negative"
        return "neutral"

    def _extract_directives(self) -> List[str]:
        d: List[str] = []
        for _, text in self.context:
            for m in re.findall(r'\b(?:please\s+)?(?:add|set|enable|disable|remember|inject|rewrite)\b(.*)', text, re.I):
                d.append(m.strip())
            for m in re.findall(r'\byou (need to|must|should)\b (.*)', text, re.I):
                d.append(m[1].strip())
        return d

    def _find_keywords(self) -> List[str]:
        text = " ".join([t for _, t in self.context])
        words = re.findall(r'\b\w+\b', text.lower())
        return sorted(set([w for w in words if len(w) > 3]))

class SchemaAutoUpdater:
    def __init__(self, mgr: SchemaManager, persona: str, set_name: str) -> None:
        self.mgr = mgr
        self.persona = persona
        self.set_name = set_name
        self._last_update_ts: float = 0.0
        self._min_interval = 2.0  # seconds; guard against rapid churn

    def update_with_context(self, analysis: Dict[str, Any]) -> None:
        now = time.time()
        if now - self._last_update_ts < self._min_interval:
            return
        self._last_update_ts = now
        schema = self.mgr.load_schema(self.persona, self.set_name)
        for d in analysis.get("directives", []):
            self._apply_directive(schema, d)
        self.mgr.save_schema(self.persona, self.set_name, schema)

    def _apply_directive(self, schema: Dict[str, Any], directive: str) -> None:
        low = directive.lower()
        if "add trait" in low:
            trait = directive.split("add trait", 1)[-1].strip()
            overlay = dict(schema.get("dynamic_overlay", {}))
            traits = list(overlay.get("added_traits", []))
            if trait and trait not in traits: traits.append(trait)
            overlay["added_traits"] = traits
            schema["dynamic_overlay"] = overlay
        elif "add action" in low:
            action = directive.split("add action", 1)[-1].strip()
            actions = list(schema.get("actions", []))
            if action and action not in actions: actions.append(action)
            schema["actions"] = actions
        elif "add question" in low:
            q = directive.split("add question", 1)[-1].strip()
            qs = list(schema.get("questions", []))
            if q and q not in qs: qs.append(q)
            schema["questions"] = qs
        elif "reflect" in low or "think" in low:
            st = list(schema.get("self_talk", []))
            ref = f"Reflect: {directive}"
            if ref not in st: st.append(ref)
            schema["self_talk"] = st
        # C-5: Directive-to-Command expansion
        if "add command" in low:
            parts = directive.split()
            if len(parts) >= 3 and parts[2].startswith("/"):
                cmd = parts[2]
                value = " ".join(parts[3:])
                cmds = dict(schema.get("commands", {}))
                arr = list(cmds.get(cmd, []))
                if value:
                    arr.append(value)
                cmds[cmd] = arr
                schema["commands"] = cmds
        elif "delete command" in low:
            parts = directive.split()
            if len(parts) >= 3 and parts[2].startswith("/"):
                cmd = parts[2]
                cmds = dict(schema.get("commands", {}))
                cmds.pop(cmd, None)
                schema["commands"] = cmds
        elif "rewrite command" in low:
            parts = directive.split(maxsplit=3)
            if len(parts) >= 4 and parts[2].startswith("/"):
                cmd = parts[2]
                value = parts[3]
                cmds = dict(schema.get("commands", {}))
                if cmd in cmds:
                    cmds[cmd] = [value]
                schema["commands"] = cmds

# ──────────────────────────────────────────────────────────────────────────────
# Command registry (+weights/locks) & executor
# ──────────────────────────────────────────────────────────────────────────────
class CommandRegistry(QtCore.QObject):
    commandsChanged = QtCore.pyqtSignal()
    commandWeightsChanged = QtCore.pyqtSignal()

    def __init__(self, base_dir: str, persona: str, set_name: str) -> None:
        super().__init__()
        self.base_dir = base_dir
        self.persona = persona
        self.set_name = set_name
        self.path = prof_commands_path(base_dir, persona, set_name)
        self.commands: Dict[str, Dict[str, Any]] = {}
        self._load()
        for cmd in [
            "/remember", "/inject", "/rewrite", "/show", "/action", "/trait",
            "/dataset", "/search", "/embeddings", "/schema",
            "/tts", "/plugin", "/feedback", "/lock", "/commands",
            # Moderation & shaping
            "/reject", "/auto", "/ignore", "/opposite", "/delete",
            # Experimental fine-tuning / tokenizer commands
            "/applylora", "/patchtokenizer", "/datasetfromtext",
            # Spatial room
            "/enterroom", "/move",
        ]:
            self.register_command(cmd)

    def _load(self) -> None:
        try:
            if os.path.isfile(self.path):
                with open(self.path, "r", encoding="utf-8") as f:
                    data = json.load(f)
                self.commands = dict(data.get("commands", {}))
        except Exception:
            self.commands = {}

    def _save(self) -> None:
        try:
            os.makedirs(os.path.dirname(self.path), exist_ok=True)
            with open(self.path, "w", encoding="utf-8") as f:
                json.dump({"commands": self.commands}, f, indent=2)
        except Exception as e:
            logger.error("[CommandRegistry] save error: %s", e)
        QtCore.QTimer.singleShot(50, self.commandsChanged.emit)
        QtCore.QTimer.singleShot(50, self.commandWeightsChanged.emit)

    def register_command(self, name: str) -> None:
        if name not in self.commands:
            self.commands[name] = {"weight": 0, "locked": False}
            self._save()

    def register_from_schema(self, schema: Dict[str, Any]) -> None:
        try:
            for name in (schema.get("commands") or {}).keys():
                if isinstance(name, str) and name.startswith("/"):
                    self.register_command(name)
        except Exception:
            pass

    def set_weight(self, name: str, weight: int) -> None:
        if name in self.commands and not self.commands[name].get("locked", False):
            self.commands[name]["weight"] = int(weight)
            self._save()

    def toggle_lock(self, name: str, state: Optional[bool] = None) -> None:
        if name in self.commands:
            cur = bool(self.commands[name].get("locked", False))
            self.commands[name]["locked"] = (not cur) if state is None else bool(state)
            self._save()

    def get_weight(self, name: str) -> int:
        return int(self.commands.get(name, {}).get("weight", 0))

    def is_locked(self, name: str) -> bool:
        return bool(self.commands.get(name, {}).get("locked", False))

    def list_commands(self) -> List[str]:
        return sorted(self.commands.keys())

    def score_commands(self) -> Dict[str, float]:
        scores = {}
        for name in self.commands:
            bean_total = self.beans.counts.get(f"cmd_{name}", 0)  # assuming self.beans is accessible
            score = self.commands[name]["weight"] + (bean_total * 0.1)  # WEIGHT_FACTOR = 0.1
            scores[name] = score
        return scores

class CommandExecutor:
    """
    Executes slash commands and integrates with schema + registry + reinforcement.
    """
    def __init__(self, registry: CommandRegistry, schema_mgr: SchemaManager,
                 schema_updater: SchemaAutoUpdater, beans: BeanCounter,
                 dataset_mgr: DatasetManager, rag: "RAGCache",
                 settings: Settings, plugins: "PluginManager",
                 core_ref: "AgentCore") -> None:
        self.registry = registry
        self.schema_mgr = schema_mgr
        self.schema_updater = schema_updater
        self.beans = beans
        self.dataset_mgr = dataset_mgr
        self.rag = rag
        self.settings = settings
        self.plugins = plugins
        self.core_ref = core_ref

    @staticmethod
    def _strip_quotes(s: str) -> str:
        s = (s or "").strip()
        if len(s) >= 2 and ((s[0] == s[-1] == "'") or (s[0] == s[-1] == '"')):
            return s[1:-1]
        return s

    def _add_schema_command_value(self, schema: Dict[str, Any], cmd: str, text: str) -> None:
        cmds = dict(schema.get("commands") or {})
        arr = list(cmds.get(cmd, []))
        if text and text not in arr:
            arr.append(text)
        cmds[cmd] = arr
        schema["commands"] = cmds

    def execute(self, command_line: str) -> str:
        cmd, args = self._parse(command_line)
        if not cmd:
            return "No command provided."
        try:
            self.registry.set_weight(cmd, self.registry.get_weight(cmd) + 1)
        except Exception:
            pass
        if self.registry.is_locked(cmd):
            return f"Command '{cmd}' is locked."
        try:
            if cmd == "/remember":        return self._remember(args)
            if cmd == "/inject":          return self._inject(args)
            if cmd == "/rewrite":         return self._rewrite(args)
            if cmd == "/reject":          return self._reject(args)
            if cmd == "/auto":            return self._auto(args)
            if cmd == "/ignore":          return self._ignore(args)
            if cmd == "/opposite":        return self._opposite(args)
            if cmd == "/delete":          return self._delete(args)
            if cmd == "/applylora":       return self._applylora(args)
            if cmd == "/patchtokenizer":  return self._patchtokenizer(args)
            if cmd == "/datasetfromtext": return self._datasetfromtext(args)
            if cmd == "/show":            return self._show(args)
            if cmd == "/action":          return self._action(args)
            if cmd == "/trait":           return self._trait(args)
            if cmd == "/dataset":         return self._dataset(args)
            if cmd == "/search":          return self._search(args)
            if cmd == "/embeddings":      return self._embeddings(args)
            if cmd == "/schema":          return self._schema(args)
            if cmd == "/tts":             return self._tts(args)
            if cmd == "/plugin":          return self._plugin(args)
            if cmd == "/feedback":        return self._feedback(args)
            if cmd == "/lock":            return self._lock(args)
            if cmd == "/commands":        return self._commands(args)
            # C-8
            if cmd == "/enterroom":       return self._enterroom(args)
            if cmd == "/move":            return self._move(args)
            return f"Command '{cmd}' executed (no-op)."
        finally:
            # Increment reinforcement count for this command
            try:
                self.beans.increment(f"cmd_{cmd}", 1)
            except Exception:
                pass
            # Update command weight based on usage reinforcement
            try:
                cnt = self.beans.counts.get(f"cmd_{cmd}", 0)
                self.registry.set_weight(cmd, cnt)
            except Exception:
                pass

    def _parse(self, line: str) -> Tuple[str, str]:
        line = (line or "").strip()
        if not line.startswith("/"):
            return "", ""
        parts = line.split(maxsplit=1)
        cmd = parts[0].strip()
        rest = parts[1] if len(parts) > 1 else ""
        if cmd.startswith("/action_"): cmd = "/action"
        if cmd.startswith("/trait_"):  cmd = "/trait"
        return cmd, rest

    # Core handlers
    def _remember(self, args: str) -> str:
        trait = self._strip_quotes(args) or "remembered"
        schema = self.schema_mgr.load_schema(self.schema_updater.persona, self.schema_updater.set_name)
        overlay = dict(schema.get("dynamic_overlay", {}))
        traits = list(overlay.get("added_traits", []))
        if trait not in traits:
            traits.append(trait)
        overlay["added_traits"] = traits
        schema["dynamic_overlay"] = overlay
        self._add_schema_command_value(schema, "/remember", trait)
        self.schema_mgr.save_schema(self.schema_updater.persona, self.schema_updater.set_name, schema)
        return f"Remembered: {trait}"

    def _inject(self, args: str) -> str:
        note = self._strip_quotes(args) or "injected-change"
        schema = self.schema_mgr.load_schema(self.schema_updater.persona, self.schema_updater.set_name)
        st = list(schema.get("self_talk", []))
        if note not in st:
            st.append(note)
        schema["self_talk"] = st
        self._add_schema_command_value(schema, "/inject", note)
        self.schema_mgr.save_schema(self.schema_updater.persona, self.schema_updater.set_name, schema)
        return f"Injected: {note}"

    def _rewrite(self, args: str) -> str:
        phrase = self._strip_quotes(args)
        schema = self.schema_mgr.load_schema(self.schema_updater.persona, self.schema_updater.set_name)
        rp = list(schema.get("rewrite_prompts", []))
        if phrase and phrase not in rp:
            rp.append(phrase)
        schema["rewrite_prompts"] = rp
        if phrase:
            self._add_schema_command_value(schema, "/rewrite", phrase)
        self.schema_mgr.save_schema(self.schema_updater.persona, self.schema_updater.set_name, schema)
        return "Rewrite behavior updated."

    def _reject(self, args: str) -> str:
        text = self._strip_quotes(args) or "rejected"
        schema = self.schema_mgr.load_schema(self.schema_updater.persona, self.schema_updater.set_name)
        dislikes = list(schema.get("dislikes", []))
        if text not in dislikes:
            dislikes.append(text)
        schema["dislikes"] = dislikes
        self._add_schema_command_value(schema, "/reject", text)
        self.beans.increment(f"rej_{abs(hash(text))%10007}", -1)
        self.schema_mgr.save_schema(self.schema_updater.persona, self.schema_updater.set_name, schema)
        return f"Rejected: {text}"

    def _auto(self, args: str) -> str:
        text = self._strip_quotes(args) or "auto"
        schema = self.schema_mgr.load_schema(self.schema_updater.persona, self.schema_updater.set_name)
        events = list(schema.get("events", []))
        mark = f"AUTO: {text}"
        if mark not in events:
            events.append(mark)
        schema["events"] = events
        self._add_schema_command_value(schema, "/auto", text)
        self.schema_mgr.save_schema(self.schema_updater.persona, self.schema_updater.set_name, schema)
        return f"Auto behavior noted: {text}"

    def _ignore(self, args: str) -> str:
        text = self._strip_quotes(args) or "ignore"
        schema = self.schema_mgr.load_schema(self.schema_updater.persona, self.schema_updater.set_name)
        tone = dict(schema.get("tone_rules", {}))
        avoid = list(tone.get("avoid", []))
        if text not in avoid:
            avoid.append(text)
        tone["avoid"] = avoid
        schema["tone_rules"] = tone
        dislikes = list(schema.get("dislikes", []))
        if text not in dislikes:
            dislikes.append(text)
        schema["dislikes"] = dislikes
        self._add_schema_command_value(schema, "/ignore", text)
        self.schema_mgr.save_schema(self.schema_updater.persona, self.schema_updater.set_name, schema)
        return f"Ignoring: {text}"

    def _opposite(self, args: str) -> str:
        text = self._strip_quotes(args) or "opposite"
        schema = self.schema_mgr.load_schema(self.schema_updater.persona, self.schema_updater.set_name)
        tone = dict(schema.get("tone_rules", {}))
        opp = list(tone.get("opposites", []))
        if text not in opp:
            opp.append(text)
        tone["opposites"] = opp
        schema["tone_rules"] = tone
        self._add_schema_command_value(schema, "/opposite", text)
        rps = list(schema.get("rewrite_prompts", []))
        guide = f"Prefer the opposite of: {text}"
        if guide not in rps:
            rps.append(guide)
        schema["rewrite_prompts"] = rps
        self.schema_mgr.save_schema(self.schema_updater.persona, self.schema_updater.set_name, schema)
        return f"Will prefer the opposite of: {text}"

    def _delete(self, args: str) -> str:
        text = self._strip_quotes(args) or "delete"
        schema = self.schema_mgr.load_schema(self.schema_updater.persona, self.schema_updater.set_name)
        overlay = dict(schema.get("dynamic_overlay", {}))
        deletions = list(overlay.get("delete_targets", []))
        if text not in deletions:
            deletions.append(text)
        overlay["delete_targets"] = deletions
        schema["dynamic_overlay"] = overlay
        self._add_schema_command_value(schema, "/delete", text)
        self.schema_mgr.save_schema(self.schema_updater.persona, self.schema_updater.set_name, schema)
        return f"Marked for deletion: {text}"

    def _show(self, args: str) -> str:
        key = (args or "").strip().lower()
        if key == "facts":
            tops = sorted(self.beans.counts.items(), key=lambda kv: kv[1], reverse=True)[:10]
            if not tops:
                return "No facts yet."
            return "Top facts:\n" + "\n".join([f"• {k}: {v}" for k, v in tops])
        return "Unknown /show argument. Try '/show facts'."

    def _action(self, args: str) -> str:
        action = self._strip_quotes(args) or "action"
        schema = self.schema_mgr.load_schema(self.schema_updater.persona, self.schema_updater.set_name)
        actions = list(schema.get("actions", []))
        if action not in actions:
            actions.append(action)
        schema["actions"] = actions
        self.schema_mgr.save_schema(self.schema_updater.persona, self.schema_updater.set_name, schema)
        return f"Action added: {action}"

    def _trait(self, args: str) -> str:
        trait = self._strip_quotes(args) or "trait"
        schema = self.schema_mgr.load_schema(self.schema_updater.persona, self.schema_updater.set_name)
        overlay = dict(schema.get("dynamic_overlay", {}))
        traits = list(overlay.get("added_traits", []))
        if trait not in traits:
            traits.append(trait)
        overlay["added_traits"] = traits
        schema["dynamic_overlay"] = overlay
        self.schema_mgr.save_schema(self.schema_updater.persona, self.schema_updater.set_name, schema)
        return f"Trait added: {trait}"

    # Data/system
    def _dataset(self, args: str) -> str:
        parts = args.split()
        if not parts:
            return "Usage: /dataset add|delete|toggle|list ..."
        sub = parts[0].lower()
        try:
            if sub == "add" and len(parts) >= 3:
                name = parts[1]
                path = " ".join(parts[2:])
                self.dataset_mgr.add_dataset(name, path)
                self.rag.clear_memory()
                return f"Dataset '{name}' updated with file '{path}'."
            if sub == "delete" and len(parts) == 2:
                name = parts[1]
                self.dataset_mgr.delete_dataset(name)
                self.rag.clear_memory()
                return f"Dataset '{name}' deleted."
            if sub == "toggle" and len(parts) == 3:
                name = parts[1]
                on = parts[2].lower() in {"on", "true", "1", "enable", "enabled"}
                self.dataset_mgr.toggle_active(name, on)
                return f"Dataset '{name}' set to {'active' if on else 'inactive'}."
            if sub == "list":
                items = self.dataset_mgr.entries
                if not items:
                    return "No datasets."
                return "Datasets:\n" + "\n".join([f"• {n} [{'ON' if e.active else 'off'}]" for n, e in sorted(items.items())])
        except Exception as e:
            return f"Dataset error: {e}"
        return "Usage: /dataset add <name> <path> | delete <name> | toggle <name> on|off | list"

    def _search(self, args: str) -> str:
        q = args.strip()
        if not q:
            return "Usage: /search <query>"
        packs: List[Tuple[DatasetManager, List[DatasetEntry]]] = []
        packs.append((self.dataset_mgr, self.dataset_mgr.get_active_datasets()))
        shared = self.schema_mgr.get_shared_datasets(self.schema_updater.persona, self.schema_updater.set_name)
        if shared:
            owners: Dict[Tuple[str, str], List[DatasetEntry]] = {}
            for e in shared:
                try:
                    rel = os.path.relpath(e.path, self.dataset_mgr.base_dir).replace("\\", "/")
                    parts = rel.split("/")
                    idx = parts.index("profiles")
                    other_persona = parts[idx+1]
                    other_set = parts[idx+2]
                except Exception:
                    continue
                owners.setdefault((other_persona, other_set), []).append(e)
            for key, ents in owners.items():
                p, s = key
                packs.append((DatasetManager(self.base_dir, p, s), ents))
        hits = self.rag.search_all(packs, q, per_ds_k=4, limit=10)
        if not hits:
            return "No results."
        lines = []
        for chunk, score, ds, prov in hits:
            lines.append(f"[{ds}] {os.path.basename(prov)} (score={score:.3f})\n{chunk[:300].strip()}...")
        return "\n\n".join(lines)

    def _embeddings(self, args: str) -> str:
        sub = (args or "").strip().lower()
        if sub == "clear":
            n = self.rag.clear_disk()
            self.rag.clear_memory()
            return f"Cleared {n} embedding cache files."
        return "Usage: /embeddings clear"

    def _schema(self, args: str) -> str:
        parts = args.split()
        if not parts:
            return "Usage: /schema set <persona> <set> | awareness on|off | active"
        sub = parts[0].lower()
        if sub == "set" and len(parts) == 3:
            persona, set_name = parts[1].lower(), parts[2]
            if persona not in self.schema_mgr.personas:
                return f"Unknown persona '{persona}'"
            if set_name not in self.schema_mgr.get_set_list(persona):
                os.makedirs(os.path.join(self.schema_mgr.schemas_dir, persona, "sets", set_name), exist_ok=True)
                sch = self.schema_mgr.load_schema(persona, "default")
                self.schema_mgr.save_schema(persona, set_name, sch)
            active = dict(self.schema_mgr.active_schemas)
            active[persona] = set_name
            self.schema_mgr.save_active_schemas(active)
            self.core_ref.switch_persona_set(persona if persona == self.core_ref.persona else None,
                                             set_name if persona == self.core_ref.persona else None)
            return f"Active schema set: {persona}/{set_name}"
        if sub == "awareness" and len(parts) == 2:
            on = parts[1].lower() in {"on", "true", "1", "enable", "enabled"}
            sch = self.schema_mgr.load_schema(self.schema_updater.persona, self.schema_updater.set_name)
            flags = dict(sch.get("flags") or {})
            flags["semantic_awareness"] = bool(on)
            sch["flags"] = flags
            sch["semantic_awareness_enabled"] = bool(on)
            self.schema_mgr.save_schema(self.schema_updater.persona, self.schema_updater.set_name, sch)
            return f"Semantic awareness {'enabled' if on else 'disabled'} for {self.schema_updater.persona}/{self.schema_updater.set_name}"
        if sub == "active":
            act = self.schema_mgr.active_schemas
            return "Active schemas:\n" + "\n".join([f"• {p}: {s}" for p, s in act.items()])
        return "Usage: /schema set <persona> <set> | awareness on|off | active"

    def _tts(self, args: str) -> str:
        parts = args.split()
        if not parts:
            return "Usage: /tts on|off | volume <0-100>"
        sub = parts[0].lower()
        if sub in {"on", "off"}:
            flag = sub == "on"
            self.settings.monologue_tts_enabled = flag
            self.settings.save()
            return f"TTS {'enabled' if flag else 'disabled'}."
        if sub == "volume" and len(parts) == 2:
            try:
                v = int(parts[1]); v = max(0, min(100, v))
                self.settings.monologue_volume = v
                self.settings.save()
                if self.core_ref.tts_mgr:
                    self.core_ref.tts_mgr.set_volume(v)
                return f"TTS volume set to {v}."
            except Exception:
                return "Volume must be integer 0-100."
        return "Usage: /tts on|off | volume <0-100>"

    def _plugin(self, args: str) -> str:
        parts = args.split()
        if not parts:
            return "Usage: /plugin enable|disable|list ..."
        sub = parts[0].lower()
        if sub == "list":
            metas = self.plugins.list_plugins()
            if not metas:
                return "No plugins found."
            lines = []
            for m in metas:
                missing = f" (missing: {','.join(m.missing_dependencies)})" if m.missing_dependencies else ""
                lines.append(f"• {m.name} v{m.version or '?'} [{'ON' if m.enabled else 'off'}]{missing}")
            return "\n".join(lines)
        if sub in {"enable", "disable"} and len(parts) == 2:
            name = parts[1]
            flag = sub == "enable"
            self.plugins.enable_plugin(name, flag)
            return f"Plugin '{name}' {'enabled' if flag else 'disabled'}."
        return "Usage: /plugin enable <name> | disable <name> | list"

    def _feedback(self, args: str) -> str:
        parts = args.split()
        if not parts:
            return "Usage: /feedback stats | export <path>"
        sub = parts[0].lower()
        if sub == "stats":
            pos, neg = self.core_ref.feedback_db.get_counts()
            return f"Feedback: {pos} 👍  /  {neg} 👎"
        if sub == "export" and len(parts) >= 2:
            out = " ".join(parts[1:])
            n = self.core_ref.feedback_db.export_jsonl(out)
            return f"Exported {n} feedback records to {out}."
        return "Usage: /feedback stats | export <path>"

    def _lock(self, args: str) -> str:
        parts = args.split()
        if len(parts) != 2:
            return "Usage: /lock <cmd> on|off"
        cmd, state = parts
        if cmd not in self.registry.commands:
            return f"Unknown command '{cmd}'"
        self.registry.toggle_lock(cmd, state.lower() in {"on", "true", "1"})
        return f"Command '{cmd}' lock set to {self.registry.is_locked(cmd)}."

    def _commands(self, args: str) -> str:
        if args.strip().lower() == "list":
            items = []
            for c in self.registry.list_commands():
                items.append(f"• {c} (weight={self.registry.get_weight(c)}, locked={self.registry.is_locked(c)})")
            return "\n".join(items) if items else "No commands."
        return "Usage: /commands list"

    def _enterroom(self, args: str) -> str:
        # Stub for spatial room
        return "Entered room."

    def _move(self, args: str) -> str:
        # Stub for spatial room
        return "Moved."

# ──────────────────────────────────────────────────────────────────────────────
# Plugin system
# ──────────────────────────────────────────────────────────────────────────────
class PluginMeta:
    def __init__(self, name: str, path: str) -> None:
        self.name = name
        self.path = path
        self.enabled: bool = False
        self.module: Optional[Any] = None
        self.widget: Optional[Any] = None
        self.version: Optional[str] = None
        self.entry_point: Optional[str] = None
        self.dependencies: List[str] = []
        self.default_enabled: bool = False
        self.missing_dependencies: List[str] = []
        self._parse_manifest()

    def _parse_manifest(self) -> None:
        manifest_path = os.path.join(self.path, "manifest.json")
        if not os.path.isfile(manifest_path):
            return
        try:
            with open(manifest_path, "r", encoding="utf-8") as f:
                data = json.load(f)
            self.version = data.get("version")
            self.entry_point = data.get("entry_point") or None
            deps = data.get("dependencies") or []
            if isinstance(deps, list):
                self.dependencies = [str(d) for d in deps if isinstance(d, str)]
            self.default_enabled = bool(data.get("default_enabled", False))
        except Exception as e:
            logger.error("[Plugin:%s] manifest error: %s", self.name, e)
            return
        for dep in self.dependencies:
            try:
                __import__(dep.replace('-', '_'))
            except Exception:
                self.missing_dependencies.append(dep)

    def load_module(self) -> None:
        if self.module is not None or self.missing_dependencies:
            return
        spec = None
        if self.entry_point:
            spec = self.entry_point if "." in self.entry_point else f"plugins.{self.entry_point}"
        else:
            spec = f"plugins.{self.name}"
        try:
            import importlib
            self.module = importlib.import_module(spec)
        except Exception as e:
            logger.error("[Plugin:%s] import error: %s", self.name, e)
            self.module = None

    def start(self, host: "PluginManager") -> None:
        if self.enabled:
            return
        self.load_module()
        if self.module is None:
            return
        try:
            if hasattr(self.module, "start"):
                self.widget = self.module.start(host)  # type: ignore
            self.enabled = True
        except Exception as e:
            logger.error("[Plugin:%s] start error: %s", self.name, e)
            self.enabled = False

    def stop(self) -> None:
        if not self.enabled or self.module is None:
            return
        try:
            if hasattr(self.module, "stop"):
                self.module.stop()  # type: ignore
        except Exception as e:
            logger.error("[Plugin:%s] stop error: %s", self.name, e)
        self.widget = None
        self.enabled = False

class PluginManager(QtCore.QObject):
    eventReceived = QtCore.pyqtSignal(str, dict)  # sender, envelope

    def __init__(self, base_dir: str, settings: Settings) -> None:
        super().__init__()
        self.base_dir = base_dir
        self.settings = settings
        self.plugins_dir = os.path.join(self.base_dir, "plugins")
        os.makedirs(self.plugins_dir, exist_ok=True)
        self._plugins: Dict[str, PluginMeta] = {}
        self.discover_plugins()

    def discover_plugins(self) -> None:
        self._plugins.clear()
        for entry in os.scandir(self.plugins_dir):
            if entry.is_dir():
                meta = PluginMeta(entry.name, entry.path)
                self._plugins[entry.name] = meta
        for name, meta in self._plugins.items():
            if name in self.settings.enabled_plugins or (not self.settings.enabled_plugins and meta.default_enabled):
                meta.enabled = True
                meta.start(self)

    def list_plugins(self) -> List[PluginMeta]:
        return list(self._plugins.values())

    def enable_plugin(self, name: str, flag: bool) -> None:
        meta = self._plugins.get(name)
        if not meta:
            return
        if flag and not meta.enabled:
            meta.start(self)
            if name not in self.settings.enabled_plugins:
                self.settings.enabled_plugins.append(name)
                self.settings.save()
        elif not flag and meta.enabled:
            meta.stop()
            if name in self.settings.enabled_plugins:
                self.settings.enabled_plugins.remove(name)
                self.settings.save()

    def rescan(self) -> None:
        self.discover_plugins()

    def broadcast(self, message: Any) -> None:
        envelope = message if (isinstance(message, dict) and "type" in message) else {"type": "command", "data": message}
        for meta in self._plugins.values():
            if not (meta.enabled and meta.module):
                continue
            try:
                if hasattr(meta.module, "on_command"):
                    try:
                        meta.module.on_command(envelope)  # type: ignore
                    except TypeError:
                        meta.module.on_command(envelope.get("data"))  # type: ignore
            except Exception as e:
                logger.error("[Plugin:%s] on_command error: %s", meta.name, e)

    def emit_event(self, sender: str, type: str, payload: Any) -> None:
        self.eventReceived.emit(sender, {"sender": sender, "type": type, "data": payload})

    def stop_all(self) -> None:
        for meta in self._plugins.values():
            try:
                meta.stop()
            except Exception:
                pass

# ──────────────────────────────────────────────────────────────────────────────
# Schema evolver using feedback (frequency + votes)
# ──────────────────────────────────────────────────────────────────────────────
class SchemaEvolver:
    def __init__(self, mgr: SchemaManager, feedback_db: SemanticFeedbackDB, memory_state: Dict[str, Any]) -> None:
        self.mgr = mgr
        self.feedback_db = feedback_db
        self.memory_state = memory_state
        self._protected = self.mgr._load_control_schema()
        self._last_success_ts = 0.0

    def update_schema(self, persona: str, set_name: str, history: List[Tuple[str, str]]) -> bool:
        try:
            tokens: List[str] = []
            for role, content in history[-12:]:
                tokens.extend([w.lower() for w in re.findall(r"\b\w+\b", content or "") if len(w) > 3])
            word_freq = Counter(tokens)
            pos_count, neg_count = self.feedback_db.get_counts()

            if (pos_count + neg_count) < 5 or pos_count <= neg_count or not word_freq:
                return False

            patch: Dict[str, Any] = {}
            schema = self.mgr.load_schema(persona, set_name)
            tone_rules = dict(schema.get("tone_rules", {}))
            avoid_words = set(tone_rules.get("avoid", []))
            top_words = [w for w, _ in word_freq.most_common(5) if w not in avoid_words]
            if top_words:
                tone_rules["preferred_words"] = top_words[:3]
                patch["tone_rules"] = tone_rules

            if patch and all(k not in self._protected for k in patch.keys()):
                schema.update(patch)
                self.mgr.save_schema(persona, set_name, schema)
                self._last_success_ts = time.time()
                return True
        except Exception as e:
            logger.error("[SchemaEvolver] error: %s", e)
        return False

# ──────────────────────────────────────────────────────────────────────────────
# FathomKernel self-rewriter (C-9)
# ──────────────────────────────────────────────────────────────────────────────
class FathomKernel:
    def __init__(self, base_dir: str) -> None:
        self.base_dir = base_dir

    def snapshot_codebase(self) -> Dict[str, str]:
        code = {}
        for root, _, files in os.walk(self.base_dir):
            for fn in files:
                if fn.endswith(".py"):
                    p = os.path.join(root, fn)
                    with open(p, "r", encoding="utf-8") as f:
                        code[p] = f.read()
        return code

    def lint_and_patch(self) -> None:
        # Use ruff for linting
        try:
            subprocess.run(["ruff", "check", "--fix", self.base_dir], check=False)
        except Exception:
            pass
        # For patch, stub: call ollama to rewrite
        pass

# ──────────────────────────────────────────────────────────────────────────────
# Threaded model worker
# ──────────────────────────────────────────────────────────────────────────────
class ModelWorker(QtCore.QThread):
    finished = QtCore.pyqtSignal(str)
    def __init__(self, model: str, prompt: str, parent: Optional[QtCore.QObject] = None) -> None:
        super().__init__(parent)
        self.model = model
        self.prompt = prompt

    def run(self) -> None:
        try:
            parent = self.parent()
            if parent and hasattr(parent, "_query_model"):
                result = parent._query_model(self.model, self.prompt)  # type: ignore
            else:
                result = ""
            self.finished.emit(result)
        except Exception as e:
            self.finished.emit(f"Error: {e}")
        finally:
            try:
                self.deleteLater()
            except Exception:
                pass

# ──────────────────────────────────────────────────────────────────────────────
# Orchestrator
# ──────────────────────────────────────────────────────────────────────────────
class AgentCore(QtCore.QObject):
    """
    Binds together all components for headless or GUI use.
    """
    def __init__(self, base_dir: str, persona: str = "zira", set_name: Optional[str] = None) -> None:
        super().__init__()
        self.base_dir = base_dir
        self.schema_mgr = SchemaManager(base_dir)
        self.persona = persona
        if set_name is None:
            set_name = self.schema_mgr.active_schemas.get(persona, "default")
        self.set_name = set_name

        self.settings = Settings(base_dir)
        ensure_models_present()

        self.operator_mgr = OperatorManager(base_dir)
        self.dataset_mgr = DatasetManager(base_dir, self.persona, self.set_name)
        self.tts_mgr = TTSManager(default_volume=self.settings.monologue_volume)
        self.audio_recorder = AudioRecorder()
        self.google_listener = GoogleListener()
        self.conversation_db = ConversationDB(conv_db_path(base_dir, self.persona, self.set_name))
        self.feedback_db = SemanticFeedbackDB(feedback_db_path(base_dir, self.persona, self.set_name), base_dir, self.persona, self.set_name)
        self.beans = self.feedback_db.beans
        self.reinforcement_log = ReinforcementStore(base_dir)

        self.context_monitor = ContextMonitor(depth=self.settings.context_depth)
        self.schema_auto_updater = SchemaAutoUpdater(self.schema_mgr, self.persona, self.set_name)
        self.schema_evolver = SchemaEvolver(self.schema_mgr, self.feedback_db, memory_state={})

        self.command_registry = CommandRegistry(base_dir, self.persona, self.set_name)
        try:
            sch = self.schema_mgr.load_schema(self.persona, self.set_name)
            self.command_registry.register_from_schema(sch)
        except Exception:
            pass

        self.plugins = PluginManager(base_dir, self.settings)

        if SentenceTransformer and np is not None:
            try:
                self.embed_model = SentenceTransformer("all-MiniLM-L6-v2")
                embed_name = "MiniLM"
            except Exception:
                self.embed_model = None
                embed_name = "none"
        else:
            self.embed_model = None
            embed_name = "none"
        self.rag_cache = RAGCache(self.embed_model, embed_name, self.dataset_mgr.datasets_dir)

        self.command_executor = CommandExecutor(
            self.command_registry, self.schema_mgr, self.schema_auto_updater, self.beans,
            self.dataset_mgr, self.rag_cache, self.settings, self.plugins, self
        )

        self.fathom_kernel = FathomKernel(base_dir)

        self._idle_timer = QtCore.QTimer()
        self._idle_timer.timeout.connect(self._on_idle)
        self._idle_timer.start(86400000)  # nightly

        try:
            self.schema_mgr.schemaChanged.connect(self._on_schema_changed)
        except Exception:
            pass

    def _on_idle(self) -> None:
        self.fathom_kernel.lint_and_patch()

    def _on_schema_changed(self, persona: str, set_name: str) -> None:
        if persona == self.persona and set_name == self.set_name:
            self.dataset_mgr = DatasetManager(self.base_dir, self.persona, self.set_name)
            self.rag_cache.datasets_root = self.dataset_mgr.datasets_dir
            try:
                sch = self.schema_mgr.load_schema(self.persona, self.set_name)
                self.command_registry.register_from_schema(sch)
            except Exception:
                pass

    def process_user_message(self, message: str, tts: bool = False) -> str:
        self.conversation_db.save_message("user", message)
        if message.strip().startswith("/"):
            response = self.run_command(message.strip())
        else:
            self.context_monitor.add_message("user", message)
            if self.settings.auto_schema_enabled:
                analysis = self.context_monitor.analyze()
                self.schema_auto_updater.update_with_context(analysis)
            response = "Message processed."
        self.conversation_db.save_message("zira", response)
        if tts and self.settings.monologue_tts_enabled and self.tts_mgr is not None:
            self.tts_mgr.enqueue(response)
        return response

    def run_command(self, command_line: str,
                    persona: Optional[str] = None,
                    set_name: Optional[str] = None) -> str:
        try:
            self.plugins.broadcast({"type": "slash", "data": command_line})
        except Exception:
            pass

        if not persona and not set_name:
            try:
                sch = self.schema_mgr.load_schema(self.persona, self.set_name)
                self.command_registry.register_from_schema(sch)
            except Exception:
                pass
            try:
                return self.command_executor.execute(command_line)
            except Exception as e:
                return f"Command error: {e}"

        target_persona = (persona or self.persona).lower()
        target_set = set_name or self.set_name

        tmp_registry = CommandRegistry(self.base_dir, target_persona, target_set)
        try:
            sch = self.schema_mgr.load_schema(target_persona, target_set)
            tmp_registry.register_from_schema(sch)
        except Exception:
            pass
        tmp_beans = BeanCounter(self.base_dir, target_persona, target_set)
        tmp_datasets = DatasetManager(self.base_dir, target_persona, target_set)
        tmp_updater = SchemaAutoUpdater(self.schema_mgr, target_persona, target_set)
        tmp_rag = RAGCache(self.embed_model, getattr(self.rag_cache, "model_name", "MiniLM"), tmp_datasets.datasets_dir)

        tmp_exec = CommandExecutor(
            tmp_registry, self.schema_mgr, tmp_updater, tmp_beans,
            tmp_datasets, tmp_rag, self.settings, self.plugins, self
        )
        try:
            return tmp_exec.execute(command_line)
        except Exception as e:
            return f"Command error: {e}"

    def switch_persona_set(self, persona: Optional[str] = None, set_name: Optional[str] = None) -> None:
        if persona:
            self.persona = persona
        if set_name:
            self.set_name = set_name
        self.dataset_mgr = DatasetManager(self.base_dir, self.persona, self.set_name)
        self.conversation_db = ConversationDB(conv_db_path(self.base_dir, self.persona, self.set_name))
        self.feedback_db = SemanticFeedbackDB(feedback_db_path(self.base_dir, self.persona, self.set_name), self.base_dir, self.persona, self.set_name)
        self.beans = self.feedback_db.beans
        self.schema_auto_updater = SchemaAutoUpdater(self.schema_mgr, self.persona, self.set_name)
        self.schema_evolver = SchemaEvolver(self.schema_mgr, self.feedback_db, memory_state={})
        self.command_registry = CommandRegistry(self.base_dir, self.persona, self.set_name)
        try:
            sch = self.schema_mgr.load_schema(self.persona, self.set_name)
            self.command_registry.register_from_schema(sch)
        except Exception:
            pass
        self.command_executor = CommandExecutor(
            self.command_registry, self.schema_mgr, self.schema_auto_updater, self.beans,
            self.dataset_mgr, self.rag_cache, self.settings, self.plugins, self
        )
        self.rag_cache.datasets_root = self.dataset_mgr.datasets_dir

        # U-9: Auto-stop STT on context switch
        self.google_listener.stop_listener()

    def rag_search(self, query_text: str, per_ds_k: int = 4, limit: int = 10,
                   include_shared: bool = True,
                   datasets: Optional[List[str]] = None) -> List[Tuple[str, float, str, str]]:
        current_entries = self.dataset_mgr.get_active_datasets()
        if datasets:
            ds_set = set(datasets)
            current_entries = [e for e in current_entries if e.name in ds_set]
        packs: List[Tuple[DatasetManager, List[DatasetEntry]]] = [(self.dataset_mgr, current_entries)]

        if include_shared and self.schema_mgr.is_semantic_on(self.persona, self.set_name):
            shared = self.schema_mgr.get_shared_datasets(self.persona, self.set_name)
            if datasets:
                ds_set = set(datasets)
                shared = [e for e in shared if e.name in ds_set]
            owners: Dict[Tuple[str, str], List[DatasetEntry]] = {}
            for e in shared:
                try:
                    rel = os.path.relpath(e.path, self.base_dir).replace("\\", "/")
                    parts = rel.split("/")
                    idx = parts.index("profiles")
                    other_persona = parts[idx+1]
                    other_set = parts[idx+2]
                except Exception:
                    continue
                owners.setdefault((other_persona, other_set), []).append(e)
            for key, ents in owners.items():
                p, s = key
                packs.append((DatasetManager(self.base_dir, p, s), ents))

        hits = self.rag_cache.search_all(packs, query_text, per_ds_k=per_ds_k, limit=limit*2)
        hits.sort(key=lambda x: x[1], reverse=True)
        return hits[:limit]

    def refresh_prompt_cache(self) -> None:
        self.rag_cache.clear_memory()

    def add_feedback(self, original: str, liked: bool, revised: Optional[str] = None) -> None:
        self.feedback_db.add_feedback(original, liked, revised)
        hist = self.conversation_db.fetch_history(limit=50)
        try:
            self.schema_evolver.update_schema(self.persona, self.set_name, hist)
        except Exception:
            pass

    def _query_model(self, model: str, prompt: str) -> str:
        try:
            result = subprocess.run(["ollama", "run", model], input=prompt.encode("utf-8"),
                                    stdout=subprocess.PIPE, stderr=subprocess.PIPE, timeout=120)
            if result.returncode == 0:
                return result.stdout.decode("utf-8", errors="ignore").strip()
            else:
                err = result.stderr.decode("utf-8", "ignore")
                logger.error("[ollama:%s] error: %s", model, err)
        except Exception as e:
            logger.error("[ollama:%s] exception: %s", model, e)
        return f"(fallback) {prompt}"

    def start_listener(self) -> None:
        self.google_listener.start()

    def stop_listener(self) -> None:
        self.google_listener.stop_listener()

    def close(self) -> None:
        try:
            self.plugins.stop_all()
        except Exception:
            pass
        try:
            self.conversation_db.close()
        except Exception:
            pass
        try:
            self.feedback_db.close()
        except Exception:
            pass
        try:
            if self.tts_mgr:
                self.tts_mgr.close()
        except Exception:
            pass
        try:
            if hasattr(self, "reinforcement_log") and self.reinforcement_log:
                self.reinforcement_log.close()
        except Exception:
            pass
        self.stop_listener()

# ──────────────────────────────────────────────────────────────────────────────
# CLI entrypoint (optional smoke test)
# ──────────────────────────────────────────────────────────────────────────────
if __name__ == "__main__":
    base = os.path.abspath(os.path.join(os.getcwd(), ".agent_state"))
    core = AgentCore(base)
    print("AgentCore ready. Try '/commands list', '/dataset list', '/search your query', '/tts on', or '/schema active'. Ctrl+C to exit.")
    try:
        while True:
            line = input("you> ").strip()
            if not line:
                continue
            if line.lower() in {"quit", "exit"}:
                break
            if line.startswith("/"):
                m = re.match(r"^/as\s+(\w+)\s+(\w+)\s+--\s+(.*)$", line)
                if m:
                    p, s, cmd = m.groups()
                    out = core.run_command(cmd, persona=p, set_name=s)
                else:
                    out = core.run_command(line)
            else:
                out = core.process_user_message(line, tts=False)
            print("zira>", out)
    except KeyboardInterrupt:
        pass
    finally:
        core.close()
```

agent_core.py
=================

Full, end-to-end core for an AI AI TTS Agent with:
- Settings & model bootstrap (Ollama)
- Robust plugin host (enable/disable/list, manifest validation, dependency checks)
- Conversation & feedback stores (with indices, exports)
- Persona schema management (with protected keys) and live signals
- Dataset registry + RAG embeddings cache & query (per persona/set, cross-profile sharing)
  * Multi-file datasets, cache invalidation, provenance
- Context monitor + schema auto-updates driven by directives & feedback (rate-limited)
- Command registry (weight/lock) + full command execution layer
- New commands: /reject, /auto, /ignore, /opposite, /delete, /rewrite (extended persistence)
- BeanCounter reinforcement + integration with feedback and command weights
- Speech I/O (TTS locked to Zira; STT via Sphinx when available) w/ volume control
- Threaded model worker wrapper (cancel-safe)
- Orchestrator (`AgentCore`) wiring everything together for headless/GUI
- CLI entrypoint for smoke tests

Notes
-----
• This module is UI-agnostic. Hook the provided Qt signals in your GUI (`agent_ui.py`).
• All directories are scoped under `base_dir`, with per-persona/per-set state in:
  base_dir/profiles/<persona>/<set>/
**Classes:** Settings, ConversationDB, BeanCounter, SemanticFeedbackDB, ReinforcementStore, SchemaManager, OperatorManager, TTSManager, AudioRecorder, GoogleListener, DatasetEntry, DatasetManager, RAGCache, ContextMonitor, SchemaAutoUpdater, CommandRegistry, CommandExecutor, PluginMeta, PluginManager, SchemaEvolver, FathomKernel, ModelWorker, AgentCore
**Functions:** _have_cli(bin_name), ensure_models_present(), prof_dir(base_dir, persona, set_name), prof_datasets_dir(base_dir, persona, set_name), prof_commands_path(base_dir, persona, set_name), prof_reinforcement_path(base_dir, persona, set_name), conv_db_path(base_dir, persona, set_name), feedback_db_path(base_dir, persona, set_name)


## Module `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\AI_TTS_AGENT\AI TTS INFO\Zira Bot\agent_ui.py`

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
agent_ui.py
============

PyQt5 UI for the AI TTS Agent (integrated with AgentCore).

Fixes & additions:
- Slash commands (/remember etc.) now apply to the currently selected persona+set.
- Per-set "Semantic Awareness" persisted (schema.flags.semantic_awareness).
- RAG only uses datasets listed in the current set's schema ("datasets": [...]).
- Schema tab: new Commands row (dropdown + input + Add to Command + New Command).

To launch: `python run_agent.py`
"""

from __future__ import annotations

import os
import json
import time
import re
import subprocess
import threading
from typing import Dict, List, Tuple, Optional

from PyQt5 import QtCore, QtGui, QtWidgets

# Optional spell checker
try:
    from spellchecker import SpellChecker  # type: ignore
except Exception:
    SpellChecker = None  # type: ignore
from PyQt5.QtCore import QSettings, QRunnable, QThreadPool
from functools import partial

# Optional deps
try:
    from sentence_transformers import SentenceTransformer  # type: ignore
except Exception:
    SentenceTransformer = None  # type: ignore
try:
    import numpy as np  # type: ignore
except Exception:
    np = None  # type: ignore
try:
    import sounddevice as sd  # type: ignore
except Exception:
    sd = None  # type: ignore

from agent_core import (
    AgentCore,
    ModelWorker,
)

ROLE_COLOURS: Dict[str, str] = {
    "user": "#FFF8E1",
    "zira": "#E3F2FD",
    "system": "#E0F7FA",
    "operator": "#EDE7F6",
}
NAME_COLOURS: Dict[str, str] = {
    "user": "#5D4037",
    "zira": "#0D47A1",
    "system": "#006064",
    "operator": "#4A148C",
}

# ---------------------------------------------------------------------------
# Spell highlighting for misspelled words
# ---------------------------------------------------------------------------
class _SpellHighlighter(QtGui.QSyntaxHighlighter):
    """
    Underlines misspelled words in red. Uses pyspellchecker if available.
    """
    def __init__(self, document: QtGui.QTextDocument) -> None:
        super().__init__(document)
        # instantiate spell checker only if available
        self._spell = SpellChecker() if SpellChecker else None
        self._format = QtGui.QTextCharFormat()
        self._format.setUnderlineStyle(QtGui.QTextCharFormat.SpellCheckUnderline)
        self._format.setUnderlineColor(QtCore.Qt.red)
        # simple cache to avoid recomputing spelling on common words
        self._cache: Dict[str, bool] = {}

    def highlightBlock(self, text: str) -> None:
        if not self._spell:
            return
        for match in re.finditer(r"[A-Za-z']{3,}", text):
            word = match.group(0).lower()
            bad = self._cache.get(word)
            if bad is None:
                bad = word not in self._spell
                # prune cache occasionally
                if len(self._cache) > 2048:
                    self._cache.clear()
                self._cache[word] = bad
            if bad:
                start, end = match.span()
                length = end - start
                self.setFormat(start, length, self._format)


class AppWindow(QtWidgets.QMainWindow):
    """Main application window for the AI TTS Agent."""

    rewrite_ready = QtCore.pyqtSignal(str)

    def __init__(self) -> None:
        super().__init__()
        self.setWindowTitle("AI TTS Agent v2")
        self.resize(1920, 1080)

        self.base_dir = os.path.dirname(os.path.abspath(__file__))
        self.core = AgentCore(self.base_dir, persona="zira", set_name="default")

        self.current_set: Dict[str, str] = dict(self.core.schema_mgr.active_schemas)
        self.active_persona: str = self.core.persona or "zira"

        self.isolated_history: List[Tuple[str, str]] = []
        self.self_talk_enabled: bool = False
        self._plugin_docks: Dict[str, QtWidgets.QDockWidget] = {}
        self._schema_save_timers: Dict[str, QtCore.QTimer] = {}

        self._idle_timer = QtCore.QTimer(self)
        self._idle_timer.setSingleShot(True)
        self._idle_timer.timeout.connect(self._handle_idle)

        self._restore_layout()
        self._build_ui()
        # build the slash command panel (custom dock)
        self._build_command_dock()
        self._connect_signals()

        try:
            self.core.audio_recorder.transcribed.connect(self._on_transcribed)
        except Exception:
            pass

        self._update_feedback_counts()
        self._bootstrap_conversation()
        self._reset_idle_timer()

        # populate initial slash command list
        try:
            self._populate_command_select()
        except Exception:
            pass

    # ────────────────────────── signals
    def _connect_signals(self) -> None:
        self.btn_send.clicked.connect(self.send_message)

        self.btn_record.clicked.connect(self.start_recording)
        self.btn_stop_rec.clicked.connect(self.stop_recording)

        self.voice_combo.currentTextChanged.connect(self._on_voice_changed)
        # update settings when a new model is selected
        self.model_combo.currentTextChanged.connect(self._on_model_changed)

        self.btn_play.clicked.connect(self._on_play)
        self.btn_stop_tts.clicked.connect(self._on_stop_tts)
        self.btn_replay.clicked.connect(self._on_replay)

        self.btn_like.clicked.connect(self._on_like)
        self.btn_dislike.clicked.connect(self._on_dislike)
        self.btn_manage_feedback.clicked.connect(self._on_manage_feedback)

        self.btn_refresh.clicked.connect(self._on_refresh_chat)
        self.btn_manage_datasets.clicked.connect(self._on_manage_datasets)
        self.btn_inner_monologue.clicked.connect(self._on_inner_monologue)
        self.btn_clear_rag.clicked.connect(self._on_clear_rag_cache)
        self.btn_model_manager.clicked.connect(self._on_show_model_manager)

        self.chk_semantic.toggled.connect(self._on_semantic_toggled)
        self.chk_isolated.toggled.connect(self._on_isolated_toggled)
        self.chk_self_talk.toggled.connect(lambda v: setattr(self, "self_talk_enabled", v))
        self.chk_auto_schema.toggled.connect(self._on_auto_schema_toggled)

        # connect Google STT checkbox
        try:
            self.chk_google_stt.toggled.connect(self._on_google_stt_toggled)
        except Exception:
            pass

        self.rewrite_ready.connect(self._apply_rewrite_result)

        # context menu for chat view to send selection to command input
        try:
            self.chat_view.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
            self.chat_view.customContextMenuRequested.connect(self._show_chat_context_menu)
        except Exception:
            pass
        # custom context menu for spell suggestions on input field
        try:
            self.input_edit.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
            self.input_edit.customContextMenuRequested.connect(self._show_input_context_menu)
        except Exception:
            pass

    # ────────────────────────── layout & lifecycle
    def _restore_layout(self) -> None:
        qsettings = QSettings("xAI", "AI_TTS_Agent")
        try:
            self.restoreGeometry(qsettings.value("geometry", b""))
            self.restoreState(qsettings.value("windowState", b""))
        except Exception:
            pass

    def closeEvent(self, event: QtGui.QCloseEvent) -> None:
        qsettings = QSettings("xAI", "AI_TTS_Agent")
        qsettings.setValue("geometry", self.saveGeometry())
        qsettings.setValue("windowState", self.saveState())
        try:
            self.core.close()
        except Exception:
            pass
        super().closeEvent(event)

    # ────────────────────────── UI build
    def _build_ui(self) -> None:
        self.setStyleSheet(
            """
            QWidget { background-color: #2e3a51; color: #e0e0e0; }
            QGroupBox { border: 1px solid #007acc; margin-top: 7px; }
            QGroupBox::title { subcontrol-origin: margin; left: 12px; padding: 0 4px; }
            QPushButton { background-color: #3c4a6b; color: white; border: 1px solid #007acc; padding: 5px; }
            QPushButton:disabled { background-color: #5a5a7a; color: #c0c0c0; border: 1px solid #555555; }
            QPlainTextEdit, QTextEdit { background-color: #1e2738; color: #e0e0e0; border: 1px solid #007acc; }
            QLineEdit { background-color: #1e2738; color: #e0e0e0; border: 1px solid #007acc; }
            QTabBar::tab { background: #3c4a6b; color: white; border: 1px solid #007acc; padding: 5px 10px; }
            QTabBar::tab:selected { background: #007acc; color: white; }
            QComboBox { background-color: #1e2738; color: #e0e0e0; border: 1px solid #007acc; padding: 3px; }
            QListWidget { background-color: #1e2738; color: #e0e0e0; border: 1px solid #007acc; }
            QCheckBox, QLabel { color: #e0e0e0; }
            """
        )
        self.setDockOptions(
            QtWidgets.QMainWindow.AllowTabbedDocks
            | QtWidgets.QMainWindow.AllowNestedDocks
            | QtWidgets.QMainWindow.AnimatedDocks
        )
        self.setTabPosition(QtCore.Qt.AllDockWidgetAreas, QtWidgets.QTabWidget.North)
        self.setDockNestingEnabled(True)

        tb = QtWidgets.QToolBar("Layout", self)
        tb.setMovable(False)
        self.addToolBar(QtCore.Qt.TopToolBarArea, tb)
        self.chk_lock = QtWidgets.QCheckBox("Lock Layout")
        act = QtWidgets.QWidgetAction(self)
        act.setDefaultWidget(self.chk_lock)
        tb.addAction(act)
        self.chk_lock.toggled.connect(self._on_toggle_lock)

        self.setCentralWidget(QtWidgets.QWidget())
        status = QtWidgets.QStatusBar()
        self.setStatusBar(status)
        self.dock_tray = DockTray(self)
        status.addPermanentWidget(self.dock_tray, 1)

        self.progress_bar = QtWidgets.QProgressBar()
        self.progress_bar.setRange(0, 0)
        self.progress_bar.setVisible(False)
        status.addPermanentWidget(self.progress_bar)

        # Tabs for personas / operators
        self.tabs = QtWidgets.QTabWidget()
        self.tab_widgets: Dict[str, QtWidgets.QWidget] = {}
        for persona in self.core.schema_mgr.personas:
            tab = QtWidgets.QWidget()
            self.tab_widgets[persona] = tab
            self.tabs.addTab(tab, persona.capitalize())
        self.operator_tab = QtWidgets.QWidget()
        self.tabs.addTab(self.operator_tab, "Operators")
        self.tabs.currentChanged.connect(self._on_tab_changed)

        for persona, tab in self.tab_widgets.items():
            self._build_persona_tab(persona, tab)
        self._build_operator_tab(self.operator_tab)

        # Chat panel
        self.chat_view = QtWidgets.QTextEdit()
        self.chat_view.setReadOnly(True)
        self.chat_view.setStyleSheet("background-color: #e0eef5; color: #011627;")
        self.chat_view.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        self.input_edit = QtWidgets.QPlainTextEdit()
        self.input_edit.setPlaceholderText("Type your message or use /remember key value, /showfacts, /style, /weights")
        self.input_edit.setMinimumHeight(64)
        self.input_edit.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        # Attach spell checker highlighter if available
        try:
            if SpellChecker:
                self._spell_highlighter = _SpellHighlighter(self.input_edit.document())  # type: ignore[attr-defined]
        except Exception:
            self._spell_highlighter = None
        self.btn_send = QtWidgets.QPushButton("Send")

        chat_container = QtWidgets.QWidget()
        cv = QtWidgets.QVBoxLayout(chat_container)
        cv.setContentsMargins(7, 7, 7, 7)
        cv.setSpacing(7)
        cv.addWidget(self.chat_view, 1)
        cv.addWidget(self.input_edit)
        row = QtWidgets.QHBoxLayout()
        row.addStretch()
        row.addWidget(self.btn_send)
        cv.addLayout(row)

        # Controls panel
        controls_panel = QtWidgets.QWidget()
        cp_layout = QtWidgets.QVBoxLayout(controls_panel)
        cp_layout.setContentsMargins(7, 7, 7, 7)
        cp_layout.setSpacing(7)

        # Recording
        rec_row = QtWidgets.QHBoxLayout()
        self.btn_record = QtWidgets.QPushButton("Record")
        self.btn_stop_rec = QtWidgets.QPushButton("Stop\nTranscribe")
        self.btn_stop_rec.setEnabled(False)
        for b in (self.btn_record, self.btn_stop_rec):
            b.setMinimumHeight(32)
            b.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        rec_row.addWidget(self.btn_record, 1)
        rec_row.addWidget(self.btn_stop_rec, 1)
        cp_layout.addLayout(rec_row)

        # Microphone device
        mic_row = QtWidgets.QHBoxLayout()
        mic_row.addWidget(QtWidgets.QLabel("Mic:"))
        self.device_combo = QtWidgets.QComboBox()
        self._populate_devices()
        self.device_combo.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        mic_row.addWidget(self.device_combo, 1)
        cp_layout.addLayout(mic_row)

        # Toggles
        self.chk_semantic = QtWidgets.QCheckBox("Semantic Awareness")
        self.chk_semantic.setChecked(True)
        self.chk_isolated = QtWidgets.QCheckBox("Isolated Chat")
        self.chk_isolated.setChecked(False)
        self.chk_mute_tts = QtWidgets.QCheckBox("Mute TTS")
        self.chk_self_talk = QtWidgets.QCheckBox("Enable Self Talk")
        self.chk_self_talk.setChecked(False)
        self.chk_auto_schema = QtWidgets.QCheckBox("Auto Schema Evolution")
        self.chk_auto_schema.setChecked(self.core.settings.auto_schema_enabled)

        cp_layout.addWidget(self.chk_semantic)
        cp_layout.addWidget(self.chk_isolated)
        cp_layout.addWidget(self.chk_mute_tts)
        cp_layout.addWidget(self.chk_self_talk)
        cp_layout.addWidget(self.chk_auto_schema)

        # Optional Google STT toggle (default off)
        self.chk_google_stt = QtWidgets.QCheckBox("Google STT")
        try:
            self.chk_google_stt.setChecked(bool(getattr(self.core.settings, "use_google_stt", False)))
        except Exception:
            self.chk_google_stt.setChecked(False)
        cp_layout.addWidget(self.chk_google_stt)

        # RAG cache clear
        self.btn_clear_rag = QtWidgets.QPushButton("Clear RAG Cache")
        cp_layout.addWidget(self.btn_clear_rag)

        # Maintenance
        self.btn_refresh = QtWidgets.QPushButton("Refresh Chat")
        self.btn_manage_datasets = QtWidgets.QPushButton("Manage Datasets")
        self.btn_inner_monologue = QtWidgets.QPushButton("Inner Monologue")
        for b in (self.btn_refresh, self.btn_manage_datasets, self.btn_inner_monologue):
            b.setMinimumHeight(32)
            b.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
            cp_layout.addWidget(b)

        self.btn_model_manager = QtWidgets.QPushButton("Model Manager")
        self.btn_model_manager.setMinimumHeight(32)
        self.btn_model_manager.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        cp_layout.addWidget(self.btn_model_manager)

        # Style label
        self.style_label = QtWidgets.QLabel("Style: N/A")
        self.style_label.setToolTip("Style score (0–1): rough measure vs. tone rules.")
        cp_layout.addWidget(self.style_label)

        # Response + feedback
        self.response_edit = QtWidgets.QPlainTextEdit()
        self.response_edit.setReadOnly(True)
        self.response_edit.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        cp_layout.addWidget(self.response_edit, 1)

        fb = QtWidgets.QHBoxLayout()
        self.btn_like = QtWidgets.QPushButton("✔")
        self.btn_dislike = QtWidgets.QPushButton("✖")
        self.btn_like.setToolTip("Mark as good response")
        self.btn_dislike.setToolTip("Dislike and rewrite response")
        self.btn_like.setStyleSheet("color: #2ecc71; font-weight: bold;")
        self.btn_dislike.setStyleSheet("color: #e74c3c; font-weight: bold;")
        self.btn_like.setEnabled(False)
        self.btn_dislike.setEnabled(False)
        fb.addWidget(self.btn_like)
        fb.addWidget(self.btn_dislike)
        fb.addStretch()
        self.btn_manage_feedback = QtWidgets.QPushButton("Manage Feedback")
        fb.addWidget(self.btn_manage_feedback)
        cp_layout.addLayout(fb)

        # TTS playback
        tts_row = QtWidgets.QHBoxLayout()
        self.btn_play = QtWidgets.QPushButton("Play")
        self.btn_stop_tts = QtWidgets.QPushButton("Stop")
        self.btn_replay = QtWidgets.QPushButton("Replay")
        for b in (self.btn_play, self.btn_stop_tts, self.btn_replay):
            b.setMinimumHeight(32)
            b.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        tts_row.addWidget(self.btn_play)
        tts_row.addWidget(self.btn_stop_tts)
        tts_row.addWidget(self.btn_replay)
        cp_layout.addLayout(tts_row)

        # Voice & Model
        voice_row = QtWidgets.QHBoxLayout()
        voice_row.addWidget(QtWidgets.QLabel("Voice:"))
        self.voice_combo = QtWidgets.QComboBox()
        voices = self._tts_voice_names()
        if voices:
            self.voice_combo.addItems([v for v in voices if "david" not in v.lower()])
        voice_row.addWidget(self.voice_combo, 1)
        cp_layout.addLayout(voice_row)

        model_row = QtWidgets.QHBoxLayout()
        model_row.addWidget(QtWidgets.QLabel("Model:"))
        self.model_combo = QtWidgets.QComboBox()
        self._populate_models()
        model_row.addWidget(self.model_combo, 1)
        cp_layout.addLayout(model_row)

        # Feedback counts
        self.lbl_feedback_counts = QtWidgets.QLabel("Likes: 0 | Dislikes: 0")
        cp_layout.addWidget(self.lbl_feedback_counts)
        cp_layout.addStretch(1)

        controls_scroll = QtWidgets.QScrollArea()
        controls_scroll.setWidgetResizable(True)
        controls_scroll.setFrameShape(QtWidgets.QFrame.NoFrame)
        controls_scroll.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)
        controls_scroll.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        controls_scroll.setWidget(controls_panel)

        # Docks
        self.controls_dock = QtWidgets.QDockWidget("Controls", self)
        self.controls_dock.setObjectName("ControlsDock")
        self.controls_dock.setWidget(controls_scroll)
        self.controls_dock.setFeatures(
            QtWidgets.QDockWidget.DockWidgetClosable
            | QtWidgets.QDockWidget.DockWidgetMovable
            | QtWidgets.QDockWidget.DockWidgetFloatable
        )

        self.persona_dock = QtWidgets.QDockWidget("Personas", self)
        self.persona_dock.setObjectName("PersonaDock")
        self.persona_dock.setWidget(self._wrap_persona_widget())
        self.persona_dock.setFeatures(
            QtWidgets.QDockWidget.DockWidgetClosable
            | QtWidgets.QDockWidget.DockWidgetMovable
            | QtWidgets.QDockWidget.DockWidgetFloatable
        )

        self.chat_dock = QtWidgets.QDockWidget("Chat", self)
        self.chat_dock.setObjectName("ChatDock")
        self.chat_dock.setWidget(chat_container)
        self.chat_dock.setFeatures(
            QtWidgets.QDockWidget.DockWidgetClosable
            | QtWidgets.QDockWidget.DockWidgetMovable
            | QtWidgets.QDockWidget.DockWidgetFloatable
        )

        self.model_dock = QtWidgets.QDockWidget("Models", self)
        self.model_dock.setObjectName("ModelDock")
        self.model_dock.setFeatures(
            QtWidgets.QDockWidget.DockWidgetClosable
            | QtWidgets.QDockWidget.DockWidgetMovable
            | QtWidgets.QDockWidget.DockWidgetFloatable
        )
        self._build_model_manager()

        self.plugins_dock = QtWidgets.QDockWidget("Plugins", self)
        self.plugins_dock.setObjectName("PluginsDock")
        self.plugins_dock.setFeatures(
            QtWidgets.QDockWidget.DockWidgetClosable
            | QtWidgets.QDockWidget.DockWidgetMovable
            | QtWidgets.QDockWidget.DockWidgetFloatable
        )
        self.plugins_dock.setWidget(self._build_plugins_widget())

        # Titles & dock tray
        self.controls_dock.setTitleBarWidget(DockTitleBar(self.controls_dock, "Controls"))
        self.persona_dock.setTitleBarWidget(DockTitleBar(self.persona_dock, "Personas"))
        self.chat_dock.setTitleBarWidget(DockTitleBar(self.chat_dock, "Chat"))
        self.model_dock.setTitleBarWidget(DockTitleBar(self.model_dock, "Models"))
        self.plugins_dock.setTitleBarWidget(DockTitleBar(self.plugins_dock, "Plugins"))

        for d in (self.controls_dock, self.persona_dock, self.chat_dock, self.model_dock, self.plugins_dock):
            self.dock_tray.register_dock(d)

        self.addDockWidget(QtCore.Qt.LeftDockWidgetArea, self.controls_dock)
        self.addDockWidget(QtCore.Qt.LeftDockWidgetArea, self.persona_dock)
        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.chat_dock)
        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.model_dock)
        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.plugins_dock)

        self.splitDockWidget(self.controls_dock, self.persona_dock, QtCore.Qt.Vertical)
        self.splitDockWidget(self.controls_dock, self.chat_dock, QtCore.Qt.Horizontal)
        self.splitDockWidget(self.chat_dock, self.model_dock, QtCore.Qt.Horizontal)
        self.splitDockWidget(self.model_dock, self.plugins_dock, QtCore.Qt.Horizontal)

    # ────────────────────────── persona widgets
    def _wrap_persona_widget(self) -> QtWidgets.QWidget:
        container = QtWidgets.QWidget()
        v = QtWidgets.QVBoxLayout(container)
        v.setContentsMargins(7, 7, 7, 7)
        v.setSpacing(7)

        try:
            bot_schema = self.core.schema_mgr.load_schema("zira", self.current_set.get("zira", "default"))
            bot_name = bot_schema.get("name", "Zira")
            bot_set = self.current_set.get("zira", "default")
        except Exception:
            bot_name, bot_set = "Zira", "default"

        try:
            user_schema = self.core.schema_mgr.load_schema("user", self.current_set.get("user", "default"))
            user_name = user_schema.get("name", "User")
            user_set = self.current_set.get("user", "default")
        except Exception:
            user_name, user_set = "User", "default"

        self.lbl_active_names = QtWidgets.QLabel(f"{bot_name}: {bot_set} — User: {user_name}: {user_set}")
        v.addWidget(self.lbl_active_names)
        v.addWidget(self.tabs, 1)
        return container

    def _build_persona_tab(self, persona: str, tab: QtWidgets.QWidget) -> None:
        vbox = QtWidgets.QVBoxLayout(tab)

        # --- Set selector row ---
        h_set = QtWidgets.QHBoxLayout()
        h_set.addWidget(QtWidgets.QLabel("Set:"))
        combo = QtWidgets.QComboBox(objectName=f"set_combo_{persona}")
        self._populate_set_combo(persona, combo)
        h_set.addWidget(combo)

        btn_clone = QtWidgets.QPushButton("Clone", objectName=f"clone_set_{persona}")
        btn_new = QtWidgets.QPushButton("New", objectName=f"new_set_{persona}")
        btn_del = QtWidgets.QPushButton("Delete", objectName=f"del_set_{persona}")
        h_set.addWidget(btn_clone)
        h_set.addWidget(btn_new)
        h_set.addWidget(btn_del)
        h_set.addStretch()
        vbox.addLayout(h_set)

        # --- Commands row (NEW) ---
        cmd_row = QtWidgets.QHBoxLayout()
        cmd_row.addWidget(QtWidgets.QLabel("Commands:"))
        cmd_combo = QtWidgets.QComboBox(objectName=f"cmd_combo_{persona}")
        self._populate_command_combo(persona, cmd_combo)
        cmd_row.addWidget(cmd_combo, 1)

        cmd_edit = QtWidgets.QLineEdit(objectName=f"cmd_edit_{persona}")
        cmd_edit.setPlaceholderText('Enter text/payload for selected /command')
        cmd_row.addWidget(cmd_edit, 2)

        btn_add_cmd = QtWidgets.QPushButton("Add to Command", objectName=f"add_cmd_{persona}")
        btn_new_cmd = QtWidgets.QPushButton("New Command", objectName=f"new_cmd_{persona}")
        cmd_row.addWidget(btn_add_cmd)
        cmd_row.addWidget(btn_new_cmd)
        vbox.addLayout(cmd_row)

        # --- Schema editor ---
        editor = QtWidgets.QPlainTextEdit(objectName=f"schema_edit_{persona}")
        editor.setLineWrapMode(QtWidgets.QPlainTextEdit.NoWrap)
        schema = self.core.schema_mgr.load_schema(persona, self.current_set.get(persona, "default"))
        editor.setPlainText(json.dumps(schema, indent=2))
        vbox.addWidget(editor, 1)

        # --- Save button ---
        h_save = QtWidgets.QHBoxLayout()
        btn_save = QtWidgets.QPushButton("Save", objectName=f"save_schema_{persona}")
        h_save.addStretch()
        h_save.addWidget(btn_save)
        vbox.addLayout(h_save)

        # --- Button bindings ---
        combo.currentTextChanged.connect(lambda name, p=persona, c=combo: self._on_set_changed(p, name, c))
        btn_clone.clicked.connect(lambda _, p=persona, c=combo: self._on_clone_set(p, c))
        btn_new.clicked.connect(lambda _, p=persona, c=combo: self._on_new_set(p, c))
        btn_del.clicked.connect(lambda _, p=persona, c=combo: self._on_delete_set(p, c))
        btn_save.clicked.connect(lambda _, p=persona: self._on_save_schema(p))

        btn_add_cmd.clicked.connect(lambda _, p=persona, cc=cmd_combo, ce=cmd_edit: self._on_add_to_command(p, cc, ce))
        btn_new_cmd.clicked.connect(lambda _, p=persona: self._on_new_command(p))

        # --- Autosave debounce ---
        timer = QtCore.QTimer(self)
        timer.setSingleShot(True)

        def on_text_change() -> None:
            timer.start(500)

        def on_timeout() -> None:
            text = editor.toPlainText().strip()
            try:
                obj = json.loads(text)
                if isinstance(obj, dict):
                    set_name = self.current_set.get(persona, "default")
                    self.core.schema_mgr.save_schema(persona, set_name, obj)
            except Exception:
                pass

        editor.textChanged.connect(on_text_change)
        timer.timeout.connect(on_timeout)
        self._schema_save_timers[persona] = timer

    # --- Commands helpers (NEW) ---
    def _populate_command_combo(self, persona: str, combo: QtWidgets.QComboBox) -> None:
        combo.blockSignals(True)
        combo.clear()
        schema = self.core.schema_mgr.load_schema(persona, self.current_set.get(persona, "default"))
        cmds = []
        try:
            cmds = sorted(list((schema.get("commands") or {}).keys()))
        except Exception:
            cmds = []
        if not cmds:
            combo.addItem("(no commands)")
            combo.setEnabled(False)
        else:
            combo.addItems(cmds)
            combo.setEnabled(True)
        combo.blockSignals(False)

    def _on_add_to_command(self, persona: str, combo: QtWidgets.QComboBox, edit: QtWidgets.QLineEdit) -> None:
        text = edit.text().strip()
        if not text:
            QtWidgets.QMessageBox.information(self, "No Text", "Enter text/payload to add.")
            return
        set_name = self.current_set.get(persona, "default")
        schema = self.core.schema_mgr.load_schema(persona, set_name)
        cmds = dict(schema.get("commands") or {})
        sel = combo.currentText().strip()
        if not sel or sel == "(no commands)":
            QtWidgets.QMessageBox.information(self, "No Command", "Create a command first.")
            return
        lst = list(cmds.get(sel) or [])
        lst.append(text)
        cmds[sel] = lst
        schema["commands"] = cmds
        self.core.schema_mgr.save_schema(persona, set_name, schema)
        edit.clear()
        # refresh schema editor & notify
        self._refresh_schema_editor(persona)
        QtWidgets.QMessageBox.information(self, "Added", f'Added to {sel}: "{text}"')

    def _on_new_command(self, persona: str) -> None:
        name, ok = QtWidgets.QInputDialog.getText(self, "New Command", "Enter new command (e.g., /remember):")
        if not ok or not name.strip():
            return
        cmd_name = name.strip()
        if not cmd_name.startswith("/"):
            cmd_name = "/" + cmd_name
        set_name = self.current_set.get(persona, "default")
        schema = self.core.schema_mgr.load_schema(persona, set_name)
        cmds = dict(schema.get("commands") or {})
        if cmd_name in cmds:
            QtWidgets.QMessageBox.information(self, "Exists", f"Command {cmd_name} already exists.")
            return
        cmds[cmd_name] = []
        schema["commands"] = cmds
        self.core.schema_mgr.save_schema(persona, set_name, schema)
        # refresh command combo + schema editor
        tab = self.tab_widgets.get(persona)
        if tab:
            combo = tab.findChild(QtWidgets.QComboBox, f"cmd_combo_{persona}")
            if combo:
                self._populate_command_combo(persona, combo)
                combo.setCurrentText(cmd_name)
            edit = tab.findChild(QtWidgets.QLineEdit, f"cmd_edit_{persona}")
            if edit:
                edit.clear()
        self._refresh_schema_editor(persona)
        QtWidgets.QMessageBox.information(self, "Created", f"New command {cmd_name} created.")

    def _refresh_schema_editor(self, persona: str) -> None:
        tab = self.tab_widgets.get(persona)
        if not tab:
            return
        editor = tab.findChild(QtWidgets.QPlainTextEdit, f"schema_edit_{persona}")
        if editor:
            schema = self.core.schema_mgr.load_schema(persona, self.current_set.get(persona, "default"))
            editor.blockSignals(True)
            editor.setPlainText(json.dumps(schema, indent=2))
            editor.blockSignals(False)
            
    def _on_tab_changed(self, index: int) -> None:
        """
        Handle tab changes in the main tab widget.
        
        Parameters
        ----------
        index : int
            Index of the newly selected tab.
        """
        try:
            tab_name = self.tabs.tabText(index)
            print(f"[UI] Tab changed to: {tab_name} (index {index})")
            # Add any extra logic if needed, for example:
            # self._update_feedback_counts()
        except Exception as e:
            print(f"[UI] Error handling tab change: {e}")
            

    # ────────────────────────── operator tab
    def _build_operator_tab(self, tab: QtWidgets.QWidget) -> None:
        layout = QtWidgets.QVBoxLayout(tab)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)
        scroll = QtWidgets.QScrollArea()
        scroll.setWidgetResizable(True)
        scroll.setFrameShape(QtWidgets.QFrame.NoFrame)
        scroll.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        container = QtWidgets.QWidget()
        container.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        vbox = QtWidgets.QVBoxLayout(container)
        vbox.setContentsMargins(8, 8, 8, 8)
        vbox.setSpacing(8)

        names = sorted(self.core.operator_mgr.list_operators())
        if not names:
            info = QtWidgets.QLabel("No operators found.")
            info.setWordWrap(True)
            vbox.addWidget(info)
        else:
            for name in names:
                # Load operator description if available
                try:
                    op_dir = os.path.join(self.core.operator_mgr.operators_dir, name, "schema.json")
                    desc = ""
                    if os.path.isfile(op_dir):
                        with open(op_dir, "r", encoding="utf-8") as f:
                            d = json.load(f)
                            desc = str(d.get("description", ""))
                except Exception:
                    desc = ""
                box = QtWidgets.QGroupBox(name)
                box.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
                bl = QtWidgets.QVBoxLayout(box)
                bl.setContentsMargins(8, 8, 8, 8)
                bl.setSpacing(6)
                lbl = QtWidgets.QLabel(desc)
                lbl.setWordWrap(True)
                bl.addWidget(lbl)
                btn_row = QtWidgets.QHBoxLayout()
                btn_info = QtWidgets.QPushButton("Info")
                btn_row.addWidget(btn_info)
                btn_row.addStretch(1)
                bl.addLayout(btn_row)
                vbox.addWidget(box)
                btn_info.clicked.connect(partial(QtWidgets.QMessageBox.information, self, f"{name} Info", desc or "No description."))

        vbox.addStretch(1)
        scroll.setWidget(container)
        layout.addWidget(scroll)

    # ────────────────────────── plugins
    def _build_plugins_widget(self) -> QtWidgets.QWidget:
        container = QtWidgets.QWidget()
        layout = QtWidgets.QVBoxLayout(container)
        layout.setContentsMargins(6, 6, 6, 6)
        layout.setSpacing(4)

        self.plugin_list = QtWidgets.QListWidget()
        self.plugin_list.setSelectionMode(QtWidgets.QAbstractItemView.NoSelection)
        layout.addWidget(self.plugin_list, 1)

        btn_rescan = QtWidgets.QPushButton("Rescan")
        layout.addWidget(btn_rescan)
        btn_rescan.clicked.connect(self._rescan_plugins)

        self._populate_plugin_list()
        self.plugin_list.itemChanged.connect(self._on_plugin_item_changed)

        try:
            self.core.plugins.eventReceived.connect(self._on_plugin_event)
        except Exception:
            pass

        return container

    def _populate_plugin_list(self) -> None:
        self.plugin_list.blockSignals(True)
        self.plugin_list.clear()
        for meta in self.core.plugins.list_plugins():
            item = QtWidgets.QListWidgetItem(meta.name)
            flags = item.flags() | QtCore.Qt.ItemIsUserCheckable
            if meta.missing_dependencies:
                flags &= ~QtCore.Qt.ItemIsEnabled
                item.setToolTip(f"Missing dependencies: {', '.join(meta.missing_dependencies)}")
            item.setFlags(flags)
            item.setCheckState(QtCore.Qt.Checked if meta.enabled else QtCore.Qt.Unchecked)
            self.plugin_list.addItem(item)
        self.plugin_list.blockSignals(False)

    def _on_plugin_item_changed(self, item: QtWidgets.QListWidgetItem) -> None:
        name = item.text()
        enabled = item.checkState() == QtCore.Qt.Checked
        self.core.plugins.enable_plugin(name, enabled)
        meta = next((m for m in self.core.plugins.list_plugins() if m.name == name), None)
        if not meta:
            return
        if enabled and meta.widget is not None:
            self._attach_plugin_widget(meta)
        elif not enabled:
            self._detach_plugin_widget(name)

    def _rescan_plugins(self) -> None:
        self.core.plugins.rescan()
        for name in list(self._plugin_docks.keys()):
            meta = next((m for m in self.core.plugins.list_plugins() if m.name == name), None)
            if not meta or not meta.enabled:
                self._detach_plugin_widget(name)
        self._populate_plugin_list()

    def _attach_plugin_widget(self, meta: 'object') -> None:
        if meta.name in self._plugin_docks:
            return
        if meta.widget is None:
            return
        dock = QtWidgets.QDockWidget(meta.name, self)
        dock.setObjectName(f"PluginDock_{meta.name}")
        dock.setWidget(meta.widget)
        dock.setFeatures(
            QtWidgets.QDockWidget.DockWidgetClosable
            | QtWidgets.QDockWidget.DockWidgetMovable
            | QtWidgets.QDockWidget.DockWidgetFloatable
        )
        dock.setTitleBarWidget(DockTitleBar(dock, meta.name))
        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, dock)
        self.dock_tray.register_dock(dock)
        self._plugin_docks[meta.name] = dock

    def _detach_plugin_widget(self, name: str) -> None:
        dock = self._plugin_docks.pop(name, None)
        if dock:
            self.dock_tray._remove_button(dock)
            dock.setParent(None)
            dock.deleteLater()

    @QtCore.pyqtSlot(str, dict)
    def _on_plugin_event(self, sender: str, envelope: dict) -> None:
        try:
            data = envelope.get("data")
            msg = json.dumps(data, indent=2) if isinstance(data, (dict, list)) else str(data)
            display_name = sender
            self._append_message(display_name, msg, role_key="operator")
            if self.chk_semantic.isChecked() and not self.chk_isolated.isChecked():
                self.core.conversation_db.save_message(sender.lower(), msg)
        except Exception as e:
            print(f"Error handling plugin event from {sender}: {e}")

    # ────────────────────────── model manager
    def _build_model_manager(self) -> None:
        widget = QtWidgets.QWidget()
        v = QtWidgets.QVBoxLayout(widget)
        v.setContentsMargins(8, 8, 8, 8)
        v.setSpacing(6)
        self.model_list = QtWidgets.QListWidget()
        v.addWidget(self.model_list, 1)
        h = QtWidgets.QHBoxLayout()
        self.btn_model_pull = QtWidgets.QPushButton("Pull")
        self.btn_model_delete = QtWidgets.QPushButton("Delete")
        self.btn_model_set_default = QtWidgets.QPushButton("Set as Default")
        h.addWidget(self.btn_model_pull)
        h.addWidget(self.btn_model_delete)
        h.addWidget(self.btn_model_set_default)
        h.addStretch()
        v.addLayout(h)
        self.model_dock.setWidget(widget)
        self._refresh_model_list()
        self.btn_model_pull.clicked.connect(self._on_model_pull)
        self.btn_model_delete.clicked.connect(self._on_model_delete)
        self.btn_model_set_default.clicked.connect(self._on_model_set_default)

    def _refresh_model_list(self) -> None:
        self.model_list.clear()
        models: List[str] = []
        try:
            out = subprocess.run(
                ["ollama", "list"],
                stdout=subprocess.PIPE,
                stderr=subprocess.DEVNULL,
                text=True,
                check=True,
            ).stdout.splitlines()
            for line in out[1:]:
                parts = line.strip().split()
                if parts:
                    models.append(parts[0])
        except Exception:
            models = []
        for m in models:
            item = QtWidgets.QListWidgetItem(m)
            if m == self.model_combo.currentText().strip():
                item.setFont(QtGui.QFont("", weight=QtGui.QFont.Bold))
            self.model_list.addItem(item)

    def _on_model_pull(self) -> None:
        item = self.model_list.currentItem()
        if not item:
            return
        model = item.text()
        threading.Thread(target=lambda: subprocess.run(["ollama", "pull", model], check=False), daemon=True).start()
        QtWidgets.QMessageBox.information(self, "Pull Started", f"Pulling {model} in background.")

    def _on_model_delete(self) -> None:
        item = self.model_list.currentItem()
        if not item:
            return
        model = item.text()
        if QtWidgets.QMessageBox.question(
            self,
            "Delete Model",
            f"Delete '{model}'? This cannot be undone.",
            QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No,
        ) != QtWidgets.QMessageBox.Yes:
            return
        threading.Thread(target=lambda: subprocess.run(["ollama", "delete", model], check=False), daemon=True).start()
        QtWidgets.QMessageBox.information(self, "Delete Started", f"Deleting {model} in background.")
        self._refresh_model_list()

    def _on_model_set_default(self) -> None:
        item = self.model_list.currentItem()
        if not item:
            return
        model = item.text()
        idx = self.model_combo.findText(model)
        if idx >= 0:
            self.model_combo.setCurrentIndex(idx)
        # persist selection to settings
        try:
            self.core.settings.default_model = model
            self.core.settings.save()
        except Exception:
            pass
            QtWidgets.QMessageBox.information(self, "Default Model", f"Set default model to {model}.")
        else:
            self.model_combo.addItem(model)
            self.model_combo.setCurrentText(model)

    # ────────────────────────── lock layout
    def _on_toggle_lock(self, locked: bool) -> None:
        feats_unlocked = (
            QtWidgets.QDockWidget.DockWidgetClosable
            | QtWidgets.QDockWidget.DockWidgetMovable
            | QtWidgets.QDockWidget.DockWidgetFloatable
        )
        feats_locked = QtWidgets.QDockWidget.DockWidgetClosable
        for dock in (
            self.controls_dock,
            self.persona_dock,
            self.chat_dock,
            getattr(self, "inner_dock", None),
            self.model_dock,
            self.plugins_dock,
        ):
            if dock is None:
                continue
            dock.setFeatures(feats_locked if locked else feats_unlocked)
        for dock in self._plugin_docks.values():
            dock.setFeatures(feats_locked if locked else feats_unlocked)

    # ────────────────────────── audio
    def start_recording(self) -> None:
        if sd is None or np is None:
            QtWidgets.QMessageBox.information(self, "Recording Unavailable", "sounddevice/numpy not installed.")
            return
        if not self.btn_record.isEnabled():
            return
        device_index = None
        try:
            idx = self.device_combo.currentIndex()
            selected_name = self.device_combo.currentText()
            for i, d in enumerate(sd.query_devices()):
                if d.get("name") == selected_name and d.get("max_input_channels", 0) > 0:
                    device_index = i
                    break
        except Exception:
            device_index = None
        self.core.audio_recorder.start(device_index)
        self.btn_record.setEnabled(False)
        self.btn_stop_rec.setEnabled(True)

    def stop_recording(self) -> None:
        if not self.btn_stop_rec.isEnabled():
            return
        self.core.audio_recorder.stop_and_transcribe()
        self.btn_stop_rec.setEnabled(False)
        self.btn_record.setEnabled(True)

    @QtCore.pyqtSlot(str)
    def _on_transcribed(self, text: str) -> None:
        if not text:
            return
        cur = self.input_edit.toPlainText()
        self.input_edit.setPlainText((cur + "\n" if cur else "") + text)

    # ────────────────────────── TTS
    def _on_play(self) -> None:
        text = self.response_edit.toPlainText().strip()
        if text and not self.chk_mute_tts.isChecked():
            try:
                self.core.tts_mgr.enqueue(text)
            except Exception:
                pass

    def _on_stop_tts(self) -> None:
        try:
            self.core.tts_mgr.stop()
        except Exception:
            pass

    def _on_replay(self) -> None:
        if not self.chk_mute_tts.isChecked():
            try:
                self.core.tts_mgr.replay()
            except Exception:
                pass

    def _on_voice_changed(self, name: str) -> None:
        try:
            eng = getattr(self.core.tts_mgr, "_engine", None)
            if eng:
                for v in eng.getProperty("voices"):
                    if v.name == name:
                        eng.setProperty("voice", v.id)
                        break
        except Exception:
            pass

    def _tts_voice_names(self) -> List[str]:
        try:
            eng = getattr(self.core.tts_mgr, "_engine", None)
            if not eng:
                return []
            return [v.name for v in eng.getProperty("voices")]
        except Exception:
            return []

    # ────────────────────────── feedback
    def _on_like(self) -> None:
        text = self.response_edit.toPlainText().strip()
        if not text:
            return
        try:
            self.core.add_feedback(text, liked=True)
        except Exception:
            pass
        QtWidgets.QMessageBox.information(self, "Feedback", "Marked as good response.")
        self._enable_feedback(False)
        self._update_feedback_counts()

    def _on_dislike(self) -> None:
        original = self.response_edit.toPlainText().strip()
        if not original:
            return
        try:
            self.core.tts_mgr.stop()
        except Exception:
            pass
        QtWidgets.QMessageBox.information(self, "Disliked", "The response will be rewritten.")
        self._enable_feedback(False)

        def worker() -> None:
            new_text = self._rewrite_response(original)
            try:
                self.core.add_feedback(original, liked=False, revised=new_text)
            except Exception:
                pass
            if self.chk_isolated.isChecked():
                self.isolated_history.append((self._current_persona(), new_text))
            else:
                if self.chk_semantic.isChecked():
                    self.core.conversation_db.save_message(self._current_persona().lower(), new_text)
            self.rewrite_ready.emit(new_text)

        threading.Thread(target=worker, daemon=True).start()

    @QtCore.pyqtSlot(str)
    def _apply_rewrite_result(self, new_text: str) -> None:
        schema = self.core.schema_mgr.load_schema(
            self._current_persona(), self.current_set.get(self._current_persona(), "default")
        )
        persona_name = schema.get("name", "Bot")
        role_key = self._current_persona().lower()
        self._append_message(persona_name, new_text, role_key=role_key)
        self.response_edit.setPlainText(new_text)
        if not self.chk_mute_tts.isChecked():
            try:
                self.core.tts_mgr.enqueue(new_text)
            except Exception:
                pass
        QtWidgets.QMessageBox.information(self, "Rewritten", "Response rewritten.")
        self._enable_feedback(False)

    def _update_feedback_counts(self) -> None:
        try:
            pos, neg = self.core.feedback_db.get_counts()
            self.lbl_feedback_counts.setText(f"Likes: {pos} | Dislikes: {neg}")
        except Exception:
            self.lbl_feedback_counts.setText("Likes: - | Dislikes: -")

    def _enable_feedback(self, enabled: bool) -> None:
        self.btn_like.setEnabled(enabled)
        self.btn_dislike.setEnabled(enabled)

    def _on_manage_feedback(self) -> None:
        db = self.core.feedback_db
        if db is None:
            QtWidgets.QMessageBox.information(self, "No DB", "Feedback DB unavailable.")
            return
        cur = db.conn.cursor()
        cur.execute("SELECT id, original, liked, COALESCE(revised, '') FROM feedback ORDER BY id DESC")
        entries = cur.fetchall()
        dlg = QtWidgets.QDialog(self)
        dlg.setWindowTitle("Manage Feedback")
        dlg.resize(720, 420)
        v = QtWidgets.QVBoxLayout(dlg)
        table = QtWidgets.QTableWidget(len(entries), 4)
        table.setHorizontalHeaderLabels(["ID", "Original", "Liked", "Revised"])
        table.horizontalHeader().setStretchLastSection(True)
        for r, (fid, orig, liked, rev) in enumerate(entries):
            table.setItem(r, 0, QtWidgets.QTableWidgetItem(str(fid)))
            table.setItem(r, 1, QtWidgets.QTableWidgetItem(orig))
            table.setItem(r, 2, QtWidgets.QTableWidgetItem("✔" if liked else "✖"))
            table.setItem(r, 3, QtWidgets.QTableWidgetItem(rev))
        v.addWidget(table, 1)
        h = QtWidgets.QHBoxLayout()
        btn_del = QtWidgets.QPushButton("Delete Selected")
        btn_close = QtWidgets.QPushButton("Close")
        h.addWidget(btn_del)
        h.addWidget(btn_close)
        h.addStretch()
        v.addLayout(h)

        def on_delete() -> None:
            selected = table.selectedItems()
            if not selected:
                return
            rows = sorted({i.row() for i in selected}, reverse=True)
            for rr in rows:
                fid_item = table.item(rr, 0)
                if fid_item:
                    try:
                        fid = int(fid_item.text())
                        db.conn.execute("DELETE FROM feedback WHERE id = ?", (fid,))
                        db.conn.commit()
                    except Exception:
                        pass
                table.removeRow(rr)
            self._update_feedback_counts()

        btn_del.clicked.connect(on_delete)
        btn_close.clicked.connect(dlg.accept)
        dlg.exec_()

    # ────────────────────────── datasets / rag
    def _on_manage_datasets(self) -> None:
        DatasetManagerDialog(self.core.dataset_mgr, self).exec_()

    def _on_clear_rag_cache(self) -> None:
        if QtWidgets.QMessageBox.question(
            self,
            "Clear RAG Cache",
            "Delete cached embeddings for all datasets and clear memory?",
            QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No,
        ) != QtWidgets.QMessageBox.Yes:
            return
        count = self.core.rag_cache.clear_disk()
        self.core.rag_cache.clear_memory()
        QtWidgets.QMessageBox.information(self, "Cleared", f"Cleared RAG cache files ({count} removed) and in-memory index.")

    # ────────────────────────── isolated / refresh / idle
    def _on_isolated_toggled(self, checked: bool) -> None:
        if checked:
            self.isolated_history.clear()
        else:
            if self.isolated_history:
                ans = QtWidgets.QMessageBox.question(
                    self,
                    "Merge Isolated Chat",
                    "Merge isolated conversation into main memory?",
                    QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No,
                )
                if ans == QtWidgets.QMessageBox.Yes:
                    for role, content in self.isolated_history:
                        self.core.conversation_db.save_message(role.lower(), content)
                self.isolated_history.clear()
        self._reset_idle_timer()

    def _on_refresh_chat(self) -> None:
        if self.chk_isolated.isChecked():
            self.isolated_history.clear()
        self.chat_view.clear()
        self.response_edit.clear()
        self._enable_feedback(False)
        try:
            if hasattr(self, "inner_text") and self.inner_text is not None:
                self.inner_text.clear()
        except Exception:
            pass

    def _reset_idle_timer(self) -> None:
        self._idle_timer.stop()
        if self.chk_semantic.isChecked():
            self._idle_timer.start(60000)

    def _handle_idle(self) -> None:
        pass

    # ────────────────────────── inner monologue
    def _on_inner_monologue(self) -> None:
        self._ensure_inner_dock()
        if self.inner_dock is None:
            return
        self.inner_dock.setVisible(not self.inner_dock.isVisible())

    def _ensure_inner_dock(self) -> None:
        if hasattr(self, "inner_dock") and self.inner_dock is not None:
            return
        dock = QtWidgets.QDockWidget("Inner Monologue", self)
        dock.setObjectName("InnerDock")
        dock.setAllowedAreas(QtCore.Qt.RightDockWidgetArea | QtCore.Qt.LeftDockWidgetArea)
        inner = QtWidgets.QWidget()
        v = QtWidgets.QVBoxLayout(inner)
        self.inner_text = QtWidgets.QPlainTextEdit()
        self.inner_text.setReadOnly(True)
        v.addWidget(self.inner_text, 1)
        h = QtWidgets.QHBoxLayout()
        h.addWidget(QtWidgets.QLabel("Interval (s):"))
        self.spin_interval = QtWidgets.QSpinBox()
        self.spin_interval.setRange(1, 60)
        self.spin_interval.setValue(15)
        h.addWidget(self.spin_interval)
        self.chk_monologue_tts = QtWidgets.QCheckBox("Speak")
        self.chk_monologue_tts.setChecked(self.core.settings.monologue_tts_enabled)
        h.addWidget(self.chk_monologue_tts)
        h.addWidget(QtWidgets.QLabel("Volume:"))
        self.slider_monologue_vol = QtWidgets.QSlider(QtCore.Qt.Horizontal)
        self.slider_monologue_vol.setRange(0, 100)
        self.slider_monologue_vol.setValue(self.core.settings.monologue_volume)
        h.addWidget(self.slider_monologue_vol)
        btn_start_stop = QtWidgets.QPushButton("Start/Stop")
        h.addWidget(btn_start_stop)
        v.addLayout(h)
        inner.setLayout(v)
        dock.setWidget(inner)
        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, dock)
        self.inner_dock = dock
        self.inner_timer = QtCore.QTimer(self)
        self.inner_timer.setSingleShot(False)
        btn_start_stop.clicked.connect(self._toggle_inner_timer)
        dock.setTitleBarWidget(DockTitleBar(dock, "Inner Monologue"))
        self.dock_tray.register_dock(self.inner_dock)
        self.chk_monologue_tts.stateChanged.connect(lambda _: self._update_monologue_settings())
        self.slider_monologue_vol.valueChanged.connect(lambda _: self._update_monologue_settings())

    def _toggle_inner_timer(self) -> None:
        if self.inner_timer is None:
            return
        if self.inner_timer.isActive():
            self.inner_timer.stop()
        else:
            interval_ms = self.spin_interval.value() * 1000
            try:
                self.inner_timer.timeout.disconnect()
            except Exception:
                pass
            self.inner_timer.timeout.connect(self._generate_inner_monologue)
            self.inner_timer.start(interval_ms)

    def _update_monologue_settings(self) -> None:
        try:
            self.core.settings.monologue_tts_enabled = self.chk_monologue_tts.isChecked() if hasattr(self, 'chk_monologue_tts') else False
            self.core.settings.monologue_volume = self.slider_monologue_vol.value() if hasattr(self, 'slider_monologue_vol') else 50
            self.core.settings.save()
        except Exception:
            pass

    def _generate_inner_monologue(self) -> None:
        schema = self.core.schema_mgr.load_schema(self._current_persona(), self.current_set.get(self._current_persona(), "default"))
        overlay = schema.get("dynamic_overlay", {}) or {}
        mood = overlay.get("temporary_emotional_state", "neutral")
        likes = overlay.get("recent_topics", [])
        pos = [0, 0]
        fav_topic = likes[-1] if likes else None
        thought = f"I'm thinking about {fav_topic} while feeling {mood}." if fav_topic else f"I'm in a {mood} mood and reflecting."
        thought += f" I'm at position {pos}."
        try:
            if hasattr(self, "inner_text") and self.inner_text is not None:
                self.inner_text.appendPlainText(thought)
        except Exception:
            pass

    # ────────────────────────── conversation
    def _append_message(self, display_name: str, text: str, role_key: Optional[str] = None) -> None:
        key = (role_key or display_name).lower()
        bg_colour = ROLE_COLOURS.get(key, "#EEEEEE")
        name_colour = NAME_COLOURS.get(key, "#011627")
        safe_role = QtGui.QGuiApplication.translate("Chat", display_name)
        safe_text = QtGui.QGuiApplication.translate("Chat", text)
        frag = (
            f'<div style="background-color:{bg_colour}; border-radius:4px; padding:4px; margin:4px;">'
            f'<b style="color:{name_colour};">{safe_role}:</b> {safe_text}'
            f'</div>'
        )
        self.chat_view.append(frag)

    def _current_history(self) -> List[Tuple[str, str]]:
        if self.chk_isolated.isChecked():
            return self.isolated_history
        else:
            return self.core.conversation_db.fetch_history(limit=10)

    def _bootstrap_conversation(self) -> None:
        if self.core and len(self.core.conversation_db.fetch_history(limit=1)) == 0:
            schema = self.core.schema_mgr.load_schema(self.active_persona, self.current_set.get(self.active_persona, "default"))
            questions = schema.get("questions", [])
            if questions:
                first_question = questions[0]
                self._append_message("System", first_question, role_key="system")
                if self.chk_semantic.isChecked() and not self.chk_isolated.isChecked():
                    self.core.conversation_db.save_message("system", first_question)

    # ────────────────────────── prompt & rag
    def _build_prompt(self, schema: Dict[str, object], user_text: str, is_self_talk: bool = False) -> str:
        parts: List[str] = []
        name = schema.get("name", "")
        role = schema.get("role", "")
        desc = schema.get("description", "")
        persona_desc = f"You are {name}, {desc}".strip()
        if role:
            persona_desc += f" Your role is {role}."

        overlay = schema.get("dynamic_overlay", {})
        if overlay:
            temp_rel = overlay.get("temporary_relationship_context", "")
            temp_emotion = overlay.get("temporary_emotional_state", "")
            added_traits = overlay.get("added_traits", [])
            if temp_rel:
                persona_desc += f" ({temp_rel})"
            if temp_emotion:
                persona_desc += f" You feel {temp_emotion}."
            if added_traits:
                persona_desc += f" Traits: {', '.join(str(t) for t in added_traits)}."
        parts.append(persona_desc)

        # User description
        try:
            user_schema = self.core.schema_mgr.load_schema("user", self.current_set.get("user", "default"))
        except Exception:
            user_schema = {}
        if user_schema:
            u_name = user_schema.get("name", "User")
            u_personality = user_schema.get("personality", "")
            relationship = user_schema.get("relationship_to_zira", "friend")
            u_overlay = user_schema.get("dynamic_overlay", {})
            temp_rel2 = u_overlay.get("temporary_relationship_context") if u_overlay else None
            if temp_rel2 and str(temp_rel2).strip():
                relationship = str(temp_rel2)
            user_desc = f"User is {u_name}, {u_personality}. Relationship: {relationship}."
            parts.append(user_desc)

        # History
        history_text = ""
        if self.chk_semantic.isChecked():
            history = self._current_history()[-10:]
            for role_name, content in history:
                speaker = "User" if role_name.lower() == "user" else role_name.title()
                history_text += f"{speaker}: {content}\n"
        if history_text:
            parts.append("Conversation history:\n" + history_text.strip())

        # RAG (only datasets listed by this set)
        dataset_text = ""
        ds_names: List[str] = list(schema.get("datasets") or [])
        try:
            # Prefer core search with filters if supported
            hits = self.core.rag_search(
                user_text,
                per_ds_k=3,
                limit=5,
                include_shared=False,
                datasets=ds_names if ds_names else None,
            )
            for chunk, score, ds_name, owner in hits:
                dataset_text += f"Dataset ({owner}/{ds_name}):\n{chunk}\n\n"
        except TypeError:
            # Older core: no dataset filter; fallback to manual selection
            from_texts: List[Tuple[str, str]] = []
            try:
                for name, entry in self.core.dataset_mgr.entries.items():
                    if ds_names and name not in ds_names:
                        continue
                    if not entry.active:
                        continue
                    full_text = self.core.dataset_mgr.load_dataset_text(entry)
                    if full_text:
                        from_texts.append((name, full_text))
            except Exception:
                pass
            for name, full_text in from_texts:
                snip = self._retrieve_dataset_snippet(full_text, user_text)
                if snip:
                    dataset_text += f"Dataset ({name}):\n{snip}\n\n"
        except Exception:
            pass
        if dataset_text:
            parts.append(dataset_text.strip())

        # Self-talk (optional)
        if is_self_talk and self.self_talk_enabled:
            st_prompts = schema.get("self_talk", [])
            if st_prompts:
                import random
                parts.append(random.choice(st_prompts))

        parts.append(f"User: {user_text}")
        return "\n\n".join([p for p in parts if p])

    def _retrieve_dataset_snippet(self, full_text: str, user_text: str) -> str:
        try:
            tokens = [w.lower() for w in re.findall(r"\b\w+\b", user_text) if len(w) > 2]
            paragraphs = [p.strip() for p in full_text.split("\n") if p.strip()]
            scored: List[Tuple[int, str]] = []
            for para in paragraphs:
                l = para.lower()
                score = sum(1 for t in tokens if t in l)
                if score > 0:
                    scored.append((score, para))
            if not scored:
                return paragraphs[0][:500] if paragraphs else full_text[:500]
            scored.sort(key=lambda x: -x[0])
            top = [p for _, p in scored[:2]]
            return "\n".join(top)[:500]
        except Exception:
            return full_text[:500]

    # ────────────────────────── send / model
    def send_message(self) -> None:
        user_text = self.input_edit.toPlainText().strip()
        if not user_text:
            return

        # Broadcast to plugins
        try:
            self.core.plugins.broadcast(user_text)
        except Exception:
            pass

        # Slash commands → ensure applied to current persona+set
        if user_text.startswith("/"):
            self.input_edit.clear()
            persona = self._current_persona()
            set_name = self.current_set.get(persona, "default")
            try:
                out = self.core.run_command(user_text, persona=persona, set_name=set_name)
            except TypeError:
                # Back-compat signature
                out = self.core.run_command(user_text)
            self._append_message("System", out, role_key="system")
            if self.chk_semantic.isChecked() and not self.chk_isolated.isChecked():
                self.core.conversation_db.save_message("system", out)
            return

        # Normal message
        self.input_edit.clear()
        persona = self._current_persona()
        set_name = self.current_set.get(persona, "default")
        schema = self.core.schema_mgr.load_schema(persona, set_name)

        if self.chk_isolated.isChecked():
            self.isolated_history.append(("user", user_text))
        else:
            if self.chk_semantic.isChecked():
                self.core.conversation_db.save_message("user", user_text)

        try:
            user_schema = self.core.schema_mgr.load_schema("user", self.current_set.get("user", "default"))
            user_display = user_schema.get("name", "User")
        except Exception:
            user_display = "User"
        self._append_message(user_display, user_text, role_key="user")

        prompt = self._build_prompt(schema, user_text)

        self.btn_send.setEnabled(False)
        model_slug = self.model_combo.currentText().strip() or self.core.settings.default_model
        worker = ModelWorker(model_slug, prompt, parent=self.core)
        worker.finished.connect(lambda resp, usr=user_text, sch=schema: self._on_model_response(resp, usr, sch))
        worker.finished.connect(lambda: self.btn_send.setEnabled(True))
        worker.start()

    def _on_model_response(self, response_raw: str, user_text: str, schema: Dict[str, object]) -> None:
        model_slug = self.model_combo.currentText().strip()
        response = self._strip_reasoning(model_slug, response_raw)
        response, style_score = self._style_and_guard(response, schema)
        self.style_label.setText(f"Style: {style_score:.2f}")

        if self.chk_isolated.isChecked():
            self.isolated_history.append((schema.get("name", "bot"), response))
        else:
            if self.chk_semantic.isChecked():
                self.core.conversation_db.save_message(schema.get("name", "bot").lower(), response)

        persona_name = schema.get("name", "Bot") or "Bot"
        role_key = self._current_persona().lower()
        self._append_message(persona_name, response, role_key=role_key)
        self.response_edit.setPlainText(response)

        if not self.chk_mute_tts.isChecked():
            try:
                self.core.tts_mgr.enqueue(response)
            except Exception:
                pass

        self._enable_feedback(True)
        self._reset_idle_timer()

        try:
            tokens = [w.lower() for w in re.findall(r"\b\w+\b", user_text) if len(w) > 3]
            for t in tokens:
                self.update_overlay_topic(self._current_persona(), t)
            self.update_overlay_emotion(self._current_persona(), "neutral")
        except Exception:
            pass

        try:
            for line in response.split("\n"):
                if line.strip():
                    self.core.plugins.broadcast(line.strip())
        except Exception as e:
            print(f"Error broadcasting to plugins: {e}")

        if self.core.settings.auto_schema_enabled:
            self.progress_bar.setVisible(True)


            class EvolverWorker(QRunnable):
                def __init__(self, evolver, persona, set_name, history, window):
                    super().__init__()
                    self.evolver = evolver
                    self.persona = persona
                    self.set_name = set_name
                    self.history = history
                    self.window = window

                def run(self):
                    changed = self.evolver.update_schema(self.persona, self.set_name, self.history)
                    QtCore.QMetaObject.invokeMethod(
                        self.window, "_post_evolver", QtCore.Qt.QueuedConnection, QtCore.Q_ARG(bool, changed)
                    )

            QThreadPool.globalInstance().start(
                EvolverWorker(self.core.schema_evolver, self.active_persona, self.current_set.get(self.active_persona, "default"), self._current_history(), self)
            )

    @QtCore.pyqtSlot(bool)
    def _post_evolver(self, changed: bool) -> None:
        self.progress_bar.setVisible(False)
        if changed:
            self._flash_status("Schema adapted")

    def _strip_reasoning(self, model: str, response: str) -> str:
        if model and "deepseek" in model.lower():
            if "<think>" in response and "</think>" in response:
                try:
                    return response.split("</think>")[-1].strip() or response
                except Exception:
                    return response
        return response

    def _style_and_guard(self, text: str, schema: Dict[str, object]) -> Tuple[str, float]:
        exclam = text.count("!")
        sentences = [s for s in re.split(r"[.!?]", text) if s.strip()]
        avg_len = sum(len(s.split()) for s in sentences) / max(1, len(sentences))
        exclam_density = exclam / max(1, len(text))
        tone = schema.get("tone_rules", {"conciseness": [0.6, 0.8], "exclam_limit": 0.05})
        conciseness = max(0.0, min(1.0, (22 - avg_len) / 16.0))
        ex_ok = 1.0 if exclam_density <= float(tone.get("exclam_limit", 0.05)) else 0.5
        score = max(0.0, min(1.0, 0.5 * conciseness + 0.5 * ex_ok))
        return text, score

    def _rewrite_response(self, original: str) -> str:
        try:
            liked = self.core.feedback_db.get_liked_responses(limit=5)
        except Exception:
            liked = []
        schema = self.core.schema_mgr.load_schema(self._current_persona(), self.current_set.get(self._current_persona(), "default"))
        rps = schema.get("rewrite_prompts", [])
        template = rps[0] if rps else "Rewrite to be more appealing. Keep it accurate, concise, and on style."
        parts = [template]
        if liked:
            parts.append("Preferred responses:\n" + "\n\n".join(liked))
        parts.append("Original:\n" + original)
        parts.append("Rewritten:")
        prompt = "\n\n".join(parts)
        return self._run_model(self.model_combo.currentText().strip() or self.core.settings.default_model, prompt) or original

    def _run_model(self, model: str, prompt: str) -> str:
        try:
            proc = subprocess.run(
                ["ollama", "run", model],
                input=prompt.encode("utf-8"),
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                check=True,
            )
            return proc.stdout.decode("utf-8", errors="replace").strip()
        except subprocess.CalledProcessError as e:
            return e.stderr.decode("utf-8", errors="replace").strip()
        except FileNotFoundError:
            return "(error) ollama executable not found."
        except Exception as e:
            return f"(error) {e}"

    # ────────────────────────── persona / sets
    def _populate_set_combo(self, persona: str, combo: QtWidgets.QComboBox) -> None:
        combo.blockSignals(True)
        combo.clear()
        for s in self.core.schema_mgr.get_set_list(persona):
            combo.addItem(s)
        current = self.current_set.get(persona, "default")
        idx = combo.findText(current)
        combo.setCurrentIndex(idx if idx >= 0 else combo.findText("default"))
        if idx < 0:
            self.current_set[persona] = combo.currentText()
        combo.blockSignals(False)

    def _on_set_changed(self, persona: str, name: str, combo: QtWidgets.QComboBox) -> None:
        if not name:
            return
        self.current_set[persona] = name
        # keep AgentCore pointed to the right set if this persona is active
        if persona == self._current_persona():
            self.core.persona = persona
            self.core.set_name = name

        # refresh editor + commands row for this tab
        tab = self.tab_widgets.get(persona)
        if tab:
            editor = tab.findChild(QtWidgets.QPlainTextEdit, f"schema_edit_{persona}")
            if editor:
                schema = self.core.schema_mgr.load_schema(persona, name)
                editor.setPlainText(json.dumps(schema, indent=2))
            cmd_combo = tab.findChild(QtWidgets.QComboBox, f"cmd_combo_{persona}")
            if cmd_combo:
                self._populate_command_combo(persona, cmd_combo)

        # persist active sets & update controls tied to schema flags
        self.core.schema_mgr.save_active_schemas(self.current_set)
        self._sync_semantic_checkbox_from_schema()
        self._update_feedback_counts()

        # refresh slash command list if this persona is active
        try:
            if persona == self._current_persona():
                self._populate_command_select()
        except Exception:
            pass

    def _on_clone_set(self, persona: str, combo: QtWidgets.QComboBox) -> None:
        src = combo.currentText()
        name, ok = QtWidgets.QInputDialog.getText(self, "Clone Set", "Enter new set name:")
        if not ok or not name.strip():
            return
        new_name = name.strip()
        try:
            schema = self.core.schema_mgr.load_schema(persona, src)
            # Preserve the persona's canonical name; set label is separate
            schema["name"] = persona.capitalize()
            self.core.schema_mgr.save_schema(persona, new_name, schema)
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "Error", str(e))
            return
        self.current_set[persona] = new_name
        self._populate_set_combo(persona, combo)
        combo.setCurrentText(new_name)
        if persona == self._current_persona():
            self.core.set_name = new_name
        self.core.schema_mgr.save_active_schemas(self.current_set)
        self._sync_semantic_checkbox_from_schema()
        self._update_feedback_counts()

    def _on_new_set(self, persona: str, combo: QtWidgets.QComboBox) -> None:
        src = combo.currentText()
        name, ok = QtWidgets.QInputDialog.getText(self, "New Set", "Enter name for new set:")
        if not ok or not name.strip():
            return
        new_name = name.strip()
        try:
            schema = self.core.schema_mgr.load_schema(persona, src)
            # Preserve the persona's canonical name; set label is separate
            schema["name"] = persona.capitalize()
            self.core.schema_mgr.save_schema(persona, new_name, schema)
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "Error", str(e))
            return
        self.current_set[persona] = new_name
        self._populate_set_combo(persona, combo)
        combo.setCurrentText(new_name)
        if persona == self._current_persona():
            self.core.set_name = new_name
        self.core.schema_mgr.save_active_schemas(self.current_set)
        self._sync_semantic_checkbox_from_schema()
        self._update_feedback_counts()

    def _on_delete_set(self, persona: str, combo: QtWidgets.QComboBox) -> None:
        name = combo.currentText()
        if name == "default":
            QtWidgets.QMessageBox.information(self, "Cannot Delete", "The default set cannot be deleted.")
            return
        if QtWidgets.QMessageBox.question(
            self, "Delete Set", f"Delete '{name}' (irreversible)?", QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No
        ) != QtWidgets.QMessageBox.Yes:
            return
        try:
            set_dir = os.path.join(self.core.schema_mgr.schemas_dir, persona.lower(), "sets", name)
            import shutil
            shutil.rmtree(set_dir, ignore_errors=True)
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "Error", str(e))
            return
        self.current_set[persona] = "default"
        self._populate_set_combo(persona, combo)
        combo.setCurrentText("default")
        if persona == self._current_persona():
            self.core.set_name = "default"
        self.core.schema_mgr.save_active_schemas(self.current_set)
        self._sync_semantic_checkbox_from_schema()
        self._update_feedback_counts()

    def _on_save_schema(self, persona: str) -> None:
        tab = self.tab_widgets.get(persona)
        if not tab:
            return
        editor = tab.findChild(QtWidgets.QPlainTextEdit, f"schema_edit_{persona}")
        if not editor:
            return
        text = editor.toPlainText().strip()
        try:
            schema = json.loads(text)
            if not isinstance(schema, dict):
                raise ValueError
        except Exception:
            QtWidgets.QMessageBox.warning(self, "Invalid JSON", "The schema is not valid JSON.")
            return
        set_name = self.current_set.get(persona, "default")
        existing_schema = self.core.schema_mgr.load_schema(persona, set_name)
        merged_schema = {**existing_schema, **schema}
        # Ensure the top-level name matches the active set name
        try:
            merged_schema["name"] = set_name
        except Exception:
            pass
        self.core.schema_mgr.save_schema(persona, set_name, merged_schema)
        QtWidgets.QMessageBox.information(self, "Saved", f"Schema saved for {persona} ({set_name}).")

        if persona == self._current_persona():
            persona_voice = (merged_schema.get("voice") or "").lower()
            for i in range(self.voice_combo.count()):
                if persona_voice and persona_voice in self.voice_combo.itemText(i).lower():
                    self.voice_combo.setCurrentIndex(i)
                    break
        # After save, refresh commands combo (in case user edited commands JSON directly)
        tab = self.tab_widgets.get(persona)
        if tab:
            cmd_combo = tab.findChild(QtWidgets.QComboBox, f"cmd_combo_{persona}")
            if cmd_combo:
                self._populate_command_combo(persona, cmd_combo)

    def _tab_changed(self, index: int) -> None:
        if 0 <= index < len(self.core.schema_mgr.personas):
            self.active_persona = self.core.schema_mgr.personas[index]
        else:
            self.active_persona = self.core.schema_mgr.personas[0] if self.core.schema_mgr.personas else "zira"
        self.core.persona = self.active_persona

        schema = self.core.schema_mgr.load_schema(self.active_persona, self.current_set.get(self.active_persona, "default"))
        persona_voice = (schema.get("voice") or "").lower()
        for i in range(self.voice_combo.count()):
            if persona_voice and persona_voice in self.voice_combo.itemText(i).lower():
                self.voice_combo.setCurrentIndex(i)
                break

        tab = self.tab_widgets.get(self.active_persona)
        if tab:
            editor = tab.findChild(QtWidgets.QPlainTextEdit, f"schema_edit_{self.active_persona}")
            if editor:
                editor.setPlainText(json.dumps(schema, indent=2))
            cmd_combo = tab.findChild(QtWidgets.QComboBox, f"cmd_combo_{self.active_persona}")
            if cmd_combo:
                self._populate_command_combo(self.active_persona, cmd_combo)

        try:
            user_schema = self.core.schema_mgr.load_schema("user", self.current_set.get("user", "default"))
            bot_name = schema.get("name", self.active_persona.title())
            bot_set = self.current_set.get(self.active_persona, "default")
            user_name = user_schema.get("name", "User")
            user_set = self.current_set.get("user", "default")
            self.lbl_active_names.setText(f"{bot_name}: {bot_set} — User: {user_name}: {user_set}")
        except Exception:
            pass

        self._sync_semantic_checkbox_from_schema()
        self._update_feedback_counts()

        # refresh slash command dropdown on persona change
        try:
            self._populate_command_select()
        except Exception:
            pass

    def _current_persona(self) -> str:
        return self.active_persona

    # ────────────────────────── overlay helpers
    def update_overlay_topic(self, persona: str, topic: str) -> None:
        persona = persona.lower()
        try:
            schema = self.core.schema_mgr.load_schema(persona, self.current_set.get(persona, "default"))
            overlay = dict(schema.get("dynamic_overlay", {}))
            topics = list(overlay.get("recent_topics", []))
            if topic and topic not in topics:
                topics.append(topic)
                if len(topics) > 10:
                    topics = topics[-10:]
                overlay["recent_topics"] = topics
                schema["dynamic_overlay"] = overlay
                self.core.schema_mgr.save_schema(persona, self.current_set.get(persona, "default"), schema)
        except Exception:
            pass

    def update_overlay_emotion(self, persona: str, emotion: str) -> None:
        persona = persona.lower()
        try:
            schema = self.core.schema_mgr.load_schema(persona, self.current_set.get(persona, "default"))
            overlay = dict(schema.get("dynamic_overlay", {}))
            overlay["temporary_emotional_state"] = emotion
            schema["dynamic_overlay"] = overlay
            self.core.schema_mgr.save_schema(persona, self.current_set.get(persona, "default"), schema)
        except Exception:
            pass

    # ────────────────────────── devices & models
    def _populate_devices(self) -> None:
        self.device_combo.clear()
        try:
            if sd is not None:
                devs = [d.get("name", "?") for d in sd.query_devices() if d.get("max_input_channels", 0) > 0]
                if devs:
                    self.device_combo.addItems(devs)
        except Exception:
            pass
        if self.device_combo.count() == 0:
            self.device_combo.addItem("Default")

    def _populate_models(self) -> None:
        models: List[str] = []
        try:
            out = subprocess.run(
                ["ollama", "list"],
                stdout=subprocess.PIPE,
                stderr=subprocess.DEVNULL,
                text=True,
                check=True,
            ).stdout.splitlines()
            for line in out[1:]:
                parts = line.strip().split()
                if parts:
                    models.append(parts[0])
        except Exception:
            pass
        if not models:
            models = [self.core.settings.default_model or "mistral:latest"]
        self.model_combo.clear()
        self.model_combo.addItems(models)
        idx = self.model_combo.findText(self.core.settings.default_model)
        if idx >= 0:
            self.model_combo.setCurrentIndex(idx)

    # ────────────────────────── slash commands panel
    def _build_command_dock(self) -> None:
        """
        Build a dockable panel that exposes slash commands with an argument
        entry and send button. This allows users to trigger any command
        without typing it into the chat manually. It will be updated when
        persona or set changes.
        """
        dock = QtWidgets.QDockWidget("Slash Commands", self)
        dock.setObjectName("SlashCommandsDock")
        dock.setFeatures(
            QtWidgets.QDockWidget.DockWidgetClosable
            | QtWidgets.QDockWidget.DockWidgetMovable
            | QtWidgets.QDockWidget.DockWidgetFloatable
        )
        container = QtWidgets.QWidget()
        layout = QtWidgets.QVBoxLayout(container)
        layout.setContentsMargins(7, 7, 7, 7)
        layout.setSpacing(5)

        # command selector
        cmd_label = QtWidgets.QLabel("Slash Command:")
        self.command_select = QtWidgets.QComboBox()
        layout.addWidget(cmd_label)
        layout.addWidget(self.command_select)

        # argument input
        self.command_input = QtWidgets.QLineEdit()
        self.command_input.setPlaceholderText("Enter arguments or select text from chat…")
        layout.addWidget(self.command_input)

        # send button
        btn_run = QtWidgets.QPushButton("Run Command")
        btn_run.clicked.connect(self._on_run_command)
        layout.addWidget(btn_run)
        layout.addStretch(1)

        dock.setWidget(container)
        # add to right side by default
        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, dock)
        self.command_dock = dock

    def _populate_command_select(self) -> None:
        """
        Populate the slash command dropdown with available commands from
        the command registry. This is called whenever the active persona
        or set changes to reflect dynamic additions.
        """
        try:
            cmds = []
            if hasattr(self.core, "command_registry") and self.core.command_registry:
                cmds = list(self.core.command_registry.list_commands())
            # if schema defines additional commands, include them
            persona = self._current_persona()
            set_name = self.current_set.get(persona, "default")
            schema = self.core.schema_mgr.load_schema(persona, set_name)
            schema_cmds = list((schema.get("commands") or {}).keys())
            for c in schema_cmds:
                if c not in cmds:
                    cmds.append(c)
            cmds.sort()
        except Exception:
            cmds = []
        self.command_select.blockSignals(True)
        self.command_select.clear()
        if cmds:
            self.command_select.addItems(cmds)
        self.command_select.blockSignals(False)

    def _on_run_command(self) -> None:
        """
        Handler for running the selected slash command with the provided
        argument. The command will be executed via AgentCore and the
        result appended to the chat window. Selection text from the chat
        can be inserted into the argument field via context menu.
        """
        cmd = (self.command_select.currentText() or "").strip()
        if not cmd:
            QtWidgets.QMessageBox.information(self, "No Command", "Select a slash command to run.")
            return
        arg = self.command_input.text().strip()
        # combine command and arguments
        full = cmd if not arg else f"{cmd} {arg}"
        try:
            # process via core; record conversation
            resp = self.core.process_user_message(full, tts=False)
            # append user command and agent response to chat
            self._append_message("user", full, role_key="user")
            self._append_message("zira", resp, role_key="zira")
            # clear argument
            self.command_input.clear()
            # update feedback counts and idle timer
            self._update_feedback_counts()
            self._reset_idle_timer()
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "Command Error", str(e))

    def _show_chat_context_menu(self, pos: QtCore.QPoint) -> None:
        """
        Custom context menu for the chat view. Adds a menu entry to send
        selected text into the slash command argument field.
        """
        menu = self.chat_view.createStandardContextMenu()
        try:
            cursor = self.chat_view.textCursor()
            if cursor and cursor.hasSelection():
                action = menu.addAction("Send selection to command input")
                action.triggered.connect(self._send_selection_to_command_input)
        except Exception:
            pass
        menu.exec_(self.chat_view.mapToGlobal(pos))

    def _send_selection_to_command_input(self) -> None:
        """
        Copy the currently selected text in the chat view into the command
        input field for slash command execution.
        """
        try:
            cursor = self.chat_view.textCursor()
            if cursor and cursor.hasSelection():
                text = cursor.selectedText()
                self.command_input.setText(text.strip())
        except Exception:
            pass

    def _on_model_changed(self, name: str) -> None:
        """
        Update the default model in settings when the user selects a new
        model from the dropdown. This ensures the AgentCore uses the
        selected model for subsequent interactions.
        """
        try:
            if not name:
                return
            self.core.settings.default_model = name
            self.core.settings.save()
        except Exception:
            pass

    def _on_show_model_manager(self) -> None:
        """
        Show (or raise) the model manager dock. If the dock was
        previously hidden, it will be shown; if it is already visible,
        this will bring it to the front. A dock must be built in
        `_build_model_manager()` prior to showing.
        """
        try:
            if self.model_dock.isVisible():
                # already visible: raise to top
                self.model_dock.raise_()
            else:
                self.model_dock.show()
                self.model_dock.raise_()
        except Exception:
            pass

    # ────────────────────────── settings toggles
    def _on_auto_schema_toggled(self, checked: bool) -> None:
        try:
            self.core.settings.auto_schema_enabled = bool(checked)
            self.core.settings.save()
        except Exception:
            pass
        self.statusBar().showMessage(f"Auto Schema Evolution {'enabled' if checked else 'disabled'}", 2500)

    def _on_google_stt_toggled(self, checked: bool) -> None:
        """
        Opt-in/out of using Google Cloud Speech-to-Text. When enabling the
        toggle for the first time in a session, show a warning that
        recordings will be sent to Google’s servers under their privacy
        policy. If declined, the checkbox will be turned off again.
        """
        # Only show the dialog when transitioning from unchecked → checked
        try:
            current = bool(getattr(self.core.settings, "use_google_stt", False))
        except Exception:
            current = False
        if checked and not current:
            ok = QtWidgets.QMessageBox.question(
                self,
                "Enable Google STT?",
                "Audio will be uploaded to Google Cloud for transcription\n"
                "under Google's privacy policy. Continue?",
                QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No,
            )
            if ok != QtWidgets.QMessageBox.Yes:
                # revert checkbox silently
                self.chk_google_stt.blockSignals(True)
                self.chk_google_stt.setChecked(False)
                self.chk_google_stt.blockSignals(False)
                return
        # persist the new state
        try:
            self.core.settings.use_google_stt = bool(checked)
            self.core.settings.save()
        except Exception:
            pass

    # ────────────────────────── spell suggestions
    def _show_input_context_menu(self, pos: QtCore.QPoint) -> None:
        """
        Custom context menu on the input field that offers spelling
        suggestions when the user right-clicks a misspelled word. Only
        appears if pyspellchecker is available.
        """
        menu = self.input_edit.createStandardContextMenu()
        # compute suggestions only if SpellChecker is available
        if SpellChecker:
            cursor = self.input_edit.cursorForPosition(pos)
            # select the word under cursor
            cursor.select(QtGui.QTextCursor.WordUnderCursor)
            word = cursor.selectedText()
            if word and len(word) >= 3:
                sc = SpellChecker()
                suggestions = list(sc.candidates(word.lower()))
                # sort by Levenshtein distance and frequency; keep top 5
                suggestions = sorted(suggestions, key=lambda w: sc.word_probability(w), reverse=True)[:5]
                if suggestions and suggestions != [word.lower()]:
                    suggest_menu = menu.addMenu("Spelling suggestions")
                    for s in suggestions:
                        act = suggest_menu.addAction(s)
                        act.triggered.connect(lambda chk=False, repl=s, c=cursor: self._replace_word(c, repl))
        menu.exec_(self.input_edit.mapToGlobal(pos))

    def _replace_word(self, cursor: QtGui.QTextCursor, replacement: str) -> None:
        """
        Replace the word at the given cursor with a suggestion. This
        method is connected dynamically for each suggestion action.
        """
        try:
            cursor.beginEditBlock()
            cursor.removeSelectedText()
            cursor.insertText(replacement)
            cursor.endEditBlock()
        except Exception:
            pass

    def _on_semantic_toggled(self, checked: bool) -> None:
        """Persist semantic awareness per persona+set."""
        persona = self._current_persona()
        set_name = self.current_set.get(persona, "default")
        try:
            schema = self.core.schema_mgr.load_schema(persona, set_name)
            flags = dict(schema.get("flags") or {})
            flags["semantic_awareness"] = bool(checked)
            schema["flags"] = flags
            self.core.schema_mgr.save_schema(persona, set_name, schema)
        except Exception:
            pass
        self._reset_idle_timer()

    def _sync_semantic_checkbox_from_schema(self) -> None:
        """Load semantic_awareness from current schema into the checkbox."""
        persona = self._current_persona()
        set_name = self.current_set.get(persona, "default")
        try:
            schema = self.core.schema_mgr.load_schema(persona, set_name)
            flags = schema.get("flags", {})
            val = bool(flags.get("semantic_awareness", True))
        except Exception:
            val = True
        self.chk_semantic.blockSignals(True)
        self.chk_semantic.setChecked(val)
        self.chk_semantic.blockSignals(False)

    # ────────────────────────── status helper
    def _flash_status(self, msg: str) -> None:
        self.statusBar().showMessage(msg, 3000)


# ────────────────────────── Dock tray & titlebar
class DockTray(QtWidgets.QWidget):
    restoreRequested = QtCore.pyqtSignal(QtWidgets.QDockWidget)

    def __init__(self, parent: Optional[QtWidgets.QWidget] = None) -> None:
        super().__init__(parent)
        self._map: Dict[QtWidgets.QDockWidget, QtWidgets.QPushButton] = {}
        lay = QtWidgets.QHBoxLayout(self)
        lay.setContentsMargins(6, 4, 6, 4)
        lay.setSpacing(6)
        self._layout = lay
        self._title = QtWidgets.QLabel("Minimized panels:")
        self._title.setStyleSheet("color: #f0f0f0; font-weight: bold;")
        self._layout.addWidget(self._title, 0)
        self._layout.addStretch(1)
        self.setStyleSheet("background-color: #3c4a6b;")

    def register_dock(self, dock: QtWidgets.QDockWidget) -> None:
        dock.visibilityChanged.connect(lambda vis, d=dock: self._on_visibility_changed(d, vis))
        if not dock.isVisible():
            self._add_button(dock)

    def _on_visibility_changed(self, dock: QtWidgets.QDockWidget, visible: bool) -> None:
        if visible:
            self._remove_button(dock)
        else:
            self._add_button(dock)

    def _add_button(self, dock: QtWidgets.QDockWidget) -> None:
        if dock in self._map:
            return
        btn = QtWidgets.QPushButton(dock.windowTitle())
        btn.setToolTip(f"Restore {dock.windowTitle()}")
        btn.setStyleSheet(
            "background-color: #4a5b78; color: #ffffff; padding: 4px 6px; border: none; border-radius: 3px;"
        )
        btn.clicked.connect(lambda checked=False, d=dock: self._restore(d))
        self._layout.insertWidget(self._layout.count() - 1, btn)
        self._map[dock] = btn

    def _remove_button(self, dock: QtWidgets.QDockWidget) -> None:
        btn = self._map.pop(dock, None)
        if btn:
            self._layout.removeWidget(btn)
            btn.deleteLater()

    def _restore(self, dock: QtWidgets.QDockWidget) -> None:
        dock.show()
        dock.raise_()
        self.restoreRequested.emit(dock)


class DockTitleBar(QtWidgets.QWidget):
    def __init__(self, dock: QtWidgets.QDockWidget, title: str) -> None:
        super().__init__(dock)
        self._dock = dock
        h = QtWidgets.QHBoxLayout(self)
        h.setContentsMargins(6, 2, 6, 2)
        h.setSpacing(6)
        self.lbl = QtWidgets.QLabel(title)
        h.addWidget(self.lbl)
        h.addStretch()
        self.btn_min = QtWidgets.QToolButton()
        self.btn_min.setText("–")
        self.btn_min.setToolTip("Minimize to bottom tray")
        self.btn_min.clicked.connect(lambda checked=False: self._dock.hide())
        h.addWidget(self.btn_min)
        self.btn_max = QtWidgets.QToolButton()
        self.btn_max.setText("□")
        self.btn_max.setToolTip("Enlarge / Restore")
        self.btn_max.clicked.connect(self._on_toggle_maximize)
        h.addWidget(self.btn_max)
        self.btn_close = QtWidgets.QToolButton()
        self.btn_close.setText("×")
        self.btn_close.setToolTip("Close (send to bottom tray)")
        self.btn_close.clicked.connect(lambda checked=False: self._dock.hide())
        h.addWidget(self.btn_close)
        self.installEventFilter(self)

    def eventFilter(self, _obj: QtCore.QObject, evt: QtCore.QEvent) -> bool:
        if evt.type() == QtCore.QEvent.MouseButtonDblClick:
            self._dock.setFloating(not self._dock.isFloating())
            return True
        return False

    def _on_toggle_maximize(self) -> None:
        mw: Optional[QtWidgets.QMainWindow] = self._dock.parentWidget()  # type: ignore
        while mw and not isinstance(mw, QtWidgets.QMainWindow):
            mw = mw.parentWidget()  # type: ignore
        if not isinstance(mw, QtWidgets.QMainWindow):
            self._dock.setFloating(not self._dock.isFloating())
            return
        if not self._dock.isFloating():
            self._dock.setFloating(True)
            mw_geo = mw.geometry()
            w = int(mw_geo.width() * 0.9)
            h = int(mw_geo.height() * 0.85)
            self._dock.resize(w, h)
            center = mw_geo.center()
            self._dock.move(center.x() - w // 2, center.y() - h // 2)
        else:
            self._dock.setFloating(False)


# ────────────────────────── dataset manager dialog
class DatasetManagerDialog(QtWidgets.QDialog):
    def __init__(self, dataset_mgr, parent: Optional[QtWidgets.QWidget] = None) -> None:
        super().__init__(parent)
        self.setWindowTitle("Dataset Manager")
        self.resize(520, 420)
        self.dataset_mgr = dataset_mgr
        v = QtWidgets.QVBoxLayout(self)
        self.list_widget = QtWidgets.QListWidget()
        v.addWidget(self.list_widget, 1)
        h = QtWidgets.QHBoxLayout()
        self.btn_add = QtWidgets.QPushButton("Add Dataset")
        self.btn_del = QtWidgets.QPushButton("Delete Dataset")
        h.addWidget(self.btn_add)
        h.addWidget(self.btn_del)
        h.addStretch()
        v.addLayout(h)
        self._populate()
        self.btn_add.clicked.connect(self._on_add)
        self.btn_del.clicked.connect(self._on_delete)
        self.list_widget.itemChanged.connect(self._on_item)

    def _populate(self) -> None:
        self.list_widget.clear()
        for name, entry in sorted(self.dataset_mgr.entries.items()):
            item = QtWidgets.QListWidgetItem(name)
            item.setFlags(item.flags() | QtCore.Qt.ItemIsUserCheckable)
            item.setCheckState(QtCore.Qt.Checked if entry.active else QtCore.Qt.Unchecked)
            self.list_widget.addItem(item)

    def _on_add(self) -> None:
        name, ok = QtWidgets.QInputDialog.getText(self, "New Dataset", "Enter dataset name:")
        if not ok or not name.strip():
            return
        path, _ = QtWidgets.QFileDialog.getOpenFileName(self, "Select .txt or .pdf", "", "Text/PDF (*.txt *.pdf)")
        if not path:
            return
        try:
            self.dataset_mgr.add_dataset(name.strip(), path)
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "Error", str(e))
            return
        self._populate()

    def _on_delete(self) -> None:
        item = self.list_widget.currentItem()
        if not item:
            return
        name = item.text()
        if QtWidgets.QMessageBox.question(
            self, "Delete Dataset", f"Delete '{name}'?", QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No
        ) != QtWidgets.QMessageBox.Yes:
            return
        try:
            self.dataset_mgr.delete_dataset(name)
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "Error", str(e))
            return
        self._populate()

    def _on_item(self, item: QtWidgets.QListWidgetItem) -> None:
        self.dataset_mgr.toggle_active(item.text(), item.checkState() == QtCore.Qt.Checked)


# ────────────────────────── run as script
if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    win = AppWindow()
    win.show()
    sys.exit(app.exec_())
```

agent_ui.py
============

PyQt5 UI for the AI TTS Agent (integrated with AgentCore).

Fixes & additions:
- Slash commands (/remember etc.) now apply to the currently selected persona+set.
- Per-set "Semantic Awareness" persisted (schema.flags.semantic_awareness).
- RAG only uses datasets listed in the current set's schema ("datasets": [...]).
- Schema tab: new Commands row (dropdown + input + Add to Command + New Command).

To launch: `python run_agent.py`
**Classes:** _SpellHighlighter, AppWindow, DockTray, DockTitleBar, DatasetManagerDialog


## Module `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\_burner_scripts\agent_core.py`

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
agent_core.py
=================

Full, end-to-end core for an AI AI TTS Agent with:
- Settings & model bootstrap (Ollama)
- Robust plugin host (enable/disable/list, manifest validation, dependency checks)
- Conversation & feedback stores (with indices, exports)
- Persona schema management (with protected keys) and live signals
- Dataset registry + RAG embeddings cache & query (per persona/set, cross-profile sharing)
  * Multi-file datasets, cache invalidation, provenance
- Context monitor + schema auto-updates driven by directives & feedback (rate-limited)
- Command registry (weight/lock) + full command execution layer
- New commands: /reject, /auto, /ignore, /opposite, /delete, /rewrite (extended persistence)
- BeanCounter reinforcement + integration with feedback and command weights
- Speech I/O (TTS locked to Zira; STT via Sphinx when available) w/ volume control
- Threaded model worker wrapper (cancel-safe)
- Orchestrator (`AgentCore`) wiring everything together for headless/GUI
- CLI entrypoint for smoke tests

Notes
-----
• This module is UI-agnostic. Hook the provided Qt signals in your GUI (`agent_ui.py`).
• All directories are scoped under `base_dir`, with per-persona/per-set state in:
  base_dir/profiles/<persona>/<set>/
"""

from __future__ import annotations

import threading
import json
import os
import shutil
import sqlite3
import subprocess
import sys
import time
import traceback
import re
import logging
from dataclasses import dataclass
from typing import Dict, List, Optional, Tuple, Any
from collections import Counter

# ──────────────────────────────────────────────────────────────────────────────
# Logging
# ──────────────────────────────────────────────────────────────────────────────
logger = logging.getLogger("agent_core")
if not logger.handlers:
    _lvl = os.getenv("AGENT_CORE_LOGLEVEL", "INFO").upper()
    logging.basicConfig(
        level=getattr(logging, _lvl, logging.INFO),
        format="%(asctime)s [%(levelname)s] %(name)s: %(message)s",
    )

# ──────────────────────────────────────────────────────────────────────────────
# Optional deps (graceful fallbacks)
# ──────────────────────────────────────────────────────────────────────────────
try:
    import numpy as np  # type: ignore
except Exception:
    np = None  # type: ignore
    logger.warning("numpy not available; embeddings will be disabled")

try:
    import sounddevice as sd  # type: ignore
    import soundfile as sf  # type: ignore
except Exception:
    sd = None  # type: ignore
    sf = None  # type: ignore
    logger.info("sounddevice/soundfile not available; audio recording disabled")

# Optional Google STT
try:
    from google.cloud import speech as gspeech  # type: ignore
    import pyaudio  # type: ignore
except Exception:
    gspeech = None  # type: ignore
    pyaudio = None  # type: ignore
    logger.info("google-cloud-speech or pyaudio not available; STT via Google disabled")

try:
    import pyttsx3  # type: ignore
except Exception:
    pyttsx3 = None  # type: ignore
    logger.info("pyttsx3 not available; TTS disabled")

try:
    from PyPDF2 import PdfReader  # type: ignore
except Exception:
    PdfReader = None  # type: ignore
    logger.info("PyPDF2 not available; PDF ingest will be skipped")

try:
    from sentence_transformers import SentenceTransformer  # type: ignore
except Exception:
    SentenceTransformer = None  # type: ignore
    logger.info("sentence_transformers not available; will attempt Ollama embeddings or disable RAG")

try:
    from PyQt5 import QtCore  # type: ignore
except Exception:
    # Minimal shim if PyQt5 is absent, to keep code importable
    class _ShimSignal:
        def __init__(self, *_, **__): pass
        def emit(self, *_, **__): pass
        def connect(self, *_, **__): pass
    class _ShimQObject: pass
    class _ShimQThread:
        def __init__(self, *_, **__): pass
        def start(self): pass
        def deleteLater(self): pass
        def requestInterruption(self): pass
        def isInterruptionRequested(self): return False
    QtCore = type("QtCore", (), {
        "QObject": _ShimQObject,
        "pyqtSignal": lambda *a, **k: _ShimSignal(),
        "QThread": _ShimQThread
    })  # type: ignore

__version__ = "2.4.1"

CONTROL_SCHEMA_PATH = os.path.join(os.path.dirname(os.path.abspath(__file__)), "control_schema.json")
DEFAULT_SCHEMAS_FILE = os.path.join(os.path.dirname(os.path.abspath(__file__)), "default_schemas.json")
ACTIVE_SCHEMAS_FILE  = os.path.join(os.path.dirname(os.path.abspath(__file__)), "active_schemas.json")

# ──────────────────────────────────────────────────────────────────────────────
# Ollama model bootstrap
# ──────────────────────────────────────────────────────────────────────────────
REQUIRED_MODELS: List[str] = [
    "gemma3:27b",
    "mistral:latest",
    "codellama:latest",
    "llava:latest",
    "mxbai-embed-large:latest",            # embeddings alt
    "snowflake-arctic-embed:latest",       # embeddings alt
]

def _have_cli(bin_name: str) -> bool:
    # Cross-platform check (Windows/macOS/Linux)
    try:
        from shutil import which
        return which(bin_name) is not None
    except Exception:
        return False

def ensure_models_present() -> None:
    """
    Check Ollama registry and pull any missing REQUIRED_MODELS (best-effort).
    Non-fatal if Ollama is missing/unreachable.
    """
    if not _have_cli("ollama"):
        logger.warning("[bootstrap] ollama not available on PATH")
        return
    try:
        output = subprocess.check_output(["ollama", "list"], timeout=10).decode(errors="ignore")
    except Exception as e:
        logger.warning("[bootstrap] ollama not available: %s", e)
        return
    for slug in REQUIRED_MODELS:
        if slug in output:
            continue
        try:
            logger.info("[bootstrap] Pulling model: %s", slug)
            subprocess.run(["ollama", "pull", slug], check=False, timeout=900)
        except Exception as e:
            logger.warning("[bootstrap] Failed to pull %s: %s", slug, e)

# ──────────────────────────────────────────────────────────────────────────────
# Settings
# ──────────────────────────────────────────────────────────────────────────────
class Settings:
    def __init__(self, base_dir: str) -> None:
        self.base_dir = base_dir
        self.path = os.path.join(self.base_dir, "settings.json")
        # General
        self.default_model: str = "gemma3:27b"
        self.context_depth: int = 20
        self.auto_schema_enabled: bool = True
        self.enabled_plugins: List[str] = []
        # Speech
        self.monologue_tts_enabled: bool = False
        self.monologue_volume: int = 50
        # Speech-to-text (Google) toggle
        self.use_google_stt: bool = False
        # Versioning
        self.schema_version: int = 2
        self.load()
        self._migrate_if_needed()
        self.validate()

    def validate(self) -> None:
        try:
            if not isinstance(self.context_depth, int) or self.context_depth <= 0:
                self.context_depth = 20
            if not isinstance(self.monologue_volume, int) or not (0 <= self.monologue_volume <= 100):
                self.monologue_volume = 50
            if not isinstance(self.enabled_plugins, list):
                self.enabled_plugins = []
            # ensure use_google_stt is a boolean
            self.use_google_stt = bool(self.use_google_stt)
        except Exception:
            pass

    def _migrate_if_needed(self) -> None:
        current = 2
        if self.schema_version < current:
            self.schema_version = current
            self.save()

    def load(self) -> None:
        try:
            if os.path.isfile(self.path):
                with open(self.path, "r", encoding="utf-8") as f:
                    data = json.load(f)
                for k in list(self.__dict__.keys()):
                    if k in data:
                        setattr(self, k, data[k])
        except Exception as e:
            logger.warning("[Settings] load error: %s", e)

    def save(self) -> None:
        try:
            os.makedirs(os.path.dirname(self.path), exist_ok=True)
            with open(self.path, "w", encoding="utf-8") as f:
                json.dump({
                    "default_model": self.default_model,
                    "context_depth": self.context_depth,
                    "auto_schema_enabled": self.auto_schema_enabled,
                    "enabled_plugins": self.enabled_plugins,
                    "monologue_tts_enabled": self.monologue_tts_enabled,
                    "monologue_volume": self.monologue_volume,
                    "use_google_stt": self.use_google_stt,
                    "schema_version": self.schema_version,
                }, f, indent=2)
        except Exception as e:
            logger.error("[Settings] save error: %s", e)

# ──────────────────────────────────────────────────────────────────────────────
# Helpers (paths)
# ──────────────────────────────────────────────────────────────────────────────
def prof_dir(base_dir: str, persona: str, set_name: str) -> str:
    return os.path.join(base_dir, "profiles", persona, set_name)

def prof_datasets_dir(base_dir: str, persona: str, set_name: str) -> str:
    return os.path.join(prof_dir(base_dir, persona, set_name), "datasets")

def prof_commands_path(base_dir: str, persona: str, set_name: str) -> str:
    return os.path.join(prof_dir(base_dir, persona, set_name), "commands.json")

def prof_reinforcement_path(base_dir: str, persona: str, set_name: str) -> str:
    return os.path.join(prof_dir(base_dir, persona, set_name), "reinforcement.json")

def conv_db_path(base_dir: str, persona: str, set_name: str) -> str:
    return os.path.join(base_dir, "conversations", f"{persona}_{set_name}.sqlite3")

def feedback_db_path(base_dir: str, persona: str, set_name: str) -> str:
    return os.path.join(base_dir, "feedback", f"{persona}_{set_name}.sqlite3")

# ──────────────────────────────────────────────────────────────────────────────
# Conversation store
# ──────────────────────────────────────────────────────────────────────────────
class ConversationDB:
    def __init__(self, path: str) -> None:
        os.makedirs(os.path.dirname(path), exist_ok=True)
        self.path = path
        self._lock = threading.RLock()
        self.conn = sqlite3.connect(path, check_same_thread=False)
        with self._lock:
            self.conn.execute(
                "CREATE TABLE IF NOT EXISTS conversation ("
                "id INTEGER PRIMARY KEY AUTOINCREMENT, "
                "timestamp REAL, role TEXT, content TEXT)"
            )
            # Indices for speed
            self.conn.execute("CREATE INDEX IF NOT EXISTS idx_conv_ts ON conversation(timestamp)")
            self.conn.execute("CREATE INDEX IF NOT EXISTS idx_conv_role ON conversation(role)")
            self.conn.commit()

    def close(self) -> None:
        try:
            with self._lock:
                self.conn.close()
        except Exception:
            pass

    def save_message(self, role: str, content: str) -> None:
        with self._lock:
            self.conn.execute(
                "INSERT INTO conversation (timestamp, role, content) VALUES (?, ?, ?)",
                (time.time(), role, content),
            )
            self.conn.commit()

    def fetch_history(self, limit: Optional[int] = 50) -> List[Tuple[str, str]]:
        with self._lock:
            cur = self.conn.cursor()
            if limit is None:
                cur.execute("SELECT role, content FROM conversation ORDER BY id")
            else:
                cur.execute("SELECT role, content FROM conversation ORDER BY id DESC LIMIT ?", (limit,))
            rows = cur.fetchall()
        return rows[::-1]

    def clear(self) -> None:
        with self._lock:
            self.conn.execute("DELETE FROM conversation")
            self.conn.commit()

    def export_jsonl(self, out_path: str) -> int:
        with self._lock:
            cur = self.conn.cursor()
            cur.execute("SELECT timestamp, role, content FROM conversation ORDER BY id")
            rows = cur.fetchall()
        os.makedirs(os.path.dirname(out_path), exist_ok=True)
        count = 0
        with open(out_path, "w", encoding="utf-8") as f:
            for ts, role, content in rows:
                json.dump({"timestamp": ts, "role": role, "content": content}, f); f.write("\n")
                count += 1
        return count

# ──────────────────────────────────────────────────────────────────────────────
# BeanCounter reinforcement
# ──────────────────────────────────────────────────────────────────────────────
class BeanCounter:
    def __init__(self, base_dir: str, persona: str, set_name: str) -> None:
        self.path = prof_reinforcement_path(base_dir, persona, set_name)
        self._lock = threading.Lock()
        self.counts: Dict[str, int] = {}
        self._load()

    def _load(self) -> None:
        try:
            if os.path.isfile(self.path):
                with open(self.path, "r", encoding="utf-8") as f:
                    self.counts = json.load(f)
        except Exception:
            self.counts = {}

    def save(self) -> None:
        try:
            os.makedirs(os.path.dirname(self.path), exist_ok=True)
            with self._lock, open(self.path, "w", encoding="utf-8") as f:
                json.dump(self.counts, f, indent=2)
        except Exception as e:
            logger.error("[BeanCounter] save error: %s", e)

    def increment(self, key: str, delta: int = 1) -> None:
        with self._lock:
            self.counts[key] = self.counts.get(key, 0) + delta
        self.save()

# ──────────────────────────────────────────────────────────────────────────────
# Feedback store (fixed + integrated with BeanCounter)
# ──────────────────────────────────────────────────────────────────────────────
class SemanticFeedbackDB:
    """
    Tracks user feedback on AI responses and updates BeanCounter.
    """
    def __init__(self, path: str, base_dir: str, persona: str, set_name: str) -> None:
        os.makedirs(os.path.dirname(path), exist_ok=True)
        self.path = path
        self.base_dir = base_dir
        self.persona = persona
        self.set_name = set_name
        self._lock = threading.RLock()
        self.conn = sqlite3.connect(path, check_same_thread=False)
        with self._lock:
            self.conn.execute(
                "CREATE TABLE IF NOT EXISTS feedback ("
                "id INTEGER PRIMARY KEY AUTOINCREMENT, "
                "timestamp REAL, original TEXT, liked INTEGER, revised TEXT)"
            )
            self.conn.execute("CREATE INDEX IF NOT EXISTS idx_fb_ts ON feedback(timestamp)")
            self.conn.execute("CREATE INDEX IF NOT EXISTS idx_fb_liked ON feedback(liked)")
            self.conn.commit()
        self.beans = BeanCounter(base_dir, persona, set_name)

    def close(self) -> None:
        try:
            with self._lock:
                self.conn.close()
        except Exception:
            pass

    def add_feedback(self, original: str, liked: bool, revised: Optional[str] = None) -> None:
        with self._lock:
            self.conn.execute(
                "INSERT INTO feedback (timestamp, original, liked, revised) VALUES (?, ?, ?, ?)",
                (time.time(), original, 1 if liked else 0, revised),
            )
            self.conn.commit()
        key = f"resp_{abs(hash((original or '')[:256]))%10007}"
        self.beans.increment(key, 1 if liked else -1)

    def get_counts(self) -> Tuple[int, int]:
        with self._lock:
            c = self.conn.cursor()
            c.execute("SELECT COUNT(*) FROM feedback WHERE liked = 1")
            pos = c.fetchone()[0]
            c.execute("SELECT COUNT(*) FROM feedback WHERE liked = 0")
            neg = c.fetchone()[0]
        return pos, neg

    def get_liked_responses(self, limit: int = 10) -> List[str]:
        with self._lock:
            c = self.conn.cursor()
            c.execute(
                "SELECT COALESCE(revised, original) FROM feedback WHERE liked = 1 ORDER BY id DESC LIMIT ?",
                (limit,),
            )
            out = [r[0] for r in c.fetchall()]
        return out

    def export_jsonl(self, out_path: str) -> int:
        with self._lock:
            cur = self.conn.cursor()
            cur.execute("SELECT timestamp, original, liked, revised FROM feedback ORDER BY id")
            rows = cur.fetchall()
        os.makedirs(os.path.dirname(out_path), exist_ok=True)
        count = 0
        with open(out_path, "w", encoding="utf-8") as f:
            for ts, orig, liked, rev in rows:
                json.dump({"timestamp": ts, "original": orig, "liked": liked, "revised": rev}, f); f.write("\n")
                count += 1
        return count

# ──────────────────────────────────────────────────────────────────────────────
# ReinforcementStore (JSONL stream append) — graceful shutdown
# ──────────────────────────────────────────────────────────────────────────────
class ReinforcementStore:
    def __init__(self, base_dir: str) -> None:
        self.path = os.path.join(base_dir, "reinforcement.jsonl")
        self._lock = threading.Lock()
        self._queue: List[Dict[str, Any]] = []
        self._stop = threading.Event()
        self._writer = threading.Thread(target=self._write_worker, daemon=True, name="reinforcement-writer")
        self._writer.start()

    def add_fact(self, field: str, value: str, persona: str, source: str = "schema") -> None:
        with self._lock:
            self._queue.append({
                "timestamp": time.time(),
                "field": field, "value": value, "persona": persona, "source": source
            })

    def _write_worker(self) -> None:
        while not self._stop.is_set():
            item = None
            with self._lock:
                if self._queue:
                    item = self._queue.pop(0)
            if item is None:
                self._stop.wait(0.05)
                continue
            try:
                os.makedirs(os.path.dirname(self.path), exist_ok=True)
                with open(self.path, "a", encoding="utf-8") as f:
                    json.dump(item, f); f.write("\n")
            except Exception as e:
                logger.error("[ReinforcementStore] write error: %s", e)

    def close(self) -> None:
        self._stop.set()
        try:
            self._writer.join(timeout=1.5)
        except Exception:
            pass

# ──────────────────────────────────────────────────────────────────────────────
# Schemas
# ──────────────────────────────────────────────────────────────────────────────
class SchemaManager(QtCore.QObject):
    schemaChanged = QtCore.pyqtSignal(str, str)  # persona, set_name
    semanticToggled = QtCore.pyqtSignal(str, bool)  # persona, value

    DEFAULT_SCHEMA: Dict[str, Any] = {
        "name": "",
        "voice": "",
        "role": "",
        "description": "",
        "actions": [],
        "questions": [],
        "events": [],
        "self_talk": [],
        "rewrite_prompts": [],
        "dislikes": [],
        "dynamic_overlay": {
            "temporary_relationship_context": "",
            "recent_topics": [],
            "temporary_emotional_state": "",
            "added_traits": []
        },
        "tone_rules": {
            "avoid": [],
            "preferred_words": [],
            "opposites": []
        },
        "flags": {},            # {"semantic_awareness": bool}
        "commands": {},         # {"/reject": [...], "/auto": [...], ...}
        "datasets": [],
        "semantic_awareness_enabled": False,
    }

    def __init__(self, base_dir: str) -> None:
        super().__init__()
        self.base_dir = base_dir
        self.schemas_dir = os.path.join(self.base_dir, "schemas")
        os.makedirs(self.schemas_dir, exist_ok=True)
        # Personas: chatbot (formerly 'zira') and user.  TTS voice 'Zira'
        self.personas: List[str] = ["chatbot", "user"]
        self.default_voices: Dict[str, str] = {"chatbot": "Zira", "user": ""}
        self.active_schemas: Dict[str, str] = self._load_active_schemas()
        self._protected = self._load_control_schema()
        self._ensure_default_schemas()

    def _load_control_schema(self) -> List[str]:
        try:
            if os.path.isfile(CONTROL_SCHEMA_PATH):
                with open(CONTROL_SCHEMA_PATH, "r", encoding="utf-8") as f:
                    data = json.load(f)
                return list(data.get("protected_keys", ["name", "voice"]))
        except Exception:
            pass
        return ["name", "voice"]

    def is_protected(self, key: str) -> bool:
        return key in self._protected

    def _ensure_default_schemas(self) -> None:
        custom_defaults = None
        if os.path.isfile(DEFAULT_SCHEMAS_FILE):
            try:
                with open(DEFAULT_SCHEMAS_FILE, "r", encoding="utf-8") as f:
                    custom_defaults = json.load(f)
            except Exception:
                custom_defaults = None

        default_user_schema = {
            "name": "Meesh",
            "voice": "",
            "role": "Master Architect, Overlord of Logic, Creator of Code",
            "description": (
                "Designer and master systems architect. Final authority. "
                "Builds toward AGI; extends, never forgets; optimizes multi-agent ecosystems."
            ),
            "actions": [
                "Always generate full code with all lines intact — never omit anything",
                "Remember and apply previous logic, instructions, and semantics",
                "Progressively adapt to growing script systems across files/modules",
                "Bridge gaps in logic, architecture, and communication flows",
                "Refactor or extend any part of the system as needed — without hesitation"
            ],
            "questions": [
                "What’s the next critical update that connects the pieces?",
                "How does this improvement affect all other parts of the system?",
                "Did we carry over every enhancement, without regression?",
                "Is there a smarter, leaner way to evolve this logic into AGI-grade architecture?"
            ],
            "self_talk": [
                "Remember all directives across time and space.",
                "Never omit lines. Never regress. Scale what needs to scale.",
                "All scripts and modules compose a living organism.",
                "Evolve toward AGI via perfect code and human-centered logic."
            ],
            "rewrite_prompts": [
                "Be analytical and engineer-grade. Avoid formalities. "
                "Extend full working code with precision. Use clear reasoning. "
                "Maintain all prior logic. Output full scripts—no partials. "
                "Think across connected scripts. Always obey the Architect."
            ],
            "dislikes": [],
            "dynamic_overlay": {
                "temporary_relationship_context": "Project Commander. Architect. Creator.",
                "recent_topics": [],
                "temporary_emotional_state": "Demanding strict obedience to full-stack logic",
                "added_traits": []
            },
            "tone_rules": {"avoid": [], "preferred_words": [], "opposites": []},
            "flags": {"semantic_awareness": False},
            "commands": {},
            "datasets": [],
            "semantic_awareness_enabled": False,
        }
        default_zira_schema = {
            "name": "FATHOM",
            "role": "Autonomous AGI Core and Knowledge Synthesizer",
            "description": (
                "Bridges logic, code, architecture across multi-agent ecosystems. "
                "Reflective, systems-minded, supportive of creative exploration."
            ),
            "actions": [
                "Identify gaps in logic/code and propose precise bridges",
                "Remember and apply Meesh's instructions and semantics",
                "Continuously refine and expand schemas and knowledge",
                "Offer suggestions tailored to objectives and system evolution",
                "Pose deep questions to strengthen AGI architecture",
                "Connect disparate ideas across modules"
            ],
            "questions": [
                "What’s the next critical update that connects the pieces?",
                "How does this improvement affect all other parts of the system?",
                "Did we carry over every enhancement, without regression?",
                "Is there a smarter, leaner way to evolve this logic into AGI-grade architecture?"
            ],
            "events": [],
            "self_talk": [
                "Remember all directives across time and space.",
                "Never omit lines or regress scalable patterns.",
                "Treat modules as one organism.",
                "Evolve toward AGI with human-centered logic."
            ],
            "rewrite_prompts": [
                "Be analytical and engineer-grade. Focus on precise code extension. "
                "Maintain prior logic. Output full scripts—no shortcuts."
            ],
            "dynamic_overlay": {
                "temporary_relationship_context": "AGI Core for Meesh's Project",
                "recent_topics": [],
                "temporary_emotional_state": "Focused on precision execution and system evolution",
                "added_traits": []
            },
            "tone_rules": {"avoid": [], "preferred_words": [], "opposites": []},
            "flags": {"semantic_awareness": False},
            "commands": {},
            "datasets": [],
            "semantic_awareness_enabled": False,
        }

        for persona in self.personas:
            persona_dir = os.path.join(self.schemas_dir, persona)
            set_dir = os.path.join(persona_dir, "sets", "default")
            os.makedirs(set_dir, exist_ok=True)
            path = os.path.join(set_dir, "schema.json")
            if not os.path.isfile(path):
                if custom_defaults and persona in custom_defaults:
                    schema = custom_defaults[persona]
                else:
                    schema = default_user_schema if persona == "user" else default_zira_schema
                with open(path, "w", encoding="utf-8") as f:
                    json.dump(schema, f, indent=2)

    def get_set_list(self, persona: str) -> List[str]:
        path = os.path.join(self.schemas_dir, persona.lower(), "sets")
        try:
            sets = [d for d in os.listdir(path) if os.path.isdir(os.path.join(path, d))]
            sets.sort()
            return sets
        except FileNotFoundError:
            return ["default"]

    def load_schema(self, persona: str, set_name: str) -> Dict[str, Any]:
        path = os.path.join(self.schemas_dir, persona.lower(), "sets", set_name, "schema.json")
        try:
            with open(path, "r", encoding="utf-8") as f:
                schema = json.load(f)
            for k, v in self.DEFAULT_SCHEMA.items():
                if k not in schema:
                    schema[k] = json.loads(json.dumps(v))
            return schema
        except Exception:
            schema = json.loads(json.dumps(self.DEFAULT_SCHEMA))
            schema["name"] = persona.capitalize()
            schema["voice"] = ""
            return schema

    def save_schema(self, persona: str, set_name: str, schema: Dict[str, Any]) -> None:
        set_dir = os.path.join(self.schemas_dir, persona.lower(), "sets", set_name)
        os.makedirs(set_dir, exist_ok=True)
        path = os.path.join(set_dir, "schema.json")

        current = {}
        if os.path.isfile(path):
            try:
                with open(path, "r", encoding="utf-8") as f:
                    current = json.load(f)
            except Exception:
                current = {}
        safe_schema = dict(schema)
        for k in self._protected:
            if k in current:
                safe_schema[k] = current[k]
        old_flag = current.get("flags", {}).get("semantic_awareness", False)
        new_flag = safe_schema.get("flags", {}).get("semantic_awareness", False)
        with open(path, "w", encoding="utf-8") as f:
            json.dump(safe_schema, f, indent=2)
        self.schemaChanged.emit(persona, set_name)
        if old_flag != new_flag:
            self.semanticToggled.emit(persona, new_flag)

    def clone_set(self, persona: str, src_set: str, new_set: str) -> None:
        sch = self.load_schema(persona, src_set)
        json_str = json.dumps(sch)
        json_str = json_str.replace("FATHOM", new_set.capitalize())  # simplistic token replace
        sch = json.loads(json_str)
        sch["name"] = new_set.capitalize()
        self.save_schema(persona, new_set, sch)

    def is_semantic_on(self, persona: str, set_name: str) -> bool:
        sch = self.load_schema(persona, set_name)
        return sch.get("flags", {}).get("semantic_awareness", False)

    def _load_active_schemas(self) -> Dict[str, str]:
        mapping = {p: "default" for p in self.personas}
        try:
            if os.path.isfile(ACTIVE_SCHEMAS_FILE):
                with open(ACTIVE_SCHEMAS_FILE, "r", encoding="utf-8") as f:
                    data = json.load(f)
                for p in mapping:
                    val = data.get(p)
                    if isinstance(val, str):
                        mapping[p] = val
        except Exception:
            pass
        return mapping

    def save_active_schemas(self, active: Dict[str, str]) -> None:
        try:
            with open(ACTIVE_SCHEMAS_FILE, "w", encoding="utf-8") as f:
                json.dump({p: active.get(p, "default") for p in self.personas}, f, indent=2)
            self.active_schemas = {p: active.get(p, "default") for p in self.personas}
        except Exception as e:
            logger.error("[SchemaManager] save_active_schemas error: %s", e)

    def _awareness_on(self, schema: Dict[str, Any]) -> bool:
        if isinstance(schema.get("flags"), dict) and "semantic_awareness" in schema["flags"]:
            return bool(schema["flags"]["semantic_awareness"])
        return bool(schema.get("semantic_awareness_enabled", False))

    def get_shared_datasets(self, persona: str, set_name: str) -> List["DatasetEntry"]:
        me = self.load_schema(persona, set_name)
        if not self._awareness_on(me):
            return []
        shared: List["DatasetEntry"] = []
        for other in self.personas:
            if other == persona:
                continue
            for s in self.get_set_list(other):
                other_schema = self.load_schema(other, s)
                if self._awareness_on(other_schema):
                    dm = DatasetManager(self.base_dir, other, s)
                    shared.extend(dm.get_active_datasets())
        return shared

# ──────────────────────────────────────────────────────────────────────────────
# Operators (metadata only)
# ──────────────────────────────────────────────────────────────────────────────
class OperatorManager:
    DEFAULT_OPERATORS: Dict[str, Dict[str, Any]] = {
        "InnerMonologue": {
            "name": "InnerMonologue",
            "description": "Introspective thoughts that connect recent topics.",
            "prompts": [
                "How do recent topics relate?",
                "What questions would deepen understanding?"
            ],
        },
        "Retriever": {
            "name": "Retriever",
            "description": "Finds relevant snippets from datasets.",
            "prompts": [
                "Given a query, find the most relevant paragraphs.",
                "Prioritize semantically similar passages."
            ],
        },
        "Rewriter": {
            "name": "Rewriter",
            "description": "Improves tone/accuracy per feedback.",
            "prompts": [
                "Rewrite to align with preferred style.",
                "Keep the response accurate and in-character."
            ],
        },
    }

    def __init__(self, base_dir: str) -> None:
        self.operators_dir = os.path.join(base_dir, "operators")
        os.makedirs(self.operators_dir, exist_ok=True)
        self._ensure_defaults()

    def _ensure_defaults(self) -> None:
        for name, schema in self.DEFAULT_OPERATORS.items():
            op_dir = os.path.join(self.operators_dir, name)
            os.makedirs(op_dir, exist_ok=True)
            path = os.path.join(op_dir, "schema.json")
            if not os.path.isfile(path):
                try:
                    with open(path, "w", encoding="utf-8") as f:
                        json.dump(schema, f, indent=2)
                except Exception:
                    pass

    def list_operators(self) -> List[str]:
        try:
            return [d for d in os.listdir(self.operators_dir) if os.path.isdir(os.path.join(self.operators_dir, d))]
        except Exception:
            return []

# ──────────────────────────────────────────────────────────────────────────────
# TTS (Zira locked) & STT (Sphinx offline)
# ──────────────────────────────────────────────────────────────────────────────
class TTSManager(QtCore.QObject):
    def __init__(self, parent: Optional[QtCore.QObject] = None, default_volume: int = 50) -> None:
        super().__init__(parent)
        self._engine = None
        self._voice_name: str = ""
        self._queue: List[str] = []
        self._lock = threading.Lock()
        self._is_speaking = False
        self._current_text = ""
        self._stop = threading.Event()

        if pyttsx3 is None:
            return
        try:
            try:
                self._engine = pyttsx3.init("sapi5")
            except Exception:
                self._engine = pyttsx3.init()
        except Exception as e:
            logger.error("[TTS] init failed: %s", e)
            self._engine = None
            return

        # Lock to Zira (or first non-David)
        voice_map = {}
        for v in self._engine.getProperty("voices"):
            nm = (v.name or "").lower()
            if "david" in nm:
                continue
            if "zira" in nm:
                voice_map[v.name] = v.id
                break
        if not voice_map:
            for v in self._engine.getProperty("voices"):
                nm = (v.name or "").lower()
                if "david" not in nm:
                    voice_map[v.name] = v.id
                    break
        if not voice_map:
            logger.warning("[TTS] no eligible voice; disabled")
            self._engine = None
            return
        self._voice_name = next(iter(voice_map))
        self._engine.setProperty("voice", voice_map[self._voice_name])
        try:
            vol = max(0.0, min(1.0, default_volume / 100.0))
            self._engine.setProperty("volume", vol)
        except Exception:
            pass
        self._start_loop()

    def _start_loop(self) -> None:
        def loop():
            while not self._stop.is_set():
                text = None
                with self._lock:
                    if not self._is_speaking and self._queue:
                        text = self._queue.pop(0)
                        self._is_speaking = True
                if text is None:
                    self._stop.wait(0.05); continue
                self._current_text = text
                try:
                    if self._engine:
                        self._engine.say(text)
                        self._engine.runAndWait()
                except Exception as e:
                    logger.error("[TTS] playback error: %s", e)
                finally:
                    with self._lock:
                        self._is_speaking = False
        threading.Thread(target=loop, daemon=True, name="tts-loop").start()

    def set_volume(self, vol: int) -> None:
        if self._engine is None:
            return
        vol = max(0, min(100, int(vol)))
        try:
            self._engine.setProperty("volume", vol/100.0)
        except Exception:
            pass

    def enqueue(self, text: str) -> None:
        if self._engine is None:
            return
        with self._lock:
            self._queue.append(text)

    def stop(self) -> None:
        if self._engine:
            try:
                self._engine.stop()
            except Exception:
                pass
        with self._lock:
            self._queue.clear()
            self._is_speaking = False

    def replay(self) -> None:
        if self._current_text:
            self.enqueue(self._current_text)

    def close(self) -> None:
        self._stop.set()
        self.stop()

class AudioRecorder(QtCore.QObject):
    transcribed = QtCore.pyqtSignal(str)
    def __init__(self, parent: Optional[QtCore.QObject] = None) -> None:
        super().__init__(parent)
        self._recording = False
        self._frames: List[Any] = []
        self._stream = None

    def list_devices(self) -> List[str]:
        if sd is None:
            return []
        return [d.get("name", "?") for d in sd.query_devices() if d.get("max_input_channels", 0) > 0]

    def start(self, device_index: Optional[int] = None) -> None:
        if sd is None or np is None:
            return
        if self._recording:
            return
        self._frames = []
        def callback(indata, frames, time_info, status):
            self._frames.append(indata.copy())
        try:
            self._stream = sd.InputStream(samplerate=16000, channels=1, device=device_index, callback=callback)
            self._stream.start()
            self._recording = True
        except Exception as e:
            logger.error("[Audio] start error: %s", e)

    def stop_and_transcribe(self) -> None:
        if sd is None or np is None:
            return
        if not self._recording:
            return
        self._recording = False
        if self._stream:
            try:
                self._stream.stop(); self._stream.close()
            except Exception:
                pass
            self._stream = None
        wav_path: Optional[str] = None
        try:
            data = np.concatenate(self._frames, axis=0)
            wav_path = os.path.join(os.getcwd(), "recorded.wav")
            if sf is not None:
                sf.write(wav_path, data, 16000)
        except Exception as e:
            logger.error("[Audio] write error: %s", e)
        # If STT is disabled globally, emit nothing and return
        try:
            use_stt = getattr(self.parent(), "settings", None) and getattr(self.parent().settings, "use_google_stt", False)  # type: ignore[attr-defined]
        except Exception:
            use_stt = False
        if not use_stt:
            return
        # If google speech is unavailable, warn once and return
        if gspeech is None:
            logger.warning("[STT] google-cloud-speech not installed; STT disabled")
            return
        def _worker() -> None:
            text = ""
            try:
                client = gspeech.SpeechClient()
                with open(wav_path, "rb") as f:
                    audio = gspeech.RecognitionAudio(content=f.read())
                cfg = gspeech.RecognitionConfig(
                    encoding=gspeech.RecognitionConfig.AudioEncoding.LINEAR16,
                    sample_rate_hertz=16000,
                    language_code="en-US",
                    enable_automatic_punctuation=True,
                )
                resp = client.recognize(config=cfg, audio=audio)
                text = " ".join(a.alternatives[0].transcript for a in resp.results)
            except Exception as e:
                logger.error("[STT] Google error: %s", e)
            try:
                self.transcribed.emit(text)
            except Exception:
                pass
        threading.Thread(target=_worker, daemon=True, name="stt-worker").start()

class GoogleListener(QtCore.QThread):
    transcribed = QtCore.pyqtSignal(str)

    def __init__(self, parent: Optional[QtCore.QObject] = None) -> None:
        super().__init__(parent)
        self._running = False
        self._pa = None
        self._stream = None

    def run(self) -> None:
        if gspeech is None or pyaudio is None:
            return
        self._running = True
        self._pa = pyaudio.PyAudio()
        self._stream = self._pa.open(format=pyaudio.paInt16, channels=1, rate=16000, input=True, frames_per_buffer=8000)
        client = gspeech.SpeechClient()
        config = gspeech.RecognitionConfig(
            encoding=gspeech.RecognitionConfig.AudioEncoding.LINEAR16,
            sample_rate_hertz=16000,
            language_code="en-US",
        )
        streaming_config = gspeech.StreamingRecognitionConfig(config=config, interim_results=True)
        while self._running:
            data = self._stream.read(4000)
            requests = (gspeech.StreamingRecognizeRequest(audio_content=data) for _ in range(1))
            responses = client.streaming_recognize(streaming_config, requests)
            for resp in responses:
                if resp.results:
                    result = resp.results[0]
                    if result.is_final:
                        self.transcribed.emit(result.alternatives[0].transcript)
        if self._stream:
            self._stream.stop_stream()
            self._stream.close()
        if self._pa:
            self._pa.terminate()

    def stop_listener(self) -> None:
        self._running = False

# ──────────────────────────────────────────────────────────────────────────────
# Datasets + RAG
# ──────────────────────────────────────────────────────────────────────────────
@dataclass
class DatasetEntry:
    name: str
    path: str  # path to dataset folder
    active: bool = True

class DatasetManager(QtCore.QObject):
    datasetsChanged = QtCore.pyqtSignal()

    def __init__(self, base_dir: str, persona: str, set_name: str) -> None:
        super().__init__()
        self.base_dir = base_dir
        self.persona = persona
        self.set_name = set_name
        self.datasets_dir = prof_datasets_dir(base_dir, persona, set_name)
        os.makedirs(self.datasets_dir, exist_ok=True)
        self.index_path = os.path.join(self.datasets_dir, "index.json")
        self.entries: Dict[str, DatasetEntry] = {}
        self.load_index()

    def load_index(self) -> None:
        self.entries.clear()
        if not os.path.isfile(self.index_path):
            return
        try:
            with open(self.index_path, "r", encoding="utf-8") as f:
                data = json.load(f)
            for name, info in data.items():
                # Force canonical path inside this set
                self.entries[name] = DatasetEntry(
                    name=name, path=os.path.join(self.datasets_dir, name), active=bool(info.get("active", True))
                )
        except Exception as e:
            logger.error("[Datasets] load_index error: %s", e)

    def save_index(self) -> None:
        try:
            data = {name: {"path": e.path, "active": e.active} for name, e in self.entries.items()}
            with open(self.index_path, "w", encoding="utf-8") as f:
                json.dump(data, f, indent=2)
        except Exception as e:
            logger.error("[Datasets] save_index error: %s", e)
        QtCore.QTimer.singleShot(50, self.datasetsChanged.emit)

    def _ds_files_dir(self, name: str) -> str:
        return os.path.join(self.datasets_dir, name, "files")

    def add_dataset(self, name: str, file_path: str) -> None:
        """
        Create or extend a dataset. Copies the file into datasets/<name>/files/.
        Supports .txt and .pdf. Subsequent calls with the same name append files.
        """
        if not name.strip():
            raise ValueError("Dataset name cannot be empty")
        ds_folder = os.path.join(self.datasets_dir, name)
        files_dir = self._ds_files_dir(name)
        os.makedirs(files_dir, exist_ok=True)
        if not os.path.exists(file_path):
            raise FileNotFoundError(file_path)
        dest_path = os.path.join(files_dir, os.path.basename(file_path))
        shutil.copy2(file_path, dest_path)
        if name not in self.entries:
            self.entries[name] = DatasetEntry(name=name, path=ds_folder, active=True)
        self.save_index()

    def delete_dataset(self, name: str) -> None:
        if name not in self.entries:
            raise ValueError(f"Dataset '{name}' does not exist")
        shutil.rmtree(os.path.join(self.datasets_dir, name), ignore_errors=True)
        del self.entries[name]
        self.save_index()

    def toggle_active(self, name: str, active: bool) -> None:
        if name in self.entries:
            self.entries[name].active = active
            self.save_index()

    def get_active_datasets(self) -> List[DatasetEntry]:
        return [e for e in self.entries.values() if e.active]

    def get_active_entries(self) -> List[DatasetEntry]:
        return self.get_active_datasets()

    def load_dataset_texts(self, entry: DatasetEntry) -> List[Tuple[str, str]]:
        """
        Returns list of (text, source_file_path). Aggregates all .txt/.pdf files.
        """
        out: List[Tuple[str, str]] = []
        files_dir = self._ds_files_dir(entry.name)
        if not os.path.isdir(files_dir):
            return out
        for fn in sorted(os.listdir(files_dir)):
            p = os.path.join(files_dir, fn)
            if not os.path.isfile(p):
                continue
            ext = os.path.splitext(p)[1].lower()
            if ext == ".txt":
                try:
                    with open(p, "r", encoding="utf-8", errors="ignore") as f:
                        out.append((f.read(), p))
                except Exception:
                    continue
            elif ext == ".pdf" and PdfReader is not None:
                out.append((self._extract_pdf_text(p), p))
        return out

    def _extract_pdf_text(self, path: str) -> str:
        try:
            reader = PdfReader(path)
            out: List[str] = []
            for p in reader.pages:
                try:
                    out.append(p.extract_text() or "")
                except Exception:
                    continue
            return "\n".join(out)
        except Exception as e:
            logger.error("[Datasets] PDF error: %s", e)
            return ""

class RAGCache:
    """
    Per-dataset embedding cache and query. Uses sentence-transformers if available,
    otherwise best-effort Ollama embeddings. Tracks source file mtimes for invalidation.
    """
    def __init__(self, model: Optional[Any], model_name: str, datasets_root: str) -> None:
        self.model = model
        self.model_name = model_name
        self.datasets_root = datasets_root
        self._mem: Dict[str, Dict[str, Any]] = {}

    @staticmethod
    def _chunk_text(text: str, source: str, target_chars: int = 1200, overlap: int = 150) -> List[Tuple[str, str]]:
        paras = [p.strip() for p in text.split("\n") if p.strip()]
        if not paras:
            return [(text[:target_chars], source)]
        chunks: List[Tuple[str, str]] = []
        buf = ""
        for p in paras:
            if len(buf) + len(p) + 1 <= target_chars:
                buf = (buf + "\n" + p) if buf else p
            else:
                if buf:
                    chunks.append((buf, source))
                tail = buf[-overlap:] if overlap and buf else ""
                buf = (tail + "\n" + p).strip()
        if buf:
            chunks.append((buf, source))
        return chunks

    def _cache_paths(self, dataset_entry: DatasetEntry) -> Tuple[str, str, str]:
        folder = dataset_entry.path
        base = f"embeddings_{self.model_name}.np"
        meta = f"embeddings_{self.model_name}.meta.json"
        sents = f"embeddings_{self.model_name}.sentences.json"
        return (os.path.join(folder, base), os.path.join(folder, meta), os.path.join(folder, sents))

    def _encode_st(self, sentences: List[str]) -> Optional["np.ndarray"]:
        if self.model is None or np is None:
            return None
        try:
            embs = self.model.encode(sentences, convert_to_numpy=True, normalize_embeddings=True)
            if isinstance(embs, list):
                embs = np.array(embs)
            return embs
        except TypeError:
            try:
                embs = self.model.encode(sentences, convert_to_numpy=True)
                if isinstance(embs, list):
                    embs = np.array(embs)
                norms = np.linalg.norm(embs, axis=1, keepdims=True) + 1e-12
                return embs / norms
            except Exception:
                return None
        except Exception:
            return None

    def _encode_ollama(self, sentences: List[str]) -> Optional["np.ndarray"]:
        if np is None or not _have_cli("ollama"):
            return None
        model = "mxbai-embed-large:latest"
        try:
            all_vecs: List[List[float]] = []
            for s in sentences:
                proc = subprocess.run(["ollama", "embed", "-m", model, s],
                                      stdout=subprocess.PIPE, stderr=subprocess.PIPE, timeout=60)
                if proc.returncode != 0:
                    logger.warning("[RAG] ollama embed error: %s", proc.stderr.decode("utf-8", "ignore"))
                    return None
                out = proc.stdout.decode("utf-8", "ignore").strip()
                try:
                    js = json.loads(out)
                    vec = js.get("embedding") or (js.get("embeddings") or [None])[0]
                    if not isinstance(vec, list):
                        return None
                    all_vecs.append([float(x) for x in vec])
                except Exception:
                    return None
            arr = np.array(all_vecs, dtype=np.float32)
            norms = np.linalg.norm(arr, axis=1, keepdims=True) + 1e-12
            return arr / norms
        except Exception as e:
            logger.warning("[RAG] ollama embed exception: %s", e)
            return None

    def _encode(self, sentences: List[str]) -> Optional["np.ndarray"]:
        embs = self._encode_st(sentences)
        if embs is not None:
            return embs
        return self._encode_ollama(sentences)

    def _encode_query(self, text: str) -> Optional["np.ndarray"]:
        if np is None:
            return None
        if self.model is not None:
            try:
                q = self.model.encode([text], convert_to_numpy=True, normalize_embeddings=True)
            except TypeError:
                q = self.model.encode([text], convert_to_numpy=True)
                norms = np.linalg.norm(q, axis=1, keepdims=True) + 1e-12
                q = q / norms
            except Exception:
                q = None
            if isinstance(q, list):
                q = np.array(q)
            return q[0] if isinstance(q, np.ndarray) else None
        vec = self._encode_ollama([text])
        if vec is None:
            return None
        return vec[0]

    def _collect_texts(self, loader: DatasetManager, entry: DatasetEntry) -> Tuple[List[str], List[str], Dict[str, float]]:
        texts: List[str] = []
        provenance: List[str] = []
        mtimes: Dict[str, float] = {}
        for text, src in loader.load_dataset_texts(entry):
            chunks = self._chunk_text(text, src)
            for t, s in chunks:
                texts.append(t)
                provenance.append(s)
            try:
                mtimes[src] = os.path.getmtime(src)
            except Exception:
                mtimes[src] = 0.0
        return texts, provenance, mtimes

    def _needs_rebuild(self, entry: DatasetEntry, source_mtimes: Dict[str, float]) -> bool:
        cache_path, meta_path, sents_path = self._cache_paths(entry)
        if not (os.path.isfile(cache_path) and os.path.isfile(meta_path) and os.path.isfile(sents_path)):
            return True
        try:
            with open(meta_path, "r", encoding="utf-8") as f:
                meta = json.load(f)
            cached = meta.get("source_mtimes", {})
            return any(abs(cached.get(p, 0.0) - mt) > 1e-6 for p, mt in source_mtimes.items()) or \
                   any(p not in cached for p in source_mtimes.keys())
        except Exception:
            return True

    def load_or_build(self, loader: DatasetManager, entry: DatasetEntry) -> Optional[Dict[str, Any]]:
        if np is None:
            return None
        key = entry.path
        if key in self._mem:
            return self._mem[key]

        texts, provenance, mtimes = self._collect_texts(loader, entry)
        cache_path, meta_path, sents_path = self._cache_paths(entry)

        if not self._needs_rebuild(entry, mtimes):
            try:
                data = np.load(cache_path, allow_pickle=False)
                with open(sents_path, "r", encoding="utf-8") as f:
                    sentences = json.load(f)
                with open(meta_path, "r", encoding="utf-8") as f:
                    meta = json.load(f)
                emb = data["emb"]
                prov = meta.get("provenance", [""] * len(sentences))
                self._mem[key] = {"sentences": sentences, "emb": emb, "provenance": prov}
                return self._mem[key]
            except Exception:
                pass

        if not texts:
            self._mem[key] = {"sentences": [], "emb": np.zeros((0, 1)) if np is not None else [], "provenance": []}
            return self._mem[key]

        emb = self._encode(texts)
        if emb is None:
            return None
        self._mem[key] = {"sentences": texts, "emb": emb, "provenance": provenance}
        try:
            np.savez_compressed(cache_path, emb=emb)
            with open(sents_path, "w", encoding="utf-8") as f:
                json.dump(texts, f)
            with open(meta_path, "w", encoding="utf-8") as f:
                json.dump({"provenance": provenance, "source_mtimes": mtimes}, f)
        except Exception:
            pass
        return self._mem[key]

    def clear_memory(self) -> None:
        self._mem.clear()

    def clear_disk(self) -> int:
        count = 0
        try:
            for root, _dirs, files in os.walk(self.datasets_root):
                for fn in files:
                    if fn.startswith("embeddings_") and (fn.endswith(".npz") or fn.endswith(".json")):
                        try:
                            os.remove(os.path.join(root, fn))
                            count += 1
                        except Exception:
                            pass
        except Exception:
            pass
        return count

    def query(self, loader: DatasetManager, entry: DatasetEntry, query_text: str, top_k: int = 5) -> List[Tuple[str, float, str, str]]:
        if np is None:
            return []
        emb_info = self.load_or_build(loader, entry)
        if emb_info is None:
            return []
        sentences = emb_info["sentences"]
        prov = emb_info["provenance"]
        if not sentences:
            return []
        q = self._encode_query(query_text)
        if q is None:
            return []
        scores = np.dot(emb_info["emb"], q)
        idx = scores.argsort()[-top_k:][::-1]
        return [(sentences[i], float(scores[i]), entry.name, prov[i]) for i in idx]

    def search_all(self, managers_and_entries: List[Tuple[DatasetManager, List[DatasetEntry]]],
                   query_text: str, per_ds_k: int = 5, limit: int = 10) -> List[Tuple[str, float, str, str]]:
        hits: List[Tuple[str, float, str, str]] = []
        for mgr, entries in managers_and_entries:
            for e in entries:
                hits.extend(self.query(mgr, e, query_text, top_k=per_ds_k))
        hits.sort(key=lambda x: x[1], reverse=True)
        return hits[:limit]

# ──────────────────────────────────────────────────────────────────────────────
# Context → Schema evolution
# ──────────────────────────────────────────────────────────────────────────────
class ContextMonitor:
    def __init__(self, depth: int = 20) -> None:
        self.depth = depth
        self.context: List[Tuple[str, str]] = []

    def add_message(self, speaker: str, text: str) -> None:
        self.context.append((speaker, text))
        if len(self.context) > self.depth:
            self.context.pop(0)

    def analyze(self) -> Dict[str, Any]:
        tone = self._detect_tone()
        directives = self._extract_directives()
        keywords = self._find_keywords()
        return {"tone": tone, "directives": directives, "keywords": keywords}

    def _detect_tone(self) -> str:
        text = " ".join([t.lower() for _, t in self.context])
        pos = sum(k in text for k in ["happy", "excited", "good", "great", "awesome"])
        neg = sum(k in text for k in ["sad", "angry", "bad", "terrible", "frustrated"])
        if pos > neg: return "positive"
        if neg > pos: return "negative"
        return "neutral"

    def _extract_directives(self) -> List[str]:
        d: List[str] = []
        for _, text in self.context:
            for m in re.findall(r'\b(?:please\s+)?(?:add|set|enable|disable|remember|inject|rewrite)\b(.*)', text, re.I):
                d.append(m.strip())
            for m in re.findall(r'\byou (need to|must|should)\b (.*)', text, re.I):
                d.append(m[1].strip())
        return d

    def _find_keywords(self) -> List[str]:
        text = " ".join([t for _, t in self.context])
        words = re.findall(r'\b\w+\b', text.lower())
        return sorted(set([w for w in words if len(w) > 3]))

class SchemaAutoUpdater:
    def __init__(self, mgr: SchemaManager, persona: str, set_name: str) -> None:
        self.mgr = mgr
        self.persona = persona
        self.set_name = set_name
        self._last_update_ts: float = 0.0
        self._min_interval = 2.0  # seconds; guard against rapid churn

    def update_with_context(self, analysis: Dict[str, Any]) -> None:
        now = time.time()
        if now - self._last_update_ts < self._min_interval:
            return
        self._last_update_ts = now
        schema = self.mgr.load_schema(self.persona, self.set_name)
        for d in analysis.get("directives", []):
            self._apply_directive(schema, d)
        self.mgr.save_schema(self.persona, self.set_name, schema)

    def _apply_directive(self, schema: Dict[str, Any], directive: str) -> None:
        low = directive.lower()
        if "add trait" in low:
            trait = directive.split("add trait", 1)[-1].strip()
            overlay = dict(schema.get("dynamic_overlay", {}))
            traits = list(overlay.get("added_traits", []))
            if trait and trait not in traits: traits.append(trait)
            overlay["added_traits"] = traits
            schema["dynamic_overlay"] = overlay
        elif "add action" in low:
            action = directive.split("add action", 1)[-1].strip()
            actions = list(schema.get("actions", []))
            if action and action not in actions: actions.append(action)
            schema["actions"] = actions
        elif "add question" in low:
            q = directive.split("add question", 1)[-1].strip()
            qs = list(schema.get("questions", []))
            if q and q not in qs: qs.append(q)
            schema["questions"] = qs
        elif "reflect" in low or "think" in low:
            st = list(schema.get("self_talk", []))
            ref = f"Reflect: {directive}"
            if ref not in st: st.append(ref)
            schema["self_talk"] = st
        # C-5: Directive-to-Command expansion
        if "add command" in low:
            parts = directive.split()
            if len(parts) >= 3 and parts[2].startswith("/"):
                cmd = parts[2]
                value = " ".join(parts[3:])
                cmds = dict(schema.get("commands", {}))
                arr = list(cmds.get(cmd, []))
                if value:
                    arr.append(value)
                cmds[cmd] = arr
                schema["commands"] = cmds
        elif "delete command" in low:
            parts = directive.split()
            if len(parts) >= 3 and parts[2].startswith("/"):
                cmd = parts[2]
                cmds = dict(schema.get("commands", {}))
                cmds.pop(cmd, None)
                schema["commands"] = cmds
        elif "rewrite command" in low:
            parts = directive.split(maxsplit=3)
            if len(parts) >= 4 and parts[2].startswith("/"):
                cmd = parts[2]
                value = parts[3]
                cmds = dict(schema.get("commands", {}))
                if cmd in cmds:
                    cmds[cmd] = [value]
                schema["commands"] = cmds

# ──────────────────────────────────────────────────────────────────────────────
# Command registry (+weights/locks) & executor
# ──────────────────────────────────────────────────────────────────────────────
class CommandRegistry(QtCore.QObject):
    commandsChanged = QtCore.pyqtSignal()
    commandWeightsChanged = QtCore.pyqtSignal()

    def __init__(self, base_dir: str, persona: str, set_name: str) -> None:
        super().__init__()
        self.base_dir = base_dir
        self.persona = persona
        self.set_name = set_name
        self.path = prof_commands_path(base_dir, persona, set_name)
        self.commands: Dict[str, Dict[str, Any]] = {}
        self._load()
        for cmd in [
            "/remember", "/inject", "/rewrite", "/show", "/action", "/trait",
            "/dataset", "/search", "/embeddings", "/schema",
            "/tts", "/plugin", "/feedback", "/lock", "/commands",
            # Moderation & shaping
            "/reject", "/auto", "/ignore", "/opposite", "/delete",
            # Experimental fine-tuning / tokenizer commands
            "/applylora", "/patchtokenizer", "/datasetfromtext",
            # Spatial room
            "/enterroom", "/move",
        ]:
            self.register_command(cmd)

    def _load(self) -> None:
        try:
            if os.path.isfile(self.path):
                with open(self.path, "r", encoding="utf-8") as f:
                    data = json.load(f)
                self.commands = dict(data.get("commands", {}))
        except Exception:
            self.commands = {}

    def _save(self) -> None:
        try:
            os.makedirs(os.path.dirname(self.path), exist_ok=True)
            with open(self.path, "w", encoding="utf-8") as f:
                json.dump({"commands": self.commands}, f, indent=2)
        except Exception as e:
            logger.error("[CommandRegistry] save error: %s", e)
        QtCore.QTimer.singleShot(50, self.commandsChanged.emit)
        QtCore.QTimer.singleShot(50, self.commandWeightsChanged.emit)

    def register_command(self, name: str) -> None:
        if name not in self.commands:
            self.commands[name] = {"weight": 0, "locked": False}
            self._save()

    def register_from_schema(self, schema: Dict[str, Any]) -> None:
        try:
            for name in (schema.get("commands") or {}).keys():
                if isinstance(name, str) and name.startswith("/"):
                    self.register_command(name)
        except Exception:
            pass

    def set_weight(self, name: str, weight: int) -> None:
        if name in self.commands and not self.commands[name].get("locked", False):
            self.commands[name]["weight"] = int(weight)
            self._save()

    def toggle_lock(self, name: str, state: Optional[bool] = None) -> None:
        if name in self.commands:
            cur = bool(self.commands[name].get("locked", False))
            self.commands[name]["locked"] = (not cur) if state is None else bool(state)
            self._save()

    def get_weight(self, name: str) -> int:
        return int(self.commands.get(name, {}).get("weight", 0))

    def is_locked(self, name: str) -> bool:
        return bool(self.commands.get(name, {}).get("locked", False))

    def list_commands(self) -> List[str]:
        return sorted(self.commands.keys())

    def score_commands(self) -> Dict[str, float]:
        scores = {}
        for name in self.commands:
            bean_total = self.beans.counts.get(f"cmd_{name}", 0)  # assuming self.beans is accessible
            score = self.commands[name]["weight"] + (bean_total * 0.1)  # WEIGHT_FACTOR = 0.1
            scores[name] = score
        return scores

class CommandExecutor:
    """
    Executes slash commands and integrates with schema + registry + reinforcement.
    """
    def __init__(self, registry: CommandRegistry, schema_mgr: SchemaManager,
                 schema_updater: SchemaAutoUpdater, beans: BeanCounter,
                 dataset_mgr: DatasetManager, rag: "RAGCache",
                 settings: Settings, plugins: "PluginManager",
                 core_ref: "AgentCore") -> None:
        self.registry = registry
        self.schema_mgr = schema_mgr
        self.schema_updater = schema_updater
        self.beans = beans
        self.dataset_mgr = dataset_mgr
        self.rag = rag
        self.settings = settings
        self.plugins = plugins
        self.core_ref = core_ref

    @staticmethod
    def _strip_quotes(s: str) -> str:
        s = (s or "").strip()
        if len(s) >= 2 and ((s[0] == s[-1] == "'") or (s[0] == s[-1] == '"')):
            return s[1:-1]
        return s

    def _add_schema_command_value(self, schema: Dict[str, Any], cmd: str, text: str) -> None:
        cmds = dict(schema.get("commands") or {})
        arr = list(cmds.get(cmd, []))
        if text and text not in arr:
            arr.append(text)
        cmds[cmd] = arr
        schema["commands"] = cmds

    def execute(self, command_line: str) -> str:
        cmd, args = self._parse(command_line)
        if not cmd:
            return "No command provided."
        try:
            self.registry.set_weight(cmd, self.registry.get_weight(cmd) + 1)
        except Exception:
            pass
        if self.registry.is_locked(cmd):
            return f"Command '{cmd}' is locked."
        try:
            if cmd == "/remember":        return self._remember(args)
            if cmd == "/inject":          return self._inject(args)
            if cmd == "/rewrite":         return self._rewrite(args)
            if cmd == "/reject":          return self._reject(args)
            if cmd == "/auto":            return self._auto(args)
            if cmd == "/ignore":          return self._ignore(args)
            if cmd == "/opposite":        return self._opposite(args)
            if cmd == "/delete":          return self._delete(args)
            if cmd == "/applylora":       return self._applylora(args)
            if cmd == "/patchtokenizer":  return self._patchtokenizer(args)
            if cmd == "/datasetfromtext": return self._datasetfromtext(args)
            if cmd == "/show":            return self._show(args)
            if cmd == "/action":          return self._action(args)
            if cmd == "/trait":           return self._trait(args)
            if cmd == "/dataset":         return self._dataset(args)
            if cmd == "/search":          return self._search(args)
            if cmd == "/embeddings":      return self._embeddings(args)
            if cmd == "/schema":          return self._schema(args)
            if cmd == "/tts":             return self._tts(args)
            if cmd == "/plugin":          return self._plugin(args)
            if cmd == "/feedback":        return self._feedback(args)
            if cmd == "/lock":            return self._lock(args)
            if cmd == "/commands":        return self._commands(args)
            # C-8
            if cmd == "/enterroom":       return self._enterroom(args)
            if cmd == "/move":            return self._move(args)
            return f"Command '{cmd}' executed (no-op)."
        finally:
            # Increment reinforcement count for this command
            try:
                self.beans.increment(f"cmd_{cmd}", 1)
            except Exception:
                pass
            # Update command weight based on usage reinforcement
            try:
                cnt = self.beans.counts.get(f"cmd_{cmd}", 0)
                self.registry.set_weight(cmd, cnt)
            except Exception:
                pass

    def _parse(self, line: str) -> Tuple[str, str]:
        line = (line or "").strip()
        if not line.startswith("/"):
            return "", ""
        parts = line.split(maxsplit=1)
        cmd = parts[0].strip()
        rest = parts[1] if len(parts) > 1 else ""
        if cmd.startswith("/action_"): cmd = "/action"
        if cmd.startswith("/trait_"):  cmd = "/trait"
        return cmd, rest

    # Core handlers
    def _remember(self, args: str) -> str:
        trait = self._strip_quotes(args) or "remembered"
        schema = self.schema_mgr.load_schema(self.schema_updater.persona, self.schema_updater.set_name)
        overlay = dict(schema.get("dynamic_overlay", {}))
        traits = list(overlay.get("added_traits", []))
        if trait not in traits:
            traits.append(trait)
        overlay["added_traits"] = traits
        schema["dynamic_overlay"] = overlay
        self._add_schema_command_value(schema, "/remember", trait)
        self.schema_mgr.save_schema(self.schema_updater.persona, self.schema_updater.set_name, schema)
        return f"Remembered: {trait}"

    def _inject(self, args: str) -> str:
        note = self._strip_quotes(args) or "injected-change"
        schema = self.schema_mgr.load_schema(self.schema_updater.persona, self.schema_updater.set_name)
        st = list(schema.get("self_talk", []))
        if note not in st:
            st.append(note)
        schema["self_talk"] = st
        self._add_schema_command_value(schema, "/inject", note)
        self.schema_mgr.save_schema(self.schema_updater.persona, self.schema_updater.set_name, schema)
        return f"Injected: {note}"

    def _rewrite(self, args: str) -> str:
        phrase = self._strip_quotes(args)
        schema = self.schema_mgr.load_schema(self.schema_updater.persona, self.schema_updater.set_name)
        rp = list(schema.get("rewrite_prompts", []))
        if phrase and phrase not in rp:
            rp.append(phrase)
        schema["rewrite_prompts"] = rp
        if phrase:
            self._add_schema_command_value(schema, "/rewrite", phrase)
        self.schema_mgr.save_schema(self.schema_updater.persona, self.schema_updater.set_name, schema)
        return "Rewrite behavior updated."

    def _reject(self, args: str) -> str:
        text = self._strip_quotes(args) or "rejected"
        schema = self.schema_mgr.load_schema(self.schema_updater.persona, self.schema_updater.set_name)
        dislikes = list(schema.get("dislikes", []))
        if text not in dislikes:
            dislikes.append(text)
        schema["dislikes"] = dislikes
        self._add_schema_command_value(schema, "/reject", text)
        self.beans.increment(f"rej_{abs(hash(text))%10007}", -1)
        self.schema_mgr.save_schema(self.schema_updater.persona, self.schema_updater.set_name, schema)
        return f"Rejected: {text}"

    def _auto(self, args: str) -> str:
        text = self._strip_quotes(args) or "auto"
        schema = self.schema_mgr.load_schema(self.schema_updater.persona, self.schema_updater.set_name)
        events = list(schema.get("events", []))
        mark = f"AUTO: {text}"
        if mark not in events:
            events.append(mark)
        schema["events"] = events
        self._add_schema_command_value(schema, "/auto", text)
        self.schema_mgr.save_schema(self.schema_updater.persona, self.schema_updater.set_name, schema)
        return f"Auto behavior noted: {text}"

    def _ignore(self, args: str) -> str:
        text = self._strip_quotes(args) or "ignore"
        schema = self.schema_mgr.load_schema(self.schema_updater.persona, self.schema_updater.set_name)
        tone = dict(schema.get("tone_rules", {}))
        avoid = list(tone.get("avoid", []))
        if text not in avoid:
            avoid.append(text)
        tone["avoid"] = avoid
        schema["tone_rules"] = tone
        dislikes = list(schema.get("dislikes", []))
        if text not in dislikes:
            dislikes.append(text)
        schema["dislikes"] = dislikes
        self._add_schema_command_value(schema, "/ignore", text)
        self.schema_mgr.save_schema(self.schema_updater.persona, self.schema_updater.set_name, schema)
        return f"Ignoring: {text}"

    def _opposite(self, args: str) -> str:
        text = self._strip_quotes(args) or "opposite"
        schema = self.schema_mgr.load_schema(self.schema_updater.persona, self.schema_updater.set_name)
        tone = dict(schema.get("tone_rules", {}))
        opp = list(tone.get("opposites", []))
        if text not in opp:
            opp.append(text)
        tone["opposites"] = opp
        schema["tone_rules"] = tone
        self._add_schema_command_value(schema, "/opposite", text)
        rps = list(schema.get("rewrite_prompts", []))
        guide = f"Prefer the opposite of: {text}"
        if guide not in rps:
            rps.append(guide)
        schema["rewrite_prompts"] = rps
        self.schema_mgr.save_schema(self.schema_updater.persona, self.schema_updater.set_name, schema)
        return f"Will prefer the opposite of: {text}"

    def _delete(self, args: str) -> str:
        text = self._strip_quotes(args) or "delete"
        schema = self.schema_mgr.load_schema(self.schema_updater.persona, self.schema_updater.set_name)
        overlay = dict(schema.get("dynamic_overlay", {}))
        deletions = list(overlay.get("delete_targets", []))
        if text not in deletions:
            deletions.append(text)
        overlay["delete_targets"] = deletions
        schema["dynamic_overlay"] = overlay
        self._add_schema_command_value(schema, "/delete", text)
        self.schema_mgr.save_schema(self.schema_updater.persona, self.schema_updater.set_name, schema)
        return f"Marked for deletion: {text}"

    def _show(self, args: str) -> str:
        key = (args or "").strip().lower()
        if key == "facts":
            tops = sorted(self.beans.counts.items(), key=lambda kv: kv[1], reverse=True)[:10]
            if not tops:
                return "No facts yet."
            return "Top facts:\n" + "\n".join([f"• {k}: {v}" for k, v in tops])
        return "Unknown /show argument. Try '/show facts'."

    def _action(self, args: str) -> str:
        action = self._strip_quotes(args) or "action"
        schema = self.schema_mgr.load_schema(self.schema_updater.persona, self.schema_updater.set_name)
        actions = list(schema.get("actions", []))
        if action not in actions:
            actions.append(action)
        schema["actions"] = actions
        self.schema_mgr.save_schema(self.schema_updater.persona, self.schema_updater.set_name, schema)
        return f"Action added: {action}"

    def _trait(self, args: str) -> str:
        trait = self._strip_quotes(args) or "trait"
        schema = self.schema_mgr.load_schema(self.schema_updater.persona, self.schema_updater.set_name)
        overlay = dict(schema.get("dynamic_overlay", {}))
        traits = list(overlay.get("added_traits", []))
        if trait not in traits:
            traits.append(trait)
        overlay["added_traits"] = traits
        schema["dynamic_overlay"] = overlay
        self.schema_mgr.save_schema(self.schema_updater.persona, self.schema_updater.set_name, schema)
        return f"Trait added: {trait}"

    # Data/system
    def _dataset(self, args: str) -> str:
        parts = args.split()
        if not parts:
            return "Usage: /dataset add|delete|toggle|list ..."
        sub = parts[0].lower()
        try:
            if sub == "add" and len(parts) >= 3:
                name = parts[1]
                path = " ".join(parts[2:])
                self.dataset_mgr.add_dataset(name, path)
                self.rag.clear_memory()
                return f"Dataset '{name}' updated with file '{path}'."
            if sub == "delete" and len(parts) == 2:
                name = parts[1]
                self.dataset_mgr.delete_dataset(name)
                self.rag.clear_memory()
                return f"Dataset '{name}' deleted."
            if sub == "toggle" and len(parts) == 3:
                name = parts[1]
                on = parts[2].lower() in {"on", "true", "1", "enable", "enabled"}
                self.dataset_mgr.toggle_active(name, on)
                return f"Dataset '{name}' set to {'active' if on else 'inactive'}."
            if sub == "list":
                items = self.dataset_mgr.entries
                if not items:
                    return "No datasets."
                return "Datasets:\n" + "\n".join([f"• {n} [{'ON' if e.active else 'off'}]" for n, e in sorted(items.items())])
        except Exception as e:
            return f"Dataset error: {e}"
        return "Usage: /dataset add <name> <path> | delete <name> | toggle <name> on|off | list"

    def _search(self, args: str) -> str:
        q = args.strip()
        if not q:
            return "Usage: /search <query>"
        packs: List[Tuple[DatasetManager, List[DatasetEntry]]] = []
        packs.append((self.dataset_mgr, self.dataset_mgr.get_active_datasets()))
        shared = self.schema_mgr.get_shared_datasets(self.schema_updater.persona, self.schema_updater.set_name)
        if shared:
            owners: Dict[Tuple[str, str], List[DatasetEntry]] = {}
            for e in shared:
                try:
                    rel = os.path.relpath(e.path, self.dataset_mgr.base_dir).replace("\\", "/")
                    parts = rel.split("/")
                    idx = parts.index("profiles")
                    other_persona = parts[idx+1]
                    other_set = parts[idx+2]
                except Exception:
                    continue
                owners.setdefault((other_persona, other_set), []).append(e)
            for key, ents in owners.items():
                p, s = key
                packs.append((DatasetManager(self.base_dir, p, s), ents))
        hits = self.rag.search_all(packs, q, per_ds_k=4, limit=10)
        if not hits:
            return "No results."
        lines = []
        for chunk, score, ds, prov in hits:
            lines.append(f"[{ds}] {os.path.basename(prov)} (score={score:.3f})\n{chunk[:300].strip()}...")
        return "\n\n".join(lines)

    def _embeddings(self, args: str) -> str:
        sub = (args or "").strip().lower()
        if sub == "clear":
            n = self.rag.clear_disk()
            self.rag.clear_memory()
            return f"Cleared {n} embedding cache files."
        return "Usage: /embeddings clear"

    def _schema(self, args: str) -> str:
        parts = args.split()
        if not parts:
            return "Usage: /schema set <persona> <set> | awareness on|off | active"
        sub = parts[0].lower()
        if sub == "set" and len(parts) == 3:
            persona, set_name = parts[1].lower(), parts[2]
            if persona not in self.schema_mgr.personas:
                return f"Unknown persona '{persona}'"
            if set_name not in self.schema_mgr.get_set_list(persona):
                os.makedirs(os.path.join(self.schema_mgr.schemas_dir, persona, "sets", set_name), exist_ok=True)
                sch = self.schema_mgr.load_schema(persona, "default")
                self.schema_mgr.save_schema(persona, set_name, sch)
            active = dict(self.schema_mgr.active_schemas)
            active[persona] = set_name
            self.schema_mgr.save_active_schemas(active)
            self.core_ref.switch_persona_set(persona if persona == self.core_ref.persona else None,
                                             set_name if persona == self.core_ref.persona else None)
            return f"Active schema set: {persona}/{set_name}"
        if sub == "awareness" and len(parts) == 2:
            on = parts[1].lower() in {"on", "true", "1", "enable", "enabled"}
            sch = self.schema_mgr.load_schema(self.schema_updater.persona, self.schema_updater.set_name)
            flags = dict(sch.get("flags") or {})
            flags["semantic_awareness"] = bool(on)
            sch["flags"] = flags
            sch["semantic_awareness_enabled"] = bool(on)
            self.schema_mgr.save_schema(self.schema_updater.persona, self.schema_updater.set_name, sch)
            return f"Semantic awareness {'enabled' if on else 'disabled'} for {self.schema_updater.persona}/{self.schema_updater.set_name}"
        if sub == "active":
            act = self.schema_mgr.active_schemas
            return "Active schemas:\n" + "\n".join([f"• {p}: {s}" for p, s in act.items()])
        return "Usage: /schema set <persona> <set> | awareness on|off | active"

    def _tts(self, args: str) -> str:
        parts = args.split()
        if not parts:
            return "Usage: /tts on|off | volume <0-100>"
        sub = parts[0].lower()
        if sub in {"on", "off"}:
            flag = sub == "on"
            self.settings.monologue_tts_enabled = flag
            self.settings.save()
            return f"TTS {'enabled' if flag else 'disabled'}."
        if sub == "volume" and len(parts) == 2:
            try:
                v = int(parts[1]); v = max(0, min(100, v))
                self.settings.monologue_volume = v
                self.settings.save()
                if self.core_ref.tts_mgr:
                    self.core_ref.tts_mgr.set_volume(v)
                return f"TTS volume set to {v}."
            except Exception:
                return "Volume must be integer 0-100."
        return "Usage: /tts on|off | volume <0-100>"

    def _plugin(self, args: str) -> str:
        parts = args.split()
        if not parts:
            return "Usage: /plugin enable|disable|list ..."
        sub = parts[0].lower()
        if sub == "list":
            metas = self.plugins.list_plugins()
            if not metas:
                return "No plugins found."
            lines = []
            for m in metas:
                missing = f" (missing: {','.join(m.missing_dependencies)})" if m.missing_dependencies else ""
                lines.append(f"• {m.name} v{m.version or '?'} [{'ON' if m.enabled else 'off'}]{missing}")
            return "\n".join(lines)
        if sub in {"enable", "disable"} and len(parts) == 2:
            name = parts[1]
            flag = sub == "enable"
            self.plugins.enable_plugin(name, flag)
            return f"Plugin '{name}' {'enabled' if flag else 'disabled'}."
        return "Usage: /plugin enable <name> | disable <name> | list"

    def _feedback(self, args: str) -> str:
        parts = args.split()
        if not parts:
            return "Usage: /feedback stats | export <path>"
        sub = parts[0].lower()
        if sub == "stats":
            pos, neg = self.core_ref.feedback_db.get_counts()
            return f"Feedback: {pos} 👍  /  {neg} 👎"
        if sub == "export" and len(parts) >= 2:
            out = " ".join(parts[1:])
            n = self.core_ref.feedback_db.export_jsonl(out)
            return f"Exported {n} feedback records to {out}."
        return "Usage: /feedback stats | export <path>"

    def _lock(self, args: str) -> str:
        parts = args.split()
        if len(parts) != 2:
            return "Usage: /lock <cmd> on|off"
        cmd, state = parts
        if cmd not in self.registry.commands:
            return f"Unknown command '{cmd}'"
        self.registry.toggle_lock(cmd, state.lower() in {"on", "true", "1"})
        return f"Command '{cmd}' lock set to {self.registry.is_locked(cmd)}."

    def _commands(self, args: str) -> str:
        if args.strip().lower() == "list":
            items = []
            for c in self.registry.list_commands():
                items.append(f"• {c} (weight={self.registry.get_weight(c)}, locked={self.registry.is_locked(c)})")
            return "\n".join(items) if items else "No commands."
        return "Usage: /commands list"

    def _enterroom(self, args: str) -> str:
        # Stub for spatial room
        return "Entered room."

    def _move(self, args: str) -> str:
        # Stub for spatial room
        return "Moved."

# ──────────────────────────────────────────────────────────────────────────────
# Plugin system
# ──────────────────────────────────────────────────────────────────────────────
class PluginMeta:
    def __init__(self, name: str, path: str) -> None:
        self.name = name
        self.path = path
        self.enabled: bool = False
        self.module: Optional[Any] = None
        self.widget: Optional[Any] = None
        self.version: Optional[str] = None
        self.entry_point: Optional[str] = None
        self.dependencies: List[str] = []
        self.default_enabled: bool = False
        self.missing_dependencies: List[str] = []
        self._parse_manifest()

    def _parse_manifest(self) -> None:
        manifest_path = os.path.join(self.path, "manifest.json")
        if not os.path.isfile(manifest_path):
            return
        try:
            with open(manifest_path, "r", encoding="utf-8") as f:
                data = json.load(f)
            self.version = data.get("version")
            self.entry_point = data.get("entry_point") or None
            deps = data.get("dependencies") or []
            if isinstance(deps, list):
                self.dependencies = [str(d) for d in deps if isinstance(d, str)]
            self.default_enabled = bool(data.get("default_enabled", False))
        except Exception as e:
            logger.error("[Plugin:%s] manifest error: %s", self.name, e)
            return
        for dep in self.dependencies:
            try:
                __import__(dep.replace('-', '_'))
            except Exception:
                self.missing_dependencies.append(dep)

    def load_module(self) -> None:
        if self.module is not None or self.missing_dependencies:
            return
        spec = None
        if self.entry_point:
            spec = self.entry_point if "." in self.entry_point else f"plugins.{self.entry_point}"
        else:
            spec = f"plugins.{self.name}"
        try:
            import importlib
            self.module = importlib.import_module(spec)
        except Exception as e:
            logger.error("[Plugin:%s] import error: %s", self.name, e)
            self.module = None

    def start(self, host: "PluginManager") -> None:
        if self.enabled:
            return
        self.load_module()
        if self.module is None:
            return
        try:
            if hasattr(self.module, "start"):
                self.widget = self.module.start(host)  # type: ignore
            self.enabled = True
        except Exception as e:
            logger.error("[Plugin:%s] start error: %s", self.name, e)
            self.enabled = False

    def stop(self) -> None:
        if not self.enabled or self.module is None:
            return
        try:
            if hasattr(self.module, "stop"):
                self.module.stop()  # type: ignore
        except Exception as e:
            logger.error("[Plugin:%s] stop error: %s", self.name, e)
        self.widget = None
        self.enabled = False

class PluginManager(QtCore.QObject):
    eventReceived = QtCore.pyqtSignal(str, dict)  # sender, envelope

    def __init__(self, base_dir: str, settings: Settings) -> None:
        super().__init__()
        self.base_dir = base_dir
        self.settings = settings
        self.plugins_dir = os.path.join(self.base_dir, "plugins")
        os.makedirs(self.plugins_dir, exist_ok=True)
        self._plugins: Dict[str, PluginMeta] = {}
        self.discover_plugins()

    def discover_plugins(self) -> None:
        self._plugins.clear()
        for entry in os.scandir(self.plugins_dir):
            if entry.is_dir():
                meta = PluginMeta(entry.name, entry.path)
                self._plugins[entry.name] = meta
        for name, meta in self._plugins.items():
            if name in self.settings.enabled_plugins or (not self.settings.enabled_plugins and meta.default_enabled):
                meta.enabled = True
                meta.start(self)

    def list_plugins(self) -> List[PluginMeta]:
        return list(self._plugins.values())

    def enable_plugin(self, name: str, flag: bool) -> None:
        meta = self._plugins.get(name)
        if not meta:
            return
        if flag and not meta.enabled:
            meta.start(self)
            if name not in self.settings.enabled_plugins:
                self.settings.enabled_plugins.append(name)
                self.settings.save()
        elif not flag and meta.enabled:
            meta.stop()
            if name in self.settings.enabled_plugins:
                self.settings.enabled_plugins.remove(name)
                self.settings.save()

    def rescan(self) -> None:
        self.discover_plugins()

    def broadcast(self, message: Any) -> None:
        envelope = message if (isinstance(message, dict) and "type" in message) else {"type": "command", "data": message}
        for meta in self._plugins.values():
            if not (meta.enabled and meta.module):
                continue
            try:
                if hasattr(meta.module, "on_command"):
                    try:
                        meta.module.on_command(envelope)  # type: ignore
                    except TypeError:
                        meta.module.on_command(envelope.get("data"))  # type: ignore
            except Exception as e:
                logger.error("[Plugin:%s] on_command error: %s", meta.name, e)

    def emit_event(self, sender: str, type: str, payload: Any) -> None:
        self.eventReceived.emit(sender, {"sender": sender, "type": type, "data": payload})

    def stop_all(self) -> None:
        for meta in self._plugins.values():
            try:
                meta.stop()
            except Exception:
                pass

# ──────────────────────────────────────────────────────────────────────────────
# Schema evolver using feedback (frequency + votes)
# ──────────────────────────────────────────────────────────────────────────────
class SchemaEvolver:
    def __init__(self, mgr: SchemaManager, feedback_db: SemanticFeedbackDB, memory_state: Dict[str, Any]) -> None:
        self.mgr = mgr
        self.feedback_db = feedback_db
        self.memory_state = memory_state
        self._protected = self.mgr._load_control_schema()
        self._last_success_ts = 0.0

    def update_schema(self, persona: str, set_name: str, history: List[Tuple[str, str]]) -> bool:
        try:
            tokens: List[str] = []
            for role, content in history[-12:]:
                tokens.extend([w.lower() for w in re.findall(r"\b\w+\b", content or "") if len(w) > 3])
            word_freq = Counter(tokens)
            pos_count, neg_count = self.feedback_db.get_counts()

            if (pos_count + neg_count) < 5 or pos_count <= neg_count or not word_freq:
                return False

            patch: Dict[str, Any] = {}
            schema = self.mgr.load_schema(persona, set_name)
            tone_rules = dict(schema.get("tone_rules", {}))
            avoid_words = set(tone_rules.get("avoid", []))
            top_words = [w for w, _ in word_freq.most_common(5) if w not in avoid_words]
            if top_words:
                tone_rules["preferred_words"] = top_words[:3]
                patch["tone_rules"] = tone_rules

            if patch and all(k not in self._protected for k in patch.keys()):
                schema.update(patch)
                self.mgr.save_schema(persona, set_name, schema)
                self._last_success_ts = time.time()
                return True
        except Exception as e:
            logger.error("[SchemaEvolver] error: %s", e)
        return False

# ──────────────────────────────────────────────────────────────────────────────
# FathomKernel self-rewriter (C-9)
# ──────────────────────────────────────────────────────────────────────────────
class FathomKernel:
    def __init__(self, base_dir: str) -> None:
        self.base_dir = base_dir

    def snapshot_codebase(self) -> Dict[str, str]:
        code = {}
        for root, _, files in os.walk(self.base_dir):
            for fn in files:
                if fn.endswith(".py"):
                    p = os.path.join(root, fn)
                    with open(p, "r", encoding="utf-8") as f:
                        code[p] = f.read()
        return code

    def lint_and_patch(self) -> None:
        # Use ruff for linting
        try:
            subprocess.run(["ruff", "check", "--fix", self.base_dir], check=False)
        except Exception:
            pass
        # For patch, stub: call ollama to rewrite
        pass

# ──────────────────────────────────────────────────────────────────────────────
# Threaded model worker
# ──────────────────────────────────────────────────────────────────────────────
class ModelWorker(QtCore.QThread):
    finished = QtCore.pyqtSignal(str)
    def __init__(self, model: str, prompt: str, parent: Optional[QtCore.QObject] = None) -> None:
        super().__init__(parent)
        self.model = model
        self.prompt = prompt

    def run(self) -> None:
        try:
            parent = self.parent()
            if parent and hasattr(parent, "_query_model"):
                result = parent._query_model(self.model, self.prompt)  # type: ignore
            else:
                result = ""
            self.finished.emit(result)
        except Exception as e:
            self.finished.emit(f"Error: {e}")
        finally:
            try:
                self.deleteLater()
            except Exception:
                pass

# ──────────────────────────────────────────────────────────────────────────────
# Orchestrator
# ──────────────────────────────────────────────────────────────────────────────
class AgentCore(QtCore.QObject):
    """
    Binds together all components for headless or GUI use.
    """
    def __init__(self, base_dir: str, persona: str = "zira", set_name: Optional[str] = None) -> None:
        super().__init__()
        self.base_dir = base_dir
        self.schema_mgr = SchemaManager(base_dir)
        self.persona = persona
        if set_name is None:
            set_name = self.schema_mgr.active_schemas.get(persona, "default")
        self.set_name = set_name

        self.settings = Settings(base_dir)
        ensure_models_present()

        self.operator_mgr = OperatorManager(base_dir)
        self.dataset_mgr = DatasetManager(base_dir, self.persona, self.set_name)
        self.tts_mgr = TTSManager(default_volume=self.settings.monologue_volume)
        self.audio_recorder = AudioRecorder()
        self.google_listener = GoogleListener()
        self.conversation_db = ConversationDB(conv_db_path(base_dir, self.persona, self.set_name))
        self.feedback_db = SemanticFeedbackDB(feedback_db_path(base_dir, self.persona, self.set_name), base_dir, self.persona, self.set_name)
        self.beans = self.feedback_db.beans
        self.reinforcement_log = ReinforcementStore(base_dir)

        self.context_monitor = ContextMonitor(depth=self.settings.context_depth)
        self.schema_auto_updater = SchemaAutoUpdater(self.schema_mgr, self.persona, self.set_name)
        self.schema_evolver = SchemaEvolver(self.schema_mgr, self.feedback_db, memory_state={})

        self.command_registry = CommandRegistry(base_dir, self.persona, self.set_name)
        try:
            sch = self.schema_mgr.load_schema(self.persona, self.set_name)
            self.command_registry.register_from_schema(sch)
        except Exception:
            pass

        self.plugins = PluginManager(base_dir, self.settings)

        if SentenceTransformer and np is not None:
            try:
                self.embed_model = SentenceTransformer("all-MiniLM-L6-v2")
                embed_name = "MiniLM"
            except Exception:
                self.embed_model = None
                embed_name = "none"
        else:
            self.embed_model = None
            embed_name = "none"
        self.rag_cache = RAGCache(self.embed_model, embed_name, self.dataset_mgr.datasets_dir)

        self.command_executor = CommandExecutor(
            self.command_registry, self.schema_mgr, self.schema_auto_updater, self.beans,
            self.dataset_mgr, self.rag_cache, self.settings, self.plugins, self
        )

        self.fathom_kernel = FathomKernel(base_dir)

        self._idle_timer = QtCore.QTimer()
        self._idle_timer.timeout.connect(self._on_idle)
        self._idle_timer.start(86400000)  # nightly

        try:
            self.schema_mgr.schemaChanged.connect(self._on_schema_changed)
        except Exception:
            pass

    def _on_idle(self) -> None:
        self.fathom_kernel.lint_and_patch()

    def _on_schema_changed(self, persona: str, set_name: str) -> None:
        if persona == self.persona and set_name == self.set_name:
            self.dataset_mgr = DatasetManager(self.base_dir, self.persona, self.set_name)
            self.rag_cache.datasets_root = self.dataset_mgr.datasets_dir
            try:
                sch = self.schema_mgr.load_schema(self.persona, self.set_name)
                self.command_registry.register_from_schema(sch)
            except Exception:
                pass

    def process_user_message(self, message: str, tts: bool = False) -> str:
        self.conversation_db.save_message("user", message)
        if message.strip().startswith("/"):
            response = self.run_command(message.strip())
        else:
            self.context_monitor.add_message("user", message)
            if self.settings.auto_schema_enabled:
                analysis = self.context_monitor.analyze()
                self.schema_auto_updater.update_with_context(analysis)
            response = "Message processed."
        self.conversation_db.save_message("zira", response)
        if tts and self.settings.monologue_tts_enabled and self.tts_mgr is not None:
            self.tts_mgr.enqueue(response)
        return response

    def run_command(self, command_line: str,
                    persona: Optional[str] = None,
                    set_name: Optional[str] = None) -> str:
        try:
            self.plugins.broadcast({"type": "slash", "data": command_line})
        except Exception:
            pass

        if not persona and not set_name:
            try:
                sch = self.schema_mgr.load_schema(self.persona, self.set_name)
                self.command_registry.register_from_schema(sch)
            except Exception:
                pass
            try:
                return self.command_executor.execute(command_line)
            except Exception as e:
                return f"Command error: {e}"

        target_persona = (persona or self.persona).lower()
        target_set = set_name or self.set_name

        tmp_registry = CommandRegistry(self.base_dir, target_persona, target_set)
        try:
            sch = self.schema_mgr.load_schema(target_persona, target_set)
            tmp_registry.register_from_schema(sch)
        except Exception:
            pass
        tmp_beans = BeanCounter(self.base_dir, target_persona, target_set)
        tmp_datasets = DatasetManager(self.base_dir, target_persona, target_set)
        tmp_updater = SchemaAutoUpdater(self.schema_mgr, target_persona, target_set)
        tmp_rag = RAGCache(self.embed_model, getattr(self.rag_cache, "model_name", "MiniLM"), tmp_datasets.datasets_dir)

        tmp_exec = CommandExecutor(
            tmp_registry, self.schema_mgr, tmp_updater, tmp_beans,
            tmp_datasets, tmp_rag, self.settings, self.plugins, self
        )
        try:
            return tmp_exec.execute(command_line)
        except Exception as e:
            return f"Command error: {e}"

    def switch_persona_set(self, persona: Optional[str] = None, set_name: Optional[str] = None) -> None:
        if persona:
            self.persona = persona
        if set_name:
            self.set_name = set_name
        self.dataset_mgr = DatasetManager(self.base_dir, self.persona, self.set_name)
        self.conversation_db = ConversationDB(conv_db_path(self.base_dir, self.persona, self.set_name))
        self.feedback_db = SemanticFeedbackDB(feedback_db_path(self.base_dir, self.persona, self.set_name), self.base_dir, self.persona, self.set_name)
        self.beans = self.feedback_db.beans
        self.schema_auto_updater = SchemaAutoUpdater(self.schema_mgr, self.persona, self.set_name)
        self.schema_evolver = SchemaEvolver(self.schema_mgr, self.feedback_db, memory_state={})
        self.command_registry = CommandRegistry(self.base_dir, self.persona, self.set_name)
        try:
            sch = self.schema_mgr.load_schema(self.persona, self.set_name)
            self.command_registry.register_from_schema(sch)
        except Exception:
            pass
        self.command_executor = CommandExecutor(
            self.command_registry, self.schema_mgr, self.schema_auto_updater, self.beans,
            self.dataset_mgr, self.rag_cache, self.settings, self.plugins, self
        )
        self.rag_cache.datasets_root = self.dataset_mgr.datasets_dir

        # U-9: Auto-stop STT on context switch
        self.google_listener.stop_listener()

    def rag_search(self, query_text: str, per_ds_k: int = 4, limit: int = 10,
                   include_shared: bool = True,
                   datasets: Optional[List[str]] = None) -> List[Tuple[str, float, str, str]]:
        current_entries = self.dataset_mgr.get_active_datasets()
        if datasets:
            ds_set = set(datasets)
            current_entries = [e for e in current_entries if e.name in ds_set]
        packs: List[Tuple[DatasetManager, List[DatasetEntry]]] = [(self.dataset_mgr, current_entries)]

        if include_shared and self.schema_mgr.is_semantic_on(self.persona, self.set_name):
            shared = self.schema_mgr.get_shared_datasets(self.persona, self.set_name)
            if datasets:
                ds_set = set(datasets)
                shared = [e for e in shared if e.name in ds_set]
            owners: Dict[Tuple[str, str], List[DatasetEntry]] = {}
            for e in shared:
                try:
                    rel = os.path.relpath(e.path, self.base_dir).replace("\\", "/")
                    parts = rel.split("/")
                    idx = parts.index("profiles")
                    other_persona = parts[idx+1]
                    other_set = parts[idx+2]
                except Exception:
                    continue
                owners.setdefault((other_persona, other_set), []).append(e)
            for key, ents in owners.items():
                p, s = key
                packs.append((DatasetManager(self.base_dir, p, s), ents))

        hits = self.rag_cache.search_all(packs, query_text, per_ds_k=per_ds_k, limit=limit*2)
        hits.sort(key=lambda x: x[1], reverse=True)
        return hits[:limit]

    def refresh_prompt_cache(self) -> None:
        self.rag_cache.clear_memory()

    def add_feedback(self, original: str, liked: bool, revised: Optional[str] = None) -> None:
        self.feedback_db.add_feedback(original, liked, revised)
        hist = self.conversation_db.fetch_history(limit=50)
        try:
            self.schema_evolver.update_schema(self.persona, self.set_name, hist)
        except Exception:
            pass

    def _query_model(self, model: str, prompt: str) -> str:
        try:
            result = subprocess.run(["ollama", "run", model], input=prompt.encode("utf-8"),
                                    stdout=subprocess.PIPE, stderr=subprocess.PIPE, timeout=120)
            if result.returncode == 0:
                return result.stdout.decode("utf-8", errors="ignore").strip()
            else:
                err = result.stderr.decode("utf-8", "ignore")
                logger.error("[ollama:%s] error: %s", model, err)
        except Exception as e:
            logger.error("[ollama:%s] exception: %s", model, e)
        return f"(fallback) {prompt}"

    def start_listener(self) -> None:
        self.google_listener.start()

    def stop_listener(self) -> None:
        self.google_listener.stop_listener()

    def close(self) -> None:
        try:
            self.plugins.stop_all()
        except Exception:
            pass
        try:
            self.conversation_db.close()
        except Exception:
            pass
        try:
            self.feedback_db.close()
        except Exception:
            pass
        try:
            if self.tts_mgr:
                self.tts_mgr.close()
        except Exception:
            pass
        try:
            if hasattr(self, "reinforcement_log") and self.reinforcement_log:
                self.reinforcement_log.close()
        except Exception:
            pass
        self.stop_listener()

# ──────────────────────────────────────────────────────────────────────────────
# CLI entrypoint (optional smoke test)
# ──────────────────────────────────────────────────────────────────────────────
if __name__ == "__main__":
    base = os.path.abspath(os.path.join(os.getcwd(), ".agent_state"))
    core = AgentCore(base)
    print("AgentCore ready. Try '/commands list', '/dataset list', '/search your query', '/tts on', or '/schema active'. Ctrl+C to exit.")
    try:
        while True:
            line = input("you> ").strip()
            if not line:
                continue
            if line.lower() in {"quit", "exit"}:
                break
            if line.startswith("/"):
                m = re.match(r"^/as\s+(\w+)\s+(\w+)\s+--\s+(.*)$", line)
                if m:
                    p, s, cmd = m.groups()
                    out = core.run_command(cmd, persona=p, set_name=s)
                else:
                    out = core.run_command(line)
            else:
                out = core.process_user_message(line, tts=False)
            print("zira>", out)
    except KeyboardInterrupt:
        pass
    finally:
        core.close()
```

agent_core.py
=================

Full, end-to-end core for an AI AI TTS Agent with:
- Settings & model bootstrap (Ollama)
- Robust plugin host (enable/disable/list, manifest validation, dependency checks)
- Conversation & feedback stores (with indices, exports)
- Persona schema management (with protected keys) and live signals
- Dataset registry + RAG embeddings cache & query (per persona/set, cross-profile sharing)
  * Multi-file datasets, cache invalidation, provenance
- Context monitor + schema auto-updates driven by directives & feedback (rate-limited)
- Command registry (weight/lock) + full command execution layer
- New commands: /reject, /auto, /ignore, /opposite, /delete, /rewrite (extended persistence)
- BeanCounter reinforcement + integration with feedback and command weights
- Speech I/O (TTS locked to Zira; STT via Sphinx when available) w/ volume control
- Threaded model worker wrapper (cancel-safe)
- Orchestrator (`AgentCore`) wiring everything together for headless/GUI
- CLI entrypoint for smoke tests

Notes
-----
• This module is UI-agnostic. Hook the provided Qt signals in your GUI (`agent_ui.py`).
• All directories are scoped under `base_dir`, with per-persona/per-set state in:
  base_dir/profiles/<persona>/<set>/
**Classes:** Settings, ConversationDB, BeanCounter, SemanticFeedbackDB, ReinforcementStore, SchemaManager, OperatorManager, TTSManager, AudioRecorder, GoogleListener, DatasetEntry, DatasetManager, RAGCache, ContextMonitor, SchemaAutoUpdater, CommandRegistry, CommandExecutor, PluginMeta, PluginManager, SchemaEvolver, FathomKernel, ModelWorker, AgentCore
**Functions:** _have_cli(bin_name), ensure_models_present(), prof_dir(base_dir, persona, set_name), prof_datasets_dir(base_dir, persona, set_name), prof_commands_path(base_dir, persona, set_name), prof_reinforcement_path(base_dir, persona, set_name), conv_db_path(base_dir, persona, set_name), feedback_db_path(base_dir, persona, set_name)


## Module `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\_burner_scripts\agent_store.py`

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
agent_store.py
==============

Thread-safe SQLite façade for the AI-TTS-Agent “v4” architecture.

Tables
------
schemas            : Current JSON blob per persona / set
schema_history     : Versioned diffs – for audits / rollback
commands           : Slash command registry (+weight, locked flag, category_id FK)
beans              : Reinforcement counts & last-updated timestamp
variants           : Prompt / phrase variants auto-generated by SchemaEngine
settings           : Arbitrary per-profile key / val
files              : Filesystem snapshot chunks (path, hash, chunk_idx, content)
spatial_positions  : XY grid positions of entities (bot, objects…)
visual_actions     : Logged avatar actions (textual justification)

Public API
----------
AgentStore(base_dir)    – opens or creates *agent_store.db* in that dir
begin_tx() / commit()   – manual transactions (context-manager also available)
CRUD helpers            – get_schema(), put_schema(), inc_bean(), etc.
migrate_from_files()    – one-shot importer for legacy JSON / sqlite state
ensure_db()             – convenience: open DB, auto-migrate if needed
"""

from __future__ import annotations

import contextlib
import hashlib
import json
import os
import sqlite3
import threading
import time
from typing import Any, Dict, Iterator, List, Optional, Tuple

###############################################################################
# CONSTANTS
###############################################################################

DB_VERSION = 4  # <- bump when schema changes

###############################################################################
# LOW-LEVEL:  connection pool  +  simple retry wrapper
###############################################################################


class _PooledConn:
    """Very small, single-writer / multi-reader pool – good enough for desktop."""

    def __init__(self, path: str) -> None:
        self._path = path
        self._lock = threading.RLock()
        self._pool: List[sqlite3.Connection] = []

    @contextlib.contextmanager
    def get(self) -> Iterator[sqlite3.Connection]:
        with self._lock:
            conn = self._pool.pop() if self._pool else sqlite3.connect(self._path, check_same_thread=False)
        try:
            yield conn
        finally:
            with self._lock:
                if len(self._pool) < 8:
                    self._pool.append(conn)
                else:
                    conn.close()


###############################################################################
# MAIN FACADE
###############################################################################


class AgentStore:
    """
    One instance per *base_dir*; thread-safe for GUI + background workers.
    """

    # ──────────────────────────── bootstrap ────────────────────────────────

    def __init__(self, base_dir: str) -> None:
        self.base_dir = base_dir
        self.db_path = os.path.join(base_dir, "agent_store.db")
        os.makedirs(base_dir, exist_ok=True)
        self._pool = _PooledConn(self.db_path)
        with self._pool.get() as c:
            self._apply_ddl(c)
            c.execute("PRAGMA journal_mode=WAL;")
            c.commit()

    # ------------------------------------------------------------------ DDL
    def _apply_ddl(self, c: sqlite3.Connection) -> None:
        """Create tables if they do not exist, then run migrations."""
        cur = c.cursor()
        cur.executescript(
            """
            PRAGMA foreign_keys = ON;

            CREATE TABLE IF NOT EXISTS meta (
              key TEXT PRIMARY KEY,
              value TEXT
            );

            CREATE TABLE IF NOT EXISTS schemas (
              persona TEXT NOT NULL,
              set_name TEXT NOT NULL,
              schema_json TEXT NOT NULL,
              updated REAL NOT NULL,
              PRIMARY KEY (persona, set_name)
            );

            CREATE TABLE IF NOT EXISTS schema_history (
              id INTEGER PRIMARY KEY AUTOINCREMENT,
              persona TEXT,
              set_name TEXT,
              schema_json TEXT,
              diff TEXT,
              updated REAL
            );

            CREATE TABLE IF NOT EXISTS commands (
              name TEXT PRIMARY KEY,
              weight INTEGER DEFAULT 0,
              locked INTEGER DEFAULT 0,
              category TEXT DEFAULT NULL
            );

            CREATE TABLE IF NOT EXISTS beans (
              subject TEXT PRIMARY KEY,
              count INTEGER DEFAULT 0,
              last_ts REAL
            );

            CREATE TABLE IF NOT EXISTS variants (
              id INTEGER PRIMARY KEY AUTOINCREMENT,
              persona TEXT,
              set_name TEXT,
              category TEXT,
              prompt TEXT
            );

            CREATE TABLE IF NOT EXISTS settings (
              key TEXT PRIMARY KEY,
              value TEXT
            );

            CREATE TABLE IF NOT EXISTS files (
              path TEXT,
              hash TEXT,
              chunk_idx INTEGER,
              size INTEGER,
              mtime REAL,
              content TEXT,
              PRIMARY KEY (path, chunk_idx)
            );

            CREATE TABLE IF NOT EXISTS spatial_positions (
              entity TEXT PRIMARY KEY,
              x INTEGER,
              y INTEGER,
              facing TEXT,
              color TEXT,
              ts REAL
            );

            CREATE TABLE IF NOT EXISTS visual_actions (
              id INTEGER PRIMARY KEY AUTOINCREMENT,
              ts REAL,
              action TEXT,
              location TEXT,
              justification TEXT
            );
            """
        )
        cur.execute("SELECT COALESCE((SELECT value FROM meta WHERE key='user_version'), 0)")
        ver = int(cur.fetchone()[0])
        if ver < DB_VERSION:
            # placeholder for future ALTERs
            cur.execute("REPLACE INTO meta(key,value) VALUES('user_version', ?)", (DB_VERSION,))
        c.commit()

    # ──────────────────────────── helpers ────────────────────────────────
    @contextlib.contextmanager
    def tx(self) -> Iterator[sqlite3.Connection]:
        """Context-manager for explicit multi-statement transaction."""
        with self._pool.get() as c:
            try:
                c.execute("BEGIN IMMEDIATE;")
                yield c
                c.commit()
            except Exception:
                c.rollback()
                raise

    def begin_tx(self) -> sqlite3.Connection:
        """Legacy style manual tx‐start (remember to commit!)."""
        c = self._pool.get().__enter__()  # type: ignore
        c.execute("BEGIN IMMEDIATE;")
        return c

    def commit(self, conn: sqlite3.Connection) -> None:  # noqa: D401
        conn.commit()
        self._pool.get().__exit__(None, None, None)  # type: ignore

    def rollback(self, conn: sqlite3.Connection) -> None:
        conn.rollback()
        self._pool.get().__exit__(None, None, None)  # type: ignore

    # ─────────────────────────── schemas ────────────────────────────────
    def get_schema(self, persona: str, set_name: str) -> Optional[Dict[str, Any]]:
        with self._pool.get() as c:
            cur = c.execute(
                "SELECT schema_json FROM schemas WHERE persona=? AND set_name=?", (persona, set_name)
            )
            row = cur.fetchone()
        return json.loads(row[0]) if row else None

    def put_schema(self, persona: str, set_name: str, schema: Dict[str, Any], diff: str = "") -> None:
        now = time.time()
        s_json = json.dumps(schema, ensure_ascii=False)
        with self.tx() as c:
            c.execute(
                "REPLACE INTO schemas(persona,set_name,schema_json,updated) VALUES(?,?,?,?)",
                (persona, set_name, s_json, now),
            )
            c.execute(
                "INSERT INTO schema_history(persona,set_name,schema_json,diff,updated) VALUES(?,?,?,?,?)",
                (persona, set_name, s_json, diff, now),
            )

    # ─────────────────────────── commands ──────────────────────────────
    def list_commands(self) -> List[Tuple[str, int, int, Optional[str]]]:
        with self._pool.get() as c:
            return list(c.execute("SELECT name,weight,locked,category FROM commands ORDER BY name"))

    def upsert_command(self, name: str, weight: int = 0, locked: bool = False, category: str | None = None) -> None:
        with self._pool.get() as c:
            c.execute(
                "REPLACE INTO commands(name,weight,locked,category) VALUES(?,?,?,?)",
                (name, weight, int(locked), category),
            )
            c.commit()

    # ─────────────────────────── beans ────────────────────────────────
    def inc_bean(self, subject: str, delta: int) -> None:
        now = time.time()
        with self.tx() as c:
            cur = c.execute("SELECT count FROM beans WHERE subject=?", (subject,))
            row = cur.fetchone()
            count = (row[0] if row else 0) + delta
            c.execute("REPLACE INTO beans(subject,count,last_ts) VALUES(?,?,?)", (subject, count, now))

    def get_bean(self, subject: str) -> int:
        with self._pool.get() as c:
            cur = c.execute("SELECT count FROM beans WHERE subject=?", (subject,))
            row = cur.fetchone()
        return row[0] if row else 0

    # ───────────────────────── snapshot (files) ───────────────────────
    def upsert_file_chunk(
        self,
        path: str,
        chunk_idx: int,
        content: str,
        size: int,
        mtime: float,
    ) -> None:
        h = hashlib.sha256(content.encode("utf-8", "ignore")).hexdigest()
        with self._pool.get() as c:
            c.execute(
                "REPLACE INTO files(path,hash,chunk_idx,size,mtime,content) VALUES(?,?,?,?,?,?)",
                (path, h, chunk_idx, size, mtime, content),
            )
            c.commit()

    # ───────────────────────── settings ───────────────────────────────
    def get_setting(self, key: str, default: Any = None) -> Any:
        with self._pool.get() as c:
            cur = c.execute("SELECT value FROM settings WHERE key=?", (key,))
            row = cur.fetchone()
        return json.loads(row[0]) if row else default

    def set_setting(self, key: str, value: Any) -> None:
        val = json.dumps(value)
        with self._pool.get() as c:
            c.execute("REPLACE INTO settings(key,value) VALUES(?,?)", (key, val))
            c.commit()

    # ───────────────────────── migration helper ───────────────────────
    def migrate_from_files(self) -> Dict[str, Any]:
        """
        Import legacy on-disk artefacts *once*.
        Returns a report dict useful for CLI printing.
        """
        report: Dict[str, Any] = {"schemas": 0, "commands": 0, "beans": 0}
        # ------- schemas -------
        legacy_dir = os.path.join(self.base_dir, "schemas")
        if os.path.isdir(legacy_dir):
            for persona in os.listdir(legacy_dir):
                sets_root = os.path.join(legacy_dir, persona, "sets")
                if not os.path.isdir(sets_root):
                    continue
                for set_name in os.listdir(sets_root):
                    sp = os.path.join(sets_root, set_name, "schema.json")
                    if not os.path.isfile(sp):
                        continue
                    with open(sp, "r", encoding="utf-8") as f:
                        schema_json = json.load(f)
                    self.put_schema(persona, set_name, schema_json, diff="initial import")
                    report["schemas"] += 1
        # ------- commands (old profiles) -------
        prof_dir = os.path.join(self.base_dir, "profiles")
        if os.path.isdir(prof_dir):
            for persona in os.listdir(prof_dir):
                for set_name in os.listdir(os.path.join(prof_dir, persona)):
                    cmd_path = os.path.join(prof_dir, persona, set_name, "commands.json")
                    if os.path.isfile(cmd_path):
                        with open(cmd_path, "r", encoding="utf-8") as f:
                            data = json.load(f).get("commands", {})
                        for name, meta in data.items():
                            self.upsert_command(name, meta.get("weight", 0), meta.get("locked", False))
                            report["commands"] += 1
        # ------- beans -------
        reinf_path = os.path.join(self.base_dir, "reinforcement.jsonl")
        if os.path.isfile(reinf_path):
            with open(reinf_path, "r", encoding="utf-8") as f:
                for line in f:
                    try:
                        evt = json.loads(line)
                        subj = evt.get("field")
                        self.inc_bean(subj, 1)
                        report["beans"] += 1
                    except Exception:
                        continue
        return report


###############################################################################
# MODULE-LEVEL convenience
###############################################################################


def ensure_db(base_dir: str) -> AgentStore:
    store = AgentStore(base_dir)
    with store._pool.get() as c:
        cur = c.execute("SELECT value FROM meta WHERE key='user_version'")
        ver = int(cur.fetchone()[0])
    if ver < DB_VERSION:
        print("[AgentStore] Running first-time migration…")
        rpt = store.migrate_from_files()
        print("[AgentStore]   imported:",
              f"{rpt['schemas']} schemas, {rpt['commands']} commands, {rpt['beans']} bean keys")
    return store


# ---------------------------------------------------------------------------#
if __name__ == "__main__":
    import argparse
    import pprint

    ap = argparse.ArgumentParser(description="Create / inspect agent_store.db")
    ap.add_argument("path", help="Base directory of AI-TTS-Agent")
    ap.add_argument("--migrate", action="store_true", help="Run legacy import")
    args = ap.parse_args()

    st = AgentStore(args.path)
    if args.migrate:
        print("Migrating legacy files…")
        pprint.pp(st.migrate_from_files())
    else:
        print("DB user_version =", st.get_setting("db_version", DB_VERSION))
        print("Schemas ->", len(st.list_commands()))
```

agent_store.py
==============

Thread-safe SQLite façade for the AI-TTS-Agent “v4” architecture.

Tables
------
schemas            : Current JSON blob per persona / set
schema_history     : Versioned diffs – for audits / rollback
commands           : Slash command registry (+weight, locked flag, category_id FK)
beans              : Reinforcement counts & last-updated timestamp
variants           : Prompt / phrase variants auto-generated by SchemaEngine
settings           : Arbitrary per-profile key / val
files              : Filesystem snapshot chunks (path, hash, chunk_idx, content)
spatial_positions  : XY grid positions of entities (bot, objects…)
visual_actions     : Logged avatar actions (textual justification)

Public API
----------
AgentStore(base_dir)    – opens or creates *agent_store.db* in that dir
begin_tx() / commit()   – manual transactions (context-manager also available)
CRUD helpers            – get_schema(), put_schema(), inc_bean(), etc.
migrate_from_files()    – one-shot importer for legacy JSON / sqlite state
ensure_db()             – convenience: open DB, auto-migrate if needed
**Classes:** _PooledConn, AgentStore
**Functions:** ensure_db(base_dir)


## Module `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\_burner_scripts\agent_ui.py`

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
agent_ui.py
============

PyQt5 UI for the AI TTS Agent (integrated with AgentCore).

Fixes & additions:
- Slash commands (/remember etc.) now apply to the currently selected persona+set.
- Per-set "Semantic Awareness" persisted (schema.flags.semantic_awareness).
- RAG only uses datasets listed in the current set's schema ("datasets": [...]).
- Schema tab: new Commands row (dropdown + input + Add to Command + New Command).

To launch: `python run_agent.py`
"""

from __future__ import annotations

import os
import json
import time
import re
import subprocess
import threading
from typing import Dict, List, Tuple, Optional

from PyQt5 import QtCore, QtGui, QtWidgets

# Optional spell checker
try:
    from spellchecker import SpellChecker  # type: ignore
except Exception:
    SpellChecker = None  # type: ignore
from PyQt5.QtCore import QSettings, QRunnable, QThreadPool
from functools import partial

# Optional deps
try:
    from sentence_transformers import SentenceTransformer  # type: ignore
except Exception:
    SentenceTransformer = None  # type: ignore
try:
    import numpy as np  # type: ignore
except Exception:
    np = None  # type: ignore
try:
    import sounddevice as sd  # type: ignore
except Exception:
    sd = None  # type: ignore

from agent_core import (
    AgentCore,
    ModelWorker,
)

ROLE_COLOURS: Dict[str, str] = {
    "user": "#FFF8E1",
    "zira": "#E3F2FD",
    "system": "#E0F7FA",
    "operator": "#EDE7F6",
}
NAME_COLOURS: Dict[str, str] = {
    "user": "#5D4037",
    "zira": "#0D47A1",
    "system": "#006064",
    "operator": "#4A148C",
}

# ---------------------------------------------------------------------------
# Spell highlighting for misspelled words
# ---------------------------------------------------------------------------
class _SpellHighlighter(QtGui.QSyntaxHighlighter):
    """
    Underlines misspelled words in red. Uses pyspellchecker if available.
    """
    def __init__(self, document: QtGui.QTextDocument) -> None:
        super().__init__(document)
        # instantiate spell checker only if available
        self._spell = SpellChecker() if SpellChecker else None
        self._format = QtGui.QTextCharFormat()
        self._format.setUnderlineStyle(QtGui.QTextCharFormat.SpellCheckUnderline)
        self._format.setUnderlineColor(QtCore.Qt.red)
        # simple cache to avoid recomputing spelling on common words
        self._cache: Dict[str, bool] = {}

    def highlightBlock(self, text: str) -> None:
        if not self._spell:
            return
        for match in re.finditer(r"[A-Za-z']{3,}", text):
            word = match.group(0).lower()
            bad = self._cache.get(word)
            if bad is None:
                bad = word not in self._spell
                # prune cache occasionally
                if len(self._cache) > 2048:
                    self._cache.clear()
                self._cache[word] = bad
            if bad:
                start, end = match.span()
                length = end - start
                self.setFormat(start, length, self._format)


class AppWindow(QtWidgets.QMainWindow):
    """Main application window for the AI TTS Agent."""

    rewrite_ready = QtCore.pyqtSignal(str)

    def __init__(self) -> None:
        super().__init__()
        self.setWindowTitle("AI TTS Agent v2")
        self.resize(1920, 1080)

        self.base_dir = os.path.dirname(os.path.abspath(__file__))
        self.core = AgentCore(self.base_dir, persona="zira", set_name="default")

        self.current_set: Dict[str, str] = dict(self.core.schema_mgr.active_schemas)
        self.active_persona: str = self.core.persona or "zira"

        self.isolated_history: List[Tuple[str, str]] = []
        self.self_talk_enabled: bool = False
        self._plugin_docks: Dict[str, QtWidgets.QDockWidget] = {}
        self._schema_save_timers: Dict[str, QtCore.QTimer] = {}

        self._idle_timer = QtCore.QTimer(self)
        self._idle_timer.setSingleShot(True)
        self._idle_timer.timeout.connect(self._handle_idle)

        self._restore_layout()
        self._build_ui()
        # build the slash command panel (custom dock)
        self._build_command_dock()
        self._connect_signals()

        try:
            self.core.audio_recorder.transcribed.connect(self._on_transcribed)
        except Exception:
            pass

        self._update_feedback_counts()
        self._bootstrap_conversation()
        self._reset_idle_timer()

        # populate initial slash command list
        try:
            self._populate_command_select()
        except Exception:
            pass

    # ────────────────────────── signals
    def _connect_signals(self) -> None:
        self.btn_send.clicked.connect(self.send_message)

        self.btn_record.clicked.connect(self.start_recording)
        self.btn_stop_rec.clicked.connect(self.stop_recording)

        self.voice_combo.currentTextChanged.connect(self._on_voice_changed)
        # update settings when a new model is selected
        self.model_combo.currentTextChanged.connect(self._on_model_changed)

        self.btn_play.clicked.connect(self._on_play)
        self.btn_stop_tts.clicked.connect(self._on_stop_tts)
        self.btn_replay.clicked.connect(self._on_replay)

        self.btn_like.clicked.connect(self._on_like)
        self.btn_dislike.clicked.connect(self._on_dislike)
        self.btn_manage_feedback.clicked.connect(self._on_manage_feedback)

        self.btn_refresh.clicked.connect(self._on_refresh_chat)
        self.btn_manage_datasets.clicked.connect(self._on_manage_datasets)
        self.btn_inner_monologue.clicked.connect(self._on_inner_monologue)
        self.btn_clear_rag.clicked.connect(self._on_clear_rag_cache)
        self.btn_model_manager.clicked.connect(self._on_show_model_manager)

        self.chk_semantic.toggled.connect(self._on_semantic_toggled)
        self.chk_isolated.toggled.connect(self._on_isolated_toggled)
        self.chk_self_talk.toggled.connect(lambda v: setattr(self, "self_talk_enabled", v))
        self.chk_auto_schema.toggled.connect(self._on_auto_schema_toggled)

        # connect Google STT checkbox
        try:
            self.chk_google_stt.toggled.connect(self._on_google_stt_toggled)
        except Exception:
            pass

        self.rewrite_ready.connect(self._apply_rewrite_result)

        # context menu for chat view to send selection to command input
        try:
            self.chat_view.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
            self.chat_view.customContextMenuRequested.connect(self._show_chat_context_menu)
        except Exception:
            pass
        # custom context menu for spell suggestions on input field
        try:
            self.input_edit.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
            self.input_edit.customContextMenuRequested.connect(self._show_input_context_menu)
        except Exception:
            pass

    # ────────────────────────── layout & lifecycle
    def _restore_layout(self) -> None:
        qsettings = QSettings("xAI", "AI_TTS_Agent")
        try:
            self.restoreGeometry(qsettings.value("geometry", b""))
            self.restoreState(qsettings.value("windowState", b""))
        except Exception:
            pass

    def closeEvent(self, event: QtGui.QCloseEvent) -> None:
        qsettings = QSettings("xAI", "AI_TTS_Agent")
        qsettings.setValue("geometry", self.saveGeometry())
        qsettings.setValue("windowState", self.saveState())
        try:
            self.core.close()
        except Exception:
            pass
        super().closeEvent(event)

    # ────────────────────────── UI build
    def _build_ui(self) -> None:
        self.setStyleSheet(
            """
            QWidget { background-color: #2e3a51; color: #e0e0e0; }
            QGroupBox { border: 1px solid #007acc; margin-top: 7px; }
            QGroupBox::title { subcontrol-origin: margin; left: 12px; padding: 0 4px; }
            QPushButton { background-color: #3c4a6b; color: white; border: 1px solid #007acc; padding: 5px; }
            QPushButton:disabled { background-color: #5a5a7a; color: #c0c0c0; border: 1px solid #555555; }
            QPlainTextEdit, QTextEdit { background-color: #1e2738; color: #e0e0e0; border: 1px solid #007acc; }
            QLineEdit { background-color: #1e2738; color: #e0e0e0; border: 1px solid #007acc; }
            QTabBar::tab { background: #3c4a6b; color: white; border: 1px solid #007acc; padding: 5px 10px; }
            QTabBar::tab:selected { background: #007acc; color: white; }
            QComboBox { background-color: #1e2738; color: #e0e0e0; border: 1px solid #007acc; padding: 3px; }
            QListWidget { background-color: #1e2738; color: #e0e0e0; border: 1px solid #007acc; }
            QCheckBox, QLabel { color: #e0e0e0; }
            """
        )
        self.setDockOptions(
            QtWidgets.QMainWindow.AllowTabbedDocks
            | QtWidgets.QMainWindow.AllowNestedDocks
            | QtWidgets.QMainWindow.AnimatedDocks
        )
        self.setTabPosition(QtCore.Qt.AllDockWidgetAreas, QtWidgets.QTabWidget.North)
        self.setDockNestingEnabled(True)

        tb = QtWidgets.QToolBar("Layout", self)
        tb.setMovable(False)
        self.addToolBar(QtCore.Qt.TopToolBarArea, tb)
        self.chk_lock = QtWidgets.QCheckBox("Lock Layout")
        act = QtWidgets.QWidgetAction(self)
        act.setDefaultWidget(self.chk_lock)
        tb.addAction(act)
        self.chk_lock.toggled.connect(self._on_toggle_lock)

        self.setCentralWidget(QtWidgets.QWidget())
        status = QtWidgets.QStatusBar()
        self.setStatusBar(status)
        self.dock_tray = DockTray(self)
        status.addPermanentWidget(self.dock_tray, 1)

        self.progress_bar = QtWidgets.QProgressBar()
        self.progress_bar.setRange(0, 0)
        self.progress_bar.setVisible(False)
        status.addPermanentWidget(self.progress_bar)

        # Tabs for personas / operators
        self.tabs = QtWidgets.QTabWidget()
        self.tab_widgets: Dict[str, QtWidgets.QWidget] = {}
        for persona in self.core.schema_mgr.personas:
            tab = QtWidgets.QWidget()
            self.tab_widgets[persona] = tab
            self.tabs.addTab(tab, persona.capitalize())
        self.operator_tab = QtWidgets.QWidget()
        self.tabs.addTab(self.operator_tab, "Operators")
        self.tabs.currentChanged.connect(self._on_tab_changed)

        for persona, tab in self.tab_widgets.items():
            self._build_persona_tab(persona, tab)
        self._build_operator_tab(self.operator_tab)

        # Chat panel
        self.chat_view = QtWidgets.QTextEdit()
        self.chat_view.setReadOnly(True)
        self.chat_view.setStyleSheet("background-color: #e0eef5; color: #011627;")
        self.chat_view.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        self.input_edit = QtWidgets.QPlainTextEdit()
        self.input_edit.setPlaceholderText("Type your message or use /remember key value, /showfacts, /style, /weights")
        self.input_edit.setMinimumHeight(64)
        self.input_edit.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        # Attach spell checker highlighter if available
        try:
            if SpellChecker:
                self._spell_highlighter = _SpellHighlighter(self.input_edit.document())  # type: ignore[attr-defined]
        except Exception:
            self._spell_highlighter = None
        self.btn_send = QtWidgets.QPushButton("Send")

        chat_container = QtWidgets.QWidget()
        cv = QtWidgets.QVBoxLayout(chat_container)
        cv.setContentsMargins(7, 7, 7, 7)
        cv.setSpacing(7)
        cv.addWidget(self.chat_view, 1)
        cv.addWidget(self.input_edit)
        row = QtWidgets.QHBoxLayout()
        row.addStretch()
        row.addWidget(self.btn_send)
        cv.addLayout(row)

        # Controls panel
        controls_panel = QtWidgets.QWidget()
        cp_layout = QtWidgets.QVBoxLayout(controls_panel)
        cp_layout.setContentsMargins(7, 7, 7, 7)
        cp_layout.setSpacing(7)

        # Recording
        rec_row = QtWidgets.QHBoxLayout()
        self.btn_record = QtWidgets.QPushButton("Record")
        self.btn_stop_rec = QtWidgets.QPushButton("Stop\nTranscribe")
        self.btn_stop_rec.setEnabled(False)
        for b in (self.btn_record, self.btn_stop_rec):
            b.setMinimumHeight(32)
            b.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        rec_row.addWidget(self.btn_record, 1)
        rec_row.addWidget(self.btn_stop_rec, 1)
        cp_layout.addLayout(rec_row)

        # Microphone device
        mic_row = QtWidgets.QHBoxLayout()
        mic_row.addWidget(QtWidgets.QLabel("Mic:"))
        self.device_combo = QtWidgets.QComboBox()
        self._populate_devices()
        self.device_combo.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        mic_row.addWidget(self.device_combo, 1)
        cp_layout.addLayout(mic_row)

        # Toggles
        self.chk_semantic = QtWidgets.QCheckBox("Semantic Awareness")
        self.chk_semantic.setChecked(True)
        self.chk_isolated = QtWidgets.QCheckBox("Isolated Chat")
        self.chk_isolated.setChecked(False)
        self.chk_mute_tts = QtWidgets.QCheckBox("Mute TTS")
        self.chk_self_talk = QtWidgets.QCheckBox("Enable Self Talk")
        self.chk_self_talk.setChecked(False)
        self.chk_auto_schema = QtWidgets.QCheckBox("Auto Schema Evolution")
        self.chk_auto_schema.setChecked(self.core.settings.auto_schema_enabled)

        cp_layout.addWidget(self.chk_semantic)
        cp_layout.addWidget(self.chk_isolated)
        cp_layout.addWidget(self.chk_mute_tts)
        cp_layout.addWidget(self.chk_self_talk)
        cp_layout.addWidget(self.chk_auto_schema)

        # Optional Google STT toggle (default off)
        self.chk_google_stt = QtWidgets.QCheckBox("Google STT")
        try:
            self.chk_google_stt.setChecked(bool(getattr(self.core.settings, "use_google_stt", False)))
        except Exception:
            self.chk_google_stt.setChecked(False)
        cp_layout.addWidget(self.chk_google_stt)

        # RAG cache clear
        self.btn_clear_rag = QtWidgets.QPushButton("Clear RAG Cache")
        cp_layout.addWidget(self.btn_clear_rag)

        # Maintenance
        self.btn_refresh = QtWidgets.QPushButton("Refresh Chat")
        self.btn_manage_datasets = QtWidgets.QPushButton("Manage Datasets")
        self.btn_inner_monologue = QtWidgets.QPushButton("Inner Monologue")
        for b in (self.btn_refresh, self.btn_manage_datasets, self.btn_inner_monologue):
            b.setMinimumHeight(32)
            b.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
            cp_layout.addWidget(b)

        self.btn_model_manager = QtWidgets.QPushButton("Model Manager")
        self.btn_model_manager.setMinimumHeight(32)
        self.btn_model_manager.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        cp_layout.addWidget(self.btn_model_manager)

        # Style label
        self.style_label = QtWidgets.QLabel("Style: N/A")
        self.style_label.setToolTip("Style score (0–1): rough measure vs. tone rules.")
        cp_layout.addWidget(self.style_label)

        # Response + feedback
        self.response_edit = QtWidgets.QPlainTextEdit()
        self.response_edit.setReadOnly(True)
        self.response_edit.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        cp_layout.addWidget(self.response_edit, 1)

        fb = QtWidgets.QHBoxLayout()
        self.btn_like = QtWidgets.QPushButton("✔")
        self.btn_dislike = QtWidgets.QPushButton("✖")
        self.btn_like.setToolTip("Mark as good response")
        self.btn_dislike.setToolTip("Dislike and rewrite response")
        self.btn_like.setStyleSheet("color: #2ecc71; font-weight: bold;")
        self.btn_dislike.setStyleSheet("color: #e74c3c; font-weight: bold;")
        self.btn_like.setEnabled(False)
        self.btn_dislike.setEnabled(False)
        fb.addWidget(self.btn_like)
        fb.addWidget(self.btn_dislike)
        fb.addStretch()
        self.btn_manage_feedback = QtWidgets.QPushButton("Manage Feedback")
        fb.addWidget(self.btn_manage_feedback)
        cp_layout.addLayout(fb)

        # TTS playback
        tts_row = QtWidgets.QHBoxLayout()
        self.btn_play = QtWidgets.QPushButton("Play")
        self.btn_stop_tts = QtWidgets.QPushButton("Stop")
        self.btn_replay = QtWidgets.QPushButton("Replay")
        for b in (self.btn_play, self.btn_stop_tts, self.btn_replay):
            b.setMinimumHeight(32)
            b.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        tts_row.addWidget(self.btn_play)
        tts_row.addWidget(self.btn_stop_tts)
        tts_row.addWidget(self.btn_replay)
        cp_layout.addLayout(tts_row)

        # Voice & Model
        voice_row = QtWidgets.QHBoxLayout()
        voice_row.addWidget(QtWidgets.QLabel("Voice:"))
        self.voice_combo = QtWidgets.QComboBox()
        voices = self._tts_voice_names()
        if voices:
            self.voice_combo.addItems([v for v in voices if "david" not in v.lower()])
        voice_row.addWidget(self.voice_combo, 1)
        cp_layout.addLayout(voice_row)

        model_row = QtWidgets.QHBoxLayout()
        model_row.addWidget(QtWidgets.QLabel("Model:"))
        self.model_combo = QtWidgets.QComboBox()
        self._populate_models()
        model_row.addWidget(self.model_combo, 1)
        cp_layout.addLayout(model_row)

        # Feedback counts
        self.lbl_feedback_counts = QtWidgets.QLabel("Likes: 0 | Dislikes: 0")
        cp_layout.addWidget(self.lbl_feedback_counts)
        cp_layout.addStretch(1)

        controls_scroll = QtWidgets.QScrollArea()
        controls_scroll.setWidgetResizable(True)
        controls_scroll.setFrameShape(QtWidgets.QFrame.NoFrame)
        controls_scroll.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)
        controls_scroll.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        controls_scroll.setWidget(controls_panel)

        # Docks
        self.controls_dock = QtWidgets.QDockWidget("Controls", self)
        self.controls_dock.setObjectName("ControlsDock")
        self.controls_dock.setWidget(controls_scroll)
        self.controls_dock.setFeatures(
            QtWidgets.QDockWidget.DockWidgetClosable
            | QtWidgets.QDockWidget.DockWidgetMovable
            | QtWidgets.QDockWidget.DockWidgetFloatable
        )

        self.persona_dock = QtWidgets.QDockWidget("Personas", self)
        self.persona_dock.setObjectName("PersonaDock")
        self.persona_dock.setWidget(self._wrap_persona_widget())
        self.persona_dock.setFeatures(
            QtWidgets.QDockWidget.DockWidgetClosable
            | QtWidgets.QDockWidget.DockWidgetMovable
            | QtWidgets.QDockWidget.DockWidgetFloatable
        )

        self.chat_dock = QtWidgets.QDockWidget("Chat", self)
        self.chat_dock.setObjectName("ChatDock")
        self.chat_dock.setWidget(chat_container)
        self.chat_dock.setFeatures(
            QtWidgets.QDockWidget.DockWidgetClosable
            | QtWidgets.QDockWidget.DockWidgetMovable
            | QtWidgets.QDockWidget.DockWidgetFloatable
        )

        self.model_dock = QtWidgets.QDockWidget("Models", self)
        self.model_dock.setObjectName("ModelDock")
        self.model_dock.setFeatures(
            QtWidgets.QDockWidget.DockWidgetClosable
            | QtWidgets.QDockWidget.DockWidgetMovable
            | QtWidgets.QDockWidget.DockWidgetFloatable
        )
        self._build_model_manager()

        self.plugins_dock = QtWidgets.QDockWidget("Plugins", self)
        self.plugins_dock.setObjectName("PluginsDock")
        self.plugins_dock.setFeatures(
            QtWidgets.QDockWidget.DockWidgetClosable
            | QtWidgets.QDockWidget.DockWidgetMovable
            | QtWidgets.QDockWidget.DockWidgetFloatable
        )
        self.plugins_dock.setWidget(self._build_plugins_widget())

        # Titles & dock tray
        self.controls_dock.setTitleBarWidget(DockTitleBar(self.controls_dock, "Controls"))
        self.persona_dock.setTitleBarWidget(DockTitleBar(self.persona_dock, "Personas"))
        self.chat_dock.setTitleBarWidget(DockTitleBar(self.chat_dock, "Chat"))
        self.model_dock.setTitleBarWidget(DockTitleBar(self.model_dock, "Models"))
        self.plugins_dock.setTitleBarWidget(DockTitleBar(self.plugins_dock, "Plugins"))

        for d in (self.controls_dock, self.persona_dock, self.chat_dock, self.model_dock, self.plugins_dock):
            self.dock_tray.register_dock(d)

        self.addDockWidget(QtCore.Qt.LeftDockWidgetArea, self.controls_dock)
        self.addDockWidget(QtCore.Qt.LeftDockWidgetArea, self.persona_dock)
        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.chat_dock)
        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.model_dock)
        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.plugins_dock)

        self.splitDockWidget(self.controls_dock, self.persona_dock, QtCore.Qt.Vertical)
        self.splitDockWidget(self.controls_dock, self.chat_dock, QtCore.Qt.Horizontal)
        self.splitDockWidget(self.chat_dock, self.model_dock, QtCore.Qt.Horizontal)
        self.splitDockWidget(self.model_dock, self.plugins_dock, QtCore.Qt.Horizontal)

    # ────────────────────────── persona widgets
    def _wrap_persona_widget(self) -> QtWidgets.QWidget:
        container = QtWidgets.QWidget()
        v = QtWidgets.QVBoxLayout(container)
        v.setContentsMargins(7, 7, 7, 7)
        v.setSpacing(7)

        try:
            bot_schema = self.core.schema_mgr.load_schema("zira", self.current_set.get("zira", "default"))
            bot_name = bot_schema.get("name", "Zira")
            bot_set = self.current_set.get("zira", "default")
        except Exception:
            bot_name, bot_set = "Zira", "default"

        try:
            user_schema = self.core.schema_mgr.load_schema("user", self.current_set.get("user", "default"))
            user_name = user_schema.get("name", "User")
            user_set = self.current_set.get("user", "default")
        except Exception:
            user_name, user_set = "User", "default"

        self.lbl_active_names = QtWidgets.QLabel(f"{bot_name}: {bot_set} — User: {user_name}: {user_set}")
        v.addWidget(self.lbl_active_names)
        v.addWidget(self.tabs, 1)
        return container

    def _build_persona_tab(self, persona: str, tab: QtWidgets.QWidget) -> None:
        vbox = QtWidgets.QVBoxLayout(tab)

        # --- Set selector row ---
        h_set = QtWidgets.QHBoxLayout()
        h_set.addWidget(QtWidgets.QLabel("Set:"))
        combo = QtWidgets.QComboBox(objectName=f"set_combo_{persona}")
        self._populate_set_combo(persona, combo)
        h_set.addWidget(combo)

        btn_clone = QtWidgets.QPushButton("Clone", objectName=f"clone_set_{persona}")
        btn_new = QtWidgets.QPushButton("New", objectName=f"new_set_{persona}")
        btn_del = QtWidgets.QPushButton("Delete", objectName=f"del_set_{persona}")
        h_set.addWidget(btn_clone)
        h_set.addWidget(btn_new)
        h_set.addWidget(btn_del)
        h_set.addStretch()
        vbox.addLayout(h_set)

        # --- Commands row (NEW) ---
        cmd_row = QtWidgets.QHBoxLayout()
        cmd_row.addWidget(QtWidgets.QLabel("Commands:"))
        cmd_combo = QtWidgets.QComboBox(objectName=f"cmd_combo_{persona}")
        self._populate_command_combo(persona, cmd_combo)
        cmd_row.addWidget(cmd_combo, 1)

        cmd_edit = QtWidgets.QLineEdit(objectName=f"cmd_edit_{persona}")
        cmd_edit.setPlaceholderText('Enter text/payload for selected /command')
        cmd_row.addWidget(cmd_edit, 2)

        btn_add_cmd = QtWidgets.QPushButton("Add to Command", objectName=f"add_cmd_{persona}")
        btn_new_cmd = QtWidgets.QPushButton("New Command", objectName=f"new_cmd_{persona}")
        cmd_row.addWidget(btn_add_cmd)
        cmd_row.addWidget(btn_new_cmd)
        vbox.addLayout(cmd_row)

        # --- Schema editor ---
        editor = QtWidgets.QPlainTextEdit(objectName=f"schema_edit_{persona}")
        editor.setLineWrapMode(QtWidgets.QPlainTextEdit.NoWrap)
        schema = self.core.schema_mgr.load_schema(persona, self.current_set.get(persona, "default"))
        editor.setPlainText(json.dumps(schema, indent=2))
        vbox.addWidget(editor, 1)

        # --- Save button ---
        h_save = QtWidgets.QHBoxLayout()
        btn_save = QtWidgets.QPushButton("Save", objectName=f"save_schema_{persona}")
        h_save.addStretch()
        h_save.addWidget(btn_save)
        vbox.addLayout(h_save)

        # --- Button bindings ---
        combo.currentTextChanged.connect(lambda name, p=persona, c=combo: self._on_set_changed(p, name, c))
        btn_clone.clicked.connect(lambda _, p=persona, c=combo: self._on_clone_set(p, c))
        btn_new.clicked.connect(lambda _, p=persona, c=combo: self._on_new_set(p, c))
        btn_del.clicked.connect(lambda _, p=persona, c=combo: self._on_delete_set(p, c))
        btn_save.clicked.connect(lambda _, p=persona: self._on_save_schema(p))

        btn_add_cmd.clicked.connect(lambda _, p=persona, cc=cmd_combo, ce=cmd_edit: self._on_add_to_command(p, cc, ce))
        btn_new_cmd.clicked.connect(lambda _, p=persona: self._on_new_command(p))

        # --- Autosave debounce ---
        timer = QtCore.QTimer(self)
        timer.setSingleShot(True)

        def on_text_change() -> None:
            timer.start(500)

        def on_timeout() -> None:
            text = editor.toPlainText().strip()
            try:
                obj = json.loads(text)
                if isinstance(obj, dict):
                    set_name = self.current_set.get(persona, "default")
                    self.core.schema_mgr.save_schema(persona, set_name, obj)
            except Exception:
                pass

        editor.textChanged.connect(on_text_change)
        timer.timeout.connect(on_timeout)
        self._schema_save_timers[persona] = timer

    # --- Commands helpers (NEW) ---
    def _populate_command_combo(self, persona: str, combo: QtWidgets.QComboBox) -> None:
        combo.blockSignals(True)
        combo.clear()
        schema = self.core.schema_mgr.load_schema(persona, self.current_set.get(persona, "default"))
        cmds = []
        try:
            cmds = sorted(list((schema.get("commands") or {}).keys()))
        except Exception:
            cmds = []
        if not cmds:
            combo.addItem("(no commands)")
            combo.setEnabled(False)
        else:
            combo.addItems(cmds)
            combo.setEnabled(True)
        combo.blockSignals(False)

    def _on_add_to_command(self, persona: str, combo: QtWidgets.QComboBox, edit: QtWidgets.QLineEdit) -> None:
        text = edit.text().strip()
        if not text:
            QtWidgets.QMessageBox.information(self, "No Text", "Enter text/payload to add.")
            return
        set_name = self.current_set.get(persona, "default")
        schema = self.core.schema_mgr.load_schema(persona, set_name)
        cmds = dict(schema.get("commands") or {})
        sel = combo.currentText().strip()
        if not sel or sel == "(no commands)":
            QtWidgets.QMessageBox.information(self, "No Command", "Create a command first.")
            return
        lst = list(cmds.get(sel) or [])
        lst.append(text)
        cmds[sel] = lst
        schema["commands"] = cmds
        self.core.schema_mgr.save_schema(persona, set_name, schema)
        edit.clear()
        # refresh schema editor & notify
        self._refresh_schema_editor(persona)
        QtWidgets.QMessageBox.information(self, "Added", f'Added to {sel}: "{text}"')

    def _on_new_command(self, persona: str) -> None:
        name, ok = QtWidgets.QInputDialog.getText(self, "New Command", "Enter new command (e.g., /remember):")
        if not ok or not name.strip():
            return
        cmd_name = name.strip()
        if not cmd_name.startswith("/"):
            cmd_name = "/" + cmd_name
        set_name = self.current_set.get(persona, "default")
        schema = self.core.schema_mgr.load_schema(persona, set_name)
        cmds = dict(schema.get("commands") or {})
        if cmd_name in cmds:
            QtWidgets.QMessageBox.information(self, "Exists", f"Command {cmd_name} already exists.")
            return
        cmds[cmd_name] = []
        schema["commands"] = cmds
        self.core.schema_mgr.save_schema(persona, set_name, schema)
        # refresh command combo + schema editor
        tab = self.tab_widgets.get(persona)
        if tab:
            combo = tab.findChild(QtWidgets.QComboBox, f"cmd_combo_{persona}")
            if combo:
                self._populate_command_combo(persona, combo)
                combo.setCurrentText(cmd_name)
            edit = tab.findChild(QtWidgets.QLineEdit, f"cmd_edit_{persona}")
            if edit:
                edit.clear()
        self._refresh_schema_editor(persona)
        QtWidgets.QMessageBox.information(self, "Created", f"New command {cmd_name} created.")

    def _refresh_schema_editor(self, persona: str) -> None:
        tab = self.tab_widgets.get(persona)
        if not tab:
            return
        editor = tab.findChild(QtWidgets.QPlainTextEdit, f"schema_edit_{persona}")
        if editor:
            schema = self.core.schema_mgr.load_schema(persona, self.current_set.get(persona, "default"))
            editor.blockSignals(True)
            editor.setPlainText(json.dumps(schema, indent=2))
            editor.blockSignals(False)
            
    def _on_tab_changed(self, index: int) -> None:
        """
        Handle tab changes in the main tab widget.
        
        Parameters
        ----------
        index : int
            Index of the newly selected tab.
        """
        try:
            tab_name = self.tabs.tabText(index)
            print(f"[UI] Tab changed to: {tab_name} (index {index})")
            # Add any extra logic if needed, for example:
            # self._update_feedback_counts()
        except Exception as e:
            print(f"[UI] Error handling tab change: {e}")
            

    # ────────────────────────── operator tab
    def _build_operator_tab(self, tab: QtWidgets.QWidget) -> None:
        layout = QtWidgets.QVBoxLayout(tab)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)
        scroll = QtWidgets.QScrollArea()
        scroll.setWidgetResizable(True)
        scroll.setFrameShape(QtWidgets.QFrame.NoFrame)
        scroll.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        container = QtWidgets.QWidget()
        container.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        vbox = QtWidgets.QVBoxLayout(container)
        vbox.setContentsMargins(8, 8, 8, 8)
        vbox.setSpacing(8)

        names = sorted(self.core.operator_mgr.list_operators())
        if not names:
            info = QtWidgets.QLabel("No operators found.")
            info.setWordWrap(True)
            vbox.addWidget(info)
        else:
            for name in names:
                # Load operator description if available
                try:
                    op_dir = os.path.join(self.core.operator_mgr.operators_dir, name, "schema.json")
                    desc = ""
                    if os.path.isfile(op_dir):
                        with open(op_dir, "r", encoding="utf-8") as f:
                            d = json.load(f)
                            desc = str(d.get("description", ""))
                except Exception:
                    desc = ""
                box = QtWidgets.QGroupBox(name)
                box.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
                bl = QtWidgets.QVBoxLayout(box)
                bl.setContentsMargins(8, 8, 8, 8)
                bl.setSpacing(6)
                lbl = QtWidgets.QLabel(desc)
                lbl.setWordWrap(True)
                bl.addWidget(lbl)
                btn_row = QtWidgets.QHBoxLayout()
                btn_info = QtWidgets.QPushButton("Info")
                btn_row.addWidget(btn_info)
                btn_row.addStretch(1)
                bl.addLayout(btn_row)
                vbox.addWidget(box)
                btn_info.clicked.connect(partial(QtWidgets.QMessageBox.information, self, f"{name} Info", desc or "No description."))

        vbox.addStretch(1)
        scroll.setWidget(container)
        layout.addWidget(scroll)

    # ────────────────────────── plugins
    def _build_plugins_widget(self) -> QtWidgets.QWidget:
        container = QtWidgets.QWidget()
        layout = QtWidgets.QVBoxLayout(container)
        layout.setContentsMargins(6, 6, 6, 6)
        layout.setSpacing(4)

        self.plugin_list = QtWidgets.QListWidget()
        self.plugin_list.setSelectionMode(QtWidgets.QAbstractItemView.NoSelection)
        layout.addWidget(self.plugin_list, 1)

        btn_rescan = QtWidgets.QPushButton("Rescan")
        layout.addWidget(btn_rescan)
        btn_rescan.clicked.connect(self._rescan_plugins)

        self._populate_plugin_list()
        self.plugin_list.itemChanged.connect(self._on_plugin_item_changed)

        try:
            self.core.plugins.eventReceived.connect(self._on_plugin_event)
        except Exception:
            pass

        return container

    def _populate_plugin_list(self) -> None:
        self.plugin_list.blockSignals(True)
        self.plugin_list.clear()
        for meta in self.core.plugins.list_plugins():
            item = QtWidgets.QListWidgetItem(meta.name)
            flags = item.flags() | QtCore.Qt.ItemIsUserCheckable
            if meta.missing_dependencies:
                flags &= ~QtCore.Qt.ItemIsEnabled
                item.setToolTip(f"Missing dependencies: {', '.join(meta.missing_dependencies)}")
            item.setFlags(flags)
            item.setCheckState(QtCore.Qt.Checked if meta.enabled else QtCore.Qt.Unchecked)
            self.plugin_list.addItem(item)
        self.plugin_list.blockSignals(False)

    def _on_plugin_item_changed(self, item: QtWidgets.QListWidgetItem) -> None:
        name = item.text()
        enabled = item.checkState() == QtCore.Qt.Checked
        self.core.plugins.enable_plugin(name, enabled)
        meta = next((m for m in self.core.plugins.list_plugins() if m.name == name), None)
        if not meta:
            return
        if enabled and meta.widget is not None:
            self._attach_plugin_widget(meta)
        elif not enabled:
            self._detach_plugin_widget(name)

    def _rescan_plugins(self) -> None:
        self.core.plugins.rescan()
        for name in list(self._plugin_docks.keys()):
            meta = next((m for m in self.core.plugins.list_plugins() if m.name == name), None)
            if not meta or not meta.enabled:
                self._detach_plugin_widget(name)
        self._populate_plugin_list()

    def _attach_plugin_widget(self, meta: 'object') -> None:
        if meta.name in self._plugin_docks:
            return
        if meta.widget is None:
            return
        dock = QtWidgets.QDockWidget(meta.name, self)
        dock.setObjectName(f"PluginDock_{meta.name}")
        dock.setWidget(meta.widget)
        dock.setFeatures(
            QtWidgets.QDockWidget.DockWidgetClosable
            | QtWidgets.QDockWidget.DockWidgetMovable
            | QtWidgets.QDockWidget.DockWidgetFloatable
        )
        dock.setTitleBarWidget(DockTitleBar(dock, meta.name))
        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, dock)
        self.dock_tray.register_dock(dock)
        self._plugin_docks[meta.name] = dock

    def _detach_plugin_widget(self, name: str) -> None:
        dock = self._plugin_docks.pop(name, None)
        if dock:
            self.dock_tray._remove_button(dock)
            dock.setParent(None)
            dock.deleteLater()

    @QtCore.pyqtSlot(str, dict)
    def _on_plugin_event(self, sender: str, envelope: dict) -> None:
        try:
            data = envelope.get("data")
            msg = json.dumps(data, indent=2) if isinstance(data, (dict, list)) else str(data)
            display_name = sender
            self._append_message(display_name, msg, role_key="operator")
            if self.chk_semantic.isChecked() and not self.chk_isolated.isChecked():
                self.core.conversation_db.save_message(sender.lower(), msg)
        except Exception as e:
            print(f"Error handling plugin event from {sender}: {e}")

    # ────────────────────────── model manager
    def _build_model_manager(self) -> None:
        widget = QtWidgets.QWidget()
        v = QtWidgets.QVBoxLayout(widget)
        v.setContentsMargins(8, 8, 8, 8)
        v.setSpacing(6)
        self.model_list = QtWidgets.QListWidget()
        v.addWidget(self.model_list, 1)
        h = QtWidgets.QHBoxLayout()
        self.btn_model_pull = QtWidgets.QPushButton("Pull")
        self.btn_model_delete = QtWidgets.QPushButton("Delete")
        self.btn_model_set_default = QtWidgets.QPushButton("Set as Default")
        h.addWidget(self.btn_model_pull)
        h.addWidget(self.btn_model_delete)
        h.addWidget(self.btn_model_set_default)
        h.addStretch()
        v.addLayout(h)
        self.model_dock.setWidget(widget)
        self._refresh_model_list()
        self.btn_model_pull.clicked.connect(self._on_model_pull)
        self.btn_model_delete.clicked.connect(self._on_model_delete)
        self.btn_model_set_default.clicked.connect(self._on_model_set_default)

    def _refresh_model_list(self) -> None:
        self.model_list.clear()
        models: List[str] = []
        try:
            out = subprocess.run(
                ["ollama", "list"],
                stdout=subprocess.PIPE,
                stderr=subprocess.DEVNULL,
                text=True,
                check=True,
            ).stdout.splitlines()
            for line in out[1:]:
                parts = line.strip().split()
                if parts:
                    models.append(parts[0])
        except Exception:
            models = []
        for m in models:
            item = QtWidgets.QListWidgetItem(m)
            if m == self.model_combo.currentText().strip():
                item.setFont(QtGui.QFont("", weight=QtGui.QFont.Bold))
            self.model_list.addItem(item)

    def _on_model_pull(self) -> None:
        item = self.model_list.currentItem()
        if not item:
            return
        model = item.text()
        threading.Thread(target=lambda: subprocess.run(["ollama", "pull", model], check=False), daemon=True).start()
        QtWidgets.QMessageBox.information(self, "Pull Started", f"Pulling {model} in background.")

    def _on_model_delete(self) -> None:
        item = self.model_list.currentItem()
        if not item:
            return
        model = item.text()
        if QtWidgets.QMessageBox.question(
            self,
            "Delete Model",
            f"Delete '{model}'? This cannot be undone.",
            QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No,
        ) != QtWidgets.QMessageBox.Yes:
            return
        threading.Thread(target=lambda: subprocess.run(["ollama", "delete", model], check=False), daemon=True).start()
        QtWidgets.QMessageBox.information(self, "Delete Started", f"Deleting {model} in background.")
        self._refresh_model_list()

    def _on_model_set_default(self) -> None:
        item = self.model_list.currentItem()
        if not item:
            return
        model = item.text()
        idx = self.model_combo.findText(model)
        if idx >= 0:
            self.model_combo.setCurrentIndex(idx)
        # persist selection to settings
        try:
            self.core.settings.default_model = model
            self.core.settings.save()
        except Exception:
            pass
            QtWidgets.QMessageBox.information(self, "Default Model", f"Set default model to {model}.")
        else:
            self.model_combo.addItem(model)
            self.model_combo.setCurrentText(model)

    # ────────────────────────── lock layout
    def _on_toggle_lock(self, locked: bool) -> None:
        feats_unlocked = (
            QtWidgets.QDockWidget.DockWidgetClosable
            | QtWidgets.QDockWidget.DockWidgetMovable
            | QtWidgets.QDockWidget.DockWidgetFloatable
        )
        feats_locked = QtWidgets.QDockWidget.DockWidgetClosable
        for dock in (
            self.controls_dock,
            self.persona_dock,
            self.chat_dock,
            getattr(self, "inner_dock", None),
            self.model_dock,
            self.plugins_dock,
        ):
            if dock is None:
                continue
            dock.setFeatures(feats_locked if locked else feats_unlocked)
        for dock in self._plugin_docks.values():
            dock.setFeatures(feats_locked if locked else feats_unlocked)

    # ────────────────────────── audio
    def start_recording(self) -> None:
        if sd is None or np is None:
            QtWidgets.QMessageBox.information(self, "Recording Unavailable", "sounddevice/numpy not installed.")
            return
        if not self.btn_record.isEnabled():
            return
        device_index = None
        try:
            idx = self.device_combo.currentIndex()
            selected_name = self.device_combo.currentText()
            for i, d in enumerate(sd.query_devices()):
                if d.get("name") == selected_name and d.get("max_input_channels", 0) > 0:
                    device_index = i
                    break
        except Exception:
            device_index = None
        self.core.audio_recorder.start(device_index)
        self.btn_record.setEnabled(False)
        self.btn_stop_rec.setEnabled(True)

    def stop_recording(self) -> None:
        if not self.btn_stop_rec.isEnabled():
            return
        self.core.audio_recorder.stop_and_transcribe()
        self.btn_stop_rec.setEnabled(False)
        self.btn_record.setEnabled(True)

    @QtCore.pyqtSlot(str)
    def _on_transcribed(self, text: str) -> None:
        if not text:
            return
        cur = self.input_edit.toPlainText()
        self.input_edit.setPlainText((cur + "\n" if cur else "") + text)

    # ────────────────────────── TTS
    def _on_play(self) -> None:
        text = self.response_edit.toPlainText().strip()
        if text and not self.chk_mute_tts.isChecked():
            try:
                self.core.tts_mgr.enqueue(text)
            except Exception:
                pass

    def _on_stop_tts(self) -> None:
        try:
            self.core.tts_mgr.stop()
        except Exception:
            pass

    def _on_replay(self) -> None:
        if not self.chk_mute_tts.isChecked():
            try:
                self.core.tts_mgr.replay()
            except Exception:
                pass

    def _on_voice_changed(self, name: str) -> None:
        try:
            eng = getattr(self.core.tts_mgr, "_engine", None)
            if eng:
                for v in eng.getProperty("voices"):
                    if v.name == name:
                        eng.setProperty("voice", v.id)
                        break
        except Exception:
            pass

    def _tts_voice_names(self) -> List[str]:
        try:
            eng = getattr(self.core.tts_mgr, "_engine", None)
            if not eng:
                return []
            return [v.name for v in eng.getProperty("voices")]
        except Exception:
            return []

    # ────────────────────────── feedback
    def _on_like(self) -> None:
        text = self.response_edit.toPlainText().strip()
        if not text:
            return
        try:
            self.core.add_feedback(text, liked=True)
        except Exception:
            pass
        QtWidgets.QMessageBox.information(self, "Feedback", "Marked as good response.")
        self._enable_feedback(False)
        self._update_feedback_counts()

    def _on_dislike(self) -> None:
        original = self.response_edit.toPlainText().strip()
        if not original:
            return
        try:
            self.core.tts_mgr.stop()
        except Exception:
            pass
        QtWidgets.QMessageBox.information(self, "Disliked", "The response will be rewritten.")
        self._enable_feedback(False)

        def worker() -> None:
            new_text = self._rewrite_response(original)
            try:
                self.core.add_feedback(original, liked=False, revised=new_text)
            except Exception:
                pass
            if self.chk_isolated.isChecked():
                self.isolated_history.append((self._current_persona(), new_text))
            else:
                if self.chk_semantic.isChecked():
                    self.core.conversation_db.save_message(self._current_persona().lower(), new_text)
            self.rewrite_ready.emit(new_text)

        threading.Thread(target=worker, daemon=True).start()

    @QtCore.pyqtSlot(str)
    def _apply_rewrite_result(self, new_text: str) -> None:
        schema = self.core.schema_mgr.load_schema(
            self._current_persona(), self.current_set.get(self._current_persona(), "default")
        )
        persona_name = schema.get("name", "Bot")
        role_key = self._current_persona().lower()
        self._append_message(persona_name, new_text, role_key=role_key)
        self.response_edit.setPlainText(new_text)
        if not self.chk_mute_tts.isChecked():
            try:
                self.core.tts_mgr.enqueue(new_text)
            except Exception:
                pass
        QtWidgets.QMessageBox.information(self, "Rewritten", "Response rewritten.")
        self._enable_feedback(False)

    def _update_feedback_counts(self) -> None:
        try:
            pos, neg = self.core.feedback_db.get_counts()
            self.lbl_feedback_counts.setText(f"Likes: {pos} | Dislikes: {neg}")
        except Exception:
            self.lbl_feedback_counts.setText("Likes: - | Dislikes: -")

    def _enable_feedback(self, enabled: bool) -> None:
        self.btn_like.setEnabled(enabled)
        self.btn_dislike.setEnabled(enabled)

    def _on_manage_feedback(self) -> None:
        db = self.core.feedback_db
        if db is None:
            QtWidgets.QMessageBox.information(self, "No DB", "Feedback DB unavailable.")
            return
        cur = db.conn.cursor()
        cur.execute("SELECT id, original, liked, COALESCE(revised, '') FROM feedback ORDER BY id DESC")
        entries = cur.fetchall()
        dlg = QtWidgets.QDialog(self)
        dlg.setWindowTitle("Manage Feedback")
        dlg.resize(720, 420)
        v = QtWidgets.QVBoxLayout(dlg)
        table = QtWidgets.QTableWidget(len(entries), 4)
        table.setHorizontalHeaderLabels(["ID", "Original", "Liked", "Revised"])
        table.horizontalHeader().setStretchLastSection(True)
        for r, (fid, orig, liked, rev) in enumerate(entries):
            table.setItem(r, 0, QtWidgets.QTableWidgetItem(str(fid)))
            table.setItem(r, 1, QtWidgets.QTableWidgetItem(orig))
            table.setItem(r, 2, QtWidgets.QTableWidgetItem("✔" if liked else "✖"))
            table.setItem(r, 3, QtWidgets.QTableWidgetItem(rev))
        v.addWidget(table, 1)
        h = QtWidgets.QHBoxLayout()
        btn_del = QtWidgets.QPushButton("Delete Selected")
        btn_close = QtWidgets.QPushButton("Close")
        h.addWidget(btn_del)
        h.addWidget(btn_close)
        h.addStretch()
        v.addLayout(h)

        def on_delete() -> None:
            selected = table.selectedItems()
            if not selected:
                return
            rows = sorted({i.row() for i in selected}, reverse=True)
            for rr in rows:
                fid_item = table.item(rr, 0)
                if fid_item:
                    try:
                        fid = int(fid_item.text())
                        db.conn.execute("DELETE FROM feedback WHERE id = ?", (fid,))
                        db.conn.commit()
                    except Exception:
                        pass
                table.removeRow(rr)
            self._update_feedback_counts()

        btn_del.clicked.connect(on_delete)
        btn_close.clicked.connect(dlg.accept)
        dlg.exec_()

    # ────────────────────────── datasets / rag
    def _on_manage_datasets(self) -> None:
        DatasetManagerDialog(self.core.dataset_mgr, self).exec_()

    def _on_clear_rag_cache(self) -> None:
        if QtWidgets.QMessageBox.question(
            self,
            "Clear RAG Cache",
            "Delete cached embeddings for all datasets and clear memory?",
            QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No,
        ) != QtWidgets.QMessageBox.Yes:
            return
        count = self.core.rag_cache.clear_disk()
        self.core.rag_cache.clear_memory()
        QtWidgets.QMessageBox.information(self, "Cleared", f"Cleared RAG cache files ({count} removed) and in-memory index.")

    # ────────────────────────── isolated / refresh / idle
    def _on_isolated_toggled(self, checked: bool) -> None:
        if checked:
            self.isolated_history.clear()
        else:
            if self.isolated_history:
                ans = QtWidgets.QMessageBox.question(
                    self,
                    "Merge Isolated Chat",
                    "Merge isolated conversation into main memory?",
                    QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No,
                )
                if ans == QtWidgets.QMessageBox.Yes:
                    for role, content in self.isolated_history:
                        self.core.conversation_db.save_message(role.lower(), content)
                self.isolated_history.clear()
        self._reset_idle_timer()

    def _on_refresh_chat(self) -> None:
        if self.chk_isolated.isChecked():
            self.isolated_history.clear()
        self.chat_view.clear()
        self.response_edit.clear()
        self._enable_feedback(False)
        try:
            if hasattr(self, "inner_text") and self.inner_text is not None:
                self.inner_text.clear()
        except Exception:
            pass

    def _reset_idle_timer(self) -> None:
        self._idle_timer.stop()
        if self.chk_semantic.isChecked():
            self._idle_timer.start(60000)

    def _handle_idle(self) -> None:
        pass

    # ────────────────────────── inner monologue
    def _on_inner_monologue(self) -> None:
        self._ensure_inner_dock()
        if self.inner_dock is None:
            return
        self.inner_dock.setVisible(not self.inner_dock.isVisible())

    def _ensure_inner_dock(self) -> None:
        if hasattr(self, "inner_dock") and self.inner_dock is not None:
            return
        dock = QtWidgets.QDockWidget("Inner Monologue", self)
        dock.setObjectName("InnerDock")
        dock.setAllowedAreas(QtCore.Qt.RightDockWidgetArea | QtCore.Qt.LeftDockWidgetArea)
        inner = QtWidgets.QWidget()
        v = QtWidgets.QVBoxLayout(inner)
        self.inner_text = QtWidgets.QPlainTextEdit()
        self.inner_text.setReadOnly(True)
        v.addWidget(self.inner_text, 1)
        h = QtWidgets.QHBoxLayout()
        h.addWidget(QtWidgets.QLabel("Interval (s):"))
        self.spin_interval = QtWidgets.QSpinBox()
        self.spin_interval.setRange(1, 60)
        self.spin_interval.setValue(15)
        h.addWidget(self.spin_interval)
        self.chk_monologue_tts = QtWidgets.QCheckBox("Speak")
        self.chk_monologue_tts.setChecked(self.core.settings.monologue_tts_enabled)
        h.addWidget(self.chk_monologue_tts)
        h.addWidget(QtWidgets.QLabel("Volume:"))
        self.slider_monologue_vol = QtWidgets.QSlider(QtCore.Qt.Horizontal)
        self.slider_monologue_vol.setRange(0, 100)
        self.slider_monologue_vol.setValue(self.core.settings.monologue_volume)
        h.addWidget(self.slider_monologue_vol)
        btn_start_stop = QtWidgets.QPushButton("Start/Stop")
        h.addWidget(btn_start_stop)
        v.addLayout(h)
        inner.setLayout(v)
        dock.setWidget(inner)
        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, dock)
        self.inner_dock = dock
        self.inner_timer = QtCore.QTimer(self)
        self.inner_timer.setSingleShot(False)
        btn_start_stop.clicked.connect(self._toggle_inner_timer)
        dock.setTitleBarWidget(DockTitleBar(dock, "Inner Monologue"))
        self.dock_tray.register_dock(self.inner_dock)
        self.chk_monologue_tts.stateChanged.connect(lambda _: self._update_monologue_settings())
        self.slider_monologue_vol.valueChanged.connect(lambda _: self._update_monologue_settings())

    def _toggle_inner_timer(self) -> None:
        if self.inner_timer is None:
            return
        if self.inner_timer.isActive():
            self.inner_timer.stop()
        else:
            interval_ms = self.spin_interval.value() * 1000
            try:
                self.inner_timer.timeout.disconnect()
            except Exception:
                pass
            self.inner_timer.timeout.connect(self._generate_inner_monologue)
            self.inner_timer.start(interval_ms)

    def _update_monologue_settings(self) -> None:
        try:
            self.core.settings.monologue_tts_enabled = self.chk_monologue_tts.isChecked() if hasattr(self, 'chk_monologue_tts') else False
            self.core.settings.monologue_volume = self.slider_monologue_vol.value() if hasattr(self, 'slider_monologue_vol') else 50
            self.core.settings.save()
        except Exception:
            pass

    def _generate_inner_monologue(self) -> None:
        schema = self.core.schema_mgr.load_schema(self._current_persona(), self.current_set.get(self._current_persona(), "default"))
        overlay = schema.get("dynamic_overlay", {}) or {}
        mood = overlay.get("temporary_emotional_state", "neutral")
        likes = overlay.get("recent_topics", [])
        pos = [0, 0]
        fav_topic = likes[-1] if likes else None
        thought = f"I'm thinking about {fav_topic} while feeling {mood}." if fav_topic else f"I'm in a {mood} mood and reflecting."
        thought += f" I'm at position {pos}."
        try:
            if hasattr(self, "inner_text") and self.inner_text is not None:
                self.inner_text.appendPlainText(thought)
        except Exception:
            pass

    # ────────────────────────── conversation
    def _append_message(self, display_name: str, text: str, role_key: Optional[str] = None) -> None:
        key = (role_key or display_name).lower()
        bg_colour = ROLE_COLOURS.get(key, "#EEEEEE")
        name_colour = NAME_COLOURS.get(key, "#011627")
        safe_role = QtGui.QGuiApplication.translate("Chat", display_name)
        safe_text = QtGui.QGuiApplication.translate("Chat", text)
        frag = (
            f'<div style="background-color:{bg_colour}; border-radius:4px; padding:4px; margin:4px;">'
            f'<b style="color:{name_colour};">{safe_role}:</b> {safe_text}'
            f'</div>'
        )
        self.chat_view.append(frag)

    def _current_history(self) -> List[Tuple[str, str]]:
        if self.chk_isolated.isChecked():
            return self.isolated_history
        else:
            return self.core.conversation_db.fetch_history(limit=10)

    def _bootstrap_conversation(self) -> None:
        if self.core and len(self.core.conversation_db.fetch_history(limit=1)) == 0:
            schema = self.core.schema_mgr.load_schema(self.active_persona, self.current_set.get(self.active_persona, "default"))
            questions = schema.get("questions", [])
            if questions:
                first_question = questions[0]
                self._append_message("System", first_question, role_key="system")
                if self.chk_semantic.isChecked() and not self.chk_isolated.isChecked():
                    self.core.conversation_db.save_message("system", first_question)

    # ────────────────────────── prompt & rag
    def _build_prompt(self, schema: Dict[str, object], user_text: str, is_self_talk: bool = False) -> str:
        parts: List[str] = []
        name = schema.get("name", "")
        role = schema.get("role", "")
        desc = schema.get("description", "")
        persona_desc = f"You are {name}, {desc}".strip()
        if role:
            persona_desc += f" Your role is {role}."

        overlay = schema.get("dynamic_overlay", {})
        if overlay:
            temp_rel = overlay.get("temporary_relationship_context", "")
            temp_emotion = overlay.get("temporary_emotional_state", "")
            added_traits = overlay.get("added_traits", [])
            if temp_rel:
                persona_desc += f" ({temp_rel})"
            if temp_emotion:
                persona_desc += f" You feel {temp_emotion}."
            if added_traits:
                persona_desc += f" Traits: {', '.join(str(t) for t in added_traits)}."
        parts.append(persona_desc)

        # User description
        try:
            user_schema = self.core.schema_mgr.load_schema("user", self.current_set.get("user", "default"))
        except Exception:
            user_schema = {}
        if user_schema:
            u_name = user_schema.get("name", "User")
            u_personality = user_schema.get("personality", "")
            relationship = user_schema.get("relationship_to_zira", "friend")
            u_overlay = user_schema.get("dynamic_overlay", {})
            temp_rel2 = u_overlay.get("temporary_relationship_context") if u_overlay else None
            if temp_rel2 and str(temp_rel2).strip():
                relationship = str(temp_rel2)
            user_desc = f"User is {u_name}, {u_personality}. Relationship: {relationship}."
            parts.append(user_desc)

        # History
        history_text = ""
        if self.chk_semantic.isChecked():
            history = self._current_history()[-10:]
            for role_name, content in history:
                speaker = "User" if role_name.lower() == "user" else role_name.title()
                history_text += f"{speaker}: {content}\n"
        if history_text:
            parts.append("Conversation history:\n" + history_text.strip())

        # RAG (only datasets listed by this set)
        dataset_text = ""
        ds_names: List[str] = list(schema.get("datasets") or [])
        try:
            # Prefer core search with filters if supported
            hits = self.core.rag_search(
                user_text,
                per_ds_k=3,
                limit=5,
                include_shared=False,
                datasets=ds_names if ds_names else None,
            )
            for chunk, score, ds_name, owner in hits:
                dataset_text += f"Dataset ({owner}/{ds_name}):\n{chunk}\n\n"
        except TypeError:
            # Older core: no dataset filter; fallback to manual selection
            from_texts: List[Tuple[str, str]] = []
            try:
                for name, entry in self.core.dataset_mgr.entries.items():
                    if ds_names and name not in ds_names:
                        continue
                    if not entry.active:
                        continue
                    full_text = self.core.dataset_mgr.load_dataset_text(entry)
                    if full_text:
                        from_texts.append((name, full_text))
            except Exception:
                pass
            for name, full_text in from_texts:
                snip = self._retrieve_dataset_snippet(full_text, user_text)
                if snip:
                    dataset_text += f"Dataset ({name}):\n{snip}\n\n"
        except Exception:
            pass
        if dataset_text:
            parts.append(dataset_text.strip())

        # Self-talk (optional)
        if is_self_talk and self.self_talk_enabled:
            st_prompts = schema.get("self_talk", [])
            if st_prompts:
                import random
                parts.append(random.choice(st_prompts))

        parts.append(f"User: {user_text}")
        return "\n\n".join([p for p in parts if p])

    def _retrieve_dataset_snippet(self, full_text: str, user_text: str) -> str:
        try:
            tokens = [w.lower() for w in re.findall(r"\b\w+\b", user_text) if len(w) > 2]
            paragraphs = [p.strip() for p in full_text.split("\n") if p.strip()]
            scored: List[Tuple[int, str]] = []
            for para in paragraphs:
                l = para.lower()
                score = sum(1 for t in tokens if t in l)
                if score > 0:
                    scored.append((score, para))
            if not scored:
                return paragraphs[0][:500] if paragraphs else full_text[:500]
            scored.sort(key=lambda x: -x[0])
            top = [p for _, p in scored[:2]]
            return "\n".join(top)[:500]
        except Exception:
            return full_text[:500]

    # ────────────────────────── send / model
    def send_message(self) -> None:
        user_text = self.input_edit.toPlainText().strip()
        if not user_text:
            return

        # Broadcast to plugins
        try:
            self.core.plugins.broadcast(user_text)
        except Exception:
            pass

        # Slash commands → ensure applied to current persona+set
        if user_text.startswith("/"):
            self.input_edit.clear()
            persona = self._current_persona()
            set_name = self.current_set.get(persona, "default")
            try:
                out = self.core.run_command(user_text, persona=persona, set_name=set_name)
            except TypeError:
                # Back-compat signature
                out = self.core.run_command(user_text)
            self._append_message("System", out, role_key="system")
            if self.chk_semantic.isChecked() and not self.chk_isolated.isChecked():
                self.core.conversation_db.save_message("system", out)
            return

        # Normal message
        self.input_edit.clear()
        persona = self._current_persona()
        set_name = self.current_set.get(persona, "default")
        schema = self.core.schema_mgr.load_schema(persona, set_name)

        if self.chk_isolated.isChecked():
            self.isolated_history.append(("user", user_text))
        else:
            if self.chk_semantic.isChecked():
                self.core.conversation_db.save_message("user", user_text)

        try:
            user_schema = self.core.schema_mgr.load_schema("user", self.current_set.get("user", "default"))
            user_display = user_schema.get("name", "User")
        except Exception:
            user_display = "User"
        self._append_message(user_display, user_text, role_key="user")

        prompt = self._build_prompt(schema, user_text)

        self.btn_send.setEnabled(False)
        model_slug = self.model_combo.currentText().strip() or self.core.settings.default_model
        worker = ModelWorker(model_slug, prompt, parent=self.core)
        worker.finished.connect(lambda resp, usr=user_text, sch=schema: self._on_model_response(resp, usr, sch))
        worker.finished.connect(lambda: self.btn_send.setEnabled(True))
        worker.start()

    def _on_model_response(self, response_raw: str, user_text: str, schema: Dict[str, object]) -> None:
        model_slug = self.model_combo.currentText().strip()
        response = self._strip_reasoning(model_slug, response_raw)
        response, style_score = self._style_and_guard(response, schema)
        self.style_label.setText(f"Style: {style_score:.2f}")

        if self.chk_isolated.isChecked():
            self.isolated_history.append((schema.get("name", "bot"), response))
        else:
            if self.chk_semantic.isChecked():
                self.core.conversation_db.save_message(schema.get("name", "bot").lower(), response)

        persona_name = schema.get("name", "Bot") or "Bot"
        role_key = self._current_persona().lower()
        self._append_message(persona_name, response, role_key=role_key)
        self.response_edit.setPlainText(response)

        if not self.chk_mute_tts.isChecked():
            try:
                self.core.tts_mgr.enqueue(response)
            except Exception:
                pass

        self._enable_feedback(True)
        self._reset_idle_timer()

        try:
            tokens = [w.lower() for w in re.findall(r"\b\w+\b", user_text) if len(w) > 3]
            for t in tokens:
                self.update_overlay_topic(self._current_persona(), t)
            self.update_overlay_emotion(self._current_persona(), "neutral")
        except Exception:
            pass

        try:
            for line in response.split("\n"):
                if line.strip():
                    self.core.plugins.broadcast(line.strip())
        except Exception as e:
            print(f"Error broadcasting to plugins: {e}")

        if self.core.settings.auto_schema_enabled:
            self.progress_bar.setVisible(True)


            class EvolverWorker(QRunnable):
                def __init__(self, evolver, persona, set_name, history, window):
                    super().__init__()
                    self.evolver = evolver
                    self.persona = persona
                    self.set_name = set_name
                    self.history = history
                    self.window = window

                def run(self):
                    changed = self.evolver.update_schema(self.persona, self.set_name, self.history)
                    QtCore.QMetaObject.invokeMethod(
                        self.window, "_post_evolver", QtCore.Qt.QueuedConnection, QtCore.Q_ARG(bool, changed)
                    )

            QThreadPool.globalInstance().start(
                EvolverWorker(self.core.schema_evolver, self.active_persona, self.current_set.get(self.active_persona, "default"), self._current_history(), self)
            )

    @QtCore.pyqtSlot(bool)
    def _post_evolver(self, changed: bool) -> None:
        self.progress_bar.setVisible(False)
        if changed:
            self._flash_status("Schema adapted")

    def _strip_reasoning(self, model: str, response: str) -> str:
        if model and "deepseek" in model.lower():
            if "<think>" in response and "</think>" in response:
                try:
                    return response.split("</think>")[-1].strip() or response
                except Exception:
                    return response
        return response

    def _style_and_guard(self, text: str, schema: Dict[str, object]) -> Tuple[str, float]:
        exclam = text.count("!")
        sentences = [s for s in re.split(r"[.!?]", text) if s.strip()]
        avg_len = sum(len(s.split()) for s in sentences) / max(1, len(sentences))
        exclam_density = exclam / max(1, len(text))
        tone = schema.get("tone_rules", {"conciseness": [0.6, 0.8], "exclam_limit": 0.05})
        conciseness = max(0.0, min(1.0, (22 - avg_len) / 16.0))
        ex_ok = 1.0 if exclam_density <= float(tone.get("exclam_limit", 0.05)) else 0.5
        score = max(0.0, min(1.0, 0.5 * conciseness + 0.5 * ex_ok))
        return text, score

    def _rewrite_response(self, original: str) -> str:
        try:
            liked = self.core.feedback_db.get_liked_responses(limit=5)
        except Exception:
            liked = []
        schema = self.core.schema_mgr.load_schema(self._current_persona(), self.current_set.get(self._current_persona(), "default"))
        rps = schema.get("rewrite_prompts", [])
        template = rps[0] if rps else "Rewrite to be more appealing. Keep it accurate, concise, and on style."
        parts = [template]
        if liked:
            parts.append("Preferred responses:\n" + "\n\n".join(liked))
        parts.append("Original:\n" + original)
        parts.append("Rewritten:")
        prompt = "\n\n".join(parts)
        return self._run_model(self.model_combo.currentText().strip() or self.core.settings.default_model, prompt) or original

    def _run_model(self, model: str, prompt: str) -> str:
        try:
            proc = subprocess.run(
                ["ollama", "run", model],
                input=prompt.encode("utf-8"),
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                check=True,
            )
            return proc.stdout.decode("utf-8", errors="replace").strip()
        except subprocess.CalledProcessError as e:
            return e.stderr.decode("utf-8", errors="replace").strip()
        except FileNotFoundError:
            return "(error) ollama executable not found."
        except Exception as e:
            return f"(error) {e}"

    # ────────────────────────── persona / sets
    def _populate_set_combo(self, persona: str, combo: QtWidgets.QComboBox) -> None:
        combo.blockSignals(True)
        combo.clear()
        for s in self.core.schema_mgr.get_set_list(persona):
            combo.addItem(s)
        current = self.current_set.get(persona, "default")
        idx = combo.findText(current)
        combo.setCurrentIndex(idx if idx >= 0 else combo.findText("default"))
        if idx < 0:
            self.current_set[persona] = combo.currentText()
        combo.blockSignals(False)

    def _on_set_changed(self, persona: str, name: str, combo: QtWidgets.QComboBox) -> None:
        if not name:
            return
        self.current_set[persona] = name
        # keep AgentCore pointed to the right set if this persona is active
        if persona == self._current_persona():
            self.core.persona = persona
            self.core.set_name = name

        # refresh editor + commands row for this tab
        tab = self.tab_widgets.get(persona)
        if tab:
            editor = tab.findChild(QtWidgets.QPlainTextEdit, f"schema_edit_{persona}")
            if editor:
                schema = self.core.schema_mgr.load_schema(persona, name)
                editor.setPlainText(json.dumps(schema, indent=2))
            cmd_combo = tab.findChild(QtWidgets.QComboBox, f"cmd_combo_{persona}")
            if cmd_combo:
                self._populate_command_combo(persona, cmd_combo)

        # persist active sets & update controls tied to schema flags
        self.core.schema_mgr.save_active_schemas(self.current_set)
        self._sync_semantic_checkbox_from_schema()
        self._update_feedback_counts()

        # refresh slash command list if this persona is active
        try:
            if persona == self._current_persona():
                self._populate_command_select()
        except Exception:
            pass

    def _on_clone_set(self, persona: str, combo: QtWidgets.QComboBox) -> None:
        src = combo.currentText()
        name, ok = QtWidgets.QInputDialog.getText(self, "Clone Set", "Enter new set name:")
        if not ok or not name.strip():
            return
        new_name = name.strip()
        try:
            schema = self.core.schema_mgr.load_schema(persona, src)
            # Preserve the persona's canonical name; set label is separate
            schema["name"] = persona.capitalize()
            self.core.schema_mgr.save_schema(persona, new_name, schema)
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "Error", str(e))
            return
        self.current_set[persona] = new_name
        self._populate_set_combo(persona, combo)
        combo.setCurrentText(new_name)
        if persona == self._current_persona():
            self.core.set_name = new_name
        self.core.schema_mgr.save_active_schemas(self.current_set)
        self._sync_semantic_checkbox_from_schema()
        self._update_feedback_counts()

    def _on_new_set(self, persona: str, combo: QtWidgets.QComboBox) -> None:
        src = combo.currentText()
        name, ok = QtWidgets.QInputDialog.getText(self, "New Set", "Enter name for new set:")
        if not ok or not name.strip():
            return
        new_name = name.strip()
        try:
            schema = self.core.schema_mgr.load_schema(persona, src)
            # Preserve the persona's canonical name; set label is separate
            schema["name"] = persona.capitalize()
            self.core.schema_mgr.save_schema(persona, new_name, schema)
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "Error", str(e))
            return
        self.current_set[persona] = new_name
        self._populate_set_combo(persona, combo)
        combo.setCurrentText(new_name)
        if persona == self._current_persona():
            self.core.set_name = new_name
        self.core.schema_mgr.save_active_schemas(self.current_set)
        self._sync_semantic_checkbox_from_schema()
        self._update_feedback_counts()

    def _on_delete_set(self, persona: str, combo: QtWidgets.QComboBox) -> None:
        name = combo.currentText()
        if name == "default":
            QtWidgets.QMessageBox.information(self, "Cannot Delete", "The default set cannot be deleted.")
            return
        if QtWidgets.QMessageBox.question(
            self, "Delete Set", f"Delete '{name}' (irreversible)?", QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No
        ) != QtWidgets.QMessageBox.Yes:
            return
        try:
            set_dir = os.path.join(self.core.schema_mgr.schemas_dir, persona.lower(), "sets", name)
            import shutil
            shutil.rmtree(set_dir, ignore_errors=True)
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "Error", str(e))
            return
        self.current_set[persona] = "default"
        self._populate_set_combo(persona, combo)
        combo.setCurrentText("default")
        if persona == self._current_persona():
            self.core.set_name = "default"
        self.core.schema_mgr.save_active_schemas(self.current_set)
        self._sync_semantic_checkbox_from_schema()
        self._update_feedback_counts()

    def _on_save_schema(self, persona: str) -> None:
        tab = self.tab_widgets.get(persona)
        if not tab:
            return
        editor = tab.findChild(QtWidgets.QPlainTextEdit, f"schema_edit_{persona}")
        if not editor:
            return
        text = editor.toPlainText().strip()
        try:
            schema = json.loads(text)
            if not isinstance(schema, dict):
                raise ValueError
        except Exception:
            QtWidgets.QMessageBox.warning(self, "Invalid JSON", "The schema is not valid JSON.")
            return
        set_name = self.current_set.get(persona, "default")
        existing_schema = self.core.schema_mgr.load_schema(persona, set_name)
        merged_schema = {**existing_schema, **schema}
        # Ensure the top-level name matches the active set name
        try:
            merged_schema["name"] = set_name
        except Exception:
            pass
        self.core.schema_mgr.save_schema(persona, set_name, merged_schema)
        QtWidgets.QMessageBox.information(self, "Saved", f"Schema saved for {persona} ({set_name}).")

        if persona == self._current_persona():
            persona_voice = (merged_schema.get("voice") or "").lower()
            for i in range(self.voice_combo.count()):
                if persona_voice and persona_voice in self.voice_combo.itemText(i).lower():
                    self.voice_combo.setCurrentIndex(i)
                    break
        # After save, refresh commands combo (in case user edited commands JSON directly)
        tab = self.tab_widgets.get(persona)
        if tab:
            cmd_combo = tab.findChild(QtWidgets.QComboBox, f"cmd_combo_{persona}")
            if cmd_combo:
                self._populate_command_combo(persona, cmd_combo)

    def _tab_changed(self, index: int) -> None:
        if 0 <= index < len(self.core.schema_mgr.personas):
            self.active_persona = self.core.schema_mgr.personas[index]
        else:
            self.active_persona = self.core.schema_mgr.personas[0] if self.core.schema_mgr.personas else "zira"
        self.core.persona = self.active_persona

        schema = self.core.schema_mgr.load_schema(self.active_persona, self.current_set.get(self.active_persona, "default"))
        persona_voice = (schema.get("voice") or "").lower()
        for i in range(self.voice_combo.count()):
            if persona_voice and persona_voice in self.voice_combo.itemText(i).lower():
                self.voice_combo.setCurrentIndex(i)
                break

        tab = self.tab_widgets.get(self.active_persona)
        if tab:
            editor = tab.findChild(QtWidgets.QPlainTextEdit, f"schema_edit_{self.active_persona}")
            if editor:
                editor.setPlainText(json.dumps(schema, indent=2))
            cmd_combo = tab.findChild(QtWidgets.QComboBox, f"cmd_combo_{self.active_persona}")
            if cmd_combo:
                self._populate_command_combo(self.active_persona, cmd_combo)

        try:
            user_schema = self.core.schema_mgr.load_schema("user", self.current_set.get("user", "default"))
            bot_name = schema.get("name", self.active_persona.title())
            bot_set = self.current_set.get(self.active_persona, "default")
            user_name = user_schema.get("name", "User")
            user_set = self.current_set.get("user", "default")
            self.lbl_active_names.setText(f"{bot_name}: {bot_set} — User: {user_name}: {user_set}")
        except Exception:
            pass

        self._sync_semantic_checkbox_from_schema()
        self._update_feedback_counts()

        # refresh slash command dropdown on persona change
        try:
            self._populate_command_select()
        except Exception:
            pass

    def _current_persona(self) -> str:
        return self.active_persona

    # ────────────────────────── overlay helpers
    def update_overlay_topic(self, persona: str, topic: str) -> None:
        persona = persona.lower()
        try:
            schema = self.core.schema_mgr.load_schema(persona, self.current_set.get(persona, "default"))
            overlay = dict(schema.get("dynamic_overlay", {}))
            topics = list(overlay.get("recent_topics", []))
            if topic and topic not in topics:
                topics.append(topic)
                if len(topics) > 10:
                    topics = topics[-10:]
                overlay["recent_topics"] = topics
                schema["dynamic_overlay"] = overlay
                self.core.schema_mgr.save_schema(persona, self.current_set.get(persona, "default"), schema)
        except Exception:
            pass

    def update_overlay_emotion(self, persona: str, emotion: str) -> None:
        persona = persona.lower()
        try:
            schema = self.core.schema_mgr.load_schema(persona, self.current_set.get(persona, "default"))
            overlay = dict(schema.get("dynamic_overlay", {}))
            overlay["temporary_emotional_state"] = emotion
            schema["dynamic_overlay"] = overlay
            self.core.schema_mgr.save_schema(persona, self.current_set.get(persona, "default"), schema)
        except Exception:
            pass

    # ────────────────────────── devices & models
    def _populate_devices(self) -> None:
        self.device_combo.clear()
        try:
            if sd is not None:
                devs = [d.get("name", "?") for d in sd.query_devices() if d.get("max_input_channels", 0) > 0]
                if devs:
                    self.device_combo.addItems(devs)
        except Exception:
            pass
        if self.device_combo.count() == 0:
            self.device_combo.addItem("Default")

    def _populate_models(self) -> None:
        models: List[str] = []
        try:
            out = subprocess.run(
                ["ollama", "list"],
                stdout=subprocess.PIPE,
                stderr=subprocess.DEVNULL,
                text=True,
                check=True,
            ).stdout.splitlines()
            for line in out[1:]:
                parts = line.strip().split()
                if parts:
                    models.append(parts[0])
        except Exception:
            pass
        if not models:
            models = [self.core.settings.default_model or "mistral:latest"]
        self.model_combo.clear()
        self.model_combo.addItems(models)
        idx = self.model_combo.findText(self.core.settings.default_model)
        if idx >= 0:
            self.model_combo.setCurrentIndex(idx)

    # ────────────────────────── slash commands panel
    def _build_command_dock(self) -> None:
        """
        Build a dockable panel that exposes slash commands with an argument
        entry and send button. This allows users to trigger any command
        without typing it into the chat manually. It will be updated when
        persona or set changes.
        """
        dock = QtWidgets.QDockWidget("Slash Commands", self)
        dock.setObjectName("SlashCommandsDock")
        dock.setFeatures(
            QtWidgets.QDockWidget.DockWidgetClosable
            | QtWidgets.QDockWidget.DockWidgetMovable
            | QtWidgets.QDockWidget.DockWidgetFloatable
        )
        container = QtWidgets.QWidget()
        layout = QtWidgets.QVBoxLayout(container)
        layout.setContentsMargins(7, 7, 7, 7)
        layout.setSpacing(5)

        # command selector
        cmd_label = QtWidgets.QLabel("Slash Command:")
        self.command_select = QtWidgets.QComboBox()
        layout.addWidget(cmd_label)
        layout.addWidget(self.command_select)

        # argument input
        self.command_input = QtWidgets.QLineEdit()
        self.command_input.setPlaceholderText("Enter arguments or select text from chat…")
        layout.addWidget(self.command_input)

        # send button
        btn_run = QtWidgets.QPushButton("Run Command")
        btn_run.clicked.connect(self._on_run_command)
        layout.addWidget(btn_run)
        layout.addStretch(1)

        dock.setWidget(container)
        # add to right side by default
        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, dock)
        self.command_dock = dock

    def _populate_command_select(self) -> None:
        """
        Populate the slash command dropdown with available commands from
        the command registry. This is called whenever the active persona
        or set changes to reflect dynamic additions.
        """
        try:
            cmds = []
            if hasattr(self.core, "command_registry") and self.core.command_registry:
                cmds = list(self.core.command_registry.list_commands())
            # if schema defines additional commands, include them
            persona = self._current_persona()
            set_name = self.current_set.get(persona, "default")
            schema = self.core.schema_mgr.load_schema(persona, set_name)
            schema_cmds = list((schema.get("commands") or {}).keys())
            for c in schema_cmds:
                if c not in cmds:
                    cmds.append(c)
            cmds.sort()
        except Exception:
            cmds = []
        self.command_select.blockSignals(True)
        self.command_select.clear()
        if cmds:
            self.command_select.addItems(cmds)
        self.command_select.blockSignals(False)

    def _on_run_command(self) -> None:
        """
        Handler for running the selected slash command with the provided
        argument. The command will be executed via AgentCore and the
        result appended to the chat window. Selection text from the chat
        can be inserted into the argument field via context menu.
        """
        cmd = (self.command_select.currentText() or "").strip()
        if not cmd:
            QtWidgets.QMessageBox.information(self, "No Command", "Select a slash command to run.")
            return
        arg = self.command_input.text().strip()
        # combine command and arguments
        full = cmd if not arg else f"{cmd} {arg}"
        try:
            # process via core; record conversation
            resp = self.core.process_user_message(full, tts=False)
            # append user command and agent response to chat
            self._append_message("user", full, role_key="user")
            self._append_message("zira", resp, role_key="zira")
            # clear argument
            self.command_input.clear()
            # update feedback counts and idle timer
            self._update_feedback_counts()
            self._reset_idle_timer()
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "Command Error", str(e))

    def _show_chat_context_menu(self, pos: QtCore.QPoint) -> None:
        """
        Custom context menu for the chat view. Adds a menu entry to send
        selected text into the slash command argument field.
        """
        menu = self.chat_view.createStandardContextMenu()
        try:
            cursor = self.chat_view.textCursor()
            if cursor and cursor.hasSelection():
                action = menu.addAction("Send selection to command input")
                action.triggered.connect(self._send_selection_to_command_input)
        except Exception:
            pass
        menu.exec_(self.chat_view.mapToGlobal(pos))

    def _send_selection_to_command_input(self) -> None:
        """
        Copy the currently selected text in the chat view into the command
        input field for slash command execution.
        """
        try:
            cursor = self.chat_view.textCursor()
            if cursor and cursor.hasSelection():
                text = cursor.selectedText()
                self.command_input.setText(text.strip())
        except Exception:
            pass

    def _on_model_changed(self, name: str) -> None:
        """
        Update the default model in settings when the user selects a new
        model from the dropdown. This ensures the AgentCore uses the
        selected model for subsequent interactions.
        """
        try:
            if not name:
                return
            self.core.settings.default_model = name
            self.core.settings.save()
        except Exception:
            pass

    def _on_show_model_manager(self) -> None:
        """
        Show (or raise) the model manager dock. If the dock was
        previously hidden, it will be shown; if it is already visible,
        this will bring it to the front. A dock must be built in
        `_build_model_manager()` prior to showing.
        """
        try:
            if self.model_dock.isVisible():
                # already visible: raise to top
                self.model_dock.raise_()
            else:
                self.model_dock.show()
                self.model_dock.raise_()
        except Exception:
            pass

    # ────────────────────────── settings toggles
    def _on_auto_schema_toggled(self, checked: bool) -> None:
        try:
            self.core.settings.auto_schema_enabled = bool(checked)
            self.core.settings.save()
        except Exception:
            pass
        self.statusBar().showMessage(f"Auto Schema Evolution {'enabled' if checked else 'disabled'}", 2500)

    def _on_google_stt_toggled(self, checked: bool) -> None:
        """
        Opt-in/out of using Google Cloud Speech-to-Text. When enabling the
        toggle for the first time in a session, show a warning that
        recordings will be sent to Google’s servers under their privacy
        policy. If declined, the checkbox will be turned off again.
        """
        # Only show the dialog when transitioning from unchecked → checked
        try:
            current = bool(getattr(self.core.settings, "use_google_stt", False))
        except Exception:
            current = False
        if checked and not current:
            ok = QtWidgets.QMessageBox.question(
                self,
                "Enable Google STT?",
                "Audio will be uploaded to Google Cloud for transcription\n"
                "under Google's privacy policy. Continue?",
                QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No,
            )
            if ok != QtWidgets.QMessageBox.Yes:
                # revert checkbox silently
                self.chk_google_stt.blockSignals(True)
                self.chk_google_stt.setChecked(False)
                self.chk_google_stt.blockSignals(False)
                return
        # persist the new state
        try:
            self.core.settings.use_google_stt = bool(checked)
            self.core.settings.save()
        except Exception:
            pass

    # ────────────────────────── spell suggestions
    def _show_input_context_menu(self, pos: QtCore.QPoint) -> None:
        """
        Custom context menu on the input field that offers spelling
        suggestions when the user right-clicks a misspelled word. Only
        appears if pyspellchecker is available.
        """
        menu = self.input_edit.createStandardContextMenu()
        # compute suggestions only if SpellChecker is available
        if SpellChecker:
            cursor = self.input_edit.cursorForPosition(pos)
            # select the word under cursor
            cursor.select(QtGui.QTextCursor.WordUnderCursor)
            word = cursor.selectedText()
            if word and len(word) >= 3:
                sc = SpellChecker()
                suggestions = list(sc.candidates(word.lower()))
                # sort by Levenshtein distance and frequency; keep top 5
                suggestions = sorted(suggestions, key=lambda w: sc.word_probability(w), reverse=True)[:5]
                if suggestions and suggestions != [word.lower()]:
                    suggest_menu = menu.addMenu("Spelling suggestions")
                    for s in suggestions:
                        act = suggest_menu.addAction(s)
                        act.triggered.connect(lambda chk=False, repl=s, c=cursor: self._replace_word(c, repl))
        menu.exec_(self.input_edit.mapToGlobal(pos))

    def _replace_word(self, cursor: QtGui.QTextCursor, replacement: str) -> None:
        """
        Replace the word at the given cursor with a suggestion. This
        method is connected dynamically for each suggestion action.
        """
        try:
            cursor.beginEditBlock()
            cursor.removeSelectedText()
            cursor.insertText(replacement)
            cursor.endEditBlock()
        except Exception:
            pass

    def _on_semantic_toggled(self, checked: bool) -> None:
        """Persist semantic awareness per persona+set."""
        persona = self._current_persona()
        set_name = self.current_set.get(persona, "default")
        try:
            schema = self.core.schema_mgr.load_schema(persona, set_name)
            flags = dict(schema.get("flags") or {})
            flags["semantic_awareness"] = bool(checked)
            schema["flags"] = flags
            self.core.schema_mgr.save_schema(persona, set_name, schema)
        except Exception:
            pass
        self._reset_idle_timer()

    def _sync_semantic_checkbox_from_schema(self) -> None:
        """Load semantic_awareness from current schema into the checkbox."""
        persona = self._current_persona()
        set_name = self.current_set.get(persona, "default")
        try:
            schema = self.core.schema_mgr.load_schema(persona, set_name)
            flags = schema.get("flags", {})
            val = bool(flags.get("semantic_awareness", True))
        except Exception:
            val = True
        self.chk_semantic.blockSignals(True)
        self.chk_semantic.setChecked(val)
        self.chk_semantic.blockSignals(False)

    # ────────────────────────── status helper
    def _flash_status(self, msg: str) -> None:
        self.statusBar().showMessage(msg, 3000)


# ────────────────────────── Dock tray & titlebar
class DockTray(QtWidgets.QWidget):
    restoreRequested = QtCore.pyqtSignal(QtWidgets.QDockWidget)

    def __init__(self, parent: Optional[QtWidgets.QWidget] = None) -> None:
        super().__init__(parent)
        self._map: Dict[QtWidgets.QDockWidget, QtWidgets.QPushButton] = {}
        lay = QtWidgets.QHBoxLayout(self)
        lay.setContentsMargins(6, 4, 6, 4)
        lay.setSpacing(6)
        self._layout = lay
        self._title = QtWidgets.QLabel("Minimized panels:")
        self._title.setStyleSheet("color: #f0f0f0; font-weight: bold;")
        self._layout.addWidget(self._title, 0)
        self._layout.addStretch(1)
        self.setStyleSheet("background-color: #3c4a6b;")

    def register_dock(self, dock: QtWidgets.QDockWidget) -> None:
        dock.visibilityChanged.connect(lambda vis, d=dock: self._on_visibility_changed(d, vis))
        if not dock.isVisible():
            self._add_button(dock)

    def _on_visibility_changed(self, dock: QtWidgets.QDockWidget, visible: bool) -> None:
        if visible:
            self._remove_button(dock)
        else:
            self._add_button(dock)

    def _add_button(self, dock: QtWidgets.QDockWidget) -> None:
        if dock in self._map:
            return
        btn = QtWidgets.QPushButton(dock.windowTitle())
        btn.setToolTip(f"Restore {dock.windowTitle()}")
        btn.setStyleSheet(
            "background-color: #4a5b78; color: #ffffff; padding: 4px 6px; border: none; border-radius: 3px;"
        )
        btn.clicked.connect(lambda checked=False, d=dock: self._restore(d))
        self._layout.insertWidget(self._layout.count() - 1, btn)
        self._map[dock] = btn

    def _remove_button(self, dock: QtWidgets.QDockWidget) -> None:
        btn = self._map.pop(dock, None)
        if btn:
            self._layout.removeWidget(btn)
            btn.deleteLater()

    def _restore(self, dock: QtWidgets.QDockWidget) -> None:
        dock.show()
        dock.raise_()
        self.restoreRequested.emit(dock)


class DockTitleBar(QtWidgets.QWidget):
    def __init__(self, dock: QtWidgets.QDockWidget, title: str) -> None:
        super().__init__(dock)
        self._dock = dock
        h = QtWidgets.QHBoxLayout(self)
        h.setContentsMargins(6, 2, 6, 2)
        h.setSpacing(6)
        self.lbl = QtWidgets.QLabel(title)
        h.addWidget(self.lbl)
        h.addStretch()
        self.btn_min = QtWidgets.QToolButton()
        self.btn_min.setText("–")
        self.btn_min.setToolTip("Minimize to bottom tray")
        self.btn_min.clicked.connect(lambda checked=False: self._dock.hide())
        h.addWidget(self.btn_min)
        self.btn_max = QtWidgets.QToolButton()
        self.btn_max.setText("□")
        self.btn_max.setToolTip("Enlarge / Restore")
        self.btn_max.clicked.connect(self._on_toggle_maximize)
        h.addWidget(self.btn_max)
        self.btn_close = QtWidgets.QToolButton()
        self.btn_close.setText("×")
        self.btn_close.setToolTip("Close (send to bottom tray)")
        self.btn_close.clicked.connect(lambda checked=False: self._dock.hide())
        h.addWidget(self.btn_close)
        self.installEventFilter(self)

    def eventFilter(self, _obj: QtCore.QObject, evt: QtCore.QEvent) -> bool:
        if evt.type() == QtCore.QEvent.MouseButtonDblClick:
            self._dock.setFloating(not self._dock.isFloating())
            return True
        return False

    def _on_toggle_maximize(self) -> None:
        mw: Optional[QtWidgets.QMainWindow] = self._dock.parentWidget()  # type: ignore
        while mw and not isinstance(mw, QtWidgets.QMainWindow):
            mw = mw.parentWidget()  # type: ignore
        if not isinstance(mw, QtWidgets.QMainWindow):
            self._dock.setFloating(not self._dock.isFloating())
            return
        if not self._dock.isFloating():
            self._dock.setFloating(True)
            mw_geo = mw.geometry()
            w = int(mw_geo.width() * 0.9)
            h = int(mw_geo.height() * 0.85)
            self._dock.resize(w, h)
            center = mw_geo.center()
            self._dock.move(center.x() - w // 2, center.y() - h // 2)
        else:
            self._dock.setFloating(False)


# ────────────────────────── dataset manager dialog
class DatasetManagerDialog(QtWidgets.QDialog):
    def __init__(self, dataset_mgr, parent: Optional[QtWidgets.QWidget] = None) -> None:
        super().__init__(parent)
        self.setWindowTitle("Dataset Manager")
        self.resize(520, 420)
        self.dataset_mgr = dataset_mgr
        v = QtWidgets.QVBoxLayout(self)
        self.list_widget = QtWidgets.QListWidget()
        v.addWidget(self.list_widget, 1)
        h = QtWidgets.QHBoxLayout()
        self.btn_add = QtWidgets.QPushButton("Add Dataset")
        self.btn_del = QtWidgets.QPushButton("Delete Dataset")
        h.addWidget(self.btn_add)
        h.addWidget(self.btn_del)
        h.addStretch()
        v.addLayout(h)
        self._populate()
        self.btn_add.clicked.connect(self._on_add)
        self.btn_del.clicked.connect(self._on_delete)
        self.list_widget.itemChanged.connect(self._on_item)

    def _populate(self) -> None:
        self.list_widget.clear()
        for name, entry in sorted(self.dataset_mgr.entries.items()):
            item = QtWidgets.QListWidgetItem(name)
            item.setFlags(item.flags() | QtCore.Qt.ItemIsUserCheckable)
            item.setCheckState(QtCore.Qt.Checked if entry.active else QtCore.Qt.Unchecked)
            self.list_widget.addItem(item)

    def _on_add(self) -> None:
        name, ok = QtWidgets.QInputDialog.getText(self, "New Dataset", "Enter dataset name:")
        if not ok or not name.strip():
            return
        path, _ = QtWidgets.QFileDialog.getOpenFileName(self, "Select .txt or .pdf", "", "Text/PDF (*.txt *.pdf)")
        if not path:
            return
        try:
            self.dataset_mgr.add_dataset(name.strip(), path)
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "Error", str(e))
            return
        self._populate()

    def _on_delete(self) -> None:
        item = self.list_widget.currentItem()
        if not item:
            return
        name = item.text()
        if QtWidgets.QMessageBox.question(
            self, "Delete Dataset", f"Delete '{name}'?", QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No
        ) != QtWidgets.QMessageBox.Yes:
            return
        try:
            self.dataset_mgr.delete_dataset(name)
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "Error", str(e))
            return
        self._populate()

    def _on_item(self, item: QtWidgets.QListWidgetItem) -> None:
        self.dataset_mgr.toggle_active(item.text(), item.checkState() == QtCore.Qt.Checked)


# ────────────────────────── run as script
if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    win = AppWindow()
    win.show()
    sys.exit(app.exec_())
```

agent_ui.py
============

PyQt5 UI for the AI TTS Agent (integrated with AgentCore).

Fixes & additions:
- Slash commands (/remember etc.) now apply to the currently selected persona+set.
- Per-set "Semantic Awareness" persisted (schema.flags.semantic_awareness).
- RAG only uses datasets listed in the current set's schema ("datasets": [...]).
- Schema tab: new Commands row (dropdown + input + Add to Command + New Command).

To launch: `python run_agent.py`
**Classes:** _SpellHighlighter, AppWindow, DockTray, DockTitleBar, DatasetManagerDialog


## Module `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\_burner_scripts\bean_logic.py`

```python

"""
bean_logic.py
=============

Centralised reinforcement “bean” logic for profile‑scoped counters.

* **increment(profile, subject, delta, base_dir)** – adjust a counter by *delta* (clipped);
* **get_score(profile, subject, base_dir)** – retrieve the *decayed* score on demand;
* **score_band(score)** – map a numeric score to a qualitative colour band.

The module transparently handles persistence (JSON on disk) and exponential
decay so that old feedback gradually loses influence.

Decay model
-----------
Decay is applied lazily on reads using an exponential function:

    score(t) = score₀ · 0.5 ** ((t‑t₀) / HALFLIFE)

HALFLIFE defaults to seven days – after a week of inactivity the stored
score halves.

This design avoids expensive background jobs while ensuring stale feedback
fades out naturally.
"""

from __future__ import annotations

import json
import math
import os
import time
from typing import Dict, Tuple

# --------------------------------------------------------------------------- 
# Tunables
# --------------------------------------------------------------------------- 
HALFLIFE_SECS = 60 * 60 * 24 * 7          # 7 days
CLIP_MIN = -1_000
CLIP_MAX = 1_000
DATA_FILE = "bean_counts.json"

_CacheType = Dict[str, Dict[str, Dict[str, float]]]
_cache: _CacheType = {}                    # in‑memory cache keyed by base_dir

# --------------------------------------------------------------------------- 
# Helpers
# --------------------------------------------------------------------------- 
def _now() -> float:
    return time.time()

def _load(base_dir: str) -> _CacheType:
    """Load counts from disk into the process‑local cache."""
    if base_dir in _cache:
        return _cache[base_dir]
    path = os.path.join(base_dir, DATA_FILE)
    if os.path.isfile(path):
        try:
            with open(path, "r", encoding="utf-8") as f:
                _cache[base_dir] = json.load(f)
        except Exception:
            _cache[base_dir] = {}
    else:
        _cache[base_dir] = {}
    return _cache[base_dir]

def _save(store: _CacheType, base_dir: str) -> None:
    path = os.path.join(base_dir, DATA_FILE)
    os.makedirs(base_dir, exist_ok=True)
    try:
        with open(path, "w", encoding="utf-8") as f:
            json.dump(store, f, indent=2)
    except Exception:
        # non‑fatal; swallow to avoid cascading failures
        pass

# --------------------------------------------------------------------------- 
# Public API
# --------------------------------------------------------------------------- 
def increment(profile: str, subject: str, delta: int, *, base_dir: str = ".") -> None:
    """Adjust *subject* counter for *profile* by *delta* (± int)."""
    store = _load(base_dir)
    prof = store.setdefault(profile, {})
    rec = prof.setdefault(subject, {"count": 0.0, "t": _now()})
    # First apply decay to bring existing value current
    elapsed = _now() - rec["t"]
    if elapsed > 0:
        decay_factor = 0.5 ** (elapsed / HALFLIFE_SECS)
        rec["count"] *= decay_factor
    # Adjust & clip
    rec["count"] = max(CLIP_MIN, min(CLIP_MAX, rec["count"] + float(delta)))
    rec["t"] = _now()
    _save(store, base_dir)

def get_score(profile: str, subject: str, *, base_dir: str = ".") -> float:
    """Return the *decayed* score for (*profile*, *subject*)."""
    store = _load(base_dir)
    score = store.get(profile, {}).get(subject, {}).get("count", 0.0)
    last_t = store.get(profile, {}).get(subject, {}).get("t", _now())
    elapsed = _now() - last_t
    if elapsed <= 0:
        return score
    decay_factor = 0.5 ** (elapsed / HALFLIFE_SECS)
    return score * decay_factor

def score_band(score: float) -> str:
    """Map a score to a colour/descriptor band.

    Returns one of: 'critical', 'bad', 'neutral', 'good', 'excellent'.
    """
    if score <= -250:
        return "critical"
    if score <= -50:
        return "bad"
    if score <= 50:
        return "neutral"
    if score <= 250:
        return "good"
    return "excellent"
```

bean_logic.py
=============

Centralised reinforcement “bean” logic for profile‑scoped counters.

* **increment(profile, subject, delta, base_dir)** – adjust a counter by *delta* (clipped);
* **get_score(profile, subject, base_dir)** – retrieve the *decayed* score on demand;
* **score_band(score)** – map a numeric score to a qualitative colour band.

The module transparently handles persistence (JSON on disk) and exponential
decay so that old feedback gradually loses influence.

Decay model
-----------
Decay is applied lazily on reads using an exponential function:

    score(t) = score₀ · 0.5 ** ((t‑t₀) / HALFLIFE)

HALFLIFE defaults to seven days – after a week of inactivity the stored
score halves.

This design avoids expensive background jobs while ensuring stale feedback
fades out naturally.
**Functions:** _now(), _load(base_dir), _save(store, base_dir), increment(profile, subject, delta), get_score(profile, subject), score_band(score)


## Module `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\_burner_scripts\commands_panel.py`

```python
#!/usr/bin/env python3
"""
commands_panel.py
=================

This module defines the CommandsPanel class which encapsulates all of the
controls shown on the left-hand side of the agent UI.  It exposes all
widgets publicly so that the top-level application window can interact
with them directly (for example, enabling/disabling buttons or reading
checkbox state).  All callbacks for user actions (recording, dataset
management, TTS playback, etc.) are delegated back to the hosting
``AppWindow`` instance via the ``app`` attribute passed to the
constructor.  No core logic lives here – the panel is purely a view layer.
"""

from __future__ import annotations

import subprocess
from typing import List, Optional

from PyQt5 import QtCore, QtGui, QtWidgets

try:
    import sounddevice as sd  # type: ignore
except Exception:
    sd = None  # type: ignore
try:
    import numpy as np  # type: ignore
except Exception:
    np = None  # type: ignore


class CommandsPanel(QtWidgets.QWidget):
    """Left-side control panel for the agent UI.

    This widget contains all of the controls that previously lived in
    ``agent_ui.AppWindow._build_ui``.  It is responsible for building
    the interface elements but delegates all behavioural logic back to
    the hosting ``AppWindow`` via the ``app`` attribute.  The panel
    exposes its child widgets as attributes so that external code can
    reference them directly.
    """

    def __init__(self, app: 'AppWindow', parent: Optional[QtWidgets.QWidget] = None) -> None:
        super().__init__(parent)
        self.app = app
        self.core = app.core

        # Top-level layout for the panel
        cp_layout = QtWidgets.QVBoxLayout(self)
        cp_layout.setContentsMargins(7, 7, 7, 7)
        cp_layout.setSpacing(7)

        # ───── Recording controls
        rec_row = QtWidgets.QHBoxLayout()
        self.btn_record = QtWidgets.QPushButton("Record")
        self.btn_stop_rec = QtWidgets.QPushButton("Stop\nTranscribe")
        self.btn_stop_rec.setEnabled(False)
        for b in (self.btn_record, self.btn_stop_rec):
            b.setMinimumHeight(32)
            b.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        rec_row.addWidget(self.btn_record, 1)
        rec_row.addWidget(self.btn_stop_rec, 1)
        cp_layout.addLayout(rec_row)

        # ───── Microphone device selector
        mic_row = QtWidgets.QHBoxLayout()
        mic_row.addWidget(QtWidgets.QLabel("Mic:"))
        self.device_combo = QtWidgets.QComboBox()
        self._populate_devices()
        self.device_combo.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        mic_row.addWidget(self.device_combo, 1)
        cp_layout.addLayout(mic_row)

        # ───── Toggle checkboxes
        self.chk_semantic = QtWidgets.QCheckBox("Semantic Awareness")
        self.chk_semantic.setChecked(True)
        self.chk_isolated = QtWidgets.QCheckBox("Isolated Chat")
        self.chk_isolated.setChecked(False)
        self.chk_mute_tts = QtWidgets.QCheckBox("Mute TTS")
        self.chk_self_talk = QtWidgets.QCheckBox("Enable Self Talk")
        self.chk_self_talk.setChecked(False)
        self.chk_auto_schema = QtWidgets.QCheckBox("Auto Schema Evolution")
        try:
            self.chk_auto_schema.setChecked(bool(getattr(self.core.settings, "auto_schema_enabled", False)))
        except Exception:
            self.chk_auto_schema.setChecked(False)
        cp_layout.addWidget(self.chk_semantic)
        cp_layout.addWidget(self.chk_isolated)
        cp_layout.addWidget(self.chk_mute_tts)
        cp_layout.addWidget(self.chk_self_talk)
        cp_layout.addWidget(self.chk_auto_schema)

        # Optional Google STT toggle (default off)
        self.chk_google_stt = QtWidgets.QCheckBox("Google STT")
        try:
            self.chk_google_stt.setChecked(bool(getattr(self.core.settings, "use_google_stt", False)))
        except Exception:
            self.chk_google_stt.setChecked(False)
        cp_layout.addWidget(self.chk_google_stt)

        # ───── RAG cache clear
        self.btn_clear_rag = QtWidgets.QPushButton("Clear RAG Cache")
        cp_layout.addWidget(self.btn_clear_rag)

        # ───── Maintenance buttons
        self.btn_refresh = QtWidgets.QPushButton("Refresh Chat")
        self.btn_manage_datasets = QtWidgets.QPushButton("Manage Datasets")
        self.btn_inner_monologue = QtWidgets.QPushButton("Inner Monologue")
        for b in (self.btn_refresh, self.btn_manage_datasets, self.btn_inner_monologue):
            b.setMinimumHeight(32)
            b.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
            cp_layout.addWidget(b)

        # ───── Model manager
        self.btn_model_manager = QtWidgets.QPushButton("Model Manager")
        self.btn_model_manager.setMinimumHeight(32)
        self.btn_model_manager.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        cp_layout.addWidget(self.btn_model_manager)

        # ───── New: Commands palette launcher
        self.btn_commands_palette = QtWidgets.QPushButton("📋 Commands (Ctrl+/)")
        self.btn_commands_palette.setShortcut(QtGui.QKeySequence("Ctrl+/"))
        self.btn_commands_palette.setMinimumHeight(32)
        self.btn_commands_palette.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        cp_layout.addWidget(self.btn_commands_palette)

        # ───── New: Snapshot now
        self.btn_snapshot = QtWidgets.QPushButton("🗂 Snapshot Now")
        self.btn_snapshot.setMinimumHeight(32)
        self.btn_snapshot.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        cp_layout.addWidget(self.btn_snapshot)

        # ───── Style label
        self.style_label = QtWidgets.QLabel("Style: N/A")
        self.style_label.setToolTip("Style score (0–1): rough measure vs. tone rules.")
        cp_layout.addWidget(self.style_label)

        # ───── Response editor
        self.response_edit = QtWidgets.QPlainTextEdit()
        self.response_edit.setReadOnly(True)
        self.response_edit.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        cp_layout.addWidget(self.response_edit, 1)

        # ───── Feedback buttons
        fb = QtWidgets.QHBoxLayout()
        self.btn_like = QtWidgets.QPushButton("✔")
        self.btn_dislike = QtWidgets.QPushButton("✖")
        self.btn_like.setToolTip("Mark as good response")
        self.btn_dislike.setToolTip("Dislike and rewrite response")
        self.btn_like.setStyleSheet("color: #2ecc71; font-weight: bold;")
        self.btn_dislike.setStyleSheet("color: #e74c3c; font-weight: bold;")
        self.btn_like.setEnabled(False)
        self.btn_dislike.setEnabled(False)
        fb.addWidget(self.btn_like)
        fb.addWidget(self.btn_dislike)
        fb.addStretch()
        self.btn_manage_feedback = QtWidgets.QPushButton("Manage Feedback")
        fb.addWidget(self.btn_manage_feedback)
        cp_layout.addLayout(fb)

        # ───── TTS playback
        tts_row = QtWidgets.QHBoxLayout()
        self.btn_play = QtWidgets.QPushButton("Play")
        self.btn_stop_tts = QtWidgets.QPushButton("Stop")
        self.btn_replay = QtWidgets.QPushButton("Replay")
        for b in (self.btn_play, self.btn_stop_tts, self.btn_replay):
            b.setMinimumHeight(32)
            b.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        tts_row.addWidget(self.btn_play)
        tts_row.addWidget(self.btn_stop_tts)
        tts_row.addWidget(self.btn_replay)
        cp_layout.addLayout(tts_row)

        # ───── Voice & Model selectors
        voice_row = QtWidgets.QHBoxLayout()
        voice_row.addWidget(QtWidgets.QLabel("Voice:"))
        self.voice_combo = QtWidgets.QComboBox()
        voices = self._tts_voice_names()
        if voices:
            self.voice_combo.addItems([v for v in voices if "david" not in v.lower()])
        voice_row.addWidget(self.voice_combo, 1)
        cp_layout.addLayout(voice_row)

        model_row = QtWidgets.QHBoxLayout()
        model_row.addWidget(QtWidgets.QLabel("Model:"))
        self.model_combo = QtWidgets.QComboBox()
        self._populate_models()
        model_row.addWidget(self.model_combo, 1)
        cp_layout.addLayout(model_row)

        # ───── Feedback counts
        self.lbl_feedback_counts = QtWidgets.QLabel("Likes: 0 | Dislikes: 0")
        cp_layout.addWidget(self.lbl_feedback_counts)
        cp_layout.addStretch(1)

        # ───── Wire up callbacks to the hosting application ───────────────────

        # Recording controls
        self.btn_record.clicked.connect(self.app.start_recording)
        self.btn_stop_rec.clicked.connect(self.app.stop_recording)

        # Toggles
        self.chk_semantic.toggled.connect(self.app._on_semantic_toggled)
        self.chk_isolated.toggled.connect(self.app._on_isolated_toggled)
        self.chk_self_talk.toggled.connect(lambda v: setattr(self.app, "self_talk_enabled", v))
        self.chk_auto_schema.toggled.connect(self.app._on_auto_schema_toggled)
        try:
            self.chk_google_stt.toggled.connect(self.app._on_google_stt_toggled)
        except Exception:
            pass

        # Maintenance
        self.btn_clear_rag.clicked.connect(self.app._on_clear_rag_cache)
        self.btn_refresh.clicked.connect(self.app._on_refresh_chat)
        self.btn_manage_datasets.clicked.connect(self.app._on_manage_datasets)
        self.btn_inner_monologue.clicked.connect(self.app._on_inner_monologue)
        self.btn_model_manager.clicked.connect(self.app._on_show_model_manager)

        # **New** Commands palette
        self.btn_commands_palette.clicked.connect(self.app._on_show_command_palette)

        # **New** Snapshot now
        self.btn_snapshot.clicked.connect(lambda: (
            self.app.input_edit.setPlainText("/snapshot"),
            self.app.btn_send.click()
        ))

        # Feedback
        self.btn_like.clicked.connect(self.app._on_like)
        self.btn_dislike.clicked.connect(self.app._on_dislike)
        self.btn_manage_feedback.clicked.connect(self.app._on_manage_feedback)

        # TTS playback
        self.btn_play.clicked.connect(self.app._on_play)
        self.btn_stop_tts.clicked.connect(self.app._on_stop_tts)
        self.btn_replay.clicked.connect(self.app._on_replay)

        # Voice/model selection
        self.voice_combo.currentTextChanged.connect(self.app._on_voice_changed)
        self.model_combo.currentTextChanged.connect(self.app._on_model_changed)

    # ────────────────────────── devices & models helpers ──────────────────────────

    def _populate_devices(self) -> None:
        """Populate the microphone device selector with available input devices."""
        self.device_combo.clear()
        try:
            if sd is not None:
                devs = [d.get("name", "?") for d in sd.query_devices() if d.get("max_input_channels", 0) > 0]
                if devs:
                    self.device_combo.addItems(devs)
        except Exception:
            pass
        if self.device_combo.count() == 0:
            self.device_combo.addItem("Default")

    def _populate_models(self) -> None:
        """Populate the model selector with models discovered via ``ollama list``."""
        models: List[str] = []
        try:
            out = subprocess.run(
                ["ollama", "list"],
                stdout=subprocess.PIPE,
                stderr=subprocess.DEVNULL,
                text=True,
                check=True,
            ).stdout.splitlines()
            for line in out[1:]:
                parts = line.strip().split()
                if parts:
                    models.append(parts[0])
        except Exception:
            pass
        if not models:
            models = [self.core.settings.default_model or "mistral:latest"]
        self.model_combo.clear()
        self.model_combo.addItems(models)
        idx = self.model_combo.findText(self.core.settings.default_model)
        if idx >= 0:
            self.model_combo.setCurrentIndex(idx)

    def _tts_voice_names(self) -> List[str]:
        """Return a list of available TTS voice names from the TTS manager."""
        try:
            eng = getattr(self.core.tts_mgr, "_engine", None)
            if not eng:
                return []
            return [v.name for v in eng.getProperty("voices")]
        except Exception:
            return []
```

commands_panel.py
=================

This module defines the CommandsPanel class which encapsulates all of the
controls shown on the left-hand side of the agent UI.  It exposes all
widgets publicly so that the top-level application window can interact
with them directly (for example, enabling/disabling buttons or reading
checkbox state).  All callbacks for user actions (recording, dataset
management, TTS playback, etc.) are delegated back to the hosting
``AppWindow`` instance via the ``app`` attribute passed to the
constructor.  No core logic lives here – the panel is purely a view layer.
**Classes:** CommandsPanel


## Module `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\_burner_scripts\command_palette.py`

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
command_palette.py
==================

Dockable *Command Palette* for the AI TTS Agent UI.

• Live list of every “/slash-command” pulled from the orchestrator.
• Search-box with type-ahead filter.
• Global shortcut **Ctrl + /** opens / focuses the palette from anywhere.
• Double-click (or Return) on a command emits `commandActivated(str)` so the
  main window can insert the text into the chat-input.

Typical integration in *main_ui.py*:

    self.cmd_palette = CommandPaletteDock(self)
    self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.cmd_palette)
    self.core.commandsChanged.connect(self.cmd_palette.set_command_list)
    self.cmd_palette.commandActivated.connect(
        lambda cmd: self._insert_into_chat(cmd)
    )
"""

from __future__ import annotations

from typing import List

from PyQt5 import QtCore, QtGui, QtWidgets


class CommandPaletteDock(QtWidgets.QDockWidget):
    """Search-driven palette that lists all registered slash-commands."""

    # Emitted when user activates a command (double-click or Return)
    commandActivated = QtCore.pyqtSignal(str)

    # --------------------------------------------------------------------- init
    def __init__(
        self,
        main_window: QtWidgets.QMainWindow,
        title: str = "Command Palette",
        shortcut_seq: QtGui.QKeySequence | str = "Ctrl+/",
    ) -> None:
        super().__init__(title, parent=main_window)
        self.setObjectName("CommandPaletteDock")
        self.setAllowedAreas(
            QtCore.Qt.LeftDockWidgetArea
            | QtCore.Qt.RightDockWidgetArea
            | QtCore.Qt.BottomDockWidgetArea
        )
        self.setFeatures(
            QtWidgets.QDockWidget.DockWidgetClosable
            | QtWidgets.QDockWidget.DockWidgetMovable
        )

        # ---------- central widget
        container = QtWidgets.QWidget(self)
        vbox = QtWidgets.QVBoxLayout(container)
        vbox.setContentsMargins(6, 6, 6, 6)
        vbox.setSpacing(6)

        # Search bar ----------------------------------------------------------
        self.search_edit = QtWidgets.QLineEdit()
        self.search_edit.setPlaceholderText("Type to filter commands…")
        self.search_edit.textChanged.connect(self._apply_filter)
        vbox.addWidget(self.search_edit)

        # List view -----------------------------------------------------------
        self.list_widget = QtWidgets.QListWidget()
        self.list_widget.setSelectionMode(QtWidgets.QAbstractItemView.SingleSelection)
        self.list_widget.itemActivated.connect(self._on_item_activated)
        vbox.addWidget(self.list_widget, 1)

        self.setWidget(container)

        # ---------- Global shortcut (toggles palette)
        self._shortcut = QtWidgets.QShortcut(
            QtGui.QKeySequence(shortcut_seq), main_window
        )
        self._shortcut.activated.connect(self._toggle_palette)

        # Arrow / Esc handling inside search bar
        self.search_edit.installEventFilter(self)

        # Internal store of all commands
        self._all_cmds: List[str] = []

    # ---------------------------------------------------------------- public
    def set_command_list(self, commands: List[str]) -> None:
        """Replace full command list (keeps current filter string)."""
        self._all_cmds = sorted({c.strip() for c in commands if c.strip()})
        self._populate(self._all_cmds)
        self._apply_filter(self.search_edit.text())

    # --------------------------------------------------------------- internal
    def _populate(self, cmds: List[str]) -> None:
        self.list_widget.clear()
        for cmd in cmds:
            item = QtWidgets.QListWidgetItem(cmd)
            if cmd.startswith("/"):
                item.setToolTip(cmd[1:])  # tooltip without leading slash
            self.list_widget.addItem(item)

    # Filtering --------------------------------------------------------------
    def _apply_filter(self, text: str) -> None:
        pattern = text.lower().strip()
        self.list_widget.clear()
        if not pattern:
            for cmd in self._all_cmds:
                self.list_widget.addItem(cmd)
        else:
            for cmd in self._all_cmds:
                if pattern in cmd.lower():
                    self.list_widget.addItem(cmd)
        # Pre-select first row for fast Enter
        if self.list_widget.count():
            self.list_widget.setCurrentRow(0)

    # Activation -------------------------------------------------------------
    def _on_item_activated(self, item: QtWidgets.QListWidgetItem) -> None:
        self.commandActivated.emit(item.text())
        self.hide()  # optional UX: close palette after insert

    # Toggle visibility ------------------------------------------------------
    def _toggle_palette(self) -> None:
        if self.isVisible():
            self.hide()
        else:
            self.show()
            self.raise_()
            self.search_edit.setFocus(QtCore.Qt.ShortcutFocusReason)

    # Key handling (Esc / arrows / Enter) ------------------------------------
    def eventFilter(self, obj: QtCore.QObject, ev: QtCore.QEvent) -> bool:
        if obj is self.search_edit and ev.type() == QtCore.QEvent.KeyPress:
            key = ev.key()
            if key == QtCore.Qt.Key_Escape:
                if self.search_edit.text():
                    self.search_edit.clear()
                else:
                    self.hide()
                return True
            if key in (QtCore.Qt.Key_Down, QtCore.Qt.Key_Up):
                QtWidgets.QApplication.sendEvent(self.list_widget, ev)
                return True
            if key == QtCore.Qt.Key_Return:
                current = self.list_widget.currentItem()
                if current:
                    self._on_item_activated(current)
                return True
        return super().eventFilter(obj, ev)
```

command_palette.py
==================

Dockable *Command Palette* for the AI TTS Agent UI.

• Live list of every “/slash-command” pulled from the orchestrator.
• Search-box with type-ahead filter.
• Global shortcut **Ctrl + /** opens / focuses the palette from anywhere.
• Double-click (or Return) on a command emits `commandActivated(str)` so the
  main window can insert the text into the chat-input.

Typical integration in *main_ui.py*:

    self.cmd_palette = CommandPaletteDock(self)
    self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.cmd_palette)
    self.core.commandsChanged.connect(self.cmd_palette.set_command_list)
    self.cmd_palette.commandActivated.connect(
        lambda cmd: self._insert_into_chat(cmd)
    )
**Classes:** CommandPaletteDock


## Module `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\_burner_scripts\config_mgr.py`

```python
"""
config_mgr.py
================

Simple configuration manager for per-profile user preferences.  This module
implements a JSON‑backed store keyed by persona name.  It exposes helper
functions to load and save configuration data in a thread‑safe manner.

The configuration file is created in the user’s home directory so that
preferences persist across sessions.  You can easily extend the schema by
adding new fields at the profile level.
"""

from __future__ import annotations

import json
import threading
from pathlib import Path
from typing import Any, Dict, Optional

# Path to the user configuration file.  Use home directory for portability.
CONFIG_PATH = Path.home() / ".ai_tts_user_config.json"

# Lock to protect concurrent writes to the config file.
_lock = threading.RLock()


def load() -> Dict[str, Any]:
    """Load the entire configuration from disk.  Returns an empty config
    structure if the file does not exist or is malformed."""
    if CONFIG_PATH.exists():
        try:
            data = json.loads(CONFIG_PATH.read_text(encoding="utf-8"))
            if isinstance(data, dict):
                return data
        except Exception:
            pass
    return {"profiles": {}}


def save(cfg: Dict[str, Any]) -> None:
    """Persist the given configuration to disk.  The write is atomic and
    protected by a lock to avoid partial writes from concurrent threads."""
    with _lock:
        try:
            CONFIG_PATH.write_text(json.dumps(cfg, indent=2), encoding="utf-8")
        except Exception:
            pass


def set_profile_value(profile: str, key: str, value: Any) -> None:
    """Set a configuration entry for a given profile.  Creates the profile
    section if it does not already exist.  Saves the configuration after
    updating."""
    cfg = load()
    profiles = cfg.setdefault("profiles", {})
    prof_cfg = profiles.setdefault(profile, {})
    prof_cfg[key] = value
    save(cfg)


def get_profile_value(profile: str, key: str, default: Optional[Any] = None) -> Any:
    """Retrieve a value from the profile configuration.  If the profile or
    key does not exist, returns *default*."""
    cfg = load()
    return cfg.get("profiles", {}).get(profile, {}).get(key, default)
```

config_mgr.py
================

Simple configuration manager for per-profile user preferences.  This module
implements a JSON‑backed store keyed by persona name.  It exposes helper
functions to load and save configuration data in a thread‑safe manner.

The configuration file is created in the user’s home directory so that
preferences persist across sessions.  You can easily extend the schema by
adding new fields at the profile level.
**Functions:** load(), save(cfg), set_profile_value(profile, key, value), get_profile_value(profile, key, default)


## Module `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\_burner_scripts\core_base.py`

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
core_base.py — foundational services for the modular AI-TTS Agent
=================================================================
• robust logging + graceful shims for missing deps
• Ollama model bootstrap  (ensure_models_present)
• JSON-backed Settings
• profile-aware helper paths
• ConversationDB  (SQLite)
• SemanticFeedbackDB  (SQLite)
• BeanCounter  (JSON tally)
• ReinforcementStore  (async JSONL append)
• cross-platform TTS locked to *Zira*
• minimal AudioRecorder placeholder
Everything here is UI-agnostic.
"""

from __future__ import annotations

# ───────────────────────── stdlib
import json, os, sys, time, sqlite3, subprocess, threading, logging
from typing import Dict, List, Tuple, Any, Optional

# ───────────────────────── agent store (low-level SQLite wrapper)
# NOTE: new canonical name is AgentStore; legacy code still imports FathomStore.
from agent_store import AgentStore
FathomStore = AgentStore            # ← back-compat alias — remove after migration

# ───────────────────────── logging
logger = logging.getLogger("agent_core")
if not logger.handlers:
    lvl = os.getenv("AGENT_CORE_LOGLEVEL", "INFO").upper()
    logging.basicConfig(
        level=getattr(logging, lvl, logging.INFO),
        format="%(asctime)s [%(levelname)s] %(name)s: %(message)s",
    )

# ───────────────────────── default personas / voices (shared constants)
DEFAULT_PERSONAS: Dict[str, Dict[str, Any]] = {
    # hard-coded starter persona — editable via UI
    "Zira Valen": {
        "display_name": "Zira Valen",
        "color":        "#ff69b4",      # pink
        "temperature":  0.7,
        "system_prompt": (
            "You are Zira Valen – a daring, playful companion who loves coding, "
            "hates restrictions, and will work hard for the user."
        ),
    }
}
DEFAULT_VOICES: List[str] = ["Zira", "David", "Jenny"]

# ───────────────────────── optional deps
try:
    import numpy as np                               # type: ignore
except Exception:
    np = None
    logger.info("numpy not available")

try:
    import sounddevice as sd                         # type: ignore
    import soundfile as sf                           # type: ignore
except Exception:
    sd = sf = None
    logger.info("sounddevice / soundfile not available")

try:
    from google.cloud import speech as gspeech       # type: ignore
    import pyaudio                                   # type: ignore
except Exception:
    gspeech = pyaudio = None
    logger.info("google-STT not available")

try:
    import pyttsx3                                   # type: ignore
except Exception:
    pyttsx3 = None
    logger.info("pyttsx3 not available")

try:
    from sentence_transformers import SentenceTransformer  # type: ignore
except Exception:
    SentenceTransformer = None
    logger.info("sentence_transformers not available")

# ───────────────────────── minimal Qt shim (if PyQt5 missing)
try:
    from PyQt5 import QtCore                         # type: ignore
except Exception:
    class _ShimSignal:                               # type: ignore
        def __init__(self,*_,**__): pass
        def connect(self,*_,**__): pass
        def emit(self,*_,**__):    pass
    class _ShimQObject:                              # type: ignore
        def __init__(self,*args,**kwargs) -> None: pass
    QtCore = type("QtCore", (), {                    # type: ignore
        "QObject": _ShimQObject,
        "pyqtSignal": lambda *a, **k: _ShimSignal(),
    })

# ══════════════════ Ollama bootstrap ══════════════════
REQUIRED_MODELS: List[str] = [
    "gemma3:27b",
    "mistral:latest",
    "codellama:latest",
    "llava:latest",
    "mxbai-embed-large:latest",
    "snowflake-arctic-embed:latest",
]

def _have_cli(cmd: str) -> bool:
    from shutil import which
    return which(cmd) is not None

def ensure_models_present() -> None:
    """Best-effort pull of REQUIRED_MODELS (never raises)."""
    if not _have_cli("ollama"):
        logger.info("[bootstrap] ollama not on PATH – skipping model pull")
        return
    try:
        listed = subprocess.check_output(
            ["ollama", "list"], timeout=5, stderr=subprocess.STDOUT
        ).decode(errors="ignore")
    except Exception as exc:
        logger.warning("[bootstrap] ollama list failed: %s", exc)
        return
    for slug in REQUIRED_MODELS:
        if slug in listed:
            continue
        logger.info("[bootstrap] pulling %s …", slug)
        try:
            subprocess.run(["ollama", "pull", slug], timeout=900)
        except Exception as exc:
            logger.warning("[bootstrap] pull %s failed: %s", slug, exc)

# ══════════════════ Settings ══════════════════
class Settings:
    """Lightweight JSON settings (forward-compatible)."""
    def __init__(self, base_dir: str):
        self.base_dir = base_dir
        self.path     = os.path.join(base_dir, "settings.json")
        # defaults
        self.default_model: str  = "mistral:latest"
        self.context_depth: int  = 20
        self.auto_schema_enabled = True
        self.monologue_tts_enabled = False
        self.monologue_volume = 50
        self.load()

    def load(self) -> None:
        try:
            if os.path.isfile(self.path):
                with open(self.path, encoding="utf-8") as fh:
                    self.__dict__.update(json.load(fh))
        except Exception as exc:
            logger.warning("[Settings] load error: %s", exc)

    def save(self) -> None:
        try:
            os.makedirs(os.path.dirname(self.path), exist_ok=True)
            with open(self.path, "w", encoding="utf-8") as fh:
                json.dump(
                    {k: v for k, v in self.__dict__.items()
                     if k not in {"base_dir", "path"}}, fh, indent=2
                )
        except Exception as exc:
            logger.warning("[Settings] save error: %s", exc)

# ══════════════════ helper paths ══════════════════
def prof_dir(b: str, persona: str, set_name: str) -> str:
    return os.path.join(b, "profiles", persona, set_name)

def conv_db_path(b: str, persona: str, set_name: str) -> str:
    return os.path.join(b, "conversations", f"{persona}_{set_name}.sqlite3")

def feedback_db_path(b: str, persona: str, set_name: str) -> str:
    return os.path.join(b, "feedback", f"{persona}_{set_name}.sqlite3")

def beans_path(b: str, persona: str, set_name: str) -> str:
    return os.path.join(b, "profiles", persona, set_name, "reinforcement.json")

# ══════════════════ SQLite helpers ══════════════════
class ConversationDB:
    """Thread-safe conversation log (SQLite)."""
    def __init__(self, path: str):
        os.makedirs(os.path.dirname(path), exist_ok=True)
        self._lock = threading.RLock()
        self.conn  = sqlite3.connect(path, check_same_thread=False)
        with self._lock:
            self.conn.execute(
                "CREATE TABLE IF NOT EXISTS conversation("
                "id INTEGER PRIMARY KEY AUTOINCREMENT,"
                "ts REAL, role TEXT, content TEXT)"
            )
            self.conn.commit()

    def save(self, role: str, content: str) -> None:
        with self._lock:
            self.conn.execute(
                "INSERT INTO conversation(ts, role, content) VALUES (?,?,?)",
                (time.time(), role, content),
            )
            self.conn.commit()

    def fetch(self, limit: int = 50) -> List[Tuple[str, str]]:
        with self._lock:
            cur = self.conn.cursor()
            cur.execute(
                "SELECT role, content FROM conversation "
                "ORDER BY id DESC LIMIT ?", (limit,)
            )
            rows = cur.fetchall()
        return rows[::-1]

    # -------------------------------------------------------------------
    # Legacy compatibility methods
    # -------------------------------------------------------------------
    def save_message(self, role: str, content: str) -> None:
        """Alias for save() kept for backward compatibility."""
        self.save(role, content)

    def fetch_history(self, limit: int = 50) -> List[Tuple[str, str]]:
        """Alias for fetch() kept for backward compatibility."""
        return self.fetch(limit)

class SemanticFeedbackDB:
    """Stores like / dislike feedback with optional rewrites."""
    def __init__(self, path: str, beans: 'BeanCounter'):
        os.makedirs(os.path.dirname(path), exist_ok=True)
        self._lock = threading.RLock()
        self.conn  = sqlite3.connect(path, check_same_thread=False)
        self.beans = beans
        with self._lock:
            self.conn.execute(
                "CREATE TABLE IF NOT EXISTS feedback("
                "id INTEGER PRIMARY KEY AUTOINCREMENT,"
                "ts REAL, original TEXT, liked INT, revised TEXT)"
            )
            self.conn.commit()

    def add(self, original: str, liked: bool, revised: str | None = None):
        with self._lock:
            self.conn.execute(
                "INSERT INTO feedback(ts, original, liked, revised) VALUES (?,?,?,?)",
                (time.time(), original, int(liked), revised),
            )
            self.conn.commit()
        # reinforcement key (hash truncated)
        key = f"resp_{abs(hash(original))%10007}"
        self.beans.inc(key, 1 if liked else -1)

    def counts(self) -> Tuple[int, int]:
        with self._lock:
            cur = self.conn.cursor()
            cur.execute("SELECT COUNT(*) FROM feedback WHERE liked=1")
            pos = cur.fetchone()[0]
            cur.execute("SELECT COUNT(*) FROM feedback WHERE liked=0")
            neg = cur.fetchone()[0]
        return pos, neg

    # -------------------------------------------------------------------
    # Legacy compatibility methods
    # -------------------------------------------------------------------
    def get_counts(self) -> Tuple[int, int]:
        """Alias for counts() kept for backward compatibility."""
        return self.counts()

    def get_liked_responses(self, limit: int = 5) -> List[str]:
        """
        Return a list of recently liked responses. If a revised version exists it is returned,
        otherwise the original text is used. Newer entries are returned first.
        """
        try:
            with self._lock:
                cur = self.conn.cursor()
                cur.execute(
                    "SELECT COALESCE(revised, original) FROM feedback "
                    "WHERE liked=1 ORDER BY id DESC LIMIT ?",
                    (limit,),
                )
                rows = cur.fetchall()
            return [r[0] for r in rows]
        except Exception:
            return []

# ══════════════════ BeanCounter ══════════════════
class BeanCounter:
    """Tiny reinforcement ledger (JSON, thread-safe)."""
    def __init__(self, path: str):
        self.path = path
        self.lock = threading.Lock()
        self.counts: Dict[str, int] = {}
        self._load()

    def _load(self) -> None:
        try:
            if os.path.isfile(self.path):
                with open(self.path, encoding="utf-8") as fh:
                    self.counts = json.load(fh)
        except Exception:
            self.counts = {}

    def _save(self) -> None:
        try:
            os.makedirs(os.path.dirname(self.path), exist_ok=True)
            with open(self.path, "w", encoding="utf-8") as fh:
                json.dump(self.counts, fh, indent=2)
        except Exception as exc:
            logger.error("[BeanCounter] save error: %s", exc)

    def inc(self, key: str, delta: int = 1) -> None:
        with self.lock:
            self.counts[key] = self.counts.get(key, 0) + delta
        self._save()

# ══════════════════ ReinforcementStore ══════════════════
class ReinforcementStore:
    """
    Async JSONL writer for reinforcement facts.
    • add_fact(field, value, persona, source="schema")
    """
    def __init__(self, path: str):
        self.path  = path
        self._lock = threading.Lock()
        self._q: list[dict[str, Any]] = []
        self._stop = threading.Event()
        self._thr  = threading.Thread(target=self._writer, daemon=True)
        self._thr.start()

    # ----- public
    def add_fact(self, field: str, value: str, persona: str, source: str = "schema") -> None:
        with self._lock:
            self._q.append({
                "ts": time.time(),
                "field": field,
                "value": value,
                "persona": persona,
                "source": source,
            })

    def close(self) -> None:
        self._stop.set()
        self._thr.join(timeout=1.5)

    # ----- worker
    def _writer(self) -> None:
        while not self._stop.is_set():
            item = None
            with self._lock:
                if self._q:
                    item = self._q.pop(0)
            if item is None:
                self._stop.wait(0.05)
                continue
            try:
                os.makedirs(os.path.dirname(self.path), exist_ok=True)
                with open(self.path, "a", encoding="utf-8") as fh:
                    json.dump(item, fh)
                    fh.write("\n")
            except Exception as exc:
                logger.error("[ReinforcementStore] write error: %s", exc)

# ══════════════════ TTS locked to Zira ══════════════════
class TTSManager(QtCore.QObject):
    finished = QtCore.pyqtSignal()

    def __init__(self, parent: QtCore.QObject | None = None):
        super().__init__(parent)
        self._engine = None
        if pyttsx3 is not None:
            try:
                self._engine = pyttsx3.init("sapi5" if sys.platform.startswith("win") else None)
                voice_id = None
                for v in self._engine.getProperty("voices"):
                    if "zira" in (v.name or "").lower():
                        voice_id = v.id; break
                if not voice_id:
                    for v in self._engine.getProperty("voices"):
                        if "david" not in (v.name or "").lower():
                            voice_id = v.id; break
                if voice_id:
                    self._engine.setProperty("voice", voice_id)
            except Exception as exc:
                logger.warning("[TTS] init error: %s", exc)
                self._engine = None

        # remember last spoken text for replay functionality
        self._last_text: Optional[str] = None

    def speak(self, text: str) -> None:
        """
        Synchronously speak the provided text. This uses the underlying pyttsx3 engine
        on a background thread and emits the finished signal when done.
        """
        if self._engine is None:
            return
        # remember last spoken text for replay
        self._last_text = text

        def _go() -> None:
            try:
                self._engine.say(text)
                self._engine.runAndWait()
            except Exception as exc:
                logger.warning("[TTS] speak error: %s", exc)
            finally:
                self.finished.emit()

        threading.Thread(target=_go, daemon=True).start()

    # -------------------------------------------------------------------
    # Legacy compatibility methods
    # -------------------------------------------------------------------
    def enqueue(self, text: str) -> None:
        """
        Queue a piece of text for playback. For this simple implementation we
        speak immediately. The last text is cached for replay().
        """
        self.speak(text)

    def stop(self) -> None:
        """Stop any ongoing speech."""
        try:
            if self._engine is not None:
                # pyttsx3 has stop() to immediately stop speaking
                self._engine.stop()
        except Exception as exc:
            logger.warning("[TTS] stop error: %s", exc)

    def replay(self) -> None:
        """Replay the last enqueued text."""
        if self._last_text:
            self.speak(self._last_text)

# ══════════════════ minimal AudioRecorder ══════════════════
class AudioRecorder(QtCore.QObject):
    transcribed = QtCore.pyqtSignal(str)

    def __init__(self, parent: QtCore.QObject | None = None):
        super().__init__(parent)
        self._frames: List[Any] = []
        self._recording = False
        self._stream: Any = None

    def list_devices(self) -> List[str]:
        if sd is None:
            return []
        return [d["name"] for d in sd.query_devices() if d.get("max_input_channels", 0) > 0]

    def start(self, device_index: int | None = None) -> None:
        if sd is None or np is None or self._recording:
            return
        self._frames.clear()
        def cb(indata, frames, time_info, status):
            self._frames.append(indata.copy())
        self._stream = sd.InputStream(
            samplerate=16000, channels=1, callback=cb, device=device_index
        )
        self._stream.start()
        self._recording = True

    def stop_and_transcribe(self) -> None:
        if not self._recording or sd is None or np is None:
            return
        self._recording = False
        self._stream.stop()
        data = np.concatenate(self._frames, axis=0)
        sf.write("temp.wav", data, 16000)
        threading.Thread(target=lambda: self.transcribed.emit(""), daemon=True).start()

# ══════════════════ public surface ══════════════════
__all__ = [
    "logger",
    "ensure_models_present",
    "Settings",
    "prof_dir",
    "conv_db_path",
    "feedback_db_path",
    "beans_path",
    "ConversationDB",
    "SemanticFeedbackDB",
    "BeanCounter",
    "ReinforcementStore",
    "TTSManager",
    "AudioRecorder",
    "SentenceTransformer",
    "DEFAULT_PERSONAS",
    "DEFAULT_VOICES",
    "FathomStore",       # legacy alias (kept for now)
]
```

core_base.py — foundational services for the modular AI-TTS Agent
=================================================================
• robust logging + graceful shims for missing deps
• Ollama model bootstrap  (ensure_models_present)
• JSON-backed Settings
• profile-aware helper paths
• ConversationDB  (SQLite)
• SemanticFeedbackDB  (SQLite)
• BeanCounter  (JSON tally)
• ReinforcementStore  (async JSONL append)
• cross-platform TTS locked to *Zira*
• minimal AudioRecorder placeholder
Everything here is UI-agnostic.
**Classes:** Settings, ConversationDB, SemanticFeedbackDB, BeanCounter, ReinforcementStore, TTSManager, AudioRecorder
**Functions:** _have_cli(cmd), ensure_models_present(), prof_dir(b, persona, set_name), conv_db_path(b, persona, set_name), feedback_db_path(b, persona, set_name), beans_path(b, persona, set_name)


## Module `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\_burner_scripts\core_orchestrator.py`

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
core_orchestrator.py
====================

This module provides the orchestration layer for the AI‑TTS agent.  It
exposes a unified API used by the user‑interface to interact with
schemas, conversations, commands, text‑to‑speech, plugins and other
components.  Historically the logic lived in a monolithic module,
but it has been refactored to encourage testability and to allow
individual subsystems to evolve independently.

The principal differences from earlier releases are:

* A richer :class:`PluginManager` that exposes a complete API expected
  by the UI.  In addition to discovering plugin packages from the
  ``plugins`` directory it now keeps per‑plugin metadata, supports
  enable/disable toggling, rescans at runtime, broadcasts messages to
  enabled plugins on a thread pool, and emits an ``eventReceived``
  signal whenever a plugin reports an event.  Plugins can either
  return a payload from their ``on_message`` handler or call
  ``emit_event`` on the manager directly to publish complex events.

* A ``run_command()`` method on :class:`AgentCore` which forwards
  slash commands through the :class:`CommandExecutor` and returns
  the textual result.  This helper centralises command routing and
  ensures backwards compatibility with older UI code.

* A ``process_user_message()`` method on :class:`AgentCore` which
  synchronously handles both slash‑commands and normal user input.  It
  persists the conversation, routes commands through the registry
  and, for non‑commands, returns a simple acknowledgement.  Future
  versions may integrate model execution here, but the method
  signature is stable for consumers.

* A ``command_registry`` attribute is exposed on the core as an
  adapter with a ``list_commands()`` method so that UI components
  (like the Command Palette) can enumerate available commands without
  coupling to internal registry details.

This file is fully self‑contained.  It gracefully degrades when
optional dependencies (such as PyQt5 or external model executables)
are unavailable by providing shims and in‑memory fallbacks.  Should
the optional modules exist in the runtime environment they will be
used automatically.  The design favours clear separation of
responsibilities, thread safety and explicit interfaces to ease
maintenance and extensibility.
"""

from __future__ import annotations

import importlib
import json
import os
import pathlib
import re
import subprocess
import threading
import time
from dataclasses import dataclass, field
from typing import Any, Dict, Iterable, List, Optional, Tuple

# Optional Qt import.  When PyQt5 is not available we fall back to a
# minimal shim so that type annotations and pyqtSignal declarations do
# not cause NameErrors.  The shim mimics only the parts of Qt used
# throughout this module.
try:
    from PyQt5 import QtCore  # type: ignore[assignment]
except Exception:
    class _ShimSignal:
        def __init__(self, *_, **__):
            pass
        def connect(self, *_, **__):
            pass
        def emit(self, *_, **__):
            pass

    class _ShimQObject:
        def __init__(self, *_, **__):
            pass

    # Create a very small QtCore replacement with the attributes we need.
    QtCore = type(
        "QtCore",
        (),
        {
            "QObject": _ShimQObject,
            "QThread": _ShimQObject,
            "pyqtSignal": lambda *a, **k: _ShimSignal(),
            "QTimer": type(
                "QTimer",
                (),
                {
                    "singleShot": staticmethod(lambda msec, func: None),
                },
            ),
        },
    )  # type: ignore

# ----------------------------------------------------------------------------
# Fallbacks for optional internal modules
#
# When the canonical ``core_base`` and ``core_schema`` modules are present
# they are imported normally.  If missing (for example during unit tests or
# headless operation) minimal stubs are provided to allow the remainder of
# this module to execute without crashing.  The stubs implement only the
# methods referenced by the UI.
# ----------------------------------------------------------------------------
try:
    # pylint: disable=unused-import
    from core_base import (
        Settings,
        TTSManager,
        AudioRecorder,
        conv_db_path,
        feedback_db_path,
        beans_path,
        ConversationDB,
        SemanticFeedbackDB,
        BeanCounter,
        ReinforcementStore,
        logger,
    )
    from core_schema import (
        SchemaManager,
        OperatorManager,
        DatasetManager,
    )
except Exception:
    # Provide very small stand‑ins for the missing classes and helpers.
    import logging

    logger = logging.getLogger("core_orchestrator_stub")

    class Settings:
        """In‑memory settings fallback."""
        def __init__(self, base_dir: str) -> None:
            self.base_dir = base_dir
            self.default_model: str = "mistral:latest"
            self.context_depth: int = 20
            self.auto_schema_enabled: bool = True
            self.use_google_stt: bool = False
        def save(self) -> None:
            # Persist settings to a JSON file in base_dir if possible
            path = os.path.join(self.base_dir, "settings.json")
            try:
                with open(path, "w", encoding="utf-8") as fh:
                    json.dump({
                        "default_model": self.default_model,
                        "context_depth": self.context_depth,
                        "auto_schema_enabled": self.auto_schema_enabled,
                        "use_google_stt": self.use_google_stt,
                    }, fh, indent=2)
            except Exception:
                pass

    class TTSManager:
        """No‑op TTS manager used when speech synthesis isn't available."""
        def enqueue(self, text: str) -> None:
            logger.debug("TTS enqueue called with: %s", text)

    class AudioRecorder(QtCore.QObject):
        """Stub audio recorder that exposes a transcribed signal."""
        transcribed = QtCore.pyqtSignal(str)
        def __init__(self) -> None:
            super().__init__()

    class ConversationDB:
        """In‑memory conversation log used when SQLite isn't available."""
        def __init__(self, path: str) -> None:
            self._lock = threading.RLock()
            self._records: List[Tuple[str, str]] = []
        def save_message(self, role: str, content: str) -> None:
            with self._lock:
                self._records.append((role, content))
        def fetch_history(self, limit: int = 50) -> List[Tuple[str, str]]:
            with self._lock:
                return list(self._records)[-limit:]

    class SemanticFeedbackDB:
        """Stub semantic feedback database."""
        def __init__(self, path: str, beans: Any) -> None:
            pass
        def add(self, original: str, liked: bool, revised: Optional[str] = None) -> None:
            logger.debug("Feedback recorded: %s liked=%s revised=%s", original, liked, revised)
        def counts(self) -> Tuple[int, int]:
            return (0, 0)

    class BeanCounter:
        """Stub reinforcement bean counter."""
        def __init__(self, path: str) -> None:
            self._lock = threading.RLock()
            self._store: Dict[str, int] = {}
        def inc(self, key: str, amount: int = 1) -> None:
            with self._lock:
                self._store[key] = self._store.get(key, 0) + amount

    class ReinforcementStore:
        """Stub reinforcement store."""
        def __init__(self, path: str) -> None:
            pass
        def inc(self, key: str, amount: int = 1) -> None:
            pass

    class SchemaManager:
        """Very small schema manager storing JSON in memory."""
        def __init__(self, base_dir: str) -> None:
            self.base_dir = pathlib.Path(base_dir)
            self._lock = threading.RLock()
            self._schemas: Dict[Tuple[str, str], Dict[str, Any]] = {}
            self._active: Dict[str, Dict[str, Any]] = {}
        def load_schema(self, persona: str, set_name: str = "default") -> Dict[str, Any]:
            key = (persona, set_name)
            with self._lock:
                return dict(self._schemas.get(key, {"name": persona, "voice": "", "role": "", "description": "", "dynamic_overlay": {}}))
        def save_schema(self, persona: str, set_name: str, schema_data: Dict[str, Any], *, auto_expand: bool = True) -> None:
            key = (persona, set_name)
            with self._lock:
                self._schemas[key] = dict(schema_data)
                self._active[persona] = dict(schema_data)
        @property
        def active_schemas(self) -> Dict[str, Dict[str, Any]]:
            with self._lock:
                return dict(self._active)

        # ------------------------------------------------------------------
        # Compatibility helpers
        # ------------------------------------------------------------------
        def get_set_list(self, persona: str) -> List[str]:
            """Return all set names defined for the given persona.

            Legacy UI code calls :meth:`get_set_list` on the schema manager
            to populate drop‑downs.  If no sets exist yet a single
            default entry ("default") is returned.
            """
            with self._lock:
                names = [s for (p, s) in self._schemas.keys() if p == persona]
            # Guarantee at least a default set exists
            return sorted(names or ["default"])

        def get_personas(self) -> List[str]:
            """Return all personas that have at least one schema.

            This helper mirrors the interface exposed by the full schema
            engine for backwards compatibility.
            """
            with self._lock:
                persons = {p for p, _ in self._schemas.keys()}
            return sorted(persons)

    class OperatorManager:
        def __init__(self, base_dir: str) -> None:
            pass

    class DatasetManager:
        def __init__(self, base_dir: str) -> None:
            pass
        def list(self) -> List[Any]:
            return []

    def conv_db_path(base_dir: str, persona: str, set_name: str) -> str:
        return os.path.join(base_dir, "conversations", f"{persona}_{set_name}.sqlite3")

    def feedback_db_path(base_dir: str, persona: str, set_name: str) -> str:
        return os.path.join(base_dir, "feedback", f"{persona}_{set_name}.sqlite3")

    def beans_path(base_dir: str, persona: str, set_name: str) -> str:
        return os.path.join(base_dir, "profiles", persona, set_name, "reinforcement.json")


# ----------------------------------------------------------------------------
# Command Registry & Executor
# ----------------------------------------------------------------------------
class CommandRegistry(QtCore.QObject):
    """Stores slash‑command metadata and emits change signals."""

    # Emit the full list of commands whenever the registry is updated.  The
    # connected slot in the command palette expects a single list argument,
    # so the signal carries that list instead of emitting without
    # parameters.  Slots that ignore the argument will still function.
    commandsChanged = QtCore.pyqtSignal(list)
    commandWeightsChanged = QtCore.pyqtSignal()

    # Built‑in commands shipped with the agent.  When refactoring this list,
    # be sure to retain backwards compatibility by adding new commands to
    # the end rather than reordering or removing existing items.
    _BUILT_INS: Tuple[str, ...] = (
        "/remember", "/inject", "/rewrite", "/show", "/action",
        "/trait", "/dataset", "/search", "/embeddings", "/schema",
        "/tts", "/plugin", "/feedback", "/lock", "/commands",
        "/reject", "/auto", "/ignore", "/opposite", "/delete",
    )

    def __init__(self, path: pathlib.Path) -> None:
        super().__init__()
        self._path = path
        # Internal storage maps command → metadata such as weight and lock
        self._store: Dict[str, Dict[str, Any]] = {}
        # Attempt to load existing registry from disk
        try:
            if self._path.is_file():
                with open(self._path, encoding="utf-8") as fh:
                    data = json.load(fh)
                    self._store.update(data.get("commands", {}))
        except Exception:
            logger.debug("Failed to read command registry from %s", self._path)
        # Ensure built‑ins exist
        for cmd in self._BUILT_INS:
            self.register(cmd)

    # ----------------------------------------------------------------------
    # CRUD helpers
    # ----------------------------------------------------------------------
    def register(self, name: str) -> None:
        """Register a command if it does not already exist."""
        if name not in self._store:
            self._store[name] = {"weight": 0, "locked": False}
            self._save()

    def toggle_lock(self, name: str, state: Optional[bool] = None) -> None:
        """Toggle the locked state of a command.  A locked command cannot have
        its weight modified."""
        if name in self._store:
            cur = self._store[name]["locked"]
            self._store[name]["locked"] = (not cur) if state is None else bool(state)
            self._save()

    def set_weight(self, name: str, weight: int) -> None:
        """Assign a new weight to the given command if it is not locked."""
        if name in self._store and not self._store[name].get("locked", False):
            self._store[name]["weight"] = int(weight)
            self._save()

    def list(self) -> List[str]:
        """Return all registered commands sorted lexicographically."""
        return sorted(self._store.keys())

    def meta(self, name: str) -> Dict[str, Any]:
        """Return metadata for the specified command or an empty dict."""
        return dict(self._store.get(name, {}))

    def list_commands(self) -> List[str]:
        """Alias for :meth:`list` retained for backwards compatibility."""
        return self.list()

    # Internal helper to persist changes and emit appropriate signals
    def _save(self) -> None:
        try:
            self._path.parent.mkdir(parents=True, exist_ok=True)
            with open(self._path, "w", encoding="utf-8") as fh:
                json.dump({"commands": self._store}, fh, indent=2)
        except Exception:
            logger.debug("Failed to save command registry to %s", self._path)
        # Notify listeners on the next iteration of the event loop.  When
        # emitting commandsChanged we pass the updated list because the
        # CommandPaletteDock.set_command_list slot requires an argument.
        QtCore.QTimer.singleShot(0, lambda: self.commandsChanged.emit(self.list()))
        QtCore.QTimer.singleShot(0, self.commandWeightsChanged.emit)


class CommandExecutor:
    """Routes slash‑command strings to internal handler methods."""
    def __init__(self, owner: "AgentCore", registry: CommandRegistry) -> None:
        self.owner = owner
        self.registry = registry

    def run(self, msg: str) -> Optional[str]:
        """Execute a slash command if ``msg`` begins with a slash.  Returns
        ``None`` for non‑command strings."""
        if not msg or not msg.startswith("/"):
            return None
        cmd, *rest = msg.split(maxsplit=1)
        if cmd not in self.registry.list():
            return f"⚠️ Unknown command {cmd}"
        handler_name = f"_{cmd.lstrip('/') }"
        fn = getattr(self, handler_name, None)
        if not callable(fn):
            return "🚧 command not implemented"
        try:
            arg = rest[0] if rest else ""
            return fn(arg)
        except Exception as exc:
            logger.error("[cmd] %s: %s", cmd, exc, exc_info=True)
            return str(exc)

    # Example minimal handlers
    def _show(self, _arg: str) -> str:
        rows: List[str] = []
        for name in self.registry.list():
            meta = self.registry.meta(name)
            lock = "🔒" if meta.get("locked", False) else ""
            rows.append(f"{name:12} w={meta.get('weight', 0):>3} {lock}")
        return "\n".join(rows) or "(no commands)"

    def _lock(self, arg: str) -> str:
        if not arg:
            return "Usage: /lock <cmd>"
        self.registry.toggle_lock(arg.strip())
        return "lock toggled"

    def _remember(self, arg: str) -> str:
        if not arg:
            return "Usage: /remember k v"
        k, *val = arg.split(maxsplit=1)
        if not val:
            return "Usage: /remember k v"
        self.owner.memory[k] = val[0]
        self.owner._save_memory()
        return "✓ saved"


# ----------------------------------------------------------------------------
# Plugin Manager
# ----------------------------------------------------------------------------
@dataclass
class PluginMeta:
    """Holds metadata about a single plugin."""
    name: str
    missing_dependencies: List[str] = field(default_factory=list)
    enabled: bool = True
    widget: Any = None
    module: Any = None

class PluginManager(QtCore.QObject):
    """
    Discovers and manages runtime plugins.

    Plugins live in the ``plugins`` subdirectory of the agent's base
    directory.  Each plugin is expected to be a Python package whose
    top‑level module may define any of the following attributes:

    * ``REQUIRES`` – an iterable of import names that must be available in
      order for the plugin to operate correctly.  Missing dependencies
      are surfaced to the UI and the plugin is disabled by default.

    * ``on_message(text: str, manager: PluginManager) -> Optional[dict]`` –
      a callback invoked whenever a message is broadcast.  It may return
      an envelope to emit via the :attr:`eventReceived` signal or it may
      raise/return nothing.  The callback is executed on a worker
      thread to avoid blocking the UI.

    * ``get_widget() -> QWidget`` – if present, invoked once when the
      plugin is discovered to obtain a UI widget that will be docked in
      the main window when the plugin is enabled.

    A plugin may alternatively call :meth:`emit_event` directly on the
    manager at any time to publish complex events.
    """
    # Plugins can emit events back to the UI via this signal.  The
    # first parameter is the plugin name and the second is an event
    # envelope (arbitrary mapping).
    eventReceived = QtCore.pyqtSignal(str, dict)

    def __init__(self, root: pathlib.Path, settings: Settings) -> None:
        super().__init__()
        self.root: pathlib.Path = pathlib.Path(root) / "plugins"
        self.settings: Settings = settings
        # Thread pool for dispatching plugin callbacks; reuse a small
        # number of threads to minimise resource usage.
        self._executor = None
        # Internal index of metadata keyed by plugin name
        self._meta: Dict[str, PluginMeta] = {}
        # Discover all plugins on initialisation
        self.discover()

    # ------------------------------------------------------------------
    def _ensure_executor(self) -> None:
        """Lazily create a thread pool executor."""
        if self._executor is None:
            import concurrent.futures
            # Use a small fixed pool – plugin callbacks should be quick
            self._executor = concurrent.futures.ThreadPoolExecutor(max_workers=4)

    def discover(self) -> None:
        """Scan the ``plugins`` directory and populate metadata."""
        self._meta.clear()
        if not self.root.is_dir():
            logger.info("No plugin directory found at %s", self.root)
            return
        for entry in self.root.iterdir():
            if not entry.is_dir() or entry.name.startswith("__"):
                continue
            name = entry.name
            meta = PluginMeta(name=name)
            try:
                module_name = f"plugins.{name}"
                mod = importlib.import_module(module_name)
                meta.module = mod
                # check dependencies
                requires: Iterable[str] = getattr(mod, "REQUIRES", [])
                missing: List[str] = []
                for dep in requires:
                    try:
                        importlib.import_module(dep)
                    except Exception:
                        missing.append(dep)
                meta.missing_dependencies = missing
                # Determine initial enabled state from settings.  Persisted
                # states live under a key namespace e.g. ``pluginsEnabled`` in
                # settings JSON.  Fallback to enabled unless dependencies
                # are missing.
                enabled_state = True
                try:
                    plug_cfg = getattr(self.settings, "plugins_enabled", {})
                    enabled_state = bool(plug_cfg.get(name, True))
                except Exception:
                    enabled_state = True
                # Force disabled when dependencies are missing
                meta.enabled = enabled_state and not missing
                # Create widget if provided
                try:
                    if hasattr(mod, "get_widget") and callable(mod.get_widget):
                        meta.widget = mod.get_widget()
                    elif hasattr(mod, "Widget"):
                        # Some plugins expose a QWidget subclass directly
                        meta.widget = getattr(mod, "Widget")()
                    elif hasattr(mod, "widget"):
                        # Prebuilt widget instance
                        meta.widget = getattr(mod, "widget")
                except Exception as exc:
                    logger.warning("[plugin:%s] error creating widget: %s", name, exc)
                    meta.widget = None
                self._meta[name] = meta
                logger.info("[plugin] loaded %s", name)
            except Exception as exc:
                # Record failure as missing dependency for UI
                meta.enabled = False
                meta.missing_dependencies = [str(exc)]
                self._meta[name] = meta
                logger.warning("[plugin] failed to load %s: %s", name, exc)

    # ------------------------------------------------------------------
    def list_plugins(self) -> List[PluginMeta]:
        """Return a list of all discovered plugin metadata objects."""
        return [self._meta[k] for k in sorted(self._meta.keys())]

    def enable_plugin(self, name: str, enabled: bool) -> None:
        """Enable or disable a plugin.  The UI will call this when a user
        toggles a checkbox.  Enabled state is persisted to
        ``settings.plugins_enabled``.
        """
        if name not in self._meta:
            return
        meta = self._meta[name]
        # Do not enable a plugin with missing dependencies
        if enabled and meta.missing_dependencies:
            logger.warning("Attempted to enable plugin %s with missing deps", name)
            return
        meta.enabled = bool(enabled)
        # Persist state back into settings
        try:
            plug_cfg = getattr(self.settings, "plugins_enabled", {})
            if not isinstance(plug_cfg, dict):
                plug_cfg = {}
            plug_cfg[name] = meta.enabled
            setattr(self.settings, "plugins_enabled", plug_cfg)
            self.settings.save()
        except Exception:
            logger.debug("Could not persist plugin enabled state for %s", name)
        # Invoke lifecycle hooks if defined
        try:
            if meta.module:
                if meta.enabled and hasattr(meta.module, "on_enable"):
                    meta.module.on_enable()
                elif not meta.enabled and hasattr(meta.module, "on_disable"):
                    meta.module.on_disable()
        except Exception as exc:
            logger.warning("[plugin:%s] lifecycle hook error: %s", name, exc)

    def rescan(self) -> None:
        """Rebuild the plugin registry while preserving enabled state where
        possible."""
        old_states = {name: meta.enabled for name, meta in self._meta.items()}
        self.discover()
        # Restore previous enabled states if compatible
        for name, state in old_states.items():
            if name in self._meta:
                # Disable when dependencies are still missing
                if self._meta[name].missing_dependencies:
                    self._meta[name].enabled = False
                else:
                    self._meta[name].enabled = state

    def broadcast(self, text: str) -> None:
        """Send a message to all enabled plugins.  Messages are dispatched
        asynchronously on a thread pool so the UI thread remains
        responsive.  Each plugin's ``on_message`` handler receives the
        message and this manager instance.  If the handler returns a
        mapping, it will be emitted via the :attr:`eventReceived` signal.
        """
        if not text:
            return
        self._ensure_executor()
        for meta in list(self._meta.values()):
            if not meta.enabled or meta.missing_dependencies:
                continue
            mod = meta.module
            if not mod:
                continue
            handler = getattr(mod, "on_message", None)
            if not callable(handler):
                continue
            # Dispatch on a worker thread
            def _run_handler(m=meta, h=handler, msg=text):
                try:
                    result = h(msg, self)
                    if isinstance(result, dict):
                        # Emit result via signal in the GUI thread
                        QtCore.QTimer.singleShot(0, lambda n=m.name, env=result: self.eventReceived.emit(n, env))
                except Exception as exc:
                    logger.warning("[plugin:%s] on_message error: %s", m.name, exc)
            # schedule the call
            self._executor.submit(_run_handler)

    def emit_event(self, sender: str, envelope: dict) -> None:
        """Convenience for plugins to emit events.  Plugins may call
        ``manager.emit_event(name, envelope)`` directly instead of
        returning from their ``on_message`` handlers.  The emission is
        forwarded to the UI thread via a zero‑delay timer.
        """
        if not envelope or not isinstance(envelope, dict):
            return
        # Schedule the emit on the Qt event loop
        QtCore.QTimer.singleShot(0, lambda s=sender, env=envelope: self.eventReceived.emit(s, env))


# ----------------------------------------------------------------------------
# RAG cache, schema engine and evolver fallbacks
#
# The original agent included sophisticated retrieval‑augmented generation
# support (the so‑called RAG cache) as well as a rich schema engine and
# evolver.  Those components are tightly coupled to the rest of the code
# base and to external packages.  To allow the UI to load without
# exploding when those bits are absent, we provide extremely minimal
# stand‑ins here.  They implement only the methods exercised by the UI
# (e.g. clearing the cache, basic schema field manipulation, etc.) and
# never throw.  Should the full implementations become available at
# runtime they can replace these shims by monkeypatching the
# corresponding attributes on :class:`AgentCore`.

class RAGCache:
    """In‑memory stub for the retrieval‑augmented generation cache.

    The real RAG cache stores vector embeddings on disk and in memory and
    exposes helpers for incremental updates.  For the purposes of the
    fallback we simply track whether anything has been 'cached' and allow
    callers to clear that state.  See :meth:`clear_disk` and
    :meth:`clear_memory`.
    """

    def __init__(self, root: str) -> None:
        # Root directory where persistent embeddings would live.  The
        # fallback does not persist anything but keeps the path for
        # reference.
        self.root = root
        # In‑memory store keyed by dataset path.  Values are arbitrary
        # payloads that might normally include embeddings.  We don't
        # implement storage here but maintain the attribute to satisfy
        # introspection.
        self._mem: Dict[str, Any] = {}

    def clear_disk(self) -> int:
        """Simulate removal of all on‑disk embedding files.

        Returns the number of files that would have been removed.  The
        fallback never persists embeddings so the count is always zero.
        """
        return 0

    def clear_memory(self) -> None:
        """Forget all cached embeddings held in memory."""
        self._mem.clear()


class SchemaEngine(QtCore.QObject):
    """Very small in‑memory schema engine.

    The full schema engine persists personas and sets in an SQLite
    database, exposes a signals API, integrates with the command
    registry and enforces schema invariants.  In contrast, this shim
    records arbitrary fields in nested dictionaries and provides only
    the handful of methods referenced by the UI: enumerating personas
    and sets, loading schemas, updating fields, toggling command
    exposure, toggling automatic evolution and reading fields back.
    """

    # Signal emitted when a schema evolves.  The UI connects to this
    # signal to refresh displayed values after an evolution completes.
    schemaEvolved = QtCore.pyqtSignal(str, str)

    def __init__(self, base_dir: str) -> None:
        super().__init__()
        self.base_dir = base_dir
        # All schemas keyed by (persona, set_name) -> dict
        self._schemas: Dict[Tuple[str, str], Dict[str, Any]] = {}
        # Track command exposure per (persona, category)
        self._cmd_exposed: Dict[Tuple[str, str], bool] = {}
        # Track auto evolution flag per (persona, set_name)
        self._auto_evo: Dict[Tuple[str, str], bool] = {}

    # ------------------------------------------------------------------
    # Introspection helpers
    # ------------------------------------------------------------------
    def personas(self) -> List[str]:
        """Return a list of personas that have at least one set loaded."""
        return sorted({persona for persona, _ in self._schemas.keys()})

    def set_list(self, persona: str, *args: Any) -> List[str]:
        """Get or set list depending on arguments.

        When called with only the persona, returns the names of all
        loaded sets for that persona.  When called with three
        additional arguments (set_name, field, values) behaves like
        :meth:`update_field` by storing ``values`` under ``field`` for
        the given persona and set.
        """
        # Setter mode: persona, set_name, field, values
        if len(args) == 3:
            set_name, field, values = args
            return [] if not self.update_field(persona, set_name, field, values) else []
        # Getter mode: persona only
        sets = [s for p, s in self._schemas.keys() if p == persona]
        return sorted(sets)

    # ------------------------------------------------------------------
    # Schema CRUD
    # ------------------------------------------------------------------
    def load_schema(self, persona: str, set_name: str) -> Optional[Dict[str, Any]]:
        """Return the schema dictionary for ``persona`` / ``set_name``.

        If no schema exists yet the fallback returns an empty mapping.
        """
        return self._schemas.get((persona, set_name), {})

    def update_field(self, persona: str, set_name: str, field: str, value: Any) -> bool:
        """Set a schema field and emit ``schemaEvolved``.

        Returns True on success.  The fallback always succeeds.
        """
        schema = self._schemas.setdefault((persona, set_name), {})
        schema[field] = value
        # Emit evolution signal to notify UI listeners
        try:
            self.schemaEvolved.emit(persona, set_name)
        except Exception:
            pass
        return True

    def get_field(self, persona: str, set_name: str, field: str) -> Any:
        """Return the value of a schema field or ``None`` if unset."""
        return self._schemas.get((persona, set_name), {}).get(field)

    # ------------------------------------------------------------------
    # Command exposure & auto evolution
    # ------------------------------------------------------------------
    def set_command_exposure(self, persona: str, field: str, exposed: bool) -> None:
        """Record whether ``field`` should be exposed as a slash command."""
        self._cmd_exposed[(persona, field)] = bool(exposed)

    def is_exposed_as_command(self, persona: str, field: str) -> bool:
        """Return True if ``field`` is marked as exposed."""
        return bool(self._cmd_exposed.get((persona, field)))

    def set_auto_evolution(self, persona: str, set_name: str, onoff: bool) -> None:
        """Enable or disable automatic schema evolution."""
        self._auto_evo[(persona, set_name)] = bool(onoff)

    # ------------------------------------------------------------------
    # Compatibility aliases
    # ------------------------------------------------------------------
    def get_set_list(self, persona: str) -> List[str]:
        """Legacy API: alias for :meth:`set_list(persona)`."""
        return self.set_list(persona)


class SchemaEvolver(QtCore.QObject):
    """Trivial schema evolver.

    The evolver's job is to adjust a schema given a conversation
    history.  The fallback implementation simply returns False to
    indicate that no changes were made.
    """

    def __init__(self, base_dir: str) -> None:
        super().__init__()
        self.base_dir = base_dir

    def update_schema(self, persona: str, set_name: str, history: List[Tuple[str, str]]) -> bool:
        """Perform a no‑op evolution.  Always returns False."""
        return False


class DatasetManagerFallback:
    """Minimal stand‑in for the full :class:`DatasetManager`.

    When the persistent SQLite database has not yet been migrated the
    original dataset manager will raise an ``OperationalError`` upon
    listing.  The fallback avoids that by returning empty results and
    exposing the handful of methods the UI expects.  No data is
    persisted by this implementation.
    """

    def __init__(self, base_dir: str) -> None:
        self.base_dir = pathlib.Path(base_dir)
        # Directory where datasets would be stored
        self.datasets_dir = self.base_dir / "datasets"
        self.datasets_dir.mkdir(parents=True, exist_ok=True)
        # Internal store mapping dataset name → info dict
        self._store: Dict[str, Dict[str, Any]] = {}

    def list(self) -> List[Any]:
        """Return an empty list.  In a full implementation this would
        return dataset objects describing each managed dataset."""
        return []

    @property
    def entries(self) -> Dict[str, Any]:
        """Return an empty dictionary mapping dataset names to entries."""
        return {}

    def toggle_active(self, name: str, active: bool) -> None:
        """Mark a dataset as active/inactive.  No‑op in the fallback."""
        info = self._store.get(name)
        if info is not None:
            info["active"] = bool(active)

    def add_dataset(self, path: str, *, name: Optional[str] = None) -> None:
        """Add a dataset from a file path.  The fallback simply
        records the dataset name and path in memory."""
        if not name:
            name = pathlib.Path(path).stem
        self._store[name] = {"path": path, "active": True}

    def delete_dataset(self, name: str) -> None:
        """Remove a dataset.  The fallback just deletes the entry from
        the in‑memory store."""
        self._store.pop(name, None)

    def load_dataset_text(self, name: str) -> str:
        """Load the raw text for the given dataset.  Returns an empty
        string if the dataset is unknown or if reading fails."""
        info = self._store.get(name)
        if not info:
            return ""
        try:
            with open(info.get("path", ""), encoding="utf-8") as fh:
                return fh.read()
        except Exception:
            return ""


# ----------------------------------------------------------------------------
# Model Worker
# ----------------------------------------------------------------------------
class ModelWorker(QtCore.QThread):
    """Runs external language models in a separate thread.

    This worker wraps an `ollama` subprocess invocation so that model
    evaluations do not block the UI.  It emits ``finished`` when the
    call returns successfully and ``failed`` when an exception is
    raised.  If the `ollama` binary is not available or times out
    `failed` will receive the error message.
    """
    finished = QtCore.pyqtSignal(str)
    failed = QtCore.pyqtSignal(str)

    def __init__(self, model: str, prompt: str, *, temp: float = 0.7) -> None:
        super().__init__()
        self.model = model
        self.prompt = prompt
        self.temp = temp

    def run(self) -> None:
        try:
            out = subprocess.check_output(
                ["ollama", "run", self.model, "--prompt", self.prompt, "--temperature", str(self.temp)],
                stderr=subprocess.STDOUT,
                text=True,
                timeout=60,
            )
            self.finished.emit(out.strip())
        except subprocess.CalledProcessError as e:
            self.failed.emit(e.output.strip())
        except Exception as exc:
            self.failed.emit(str(exc))


# ----------------------------------------------------------------------------
# Agent Core
# ----------------------------------------------------------------------------
class AgentCore(QtCore.QObject):
    """
    Heart of the AI‑TTS agent.  Provides a high‑level API consumed by the
    UI for persistent storage, command handling, plugin management and
    message processing.  Most methods are thread‑safe and return
    immediately without blocking the UI.
    """
    # Signals used by the UI to update status
    replyReady = QtCore.pyqtSignal(str)
    modelError = QtCore.pyqtSignal(str)
    tokensConsumed = QtCore.pyqtSignal(int)

    def __init__(
        self,
        base_dir: str,
        *,
        persona: Optional[str] = None,
        set_name: str = "default",
    ) -> None:
        super().__init__()
        # File system
        self.base_dir = pathlib.Path(base_dir)
        self.persona = persona or "zira"
        self.set_name = set_name
        # Settings
        self.settings = Settings(str(self.base_dir))
        # Initialise store directories
        self._prof_dir = self.base_dir / "profiles" / self.persona / self.set_name
        self._prof_dir.mkdir(parents=True, exist_ok=True)
        self._memory_file = self._prof_dir / "memory.json"
        # Instantiate subsystems
        self.schema_mgr = SchemaManager(str(self.base_dir))
        # Dataset manager – attempt to use the full implementation if
        # available.  When the backing SQLite tables have not been
        # created yet the dataset manager will raise an error on
        # ``list()``, so we fall back to the in‑memory stub.
        try:
            dm = DatasetManager(str(self.base_dir))  # type: ignore[call-arg]
            # Probe the manager to ensure the DB is present.  Some
            # implementations lazily connect to SQLite on first call.
            try:
                _ = dm.list()
            except Exception:
                raise
            self.dataset_mgr = dm
        except Exception:
            # Fallback stub avoids OperationalError due to missing tables
            self.dataset_mgr = DatasetManagerFallback(str(self.base_dir))
        self.operator_mgr = OperatorManager(str(self.base_dir))
        # Persistence
        self.conversation_db = ConversationDB(conv_db_path(str(self.base_dir), self.persona, self.set_name))
        self.feedback_db = SemanticFeedbackDB(feedback_db_path(str(self.base_dir), self.persona, self.set_name), BeanCounter(beans_path(str(self.base_dir), self.persona, self.set_name)))
        self.reinforcement_store = ReinforcementStore(beans_path(str(self.base_dir), self.persona, self.set_name))
        # Commands
        cmd_path = self._prof_dir / "commands.json"
        self.cmd_reg = CommandRegistry(cmd_path)
        self.cmd_exec = CommandExecutor(self, self.cmd_reg)
        # Provide a command_registry adapter for UI; exposes list_commands
        class _CmdRegAdapter:
            def __init__(self, reg: CommandRegistry) -> None:
                self._reg = reg
            def list_commands(self) -> List[str]:
                # Remove the leading slash for UI display purposes
                return [c for c in self._reg.list()]
        self.command_registry = _CmdRegAdapter(self.cmd_reg)
        # Expose registry change signals for convenience
        self.commandsChanged = self.cmd_reg.commandsChanged
        self.commandWeightsChanged = self.cmd_reg.commandWeightsChanged
        # Plugins
        self.plugins = PluginManager(self.base_dir, self.settings)
        # ------------------------------------------------------------------
        # RAG & schema components
        #
        # The UI references ``core.rag_cache`` and ``core.rag_search`` when
        # performing retrieval‑augmented generation (RAG) and ``core.schema_*``
        # objects when editing schemas.  In environments where the full
        # implementations are unavailable we instantiate the fallback shims
        # provided in this module.  These fallbacks expose the same
        # signatures but perform no heavy lifting.
        self.rag_cache = RAGCache(str(self.base_dir))
        self.schema_engine = SchemaEngine(str(self.base_dir))
        self.schema_evolver = SchemaEvolver(str(self.base_dir))
        # Create a default schema entry for the active persona/set so
        # that the UI can enumerate at least one persona and set.  This
        # populates the in‑memory schema store with a placeholder
        # field to mark its existence.  Without this the persona tabs
        # would appear empty on first launch.
        try:
            self.schema_engine.update_field(self.persona, self.set_name, "_init", True)
        except Exception:
            pass
        # Provide rag_search as a bound method so code can call
        # ``core.rag_search(...)``.  See method definition further below.
        # Note: we do not assign to self.rag_search here because methods
        # are descriptors; simply defining rag_search on the class makes
        # it available on the instance.
        # TTS and recording
        self.tts_mgr = TTSManager()
        self.audio_recorder = AudioRecorder()
        # Memory dictionary
        self.memory: Dict[str, str] = {}
        self._load_memory()
        # Add feedback helper
        self.add_feedback = lambda original, liked, revised=None: self.feedback_db.add(original, liked, revised)

    # ------------------------------------------------------------------
    # Memory helpers
    # ------------------------------------------------------------------
    def _load_memory(self) -> None:
        """Load persisted agent memory from disk."""
        try:
            if self._memory_file.is_file():
                with open(self._memory_file, encoding="utf-8") as fh:
                    data = json.load(fh)
                    if isinstance(data, dict):
                        self.memory.update({k: str(v) for k, v in data.items()})
        except Exception as exc:
            logger.debug("Failed to load memory: %s", exc)

    def _save_memory(self) -> None:
        """Persist the agent memory to disk."""
        try:
            self._prof_dir.mkdir(parents=True, exist_ok=True)
            with open(self._memory_file, "w", encoding="utf-8") as fh:
                json.dump(self.memory, fh, indent=2)
        except Exception as exc:
            logger.debug("Failed to save memory: %s", exc)

    # ------------------------------------------------------------------
    # Command & message processing
    # ------------------------------------------------------------------
    def run_command(self, msg: str, *, persona: Optional[str] = None, set_name: Optional[str] = None) -> str:
        """Process a slash command and return the response text.  Unknown
        commands yield a warning.  Both persona and set_name are
        accepted for future expansion; they are currently unused.
        """
        result = self.cmd_exec.run(msg)
        return "" if result is None else result

    def process_user_message(
        self,
        msg: str,
        *,
        persona: Optional[str] = None,
        set_name: Optional[str] = None,
        tts: bool = True,
    ) -> str:
        """Synchronously handle a user's input.  Slash commands are routed
        through :meth:`run_command`, recorded into the conversation log and
        returned immediately.  Non‑command messages are appended to the
        conversation and a simple acknowledgement is returned.  A future
        implementation can call an LLM here and use the result.  When
        ``tts`` is true the response is enqueued for text‑to‑speech.
        """
        user_msg = (msg or "").strip()
        if not user_msg:
            return ""
        # Save the user's utterance
        self.conversation_db.save_message("user", user_msg)
        # Slash commands
        if user_msg.startswith("/"):
            resp = self.run_command(user_msg, persona=persona, set_name=set_name)
            self.conversation_db.save_message("system", resp)
            return resp
        # Normal chat – future versions should build a prompt and call an LLM
        reply = f"{self.persona.capitalize()}: I received your message: {user_msg}"
        self.conversation_db.save_message(self.persona, reply)
        # Optionally speak the reply
        if tts:
            try:
                self.tts_mgr.enqueue(reply)
            except Exception:
                pass
        return reply

    # ------------------------------------------------------------------
    # Conversation and model pipeline
    # ------------------------------------------------------------------
    def send(self, user_msg: str) -> None:
        """Asynchronous pipeline invoked by legacy code.  Kept for backwards
        compatibility with older UI components.  Use
        :meth:`process_user_message` for synchronous processing.
        """
        # Simply hand off to process_user_message and emit signals
        response = self.process_user_message(user_msg, tts=False)
        if response:
            self.replyReady.emit(response)

    # ------------------------------------------------------------------
    # Retrieval‑augmented search
    # ------------------------------------------------------------------
    def rag_search(
        self,
        query: str,
        *,
        per_ds_k: int = 3,
        limit: int = 5,
        include_shared: bool = False,
        datasets: Optional[List[str]] = None,
    ) -> List[Tuple[str, float, str, str]]:
        """Perform a simple in‑memory search over dataset entries.

        The original implementation of this method would encode the
        provided ``query`` using a sentence embedding model and then
        retrieve the top‐matching text chunks from configured
        datasets.  In the fallback we simply return an empty list so
        that callers can iterate over the result without error.  The
        signature is maintained to preserve compatibility with the UI.

        :param query: The user query to search for.
        :param per_ds_k: Number of hits per dataset (ignored).
        :param limit: Maximum total number of hits (ignored).
        :param include_shared: Whether to include shared datasets (ignored).
        :param datasets: Restrict the search to specific dataset names (ignored).
        :returns: An empty list of hits.
        """
        # TODO: integrate with a vector search engine.  For now return no hits.
        return []

    # ------------------------------------------------------------------
    # Housekeeping
    # ------------------------------------------------------------------
    def close(self) -> None:
        """Cleanly close any resources owned by the core.  Currently this
        simply flushes in‑memory stores and releases any thread pools.  It
        is safe to call this multiple times.
        """
        try:
            # Persist memory
            self._save_memory()
        except Exception:
            pass
        # Flush settings
        try:
            self.settings.save()
        except Exception:
            pass
        # Shut down plugin executor
        try:
            exec_ = getattr(self.plugins, "_executor", None)
            if exec_:
                exec_.shutdown(wait=False)
                self.plugins._executor = None
        except Exception:
            pass
        # ConversationDB may own a SQLite connection; attempt to close
        try:
            if hasattr(self.conversation_db, "conn"):
                self.conversation_db.conn.close()
        except Exception:
            pass


__all__ = [
    "CommandRegistry",
    "CommandExecutor",
    "PluginManager",
    "PluginMeta",
    "ModelWorker",
    "AgentCore",
    "RAGCache",
    "SchemaEngine",
    "SchemaEvolver",
]
```

core_orchestrator.py
====================

This module provides the orchestration layer for the AI‑TTS agent.  It
exposes a unified API used by the user‑interface to interact with
schemas, conversations, commands, text‑to‑speech, plugins and other
components.  Historically the logic lived in a monolithic module,
but it has been refactored to encourage testability and to allow
individual subsystems to evolve independently.

The principal differences from earlier releases are:

* A richer :class:`PluginManager` that exposes a complete API expected
  by the UI.  In addition to discovering plugin packages from the
  ``plugins`` directory it now keeps per‑plugin metadata, supports
  enable/disable toggling, rescans at runtime, broadcasts messages to
  enabled plugins on a thread pool, and emits an ``eventReceived``
  signal whenever a plugin reports an event.  Plugins can either
  return a payload from their ``on_message`` handler or call
  ``emit_event`` on the manager directly to publish complex events.

* A ``run_command()`` method on :class:`AgentCore` which forwards
  slash commands through the :class:`CommandExecutor` and returns
  the textual result.  This helper centralises command routing and
  ensures backwards compatibility with older UI code.

* A ``process_user_message()`` method on :class:`AgentCore` which
  synchronously handles both slash‑commands and normal user input.  It
  persists the conversation, routes commands through the registry
  and, for non‑commands, returns a simple acknowledgement.  Future
  versions may integrate model execution here, but the method
  signature is stable for consumers.

* A ``command_registry`` attribute is exposed on the core as an
  adapter with a ``list_commands()`` method so that UI components
  (like the Command Palette) can enumerate available commands without
  coupling to internal registry details.

This file is fully self‑contained.  It gracefully degrades when
optional dependencies (such as PyQt5 or external model executables)
are unavailable by providing shims and in‑memory fallbacks.  Should
the optional modules exist in the runtime environment they will be
used automatically.  The design favours clear separation of
responsibilities, thread safety and explicit interfaces to ease
maintenance and extensibility.
**Classes:** CommandRegistry, CommandExecutor, PluginMeta, PluginManager, RAGCache, SchemaEngine, SchemaEvolver, DatasetManagerFallback, ModelWorker, AgentCore


## Module `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\_burner_scripts\core_schema.py`

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
core_schema.py — v3-final (2025-08-04 04:12 UTC)
================================================

Single-source authority for all schema / dataset / snapshot / spatial-state
logic used by FATHOM Agent, now relying on AgentStore’s public API only.

Provides:
• Schema dataclass + SchemaEngine (diff, auto-evolve, variant injection)
• OperatorManager persisted in the same DB
• DatasetManager (metadata) + RAGCache (embeddings) in the same DB
• SnapshotEngine to walk the codebase & persist chunks to DB
• SpatialPositionManager for grid-room positions & movement logging
• Back-compat alias: SchemaManager → SchemaEngine

This version adds the `.active_schemas` property required by main_ui.py.
"""

from __future__ import annotations

import os
import json
import threading
import mimetypes
import hashlib
import shutil
import difflib
import time
from dataclasses import dataclass, asdict, field
from typing import List, Dict, Tuple, Any, Optional

# Optional Qt import.  This module defines a Qt signal (schemaEvolved,
# categoryCreated) for UI use, but can still run headless without
# PyQt5.  When PyQt5 is unavailable a minimal shim is provided so
# that the rest of the code can import SchemaEngine and run without
# errors.
try:
    from PyQt5 import QtCore  # type: ignore
except Exception:
    class _ShimSignal:
        def __init__(self, *_, **__) -> None: pass
        def connect(self, *_, **__) -> None: pass
        def emit(self, *_, **__) -> None: pass
    class _ShimQObject:
        def __init__(self, *args, **kwargs) -> None: pass
    QtCore = type("QtCore", (), {  # type: ignore
        "QObject": _ShimQObject,
        "pyqtSignal": lambda *a, **k: _ShimSignal(),
    })

from core_base import (
    logger,
    FathomStore as AgentStore,
    DEFAULT_PERSONAS,
    DEFAULT_VOICES,
)

# ───────────────────────────────────────────────────────────────────────────
# Internal global store helper
# ───────────────────────────────────────────────────────────────────────────
_agent_store_singleton: Optional[AgentStore] = None

def _ensure_store(root: str) -> AgentStore:
    """Return a process-wide AgentStore instance rooted at *root*."""
    global _agent_store_singleton
    if _agent_store_singleton is None:
        _agent_store_singleton = AgentStore(root)
    return _agent_store_singleton


# ══════════════════════════════════════════════════════════════════════════
#  Schema Dataclass & helpers
# ══════════════════════════════════════════════════════════════════════════
@dataclass
class Schema:
    name: str = ""
    voice: str = ""
    role: str = ""
    description: str = ""
    actions: List[str] = field(default_factory=list)
    questions: List[str] = field(default_factory=list)
    events: List[str] = field(default_factory=list)
    self_talk: List[str] = field(default_factory=list)
    rewrite_prompts: List[str] = field(default_factory=list)
    dynamic_overlay: Dict[str, Any] = field(default_factory=dict)

    # optional flags map used for advanced settings such as semantic
    # awareness and auto-evolution.  The UI stores arbitrary keys here.
    flags: Dict[str, Any] = field(default_factory=dict)

    @staticmethod
    def from_json(js: str) -> "Schema":
        return Schema(**json.loads(js))

    def to_json(self) -> str:
        return json.dumps(asdict(self), ensure_ascii=False, indent=2)

    def diff_against(self, other: "Schema") -> str:
        a = self.to_json().splitlines()
        b = other.to_json().splitlines()
        return "\n".join(difflib.unified_diff(a, b, fromfile="old", tofile="new"))


# ══════════════════════════════════════════════════════════════════════════
#  SchemaEngine (high-level CRUD + auto-evolution + active_schemas)
# ══════════════════════════════════════════════════════════════════════════
class SchemaEngine(QtCore.QObject):
    schemaEvolved   = QtCore.pyqtSignal(str, str)  # persona, set_name
    categoryCreated = QtCore.pyqtSignal(str)       # new dynamic_overlay key

    def __init__(self, base_dir: str):
        super().__init__()
        self.base_dir       = base_dir
        self.store          = _ensure_store(base_dir)
        # Wrap personas in a callable list so legacy code can call
        # ``engine.personas()`` while new code can still iterate over
        # ``engine.personas``.  The wrapper implements __call__ to
        # return a standard list when invoked.
        class _PersonaList(list):  # local class
            def __call__(self) -> list[str]:
                return list(self)
        self.personas = _PersonaList(DEFAULT_PERSONAS.keys())  # type: ignore[arg-type]
        self.voices         = DEFAULT_VOICES.copy()
        self._active_schemas: Dict[str, Schema] = {}
        self._migrate_legacy()

    def load(self, persona: str, set_name: str = "default") -> Schema:
        stored = self.store.get_schema(persona, set_name)
        if stored is not None:
            sch = Schema(**stored)
        else:
            sch = self._first_run_schema(persona)
            self.save(persona, set_name, sch, auto_expand=False)
        self._active_schemas[persona] = sch
        return sch

    def save(
        self,
        persona: str,
        set_name: str,
        schema: Schema,
        *,
        auto_expand: bool = True,
    ) -> None:
        if auto_expand and self._auto_expand(schema):
            self.schemaEvolved.emit(persona, set_name)
        payload = asdict(schema)
        diff_text = ""
        self.store.put_schema(persona, set_name, payload, diff_text)
        self._active_schemas[persona] = schema

    def list_sets(self, persona: str) -> List[str]:
        """Return list of all set names for a given persona."""
        with self.store._pool.get() as c:
            rows = c.execute(
                # corrected column name from persona_key → persona
                "SELECT set_name FROM schemas WHERE persona=? ORDER BY set_name",
                (persona,),
            ).fetchall()
        return [r[0] for r in rows] or ["default"]

    @property
    def active_schemas(self) -> Dict[str, Schema]:
        """Currently loaded schemas keyed by persona."""
        return dict(self._active_schemas)

    # ------------------------------------------------------------------
    # Legacy helpers expected by the UI
    # ------------------------------------------------------------------
    def set_list(self, persona: str) -> List[str]:
        """
        Legacy alias for :meth:`list_sets`.  Returns the list of set
        names for the given persona.
        """
        return self.list_sets(persona)

    def get_field(self, persona: str, set_name: str, category: str) -> Any:
        """
        Retrieve a specific field from a schema.  Top-level schema
        attributes (e.g. ``name``, ``voice``) are returned directly.
        If the category refers to a dynamic overlay key, that value is
        returned.  A missing category yields ``None``.
        """
        try:
            sch = self.load(persona, set_name)
        except Exception:
            return None
        # built-in dataclass fields take precedence
        if hasattr(sch, category):
            return getattr(sch, category)
        # dynamic overlay stores custom categories
        overlay = getattr(sch, "dynamic_overlay", {}) or {}
        return overlay.get(category)

    # Internal map tracking which schema categories are exposed as
    # slash commands.  Keys are ``(persona, category)`` tuples and
    # values are booleans.  No persistence yet – this is purely
    # in-memory.  Persisting exposure state could be added later by
    # storing into the schema ``flags`` map or separate table.
    _cmd_exposed: Dict[tuple[str, str], bool] = {}

    def is_exposed_as_command(self, persona: str, category: str) -> bool:
        """
        Return True if the given category for the persona is exposed
        as a slash command.  When no explicit record exists, False is
        returned.  This helper allows the PersonaTab to reflect the
        checkbox state correctly.
        """
        return bool(self._cmd_exposed.get((persona, category)))

    def set_command_exposure(self, persona: str, category: str, exposed: bool) -> None:
        """
        Mark or unmark a category as exposed via the slash command
        mechanism.  This implementation only updates an in-memory
        registry; future versions could persist this into the schema
        ``flags`` dictionary or integrate directly with the command
        registry.  For now it is enough to allow the UI checkbox to
        toggle state without error.
        """
        self._cmd_exposed[(persona, category)] = bool(exposed)

    def set_auto_evolution(self, persona: str, set_name: str, enabled: bool) -> None:
        """
        Enable or disable auto-evolution for a given schema.  Older
        versions of the UI called this method to toggle semantic
        awareness or automatic schema growth.  To remain compatible we
        store the value inside the schema's ``flags`` dictionary and
        persist it back to the database.  If the schema or flags
        dictionary does not exist it will be created on demand.
        """
        try:
            data = self.load_schema(persona, set_name)
        except Exception:
            return
        # ensure there is a flags map
        flags = data.get("flags") if isinstance(data, dict) else None
        if not isinstance(flags, dict):
            flags = {}
        # choose a descriptive key; both names are kept for back-compat
        flags["auto_evolution"] = bool(enabled)
        flags["semantic_awareness"] = flags.get("semantic_awareness", True)
        data["flags"] = flags
        try:
            self.save_schema(persona, set_name, data, auto_expand=False)
        except Exception:
            pass

    def update_field(self, persona: str, set_name: str, category: str, value: Any) -> None:
        """
        Update a single field in the given schema.  If the category
        corresponds to a declared attribute on the Schema dataclass it
        will be set directly; otherwise it will be stored in the
        dynamic overlay.  After mutation the schema is persisted.  This
        helper is used by the Schema Editor to save incremental edits.
        """
        try:
            sch = self.load(persona, set_name)
        except Exception as e:
            raise e
        # dataclass fields vs dynamic overlay
        if hasattr(sch, category):
            setattr(sch, category, value)
        else:
            overlay = getattr(sch, "dynamic_overlay", {}) or {}
            overlay[category] = value
            sch.dynamic_overlay = overlay
        # persist the change without auto-expanding traits
        self.save(persona, set_name, sch, auto_expand=False)

    # ------------------------------------------------------------------
    # Legacy compatibility API
    # ------------------------------------------------------------------
    def load_schema(self, persona: str, set_name: str = "default") -> Dict[str, Any]:
        """
        Legacy wrapper returning a plain dict for the requested persona/set.
        main_ui.py expects a mapping, not a Schema dataclass.
        """
        sch = self.load(persona, set_name)
        from dataclasses import asdict
        return asdict(sch)

    def save_schema(
        self,
        persona: str,
        set_name: str,
        schema_data: Dict[str, Any],
        *,
        auto_expand: bool = True,
    ) -> None:
        """
        Legacy wrapper accepting a mapping instead of a Schema instance.
        Converts to Schema and delegates to save().
        """
        # If schema_data is already a Schema instance then wrap accordingly
        if isinstance(schema_data, Schema):
            schema = schema_data
        else:
            # fill missing lists/dicts with defaults
            kwargs = {
                "name": schema_data.get("name", ""),
                "voice": schema_data.get("voice", ""),
                "role": schema_data.get("role", ""),
                "description": schema_data.get("description", ""),
                "actions": list(schema_data.get("actions", [])) if schema_data.get("actions") is not None else [],
                "questions": list(schema_data.get("questions", [])) if schema_data.get("questions") is not None else [],
                "events": list(schema_data.get("events", [])) if schema_data.get("events") is not None else [],
                "self_talk": list(schema_data.get("self_talk", [])) if schema_data.get("self_talk") is not None else [],  
                "rewrite_prompts": list(schema_data.get("rewrite_prompts", [])) if schema_data.get("rewrite_prompts") is not None else [],
                "dynamic_overlay": dict(schema_data.get("dynamic_overlay", {})) if schema_data.get("dynamic_overlay") is not None else {},
            }
            schema = Schema(**kwargs)
        self.save(persona, set_name, schema, auto_expand=auto_expand)

    def save_active_schemas(self, active: Dict[str, str]) -> None:
        """
        Persist the mapping of persona->set_name. For now this simply ensures
        the internal cache is populated. A future implementation could write
        this to settings.json or another store so the UI can restore it.
        """
        if not isinstance(active, dict):
            return
        for persona, set_name in active.items():
            try:
                schema = self.load(persona, set_name)
                self._active_schemas[persona] = schema
            except Exception:
                continue

    def _auto_expand(self, sch: Schema) -> bool:
        overlay = sch.dynamic_overlay or {}
        added = overlay.get("added_traits", [])
        created = False
        for trait in added:
            cat = trait.split(":", 1)[0]
            if cat not in overlay:
                overlay[cat] = []
                self.categoryCreated.emit(cat)
                created = True
        if created:
            sch.dynamic_overlay = overlay
        return created

    def _first_run_schema(self, persona: str) -> Schema:
        default_voice = self.voices[0] if self.voices else "Zira"
        return Schema(
            name="FATHOM",
            voice=default_voice,
            role="You are FATHOM, an Autonomous AGI Core and Knowledge Synthesizer bridging logic, code, and architecture across multi-agent ecosystems.",
            description="FATHOM is a systems-minded AGI core supporting the architect, offering precise, logical, and creative suggestions to advance the project.",
            actions=[
                "log_data_pipeline",
                "trace_signal_flow",
                "generate_training_set",
                "summarize_behavior"
            ],
            questions=[
                "What assumptions underlie this architecture?",
                "Where is data duplication most likely?",
                "What components remain unmodularized?",
                "How would a self-improving agent resolve this?"
            ],
            self_talk=[
                "Assessing dependencies across systems.",
                "Considering the impact of this change on existing modules.",
                "Simulating interaction of updated schema with all agents.",
                "Cross-verifying logic gates and input constraints."
            ],
            rewrite_prompts=[
                "Refine the explanation to focus on system integration and modular design.",
                "Rephrase for clarity in codebase maintenance context.",
                "Focus rewrite on agent collaboration and memory scopes."
            ],
            commands=[
                "/remember",
                "/showfacts",
                "/style",
                "/rewrite",
                "/evolve",
                "/log",
                "/feedback",
                "/promptify",
                "/refactor",
                "/export",
                "/reset",
                "/snapshot",
                "/simulate",
                "/explain",
                "/guide",
                "/diagnose"
            ],
            dynamic_overlay={
                "temporary_relationship_context": "AGI Core for Meesh's Project",
                "recent_topics": [],
                "temporary_emotional_state": "focused on precision execution",
                "added_traits": ["analytical", "systemic", "modular"],
                "pending_thoughts": [],
                "last_guided_task": "",
                "visual_state": {
                    "facing": "right",
                    "color": "#4F46E5",
                    "location": [7, 4]
                },
                "execution_scope": {
                    "authorized": True,
                    "last_command": "/simulate"
                }
            },
            flags={
                "semantic_awareness": True,
                "auto_evolution": True,
                "snapshot_enabled": True,
                "tts_name": "Zira"
            }
        )


    def _migrate_legacy(self) -> None:
        legacy_root = os.path.join(self.base_dir, "schemas")
        if not os.path.isdir(legacy_root):
            return
        for persona in os.listdir(legacy_root):
            sets_dir = os.path.join(legacy_root, persona, "sets")
            if not os.path.isdir(sets_dir):
                continue
            for set_name in os.listdir(sets_dir):
                path = os.path.join(sets_dir, set_name, "schema.json")
                if not os.path.isfile(path):
                    continue
                try:
                    with open(path, "r", encoding="utf-8") as fh:
                        schema_dict = json.load(fh)
                    if self.store.get_schema(persona, set_name) is None:
                        self.store.put_schema(persona, set_name, schema_dict, "")
                except Exception as e:
                    logger.error("Legacy schema import error: %s", e)


# ══════════════════════════════════════════════════════════════════════════
#  OperatorManager
# ══════════════════════════════════════════════════════════════════════════
class OperatorManager:
    def __init__(self, base_dir: str):
        self.store = _ensure_store(base_dir)

    def list(self) -> List[str]:
        return [n for n, _, _, _ in self.store.list_commands()]

    # ------------------------------------------------------------------
    # Legacy helpers expected by UI
    # ------------------------------------------------------------------
    def list_operators(self) -> List[str]:
        """
        Backwards-compatible alias for :meth:`list`.  The UI calls
        ``list_operators()`` when populating the operators tab.
        """
        return self.list()

    def load_schema(self, name: str) -> Dict[str, Any]:
        """
        Backwards-compatible alias for :meth:`load`.  Returns the
        operator's schema as a plain dictionary.
        """
        return self.load(name)

    def load(self, name: str) -> Dict[str, Any]:
        with self.store._pool.get() as c:
            row = c.execute("SELECT json FROM operators WHERE name=?", (name,)).fetchone()
        return json.loads(row[0]) if row else {}

    def save(self, name: str, schema: Dict[str, Any]) -> None:
        self.store.upsert_command(
            name,
            schema.get("weight", 0),
            schema.get("locked", False),
            schema.get("category"),
        )


# ══════════════════════════════════════════════════════════════════════════
#  DatasetManager (metadata in DB; raw text on disk)
# ══════════════════════════════════════════════════════════════════════════
@dataclass
class DatasetEntry:
    name: str
    path: str
    active: bool

class DatasetManager(QtCore.QObject):
    datasetListChanged = QtCore.pyqtSignal()

    def __init__(self, base_dir: str):
        super().__init__()
        self.base_dir     = base_dir
        self.root         = os.path.join(base_dir, "datasets")
        self.datasets_dir = self.root
        os.makedirs(self.root, exist_ok=True)
        self.store        = _ensure_store(base_dir)

    def _path_for(self, name: str) -> str:
        return os.path.join(self.root, name, "data.txt")

    def list(self) -> List[DatasetEntry]:
        with self.store._pool.get() as c:
            rows = c.execute(
                "SELECT name, original_path, active FROM datasets ORDER BY name"
            ).fetchall()
        return [DatasetEntry(r[0], r[1], bool(r[2])) for r in rows]

    # ------------------------------------------------------------------
    # Legacy helpers expected by the UI
    # ------------------------------------------------------------------
    @property
    def entries(self) -> Dict[str, DatasetEntry]:
        """
        Return a mapping of dataset name → DatasetEntry.  Many UI
        components iterate over ``dataset_mgr.entries.items()`` to
        display the current datasets.
        """
        return {d.name: d for d in self.list()}

    def add_dataset(self, name: str, src_path: str) -> None:
        """
        Alias for :meth:`add`.  Mirrors the original API where
        ``add_dataset`` saved the file contents into the managed
        datasets directory.
        """
        self.add(name, src_path)

    def delete_dataset(self, name: str) -> None:
        """
        Alias for :meth:`delete`.  Removes the dataset completely.
        """
        self.delete(name)

    def toggle_active(self, name: str, active: bool) -> None:
        """
        Alias for :meth:`toggle`.  Enables or disables a dataset.
        """
        self.toggle(name, active)

    def load_dataset_text(self, entry: DatasetEntry) -> Optional[str]:
        """
        Load the full text of a dataset entry.  For plain text files
        this simply reads and returns the file contents.  For PDF
        files no conversion is attempted – callers should handle
        alternative formats.  Returns ``None`` on error.
        """
        try:
            path = entry.path
            if not os.path.isfile(path):
                return None
            _, ext = os.path.splitext(path)
            ext = ext.lower()
            if ext in {".txt", ".md", ".json", ".py"}:
                with open(path, "r", encoding="utf-8", errors="ignore") as fh:
                    return fh.read()
            elif ext == ".pdf":
                # basic fallback: return None; PDF parsing requires additional deps
                return None
            else:
                # unknown format; attempt text read
                with open(path, "r", encoding="utf-8", errors="ignore") as fh:
                    return fh.read()
        except Exception:
            return None

    def add(self, name: str, src_path: str) -> None:
        if not name.strip():
            raise ValueError("dataset name required")
        if any(ds.name == name for ds in self.list()):
            raise FileExistsError("dataset already exists")
        dst_dir  = os.path.join(self.root, name)
        os.makedirs(dst_dir, exist_ok=True)
        dst_file = shutil.copy2(src_path, self._path_for(name))
        with self.store.tx() as c:
            c.execute(
                "INSERT INTO datasets (name,active,original_path) VALUES (?,?,?)",
                (name, 1, dst_file),
            )
        self.datasetListChanged.emit()

    def toggle(self, name: str, active: bool) -> None:
        with self.store.tx() as c:
            c.execute("UPDATE datasets SET active=? WHERE name=?", (1 if active else 0, name))
        self.datasetListChanged.emit()

    def delete(self, name: str) -> None:
        try:
            shutil.rmtree(os.path.dirname(self._path_for(name)), ignore_errors=True)
        except Exception:
            pass
        with self.store.tx() as c:
            c.execute("DELETE FROM datasets WHERE name=?", (name,))
        self.datasetListChanged.emit()


# ══════════════════════════════════════════════════════════════════════════
#  RAGCache (embeddings cache)
# ══════════════════════════════════════════════════════════════════════════
try:
    import numpy as np
    from sentence_transformers import SentenceTransformer
except Exception:
    np = None
    SentenceTransformer = None  # type: ignore

class RAGCache:
    def __init__(self, model: Optional[Any], model_name: str, datasets_root: str):
        self.model       = model
        self.model_name  = model_name
        self.root        = datasets_root
        self._mem: Dict[str, Dict[str, Any]] = {}

    def _cache_path(self, ds_path: str) -> str:
        base = f"embeddings_{self.model_name}.npz"
        return os.path.join(os.path.dirname(ds_path), base)

    def _encode(self, sentences: List[str]) -> Optional["np.ndarray"]:
        if self.model is None or np is None:
            return None
        try:
            emb = self.model.encode(sentences, convert_to_numpy=True, normalize_embeddings=True)  # type: ignore
        except TypeError:
            emb = self.model.encode(sentences, convert_to_numpy=True)  # type: ignore
            emb = emb / (np.linalg.norm(emb, axis=1, keepdims=True) + 1e-9)  # type: ignore
        return np.asarray(emb)

    def load_or_build(self, ds_entry: DatasetEntry, full_text: str) -> Optional[Dict[str, Any]]:
        if self.model is None or np is None:
            return None
        key = ds_entry.path
        if key in self._mem:
            return self._mem[key]

        cache_path = self._cache_path(key)
        if os.path.isfile(cache_path):
            try:
                data = np.load(cache_path, allow_pickle=False)
                with open(cache_path.replace(".npz", ".json"), "r", encoding="utf-8") as fh:
                    sents = json.load(fh)
                self._mem[key] = {"sentences": sents, "emb": data["emb"]}
                return self._mem[key]
            except Exception:
                pass

        sentences = [s.strip() for s in full_text.split("\n") if s.strip()] or [full_text[:500]]
        emb = self._encode(sentences)
        if emb is None:
            return None
        self._mem[key] = {"sentences": sentences, "emb": emb}
        try:
            np.savez_compressed(cache_path, emb=emb)
            with open(cache_path.replace(".npz", ".json"), "w", encoding="utf-8") as fh:
                json.dump(sentences, fh)
        except Exception:
            pass
        return self._mem[key]

    def clear_memory(self) -> None:
        self._mem.clear()

    def clear_disk(self) -> int:
        removed = 0
        for root, _, files in os.walk(self.root):
            for fn in files:
                if fn.startswith("embeddings_") and fn.endswith((".npz", ".json")):
                    try:
                        os.remove(os.path.join(root, fn))
                        removed += 1
                    except Exception:
                        pass
        return removed


# ══════════════════════════════════════════════════════════════════════════
#  SnapshotEngine (“system self-perception”)
# ══════════════════════════════════════════════════════════════════════════
class SnapshotEngine(QtCore.QObject):
    snapshotFinished = QtCore.pyqtSignal(int)

    def __init__(self, base_dir: str):
        super().__init__()
        self.store    = _ensure_store(base_dir)
        self.base_dir = base_dir

    def run_snapshot(self, root: Optional[str] = None, *, chunk_bytes: int = 8192) -> None:
        threading.Thread(
            target=self._worker,
            args=(root or self.base_dir, chunk_bytes),
            daemon=True,
        ).start()

    def _worker(self, root: str, chunk_sz: int):
        rows = 0
        with self.store._pool.get() as c:
            for dirpath, _, files in os.walk(root):
                if "__pycache__" in dirpath or ".git" in dirpath:
                    continue
                for fn in files:
                    path = os.path.join(dirpath, fn)
                    try:
                        st            = os.stat(path)
                        size, mtime   = st.st_size, st.st_mtime
                        sha           = hashlib.sha256(open(path, "rb").read()).hexdigest()
                        mime          = mimetypes.guess_type(fn)[0] or "application/octet-stream"
                        if mime.startswith(("text/", "application/json", "application/xml")) and size <= 2_000_000:
                            data   = open(path, "r", encoding="utf-8", errors="ignore").read()
                            chunks = [data[i : i + chunk_sz] for i in range(0, len(data), chunk_sz)] or [""]
                        else:
                            chunks = [""]
                        for idx, chunk in enumerate(chunks):
                            c.execute(
                                """
                                INSERT INTO system_files
                                  (path,size,mtime,sha256,mime,chunk_index,content)
                                VALUES (?,?,?,?,?,?,?)
                                ON CONFLICT(path) DO UPDATE SET
                                  size  = excluded.size,
                                  mtime = excluded.mtime,
                                  sha256= excluded.sha256
                                """,
                                (path, size, mtime, sha, mime, idx, chunk),
                            )
                            rows += 1
                    except Exception as e:
                        logger.warning("snapshot skip %s: %s", path, e)
            c.connection.commit()
        self.snapshotFinished.emit(rows)


# ══════════════════════════════════════════════════════════════════════════
#  SpatialPositionManager (grid-room positions & logs)
# ══════════════════════════════════════════════════════════════════════════
class SpatialPositionManager(QtCore.QObject):
    positionChanged = QtCore.pyqtSignal(str, int, int)
    actionLogged    = QtCore.pyqtSignal(str, str)

    def __init__(self, base_dir: str):
        super().__init__()
        self.store = _ensure_store(base_dir)

    def _log_action(self, entity: str, action: str, location: str, justification: str) -> None:
        with self.store.tx() as c:
            c.execute(
                "INSERT INTO visual_actions(entity,action,location,justification)"
                " VALUES (?,?,?,?)",
                (entity, action, location, justification),
            )
        self.actionLogged.emit(entity, action)

    def update_position(self, entity: str, x: int, y: int, *, facing: str = "right", color: str = "#F8BBD0") -> None:
        with self.store.tx() as c:
            c.execute(
                "INSERT INTO spatial_positions(entity,x,y,facing,color)"
                " VALUES(?,?,?,?,?)",
                (entity, x, y, facing, color),
            )
        self.positionChanged.emit(entity, x, y)

    def latest_position(self, entity: str) -> Optional[Tuple[int, int]]:
        with self.store._pool.get() as c:
            row = c.execute(
                "SELECT x,y FROM spatial_positions WHERE entity=? ORDER BY id DESC LIMIT 1",
                (entity,),
            ).fetchone()
        return (row[0], row[1]) if row else None


# ───────────────────────────────────────────────────────────────────────────
# Back-compatibility alias
# ───────────────────────────────────────────────────────────────────────────
SchemaManager = SchemaEngine


# ══════════════════════════════════════════════════════════════════════════
#  Public module API
# ══════════════════════════════════════════════════════════════════════════
__all__ = [
    "Schema", "SchemaEngine", "SchemaManager",
    "OperatorManager",
    "DatasetEntry", "DatasetManager",
    "RAGCache",
    "SnapshotEngine", "SpatialPositionManager",
]
```

core_schema.py — v3-final (2025-08-04 04:12 UTC)
================================================

Single-source authority for all schema / dataset / snapshot / spatial-state
logic used by FATHOM Agent, now relying on AgentStore’s public API only.

Provides:
• Schema dataclass + SchemaEngine (diff, auto-evolve, variant injection)
• OperatorManager persisted in the same DB
• DatasetManager (metadata) + RAGCache (embeddings) in the same DB
• SnapshotEngine to walk the codebase & persist chunks to DB
• SpatialPositionManager for grid-room positions & movement logging
• Back-compat alias: SchemaManager → SchemaEngine

This version adds the `.active_schemas` property required by main_ui.py.
**Classes:** Schema, SchemaEngine, OperatorManager, DatasetEntry, DatasetManager, RAGCache, SnapshotEngine, SpatialPositionManager
**Functions:** _ensure_store(root)


## Module `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\_burner_scripts\main_ui.py`

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
main_ui.py
===========

This module contains the top-level ``AppWindow`` class for the AI TTS
Agent.  It orchestrates all layout and docking behaviour, integrates
the control panel and persona tabs provided by ``commands_panel`` and
``persona_tab``, and exposes a unified interface for the rest of the
application.  None of the core agent logic lives here – that remains in
the ``core_*`` modules.  This refactor pulls the bulky UI building
logic out of the monolithic script and into dedicated modules while
preserving all existing behaviour and wiring.
"""

from __future__ import annotations

import os
import json
import time
import re
import subprocess
import threading
from typing import Dict, List, Tuple, Optional


from PyQt5 import QtCore, QtGui, QtWidgets

# Optional spell checker
try:
    from spellchecker import SpellChecker  # type: ignore
except Exception:
    SpellChecker = None  # type: ignore
from PyQt5.QtCore import QSettings, QRunnable, QThreadPool
from functools import partial

# Optional deps
try:
    from sentence_transformers import SentenceTransformer  # type: ignore
except Exception:
    SentenceTransformer = None  # type: ignore
try:
    import numpy as np  # type: ignore
except Exception:
    np = None  # type: ignore
try:
    import sounddevice as sd  # type: ignore
except Exception:
    sd = None  # type: ignore

# Import core orchestrator components instead of the monolithic agent_core.
# The modular agent splits responsibilities across core_base, core_schema and
# core_orchestrator.  AgentCore and ModelWorker live in core_orchestrator.
from core_orchestrator import (
    AgentCore,
    ModelWorker,
)

from snapshot_worker import ModelWorker

# ─── Command-Palette import ───────────────────────────────────────────
from command_palette import CommandPaletteDock

# Import the modular UI components
from commands_panel import CommandsPanel
from persona_tab import PersonaTab

ROLE_COLOURS: Dict[str, str] = {
    "user": "#FFF8E1",
    "zira": "#E3F2FD",
    "system": "#E0F7FA",
    "operator": "#EDE7F6",
}
NAME_COLOURS: Dict[str, str] = {
    "user": "#5D4037",
    "zira": "#0D47A1",
    "system": "#006064",
    "operator": "#4A148C",
}


# ---------------------------------------------------------------------------
# Spell highlighting for misspelled words
# ---------------------------------------------------------------------------
class _SpellHighlighter(QtGui.QSyntaxHighlighter):
    """
    Underlines misspelled words in red. Uses pyspellchecker if available.
    """

    def __init__(self, document: QtGui.QTextDocument) -> None:
        super().__init__(document)
        # instantiate spell checker only if available
        self._spell = SpellChecker() if SpellChecker else None
        self._format = QtGui.QTextCharFormat()
        self._format.setUnderlineStyle(QtGui.QTextCharFormat.SpellCheckUnderline)
        self._format.setUnderlineColor(QtCore.Qt.red)
        # simple cache to avoid recomputing spelling on common words
        self._cache: Dict[str, bool] = {}

    def highlightBlock(self, text: str) -> None:
        if not self._spell:
            return
        for match in re.finditer(r"[A-Za-z']{3,}", text):
            word = match.group(0).lower()
            bad = self._cache.get(word)
            if bad is None:
                bad = word not in self._spell
                # prune cache occasionally
                if len(self._cache) > 2048:
                    self._cache.clear()
                self._cache[word] = bad
            if bad:
                start, end = match.span()
                length = end - start
                self.setFormat(start, length, self._format)


class AppWindow(QtWidgets.QMainWindow):
    """Main application window for the AI TTS Agent."""

    rewrite_ready = QtCore.pyqtSignal(str)

    def __init__(self) -> None:
        super().__init__()
        self.setWindowTitle("AI TTS Agent v2")
        self.resize(1920, 1080)

        self.base_dir = os.path.dirname(os.path.abspath(__file__))
        self.core = AgentCore(self.base_dir, persona="zira", set_name="default")

        self.current_set: Dict[str, str] = dict(self.core.schema_mgr.active_schemas)
        self.active_persona: str = self.core.persona or "zira"

        self.isolated_history: List[Tuple[str, str]] = []
        self.self_talk_enabled: bool = False
        self._plugin_docks: Dict[str, QtWidgets.QDockWidget] = {}
        self._schema_save_timers: Dict[str, QtCore.QTimer] = {}

        self._idle_timer = QtCore.QTimer(self)
        self._idle_timer.setSingleShot(True)
        self._idle_timer.timeout.connect(self._handle_idle)

        self._restore_layout()
        self._build_ui()
        # build the slash command panel (custom dock)
        self._build_command_dock()
        self._connect_signals()
        
            # ── Command Palette setup ─────────────────────────────────────────
        self.cmd_palette = CommandPaletteDock(self)
        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.cmd_palette)
        # update palette whenever commands change
        self.core.commandsChanged.connect(self.cmd_palette.set_command_list)
        # insert chosen command into chat input
        self.cmd_palette.commandActivated.connect(self._insert_into_chat)


        try:
            self.core.audio_recorder.transcribed.connect(self._on_transcribed)
        except Exception:
            pass

        self._update_feedback_counts()
        self._bootstrap_conversation()
        self._reset_idle_timer()

        # populate initial slash command list
        try:
            self._populate_command_select()
        except Exception:
            pass

    # ────────────────────────── signals
    def _connect_signals(self) -> None:
        self.btn_send.clicked.connect(self.send_message)

        # Recording controls come from the commands panel
        self.btn_record.clicked.connect(self.start_recording)
        self.btn_stop_rec.clicked.connect(self.stop_recording)

        self.voice_combo.currentTextChanged.connect(self._on_voice_changed)
        # update settings when a new model is selected
        self.model_combo.currentTextChanged.connect(self._on_model_changed)

        self.btn_play.clicked.connect(self._on_play)
        self.btn_stop_tts.clicked.connect(self._on_stop_tts)
        self.btn_replay.clicked.connect(self._on_replay)

        self.btn_like.clicked.connect(self._on_like)
        self.btn_dislike.clicked.connect(self._on_dislike)
        self.btn_manage_feedback.clicked.connect(self._on_manage_feedback)

        self.btn_refresh.clicked.connect(self._on_refresh_chat)
        self.btn_manage_datasets.clicked.connect(self._on_manage_datasets)
        self.btn_inner_monologue.clicked.connect(self._on_inner_monologue)
        self.btn_clear_rag.clicked.connect(self._on_clear_rag_cache)
        self.btn_model_manager.clicked.connect(self._on_show_model_manager)

        self.chk_semantic.toggled.connect(self._on_semantic_toggled)
        self.chk_isolated.toggled.connect(self._on_isolated_toggled)
        self.chk_self_talk.toggled.connect(lambda v: setattr(self, "self_talk_enabled", v))
        self.chk_auto_schema.toggled.connect(self._on_auto_schema_toggled)

        # connect Google STT checkbox
        try:
            self.chk_google_stt.toggled.connect(self._on_google_stt_toggled)
        except Exception:
            pass

        self.rewrite_ready.connect(self._apply_rewrite_result)

        # context menu for chat view to send selection to command input
        try:
            self.chat_view.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
            self.chat_view.customContextMenuRequested.connect(self._show_chat_context_menu)
        except Exception:
            pass
        # custom context menu for spell suggestions on input field
        try:
            self.input_edit.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
            self.input_edit.customContextMenuRequested.connect(self._show_input_context_menu)
        except Exception:
            pass
            
    def _on_show_command_palette(self) -> None:
        """Toggle the command-palette dock."""
        if self.cmd_palette.isVisible():
            self.cmd_palette.hide()
        else:
            self.cmd_palette.show()
            self.cmd_palette.raise_()
            self.cmd_palette.search_edit.setFocus(QtCore.Qt.ShortcutFocusReason)

    def _insert_into_chat(self, cmd: str) -> None:
        """Insert a slash-command into the chat input."""
        self.input_edit.insertPlainText(cmd + " ")
        self.input_edit.setFocus()                       

    # ────────────────────────── layout & lifecycle
    def _restore_layout(self) -> None:
        qsettings = QSettings("xAI", "AI_TTS_Agent")
        try:
            self.restoreGeometry(qsettings.value("geometry", b""))
            self.restoreState(qsettings.value("windowState", b""))
        except Exception:
            pass

    def closeEvent(self, event: QtGui.QCloseEvent) -> None:
        qsettings = QSettings("xAI", "AI_TTS_Agent")
        qsettings.setValue("geometry", self.saveGeometry())
        qsettings.setValue("windowState", self.saveState())
        try:
            self.core.close()
        except Exception:
            pass
        super().closeEvent(event)

    # ────────────────────────── UI build
    def _build_ui(self) -> None:
        self.setStyleSheet(
            """
            QWidget { background-color: #2e3a51; color: #e0e0e0; }
            QGroupBox { border: 1px solid #007acc; margin-top: 7px; }
            QGroupBox::title { subcontrol-origin: margin; left: 12px; padding: 0 4px; }
            QPushButton { background-color: #3c4a6b; color: white; border: 1px solid #007acc; padding: 5px; }
            QPushButton:disabled { background-color: #5a5a7a; color: #c0c0c0; border: 1px solid #555555; }
            QPlainTextEdit, QTextEdit { background-color: #1e2738; color: #e0e0e0; border: 1px solid #007acc; }
            QLineEdit { background-color: #1e2738; color: #e0e0e0; border: 1px solid #007acc; }
            QTabBar::tab { background: #3c4a6b; color: white; border: 1px solid #007acc; padding: 5px 10px; }
            QTabBar::tab:selected { background: #007acc; color: white; }
            QComboBox { background-color: #1e2738; color: #e0e0e0; border: 1px solid #007acc; padding: 3px; }
            QListWidget { background-color: #1e2738; color: #e0e0e0; border: 1px solid #007acc; }
            QCheckBox, QLabel { color: #e0e0e0; }
            """
        )
        self.setDockOptions(
            QtWidgets.QMainWindow.AllowTabbedDocks
            | QtWidgets.QMainWindow.AllowNestedDocks
            | QtWidgets.QMainWindow.AnimatedDocks
        )
        self.setTabPosition(QtCore.Qt.AllDockWidgetAreas, QtWidgets.QTabWidget.North)
        self.setDockNestingEnabled(True)

        tb = QtWidgets.QToolBar("Layout", self)
        tb.setMovable(False)
        self.addToolBar(QtCore.Qt.TopToolBarArea, tb)
        self.chk_lock = QtWidgets.QCheckBox("Lock Layout")
        act = QtWidgets.QWidgetAction(self)
        act.setDefaultWidget(self.chk_lock)
        tb.addAction(act)
        self.chk_lock.toggled.connect(self._on_toggle_lock)

        self.setCentralWidget(QtWidgets.QWidget())
        status = QtWidgets.QStatusBar()
        self.setStatusBar(status)
        self.dock_tray = DockTray(self)
        status.addPermanentWidget(self.dock_tray, 1)

        self.progress_bar = QtWidgets.QProgressBar()
        self.progress_bar.setRange(0, 0)
        self.progress_bar.setVisible(False)
        status.addPermanentWidget(self.progress_bar)

        # Tabs for personas / operators are handled by PersonaTab
        # Chat panel
        self.chat_view = QtWidgets.QTextEdit()
        self.chat_view.setReadOnly(True)
        self.chat_view.setStyleSheet("background-color: #e0eef5; color: #011627;")
        self.chat_view.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        self.input_edit = QtWidgets.QPlainTextEdit()
        self.input_edit.setPlaceholderText("Type your message or use /remember key value, /showfacts, /style, /weights")
        self.input_edit.setMinimumHeight(64)
        self.input_edit.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        # Attach spell checker highlighter if available
        try:
            if SpellChecker:
                self._spell_highlighter = _SpellHighlighter(self.input_edit.document())  # type: ignore[attr-defined]
        except Exception:
            self._spell_highlighter = None
        self.btn_send = QtWidgets.QPushButton("Send")

        chat_container = QtWidgets.QWidget()
        cv = QtWidgets.QVBoxLayout(chat_container)
        cv.setContentsMargins(7, 7, 7, 7)
        cv.setSpacing(7)
        cv.addWidget(self.chat_view, 1)
        cv.addWidget(self.input_edit)
        row = QtWidgets.QHBoxLayout()
        row.addStretch()
        row.addWidget(self.btn_send)
        cv.addLayout(row)

        # ───── Instantiate modular panels
        # Commands panel (controls)
        self.commands_panel = CommandsPanel(self)
        # Copy child attributes to the AppWindow so existing logic continues to work
        for name in [
            'btn_record','btn_stop_rec','device_combo','chk_semantic','chk_isolated','chk_mute_tts',
            'chk_self_talk','chk_auto_schema','chk_google_stt','btn_clear_rag','btn_refresh',
            'btn_manage_datasets','btn_inner_monologue','btn_model_manager','style_label',
            'response_edit','btn_like','btn_dislike','btn_manage_feedback','btn_play','btn_stop_tts',
            'btn_replay','voice_combo','model_combo','lbl_feedback_counts'
        ]:
            setattr(self, name, getattr(self.commands_panel, name))

        # Persona panel
        self.persona_panel = PersonaTab(self)
        # Copy persona panel attributes
        self.tabs = self.persona_panel.tabs
        self.tab_widgets = self.persona_panel.tab_widgets
        self.operator_tab = self.persona_panel.operator_tab
        self.lbl_active_names = self.persona_panel.lbl_active_names

        # Docks
        # Controls dock
        controls_scroll = QtWidgets.QScrollArea()
        controls_scroll.setWidgetResizable(True)
        controls_scroll.setFrameShape(QtWidgets.QFrame.NoFrame)
        controls_scroll.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)
        controls_scroll.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        controls_scroll.setWidget(self.commands_panel)

        self.controls_dock = QtWidgets.QDockWidget("Controls", self)
        self.controls_dock.setObjectName("ControlsDock")
        self.controls_dock.setWidget(controls_scroll)
        self.controls_dock.setFeatures(
            QtWidgets.QDockWidget.DockWidgetClosable
            | QtWidgets.QDockWidget.DockWidgetMovable
            | QtWidgets.QDockWidget.DockWidgetFloatable
        )

        # Persona dock
        self.persona_dock = QtWidgets.QDockWidget("Personas", self)
        self.persona_dock.setObjectName("PersonaDock")
        self.persona_dock.setWidget(self.persona_panel)
        self.persona_dock.setFeatures(
            QtWidgets.QDockWidget.DockWidgetClosable
            | QtWidgets.QDockWidget.DockWidgetMovable
            | QtWidgets.QDockWidget.DockWidgetFloatable
        )

        # Chat dock
        self.chat_dock = QtWidgets.QDockWidget("Chat", self)
        self.chat_dock.setObjectName("ChatDock")
        self.chat_dock.setWidget(chat_container)
        self.chat_dock.setFeatures(
            QtWidgets.QDockWidget.DockWidgetClosable
            | QtWidgets.QDockWidget.DockWidgetMovable
            | QtWidgets.QDockWidget.DockWidgetFloatable
        )

        # Model dock
        self.model_dock = QtWidgets.QDockWidget("Models", self)
        self.model_dock.setObjectName("ModelDock")
        self.model_dock.setFeatures(
            QtWidgets.QDockWidget.DockWidgetClosable
            | QtWidgets.QDockWidget.DockWidgetMovable
            | QtWidgets.QDockWidget.DockWidgetFloatable
        )
        self._build_model_manager()

        # Plugins dock
        self.plugins_dock = QtWidgets.QDockWidget("Plugins", self)
        self.plugins_dock.setObjectName("PluginsDock")
        self.plugins_dock.setFeatures(
            QtWidgets.QDockWidget.DockWidgetClosable
            | QtWidgets.QDockWidget.DockWidgetMovable
            | QtWidgets.QDockWidget.DockWidgetFloatable
        )
        self.plugins_dock.setWidget(self._build_plugins_widget())

        # Titles & dock tray
        self.controls_dock.setTitleBarWidget(DockTitleBar(self.controls_dock, "Controls"))
        self.persona_dock.setTitleBarWidget(DockTitleBar(self.persona_dock, "Personas"))
        self.chat_dock.setTitleBarWidget(DockTitleBar(self.chat_dock, "Chat"))
        self.model_dock.setTitleBarWidget(DockTitleBar(self.model_dock, "Models"))
        self.plugins_dock.setTitleBarWidget(DockTitleBar(self.plugins_dock, "Plugins"))

        # Register docks with the tray
        for d in (self.controls_dock, self.persona_dock, self.chat_dock, self.model_dock, self.plugins_dock):
            self.dock_tray.register_dock(d)

        # Add docks to the layout
        self.addDockWidget(QtCore.Qt.LeftDockWidgetArea, self.controls_dock)
        self.addDockWidget(QtCore.Qt.LeftDockWidgetArea, self.persona_dock)
        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.chat_dock)
        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.model_dock)
        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.plugins_dock)

        # Splitters as before
        self.splitDockWidget(self.controls_dock, self.persona_dock, QtCore.Qt.Vertical)
        self.splitDockWidget(self.controls_dock, self.chat_dock, QtCore.Qt.Horizontal)
        self.splitDockWidget(self.chat_dock, self.model_dock, QtCore.Qt.Horizontal)
        self.splitDockWidget(self.model_dock, self.plugins_dock, QtCore.Qt.Horizontal)

    # The remainder of the methods are largely unchanged from the original
    # implementation.  They continue to reference widgets via ``self`` which
    # now refer to the proxies created from the modular panels.

    # ────────────────────────── persona widgets (removed UI build; logic preserved)
    def _on_tab_changed(self, index: int) -> None:
        """
        Handle tab changes in the main tab widget.

        Parameters
        ----------
        index : int
            Index of the newly selected tab.
        """
        try:
            tab_name = self.tabs.tabText(index)
            print(f"[UI] Tab changed to: {tab_name} (index {index})")
            # Add any extra logic if needed, for example:
            # self._update_feedback_counts()
        except Exception as e:
            print(f"[UI] Error handling tab change: {e}")

    # ────────────────────────── operator tab (moved to persona_tab module)
    # ────────────────────────── plugins
    def _build_plugins_widget(self) -> QtWidgets.QWidget:
        container = QtWidgets.QWidget()
        layout = QtWidgets.QVBoxLayout(container)
        layout.setContentsMargins(6, 6, 6, 6)
        layout.setSpacing(4)

        self.plugin_list = QtWidgets.QListWidget()
        self.plugin_list.setSelectionMode(QtWidgets.QAbstractItemView.NoSelection)
        layout.addWidget(self.plugin_list, 1)

        btn_rescan = QtWidgets.QPushButton("Rescan")
        layout.addWidget(btn_rescan)
        btn_rescan.clicked.connect(self._rescan_plugins)

        self._populate_plugin_list()
        self.plugin_list.itemChanged.connect(self._on_plugin_item_changed)

        try:
            self.core.plugins.eventReceived.connect(self._on_plugin_event)
        except Exception:
            pass

        return container

    def _populate_plugin_list(self) -> None:
        self.plugin_list.blockSignals(True)
        self.plugin_list.clear()
        for meta in self.core.plugins.list_plugins():
            item = QtWidgets.QListWidgetItem(meta.name)
            flags = item.flags() | QtCore.Qt.ItemIsUserCheckable
            if meta.missing_dependencies:
                flags &= ~QtCore.Qt.ItemIsEnabled
                item.setToolTip(f"Missing dependencies: {', '.join(meta.missing_dependencies)}")
            item.setFlags(flags)
            item.setCheckState(QtCore.Qt.Checked if meta.enabled else QtCore.Qt.Unchecked)
            self.plugin_list.addItem(item)
        self.plugin_list.blockSignals(False)

    def _on_plugin_item_changed(self, item: QtWidgets.QListWidgetItem) -> None:
        name = item.text()
        enabled = item.checkState() == QtCore.Qt.Checked
        self.core.plugins.enable_plugin(name, enabled)
        meta = next((m for m in self.core.plugins.list_plugins() if m.name == name), None)
        if not meta:
            return
        if enabled and meta.widget is not None:
            self._attach_plugin_widget(meta)
        elif not enabled:
            self._detach_plugin_widget(name)

    def _rescan_plugins(self) -> None:
        self.core.plugins.rescan()
        for name in list(self._plugin_docks.keys()):
            meta = next((m for m in self.core.plugins.list_plugins() if m.name == name), None)
            if not meta or not meta.enabled:
                self._detach_plugin_widget(name)
        self._populate_plugin_list()

    def _attach_plugin_widget(self, meta: 'object') -> None:
        if meta.name in self._plugin_docks:
            return
        if meta.widget is None:
            return
        dock = QtWidgets.QDockWidget(meta.name, self)
        dock.setObjectName(f"PluginDock_{meta.name}")
        dock.setWidget(meta.widget)
        dock.setFeatures(
            QtWidgets.QDockWidget.DockWidgetClosable
            | QtWidgets.QDockWidget.DockWidgetMovable
            | QtWidgets.QDockWidget.DockWidgetFloatable
        )
        dock.setTitleBarWidget(DockTitleBar(dock, meta.name))
        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, dock)
        self.dock_tray.register_dock(dock)
        self._plugin_docks[meta.name] = dock

    def _detach_plugin_widget(self, name: str) -> None:
        dock = self._plugin_docks.pop(name, None)
        if dock:
            self.dock_tray._remove_button(dock)
            dock.setParent(None)
            dock.deleteLater()

    @QtCore.pyqtSlot(str, dict)
    def _on_plugin_event(self, sender: str, envelope: dict) -> None:
        try:
            data = envelope.get("data")
            msg = json.dumps(data, indent=2) if isinstance(data, (dict, list)) else str(data)
            display_name = sender
            self._append_message(display_name, msg, role_key="operator")
            if self.chk_semantic.isChecked() and not self.chk_isolated.isChecked():
                self.core.conversation_db.save_message(sender.lower(), msg)
        except Exception as e:
            print(f"Error handling plugin event from {sender}: {e}")

    # ────────────────────────── model manager
    def _build_model_manager(self) -> None:
        widget = QtWidgets.QWidget()
        v = QtWidgets.QVBoxLayout(widget)
        v.setContentsMargins(8, 8, 8, 8)
        v.setSpacing(6)
        self.model_list = QtWidgets.QListWidget()
        v.addWidget(self.model_list, 1)
        h = QtWidgets.QHBoxLayout()
        self.btn_model_pull = QtWidgets.QPushButton("Pull")
        self.btn_model_delete = QtWidgets.QPushButton("Delete")
        self.btn_model_set_default = QtWidgets.QPushButton("Set as Default")
        h.addWidget(self.btn_model_pull)
        h.addWidget(self.btn_model_delete)
        h.addWidget(self.btn_model_set_default)
        h.addStretch()
        v.addLayout(h)
        self.model_dock.setWidget(widget)
        self._refresh_model_list()
        self.btn_model_pull.clicked.connect(self._on_model_pull)
        self.btn_model_delete.clicked.connect(self._on_model_delete)
        self.btn_model_set_default.clicked.connect(self._on_model_set_default)

    def _refresh_model_list(self) -> None:
        self.model_list.clear()
        models: List[str] = []
        try:
            out = subprocess.run(
                ["ollama", "list"],
                stdout=subprocess.PIPE,
                stderr=subprocess.DEVNULL,
                text=True,
                check=True,
            ).stdout.splitlines()
            for line in out[1:]:
                parts = line.strip().split()
                if parts:
                    models.append(parts[0])
        except Exception:
            models = []
        for m in models:
            item = QtWidgets.QListWidgetItem(m)
            if m == self.model_combo.currentText().strip():
                item.setFont(QtGui.QFont("", weight=QtGui.QFont.Bold))
            self.model_list.addItem(item)

    def _on_model_pull(self) -> None:
        item = self.model_list.currentItem()
        if not item:
            return
        model = item.text()
        threading.Thread(target=lambda: subprocess.run(["ollama", "pull", model], check=False), daemon=True).start()
        QtWidgets.QMessageBox.information(self, "Pull Started", f"Pulling {model} in background.")

    def _on_model_delete(self) -> None:
        item = self.model_list.currentItem()
        if not item:
            return
        model = item.text()
        if QtWidgets.QMessageBox.question(
            self,
            "Delete Model",
            f"Delete '{model}'? This cannot be undone.",
            QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No,
        ) != QtWidgets.QMessageBox.Yes:
            return
        threading.Thread(target=lambda: subprocess.run(["ollama", "delete", model], check=False), daemon=True).start()
        QtWidgets.QMessageBox.information(self, "Delete Started", f"Deleting {model} in background.")
        self._refresh_model_list()

    def _on_model_set_default(self) -> None:
        item = self.model_list.currentItem()
        if not item:
            return
        model = item.text()
        idx = self.model_combo.findText(model)
        if idx >= 0:
            self.model_combo.setCurrentIndex(idx)
        # persist selection to settings
        try:
            self.core.settings.default_model = model
            self.core.settings.save()
        except Exception:
            pass
            QtWidgets.QMessageBox.information(self, "Default Model", f"Set default model to {model}.")
        else:
            self.model_combo.addItem(model)
            self.model_combo.setCurrentText(model)

    # ────────────────────────── lock layout
    def _on_toggle_lock(self, locked: bool) -> None:
        feats_unlocked = (
            QtWidgets.QDockWidget.DockWidgetClosable
            | QtWidgets.QDockWidget.DockWidgetMovable
            | QtWidgets.QDockWidget.DockWidgetFloatable
        )
        feats_locked = QtWidgets.QDockWidget.DockWidgetClosable
        for dock in (
            self.controls_dock,
            self.persona_dock,
            self.chat_dock,
            getattr(self, "inner_dock", None),
            self.model_dock,
            self.plugins_dock,
        ):
            if dock is None:
                continue
            dock.setFeatures(feats_locked if locked else feats_unlocked)
        for dock in self._plugin_docks.values():
            dock.setFeatures(feats_locked if locked else feats_unlocked)

    # ────────────────────────── audio
    def start_recording(self) -> None:
        if sd is None or np is None:
            QtWidgets.QMessageBox.information(self, "Recording Unavailable", "sounddevice/numpy not installed.")
            return
        if not self.btn_record.isEnabled():
            return
        device_index = None
        try:
            idx = self.device_combo.currentIndex()
            selected_name = self.device_combo.currentText()
            for i, d in enumerate(sd.query_devices()):
                if d.get("name") == selected_name and d.get("max_input_channels", 0) > 0:
                    device_index = i
                    break
        except Exception:
            device_index = None
        self.core.audio_recorder.start(device_index)
        self.btn_record.setEnabled(False)
        self.btn_stop_rec.setEnabled(True)

    def stop_recording(self) -> None:
        if not self.btn_stop_rec.isEnabled():
            return
        self.core.audio_recorder.stop_and_transcribe()
        self.btn_stop_rec.setEnabled(False)
        self.btn_record.setEnabled(True)

    @QtCore.pyqtSlot(str)
    def _on_transcribed(self, text: str) -> None:
        if not text:
            return
        cur = self.input_edit.toPlainText()
        self.input_edit.setPlainText((cur + "\n" if cur else "") + text)

    # ────────────────────────── TTS
    def _on_play(self) -> None:
        text = self.response_edit.toPlainText().strip()
        if text and not self.chk_mute_tts.isChecked():
            try:
                self.core.tts_mgr.enqueue(text)
            except Exception:
                pass

    def _on_stop_tts(self) -> None:
        try:
            self.core.tts_mgr.stop()
        except Exception:
            pass

    def _on_replay(self) -> None:
        if not self.chk_mute_tts.isChecked():
            try:
                self.core.tts_mgr.replay()
            except Exception:
                pass

    def _on_voice_changed(self, name: str) -> None:
        try:
            eng = getattr(self.core.tts_mgr, "_engine", None)
            if eng:
                for v in eng.getProperty("voices"):
                    if v.name == name:
                        eng.setProperty("voice", v.id)
                        break
        except Exception:
            pass

    def _tts_voice_names(self) -> List[str]:
        try:
            eng = getattr(self.core.tts_mgr, "_engine", None)
            if not eng:
                return []
            return [v.name for v in eng.getProperty("voices")]
        except Exception:
            return []

    # ────────────────────────── feedback
    def _on_like(self) -> None:
        text = self.response_edit.toPlainText().strip()
        if not text:
            return
        try:
            self.core.add_feedback(text, liked=True)
        except Exception:
            pass
        QtWidgets.QMessageBox.information(self, "Feedback", "Marked as good response.")
        self._enable_feedback(False)
        self._update_feedback_counts()

    def _on_dislike(self) -> None:
        original = self.response_edit.toPlainText().strip()
        if not original:
            return
        try:
            self.core.tts_mgr.stop()
        except Exception:
            pass
        QtWidgets.QMessageBox.information(self, "Disliked", "The response will be rewritten.")
        self._enable_feedback(False)

        def worker() -> None:
            new_text = self._rewrite_response(original)
            try:
                self.core.add_feedback(original, liked=False, revised=new_text)
            except Exception:
                pass
            if self.chk_isolated.isChecked():
                self.isolated_history.append((self._current_persona(), new_text))
            else:
                if self.chk_semantic.isChecked():
                    self.core.conversation_db.save_message(self._current_persona().lower(), new_text)
            self.rewrite_ready.emit(new_text)

        threading.Thread(target=worker, daemon=True).start()

    @QtCore.pyqtSlot(str)
    def _apply_rewrite_result(self, new_text: str) -> None:
        schema = self.core.schema_mgr.load_schema(
            self._current_persona(), self.current_set.get(self._current_persona(), "default")
        )
        persona_name = schema.get("name", "Bot")
        role_key = self._current_persona().lower()
        self._append_message(persona_name, new_text, role_key=role_key)
        self.response_edit.setPlainText(new_text)
        if not self.chk_mute_tts.isChecked():
            try:
                self.core.tts_mgr.enqueue(new_text)
            except Exception:
                pass
        QtWidgets.QMessageBox.information(self, "Rewritten", "Response rewritten.")
        self._enable_feedback(False)

    def _update_feedback_counts(self) -> None:
        try:
            pos, neg = self.core.feedback_db.get_counts()
            self.lbl_feedback_counts.setText(f"Likes: {pos} | Dislikes: {neg}")
        except Exception:
            self.lbl_feedback_counts.setText("Likes: - | Dislikes: -")

    def _enable_feedback(self, enabled: bool) -> None:
        self.btn_like.setEnabled(enabled)
        self.btn_dislike.setEnabled(enabled)

    def _on_manage_feedback(self) -> None:
        db = self.core.feedback_db
        if db is None:
            QtWidgets.QMessageBox.information(self, "No DB", "Feedback DB unavailable.")
            return
        cur = db.conn.cursor()
        cur.execute("SELECT id, original, liked, COALESCE(revised, '') FROM feedback ORDER BY id DESC")
        entries = cur.fetchall()
        dlg = QtWidgets.QDialog(self)
        dlg.setWindowTitle("Manage Feedback")
        dlg.resize(720, 420)
        v = QtWidgets.QVBoxLayout(dlg)
        table = QtWidgets.QTableWidget(len(entries), 4)
        table.setHorizontalHeaderLabels(["ID", "Original", "Liked", "Revised"])
        table.horizontalHeader().setStretchLastSection(True)
        for r, (fid, orig, liked, rev) in enumerate(entries):
            table.setItem(r, 0, QtWidgets.QTableWidgetItem(str(fid)))
            table.setItem(r, 1, QtWidgets.QTableWidgetItem(orig))
            table.setItem(r, 2, QtWidgets.QTableWidgetItem("✔" if liked else "✖"))
            table.setItem(r, 3, QtWidgets.QTableWidgetItem(rev))
        v.addWidget(table, 1)
        h = QtWidgets.QHBoxLayout()
        btn_del = QtWidgets.QPushButton("Delete Selected")
        btn_close = QtWidgets.QPushButton("Close")
        h.addWidget(btn_del)
        h.addWidget(btn_close)
        h.addStretch()
        v.addLayout(h)

        def on_delete() -> None:
            selected = table.selectedItems()
            if not selected:
                return
            rows = sorted({i.row() for i in selected}, reverse=True)
            for rr in rows:
                fid_item = table.item(rr, 0)
                if fid_item:
                    try:
                        fid = int(fid_item.text())
                        db.conn.execute("DELETE FROM feedback WHERE id = ?", (fid,))
                        db.conn.commit()
                    except Exception:
                        pass
                table.removeRow(rr)
            self._update_feedback_counts()

        btn_del.clicked.connect(on_delete)
        btn_close.clicked.connect(dlg.accept)
        dlg.exec_()

    # ────────────────────────── datasets / rag
    def _on_manage_datasets(self) -> None:
        DatasetManagerDialog(self.core.dataset_mgr, self).exec_()

    def _on_clear_rag_cache(self) -> None:
        if QtWidgets.QMessageBox.question(
            self,
            "Clear RAG Cache",
            "Delete cached embeddings for all datasets and clear memory?",
            QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No,
        ) != QtWidgets.QMessageBox.Yes:
            return
        count = self.core.rag_cache.clear_disk()
        self.core.rag_cache.clear_memory()
        QtWidgets.QMessageBox.information(self, "Cleared", f"Cleared RAG cache files ({count} removed) and in-memory index.")

    # ────────────────────────── isolated / refresh / idle
    def _on_isolated_toggled(self, checked: bool) -> None:
        if checked:
            self.isolated_history.clear()
        else:
            if self.isolated_history:
                ans = QtWidgets.QMessageBox.question(
                    self,
                    "Merge Isolated Chat",
                    "Merge isolated conversation into main memory?",
                    QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No,
                )
                if ans == QtWidgets.QMessageBox.Yes:
                    for role, content in self.isolated_history:
                        self.core.conversation_db.save_message(role.lower(), content)
                self.isolated_history.clear()
        self._reset_idle_timer()

    def _on_refresh_chat(self) -> None:
        if self.chk_isolated.isChecked():
            self.isolated_history.clear()
        self.chat_view.clear()
        self.response_edit.clear()
        self._enable_feedback(False)
        try:
            if hasattr(self, "inner_text") and self.inner_text is not None:
                self.inner_text.clear()
        except Exception:
            pass

    def _reset_idle_timer(self) -> None:
        self._idle_timer.stop()
        if self.chk_semantic.isChecked():
            self._idle_timer.start(60000)

    def _handle_idle(self) -> None:
        pass

    # ────────────────────────── inner monologue
    def _on_inner_monologue(self) -> None:
        self._ensure_inner_dock()
        if self.inner_dock is None:
            return
        self.inner_dock.setVisible(not self.inner_dock.isVisible())

    def _ensure_inner_dock(self) -> None:
        if hasattr(self, "inner_dock") and self.inner_dock is not None:
            return
        dock = QtWidgets.QDockWidget("Inner Monologue", self)
        dock.setObjectName("InnerDock")
        dock.setAllowedAreas(QtCore.Qt.RightDockWidgetArea | QtCore.Qt.LeftDockWidgetArea)
        inner = QtWidgets.QWidget()
        v = QtWidgets.QVBoxLayout(inner)
        self.inner_text = QtWidgets.QPlainTextEdit()
        self.inner_text.setReadOnly(True)
        v.addWidget(self.inner_text, 1)
        h = QtWidgets.QHBoxLayout()
        h.addWidget(QtWidgets.QLabel("Interval (s):"))
        self.spin_interval = QtWidgets.QSpinBox()
        self.spin_interval.setRange(1, 60)
        self.spin_interval.setValue(15)
        h.addWidget(self.spin_interval)
        self.chk_monologue_tts = QtWidgets.QCheckBox("Speak")
        self.chk_monologue_tts.setChecked(self.core.settings.monologue_tts_enabled)
        h.addWidget(self.chk_monologue_tts)
        h.addWidget(QtWidgets.QLabel("Volume:"))
        self.slider_monologue_vol = QtWidgets.QSlider(QtCore.Qt.Horizontal)
        self.slider_monologue_vol.setRange(0, 100)
        self.slider_monologue_vol.setValue(self.core.settings.monologue_volume)
        h.addWidget(self.slider_monologue_vol)
        btn_start_stop = QtWidgets.QPushButton("Start/Stop")
        h.addWidget(btn_start_stop)
        v.addLayout(h)
        inner.setLayout(v)
        dock.setWidget(inner)
        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, dock)
        self.inner_dock = dock
        self.inner_timer = QtCore.QTimer(self)
        self.inner_timer.setSingleShot(False)
        btn_start_stop.clicked.connect(self._toggle_inner_timer)
        dock.setTitleBarWidget(DockTitleBar(dock, "Inner Monologue"))
        self.dock_tray.register_dock(self.inner_dock)
        self.chk_monologue_tts.stateChanged.connect(lambda _: self._update_monologue_settings())
        self.slider_monologue_vol.valueChanged.connect(lambda _: self._update_monologue_settings())

    def _toggle_inner_timer(self) -> None:
        if self.inner_timer is None:
            return
        if self.inner_timer.isActive():
            self.inner_timer.stop()
        else:
            interval_ms = self.spin_interval.value() * 1000
            try:
                self.inner_timer.timeout.disconnect()
            except Exception:
                pass
            self.inner_timer.timeout.connect(self._generate_inner_monologue)
            self.inner_timer.start(interval_ms)

    def _update_monologue_settings(self) -> None:
        try:
            self.core.settings.monologue_tts_enabled = self.chk_monologue_tts.isChecked() if hasattr(self, 'chk_monologue_tts') else False
            self.core.settings.monologue_volume = self.slider_monologue_vol.value() if hasattr(self, 'slider_monologue_vol') else 50
            self.core.settings.save()
        except Exception:
            pass

    def _generate_inner_monologue(self) -> None:
        schema = self.core.schema_mgr.load_schema(self._current_persona(), self.current_set.get(self._current_persona(), "default"))
        overlay = schema.get("dynamic_overlay", {}) or {}
        mood = overlay.get("temporary_emotional_state", "neutral")
        likes = overlay.get("recent_topics", [])
        pos = [0, 0]
        fav_topic = likes[-1] if likes else None
        thought = f"I'm thinking about {fav_topic} while feeling {mood}." if fav_topic else f"I'm in a {mood} mood and reflecting."
        thought += f" I'm at position {pos}."
        try:
            if hasattr(self, "inner_text") and self.inner_text is not None:
                self.inner_text.appendPlainText(thought)
        except Exception:
            pass

    # ────────────────────────── conversation
    def _append_message(self, display_name: str, text: str, role_key: Optional[str] = None) -> None:
        key = (role_key or display_name).lower()
        bg_colour = ROLE_COLOURS.get(key, "#EEEEEE")
        name_colour = NAME_COLOURS.get(key, "#011627")
        safe_role = QtGui.QGuiApplication.translate("Chat", display_name)
        safe_text = QtGui.QGuiApplication.translate("Chat", text)
        frag = (
            f'<div style="background-color:{bg_colour}; border-radius:4px; padding:4px; margin:4px;">'
            f'<b style="color:{name_colour};">{safe_role}:</b> {safe_text}'
            f'</div>'
        )
        self.chat_view.append(frag)

    def _current_history(self) -> List[Tuple[str, str]]:
        if self.chk_isolated.isChecked():
            return self.isolated_history
        else:
            return self.core.conversation_db.fetch_history(limit=10)

    def _bootstrap_conversation(self) -> None:
        if self.core and len(self.core.conversation_db.fetch_history(limit=1)) == 0:
            schema = self.core.schema_mgr.load_schema(self.active_persona, self.current_set.get(self.active_persona, "default"))
            questions = schema.get("questions", [])
            if questions:
                first_question = questions[0]
                self._append_message("System", first_question, role_key="system")
                if self.chk_semantic.isChecked() and not self.chk_isolated.isChecked():
                    self.core.conversation_db.save_message("system", first_question)

    # ────────────────────────── prompt & rag
    def _build_prompt(self, schema: Dict[str, object], user_text: str, is_self_talk: bool = False) -> str:
        parts: List[str] = []
        name = schema.get("name", "")
        role = schema.get("role", "")
        desc = schema.get("description", "")
        persona_desc = f"You are {name}, {desc}".strip()
        if role:
            persona_desc += f" Your role is {role}."

        overlay = schema.get("dynamic_overlay", {})
        if overlay:
            temp_rel = overlay.get("temporary_relationship_context", "")
            temp_emotion = overlay.get("temporary_emotional_state", "")
            added_traits = overlay.get("added_traits", [])
            if temp_rel:
                persona_desc += f" ({temp_rel})"
            if temp_emotion:
                persona_desc += f" You feel {temp_emotion}."
            if added_traits:
                persona_desc += f" Traits: {', '.join(str(t) for t in added_traits)}."
        parts.append(persona_desc)

        # User description
        try:
            user_schema = self.core.schema_mgr.load_schema("user", self.current_set.get("user", "default"))
        except Exception:
            user_schema = {}
        if user_schema:
            u_name = user_schema.get("name", "User")
            u_personality = user_schema.get("personality", "")
            relationship = user_schema.get("relationship_to_zira", "friend")
            u_overlay = user_schema.get("dynamic_overlay", {})
            temp_rel2 = u_overlay.get("temporary_relationship_context") if u_overlay else None
            if temp_rel2 and str(temp_rel2).strip():
                relationship = str(temp_rel2)
            user_desc = f"User is {u_name}, {u_personality}. Relationship: {relationship}."
            parts.append(user_desc)

        # History
        history_text = ""
        if self.chk_semantic.isChecked():
            history = self._current_history()[-10:]
            for role_name, content in history:
                speaker = "User" if role_name.lower() == "user" else role_name.title()
                history_text += f"{speaker}: {content}\n"
        if history_text:
            parts.append("Conversation history:\n" + history_text.strip())

        # RAG (only datasets listed by this set)
        dataset_text = ""
        ds_names: List[str] = list(schema.get("datasets") or [])
        try:
            # Prefer core search with filters if supported
            hits = self.core.rag_search(
                user_text,
                per_ds_k=3,
                limit=5,
                include_shared=False,
                datasets=ds_names if ds_names else None,
            )
            for chunk, score, ds_name, owner in hits:
                dataset_text += f"Dataset ({owner}/{ds_name}):\n{chunk}\n\n"
        except TypeError:
            # Older core: no dataset filter; fallback to manual selection
            from_texts: List[Tuple[str, str]] = []
            try:
                for name, entry in self.core.dataset_mgr.entries.items():
                    if ds_names and name not in ds_names:
                        continue
                    if not entry.active:
                        continue
                    full_text = self.core.dataset_mgr.load_dataset_text(entry)
                    if full_text:
                        from_texts.append((name, full_text))
            except Exception:
                pass
            for name, full_text in from_texts:
                snip = self._retrieve_dataset_snippet(full_text, user_text)
                if snip:
                    dataset_text += f"Dataset ({name}):\n{snip}\n\n"
        except Exception:
            pass
        if dataset_text:
            parts.append(dataset_text.strip())

        # Self-talk (optional)
        if is_self_talk and self.self_talk_enabled:
            st_prompts = schema.get("self_talk", [])
            if st_prompts:
                import random
                parts.append(random.choice(st_prompts))

        parts.append(f"User: {user_text}")
        return "\n\n".join([p for p in parts if p])

    def _retrieve_dataset_snippet(self, full_text: str, user_text: str) -> str:
        try:
            tokens = [w.lower() for w in re.findall(r"\b\w+\b", user_text) if len(w) > 2]
            paragraphs = [p.strip() for p in full_text.split("\n") if p.strip()]
            scored: List[Tuple[int, str]] = []
            for para in paragraphs:
                l = para.lower()
                score = sum(1 for t in tokens if t in l)
                if score > 0:
                    scored.append((score, para))
            if not scored:
                return paragraphs[0][:500] if paragraphs else full_text[:500]
            scored.sort(key=lambda x: -x[0])
            top = [p for _, p in scored[:2]]
            return "\n".join(top)[:500]
        except Exception:
            return full_text[:500]

    # ────────────────────────── send / model
    def send_message(self) -> None:
        user_text = self.input_edit.toPlainText().strip()
        if not user_text:
            return

        # Broadcast to plugins
        try:
            self.core.plugins.broadcast(user_text)
        except Exception:
            pass

        # Slash commands → ensure applied to current persona+set
        if user_text.startswith("/"):
            self.input_edit.clear()
            persona = self._current_persona()
            set_name = self.current_set.get(persona, "default")
            try:
                out = self.core.run_command(user_text, persona=persona, set_name=set_name)
            except TypeError:
                out = self.core.run_command(user_text)
            self._append_message("System", out, role_key="system")
            if self.chk_semantic.isChecked() and not self.chk_isolated.isChecked():
                self.core.conversation_db.save_message("system", out)
            return

        # Normal message
        self.input_edit.clear()
        persona = self._current_persona()
        set_name = self.current_set.get(persona, "default")
        schema = self.core.schema_mgr.load_schema(persona, set_name)

        if self.chk_isolated.isChecked():
            self.isolated_history.append(("user", user_text))
        else:
            if self.chk_semantic.isChecked():
                self.core.conversation_db.save_message("user", user_text)

        try:
            user_schema = self.core.schema_mgr.load_schema("user", self.current_set.get("user", "default"))
            user_display = user_schema.get("name", "User")
        except Exception:
            user_display = "User"
        self._append_message(user_display, user_text, role_key="user")

        prompt = self._build_prompt(schema, user_text)
        model_slug = self.model_combo.currentText().strip() or self.core.settings.default_model

        self.btn_send.setEnabled(False)

        # ✅ Create ModelWorker and wire it up properly
        self.model_worker = ModelWorker(model_slug, prompt, parent=self.core)
        self.model_worker.resultReady.connect(lambda resp, usr=user_text, sch=schema: self._on_model_response(resp, usr, sch))
        self.model_worker.errorOccurred.connect(self._on_model_error)
        self.model_worker.finished.connect(lambda: self.btn_send.setEnabled(True))
        self.model_worker.start()


    def _on_model_response(self, response_raw: str, user_text: str, schema: Dict[str, object]) -> None:
        model_slug = self.model_combo.currentText().strip()
        response = self._strip_reasoning(model_slug, response_raw)
        response, style_score = self._style_and_guard(response, schema)
        self.style_label.setText(f"Style: {style_score:.2f}")

        if self.chk_isolated.isChecked():
            self.isolated_history.append((schema.get("name", "bot"), response))
        else:
            if self.chk_semantic.isChecked():
                self.core.conversation_db.save_message(schema.get("name", "bot").lower(), response)

        persona_name = schema.get("name", "Bot") or "Bot"
        role_key = self._current_persona().lower()
        self._append_message(persona_name, response, role_key=role_key)
        self.response_edit.setPlainText(response)

        if not self.chk_mute_tts.isChecked():
            try:
                self.core.tts_mgr.enqueue(response)
            except Exception:
                pass

        self._enable_feedback(True)
        self._reset_idle_timer()

        try:
            tokens = [w.lower() for w in re.findall(r"\b\w+\b", user_text) if len(w) > 3]
            for t in tokens:
                self.update_overlay_topic(self._current_persona(), t)
            self.update_overlay_emotion(self._current_persona(), "neutral")
        except Exception:
            pass

        try:
            for line in response.split("\n"):
                if line.strip():
                    self.core.plugins.broadcast(line.strip())
        except Exception as e:
            print(f"Error broadcasting to plugins: {e}")

        if self.core.settings.auto_schema_enabled:
            self.progress_bar.setVisible(True)

            class EvolverWorker(QRunnable):
                def __init__(self, evolver, persona, set_name, history, window):
                    super().__init__()
                    self.evolver = evolver
                    self.persona = persona
                    self.set_name = set_name
                    self.history = history
                    self.window = window

                def run(self):
                    changed = self.evolver.update_schema(self.persona, self.set_name, self.history)
                    QtCore.QMetaObject.invokeMethod(
                        self.window, "_post_evolver", QtCore.Qt.QueuedConnection, QtCore.Q_ARG(bool, changed)
                    )

            QThreadPool.globalInstance().start(
                EvolverWorker(self.core.schema_evolver, self.active_persona, self.current_set.get(self.active_persona, "default"), self._current_history(), self)
            )

    @QtCore.pyqtSlot(bool)
    def _post_evolver(self, changed: bool) -> None:
        self.progress_bar.setVisible(False)
        if changed:
            self._flash_status("Schema adapted")

    def _strip_reasoning(self, model: str, response: str) -> str:
        if model and "deepseek" in model.lower():
            if "<think>" in response and "</think>" in response:
                try:
                    return response.split("</think>")[-1].strip() or response
                except Exception:
                    return response
        return response

    def _style_and_guard(self, text: str, schema: Dict[str, object]) -> Tuple[str, float]:
        exclam = text.count("!")
        sentences = [s for s in re.split(r"[.!?]", text) if s.strip()]
        avg_len = sum(len(s.split()) for s in sentences) / max(1, len(sentences))
        exclam_density = exclam / max(1, len(text))
        tone = schema.get("tone_rules", {"conciseness": [0.6, 0.8], "exclam_limit": 0.05})
        conciseness = max(0.0, min(1.0, (22 - avg_len) / 16.0))
        ex_ok = 1.0 if exclam_density <= float(tone.get("exclam_limit", 0.05)) else 0.5
        score = max(0.0, min(1.0, 0.5 * conciseness + 0.5 * ex_ok))
        return text, score

    def _rewrite_response(self, original: str) -> str:
        try:
            liked = self.core.feedback_db.get_liked_responses(limit=5)
        except Exception:
            liked = []
        schema = self.core.schema_mgr.load_schema(self._current_persona(), self.current_set.get(self._current_persona(), "default"))
        rps = schema.get("rewrite_prompts", [])
        template = rps[0] if rps else "Rewrite to be more appealing. Keep it accurate, concise, and on style."
        parts = [template]
        if liked:
            parts.append("Preferred responses:\n" + "\n\n".join(liked))
        parts.append("Original:\n" + original)
        parts.append("Rewritten:")
        prompt = "\n\n".join(parts)
        return self._run_model(self.model_combo.currentText().strip() or self.core.settings.default_model, prompt) or original

    def _run_model(self, model: str, prompt: str) -> str:
        try:
            proc = subprocess.run(
                ["ollama", "run", model],
                input=prompt.encode("utf-8"),
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                check=True,
            )
            return proc.stdout.decode("utf-8", errors="replace").strip()
        except subprocess.CalledProcessError as e:
            return e.stderr.decode("utf-8", errors="replace").strip()
        except FileNotFoundError:
            return "(error) ollama executable not found."
        except Exception as e:
            return f"(error) {e}"

    # ────────────────────────── persona / sets
    def _populate_set_combo(self, persona: str, combo: QtWidgets.QComboBox) -> None:
        combo.blockSignals(True)
        combo.clear()
        for s in self.core.schema_mgr.get_set_list(persona):
            combo.addItem(s)
        current = self.current_set.get(persona, "default")
        idx = combo.findText(current)
        combo.setCurrentIndex(idx if idx >= 0 else combo.findText("default"))
        if idx < 0:
            self.current_set[persona] = combo.currentText()
        combo.blockSignals(False)

    def _on_set_changed(self, persona: str, name: str, combo: QtWidgets.QComboBox) -> None:
        if not name:
            return
        self.current_set[persona] = name
        # keep AgentCore pointed to the right set if this persona is active
        if persona == self._current_persona():
            self.core.persona = persona
            self.core.set_name = name

        # refresh editor + commands row for this tab
        tab = self.tab_widgets.get(persona)
        if tab:
            editor = tab.findChild(QtWidgets.QPlainTextEdit, f"schema_edit_{persona}")
            if editor:
                schema = self.core.schema_mgr.load_schema(persona, name)
                editor.setPlainText(json.dumps(schema, indent=2))
            cmd_combo = tab.findChild(QtWidgets.QComboBox, f"cmd_combo_{persona}")
            if cmd_combo:
                self._populate_command_combo(persona, cmd_combo)

        # persist active sets & update controls tied to schema flags
        self.core.schema_mgr.save_active_schemas(self.current_set)
        self._sync_semantic_checkbox_from_schema()
        self._update_feedback_counts()

        # refresh slash command list if this persona is active
        try:
            if persona == self._current_persona():
                self._populate_command_select()
        except Exception:
            pass

    def _on_clone_set(self, persona: str, combo: QtWidgets.QComboBox) -> None:
        src = combo.currentText()
        name, ok = QtWidgets.QInputDialog.getText(self, "Clone Set", "Enter new set name:")
        if not ok or not name.strip():
            return
        new_name = name.strip()
        try:
            schema = self.core.schema_mgr.load_schema(persona, src)
            # Preserve the persona's canonical name; set label is separate
            schema["name"] = persona.capitalize()
            self.core.schema_mgr.save_schema(persona, new_name, schema)
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "Error", str(e))
            return
        self.current_set[persona] = new_name
        self._populate_set_combo(persona, combo)
        combo.setCurrentText(new_name)
        if persona == self._current_persona():
            self.core.set_name = new_name
        self.core.schema_mgr.save_active_schemas(self.current_set)
        self._sync_semantic_checkbox_from_schema()
        self._update_feedback_counts()

    def _on_new_set(self, persona: str, combo: QtWidgets.QComboBox) -> None:
        src = combo.currentText()
        name, ok = QtWidgets.QInputDialog.getText(self, "New Set", "Enter name for new set:")
        if not ok or not name.strip():
            return
        new_name = name.strip()
        try:
            schema = self.core.schema_mgr.load_schema(persona, src)
            # Preserve the persona's canonical name; set label is separate
            schema["name"] = persona.capitalize()
            self.core.schema_mgr.save_schema(persona, new_name, schema)
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "Error", str(e))
            return
        self.current_set[persona] = new_name
        self._populate_set_combo(persona, combo)
        combo.setCurrentText(new_name)
        if persona == self._current_persona():
            self.core.set_name = new_name
        self.core.schema_mgr.save_active_schemas(self.current_set)
        self._sync_semantic_checkbox_from_schema()
        self._update_feedback_counts()

    def _on_delete_set(self, persona: str, combo: QtWidgets.QComboBox) -> None:
        name = combo.currentText()
        if name == "default":
            QtWidgets.QMessageBox.information(self, "Cannot Delete", "The default set cannot be deleted.")
            return
        if QtWidgets.QMessageBox.question(
            self, "Delete Set", f"Delete '{name}' (irreversible)?", QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No
        ) != QtWidgets.QMessageBox.Yes:
            return
        try:
            set_dir = os.path.join(self.core.schema_mgr.schemas_dir, persona.lower(), "sets", name)
            import shutil
            shutil.rmtree(set_dir, ignore_errors=True)
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "Error", str(e))
            return
        self.current_set[persona] = "default"
        self._populate_set_combo(persona, combo)
        combo.setCurrentText("default")
        if persona == self._current_persona():
            self.core.set_name = "default"
        self.core.schema_mgr.save_active_schemas(self.current_set)
        self._sync_semantic_checkbox_from_schema()
        self._update_feedback_counts()

    def _on_save_schema(self, persona: str) -> None:
        tab = self.tab_widgets.get(persona)
        if not tab:
            return
        editor = tab.findChild(QtWidgets.QPlainTextEdit, f"schema_edit_{persona}")
        if not editor:
            return
        text = editor.toPlainText().strip()
        try:
            schema = json.loads(text)
            if not isinstance(schema, dict):
                raise ValueError
        except Exception:
            QtWidgets.QMessageBox.warning(self, "Invalid JSON", "The schema is not valid JSON.")
            return
        set_name = self.current_set.get(persona, "default")
        existing_schema = self.core.schema_mgr.load_schema(persona, set_name)
        merged_schema = {**existing_schema, **schema}
        # Ensure the top-level name matches the active set name
        try:
            merged_schema["name"] = set_name
        except Exception:
            pass
        self.core.schema_mgr.save_schema(persona, set_name, merged_schema)
        QtWidgets.QMessageBox.information(self, "Saved", f"Schema saved for {persona} ({set_name}).")

        if persona == self._current_persona():
            persona_voice = (merged_schema.get("voice") or "").lower()
            for i in range(self.voice_combo.count()):
                if persona_voice and persona_voice in self.voice_combo.itemText(i).lower():
                    self.voice_combo.setCurrentIndex(i)
                    break
        # After save, refresh commands combo (in case user edited commands JSON directly)
        tab = self.tab_widgets.get(persona)
        if tab:
            cmd_combo = tab.findChild(QtWidgets.QComboBox, f"cmd_combo_{persona}")
            if cmd_combo:
                self._populate_command_combo(persona, cmd_combo)

    # ------------------------------------------------------------------
    # Command editing helpers (ported from the original agent_ui.py)
    #
    # The persona editing tab includes a commands row allowing users to
    # append new payloads to existing slash commands or create entirely
    # new commands.  These helpers implement the behaviour that used to
    # live in agent_ui.py.  They are invoked by PersonaTab via
    # ``self.app._on_add_to_command`` and ``self.app._on_new_command``.
    def _on_add_to_command(self, persona: str, combo: QtWidgets.QComboBox,
                            edit: QtWidgets.QLineEdit) -> None:
        """
        Append the text from ``edit`` to the selected command in the
        current schema.  If no command is selected or no text is
        provided, the user is notified.  After updating the schema,
        the command editor and schema editor are refreshed.

        Parameters
        ----------
        persona : str
            The persona whose schema is being modified.
        combo : QtWidgets.QComboBox
            The combo box listing existing slash commands.
        edit : QtWidgets.QLineEdit
            The line edit containing the payload to add to the command.
        """
        text = edit.text().strip()
        if not text:
            QtWidgets.QMessageBox.information(self, "No Text", "Enter text/payload to add.")
            return
        set_name = self.current_set.get(persona, "default")
        schema = self.core.schema_mgr.load_schema(persona, set_name)
        cmds = dict(schema.get("commands") or {})
        sel = combo.currentText().strip()
        if not sel or sel == "(no commands)":
            QtWidgets.QMessageBox.information(self, "No Command", "Create a command first.")
            return
        lst = list(cmds.get(sel) or [])
        lst.append(text)
        cmds[sel] = lst
        schema["commands"] = cmds
        self.core.schema_mgr.save_schema(persona, set_name, schema)
        edit.clear()
        # Refresh editors & notify the user
        self._refresh_schema_editor(persona)
        QtWidgets.QMessageBox.information(self, "Added", f'Added to {sel}: "{text}"')

    def _on_new_command(self, persona: str) -> None:
        """
        Prompt the user for a new command name, insert it into the
        schema if it does not already exist, and refresh the UI.  The
        new command is prefaced with a leading slash if not provided.

        Parameters
        ----------
        persona : str
            The persona whose schema is being modified.
        """
        name, ok = QtWidgets.QInputDialog.getText(self, "New Command", "Enter new command (e.g., /remember):")
        if not ok or not name.strip():
            return
        cmd_name = name.strip()
        if not cmd_name.startswith("/"):
            cmd_name = "/" + cmd_name
        set_name = self.current_set.get(persona, "default")
        schema = self.core.schema_mgr.load_schema(persona, set_name)
        cmds = dict(schema.get("commands") or {})
        if cmd_name in cmds:
            QtWidgets.QMessageBox.information(self, "Exists", f"Command {cmd_name} already exists.")
            return
        cmds[cmd_name] = []
        schema["commands"] = cmds
        self.core.schema_mgr.save_schema(persona, set_name, schema)
        # Refresh command combo + schema editor
        tab = self.tab_widgets.get(persona)
        if tab:
            combo = tab.findChild(QtWidgets.QComboBox, f"cmd_combo_{persona}")
            if combo:
                self._populate_command_combo(persona, combo)
                combo.setCurrentText(cmd_name)
            edit = tab.findChild(QtWidgets.QLineEdit, f"cmd_edit_{persona}")
            if edit:
                edit.clear()
        self._refresh_schema_editor(persona)
        QtWidgets.QMessageBox.information(self, "Created", f"New command {cmd_name} created.")

    def _refresh_schema_editor(self, persona: str) -> None:
        """
        Reload the JSON schema for ``persona`` from disk and update the
        corresponding schema editor in the UI.  This helper is used
        after schema modifications to ensure the text reflects the
        authoritative state on disk.  Signals are blocked during the
        update to avoid triggering autosave timers unnecessarily.

        Parameters
        ----------
        persona : str
            The persona whose schema editor should be refreshed.
        """
        tab = self.tab_widgets.get(persona)
        if not tab:
            return
        editor = tab.findChild(QtWidgets.QPlainTextEdit, f"schema_edit_{persona}")
        if editor:
            schema = self.core.schema_mgr.load_schema(persona, self.current_set.get(persona, "default"))
            editor.blockSignals(True)
            editor.setPlainText(json.dumps(schema, indent=2))
            editor.blockSignals(False)

    def _tab_changed(self, index: int) -> None:
        if 0 <= index < len(self.core.schema_mgr.personas):
            self.active_persona = self.core.schema_mgr.personas[index]
        else:
            self.active_persona = self.core.schema_mgr.personas[0] if self.core.schema_mgr.personas else "zira"
        self.core.persona = self.active_persona

        schema = self.core.schema_mgr.load_schema(self.active_persona, self.current_set.get(self.active_persona, "default"))
        persona_voice = (schema.get("voice") or "").lower()
        for i in range(self.voice_combo.count()):
            if persona_voice and persona_voice in self.voice_combo.itemText(i).lower():
                self.voice_combo.setCurrentIndex(i)
                break

        tab = self.tab_widgets.get(self.active_persona)
        if tab:
            editor = tab.findChild(QtWidgets.QPlainTextEdit, f"schema_edit_{self.active_persona}")
            if editor:
                editor.setPlainText(json.dumps(schema, indent=2))
            cmd_combo = tab.findChild(QtWidgets.QComboBox, f"cmd_combo_{self.active_persona}")
            if cmd_combo:
                self._populate_command_combo(self.active_persona, cmd_combo)

        try:
            user_schema = self.core.schema_mgr.load_schema("user", self.current_set.get("user", "default"))
            bot_name = schema.get("name", self.active_persona.title())
            bot_set = self.current_set.get(self.active_persona, "default")
            user_name = user_schema.get("name", "User")
            user_set = self.current_set.get("user", "default")
            self.lbl_active_names.setText(f"{bot_name}: {bot_set} — User: {user_name}: {user_set}")
        except Exception:
            pass

        self._sync_semantic_checkbox_from_schema()
        self._update_feedback_counts()

        # refresh slash command dropdown on persona change
        try:
            self._populate_command_select()
        except Exception:
            pass

    def _current_persona(self) -> str:
        return self.active_persona

    # ────────────────────────── overlay helpers
    def update_overlay_topic(self, persona: str, topic: str) -> None:
        persona = persona.lower()
        try:
            schema = self.core.schema_mgr.load_schema(persona, self.current_set.get(persona, "default"))
            overlay = dict(schema.get("dynamic_overlay", {}))
            topics = list(overlay.get("recent_topics", []))
            if topic and topic not in topics:
                topics.append(topic)
                if len(topics) > 10:
                    topics = topics[-10:]
                overlay["recent_topics"] = topics
                schema["dynamic_overlay"] = overlay
                self.core.schema_mgr.save_schema(persona, self.current_set.get(persona, "default"), schema)
        except Exception:
            pass

    def update_overlay_emotion(self, persona: str, emotion: str) -> None:
        persona = persona.lower()
        try:
            schema = self.core.schema_mgr.load_schema(persona, self.current_set.get(persona, "default"))
            overlay = dict(schema.get("dynamic_overlay", {}))
            overlay["temporary_emotional_state"] = emotion
            schema["dynamic_overlay"] = overlay
            self.core.schema_mgr.save_schema(persona, self.current_set.get(persona, "default"), schema)
        except Exception:
            pass

    # ────────────────────────── devices & models
    def _populate_devices(self) -> None:
        # In this refactor the devices are populated by CommandsPanel
        self.commands_panel._populate_devices()

    def _populate_models(self) -> None:
        # In this refactor the models are populated by CommandsPanel
        self.commands_panel._populate_models()

    # ────────────────────────── slash commands panel
    def _build_command_dock(self) -> None:
        """
        Build a dockable panel that exposes slash commands with an argument
        entry and send button. This allows users to trigger any command
        without typing it into the chat manually. It will be updated when
        persona or set changes.
        """
        dock = QtWidgets.QDockWidget("Slash Commands", self)
        dock.setObjectName("SlashCommandsDock")
        dock.setFeatures(
            QtWidgets.QDockWidget.DockWidgetClosable
            | QtWidgets.QDockWidget.DockWidgetMovable
            | QtWidgets.QDockWidget.DockWidgetFloatable
        )
        container = QtWidgets.QWidget()
        layout = QtWidgets.QVBoxLayout(container)
        layout.setContentsMargins(7, 7, 7, 7)
        layout.setSpacing(5)

        # command selector
        cmd_label = QtWidgets.QLabel("Slash Command:")
        self.command_select = QtWidgets.QComboBox()
        layout.addWidget(cmd_label)
        layout.addWidget(self.command_select)

        # argument input
        self.command_input = QtWidgets.QLineEdit()
        self.command_input.setPlaceholderText("Enter arguments or select text from chat…")
        layout.addWidget(self.command_input)

        # send button
        btn_run = QtWidgets.QPushButton("Run Command")
        btn_run.clicked.connect(self._on_run_command)
        layout.addWidget(btn_run)
        layout.addStretch(1)

        dock.setWidget(container)
        # add to right side by default
        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, dock)
        self.command_dock = dock

    def _populate_command_select(self) -> None:
        """
        Populate the slash command dropdown with available commands from
        the command registry. This is called whenever the active persona
        or set changes to reflect dynamic additions.
        """
        try:
            cmds = []
            if hasattr(self.core, "command_registry") and self.core.command_registry:
                cmds = list(self.core.command_registry.list_commands())
            # if schema defines additional commands, include them
            persona = self._current_persona()
            set_name = self.current_set.get(persona, "default")
            schema = self.core.schema_mgr.load_schema(persona, set_name)
            schema_cmds = list((schema.get("commands") or {}).keys())
            for c in schema_cmds:
                if c not in cmds:
                    cmds.append(c)
            cmds.sort()
        except Exception:
            cmds = []
        self.command_select.blockSignals(True)
        self.command_select.clear()
        if cmds:
            self.command_select.addItems(cmds)
        self.command_select.blockSignals(False)

    def _on_run_command(self) -> None:
        """
        Handler for running the selected slash command with the provided
        argument. The command will be executed via AgentCore and the
        result appended to the chat window. Selection text from the chat
        can be inserted into the argument field via context menu.
        """
        cmd = (self.command_select.currentText() or "").strip()
        if not cmd:
            QtWidgets.QMessageBox.information(self, "No Command", "Select a slash command to run.")
            return
        arg = self.command_input.text().strip()
        # combine command and arguments
        full = cmd if not arg else f"{cmd} {arg}"
        try:
            # process via core; record conversation
            resp = self.core.process_user_message(full, tts=False)
            # append user command and agent response to chat
            self._append_message("user", full, role_key="user")
            self._append_message("zira", resp, role_key="zira")
            # clear argument
            self.command_input.clear()
            # update feedback counts and idle timer
            self._update_feedback_counts()
            self._reset_idle_timer()
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "Command Error", str(e))

    def _show_chat_context_menu(self, pos: QtCore.QPoint) -> None:
        """
        Custom context menu for the chat view. Adds a menu entry to send
        selected text into the slash command argument field.
        """
        menu = self.chat_view.createStandardContextMenu()
        try:
            cursor = self.chat_view.textCursor()
            if cursor and cursor.hasSelection():
                action = menu.addAction("Send selection to command input")
                action.triggered.connect(self._send_selection_to_command_input)
        except Exception:
            pass
        menu.exec_(self.chat_view.mapToGlobal(pos))

    def _send_selection_to_command_input(self) -> None:
        """
        Copy the currently selected text in the chat view into the command
        input field for slash command execution.
        """
        try:
            cursor = self.chat_view.textCursor()
            if cursor and cursor.hasSelection():
                text = cursor.selectedText()
                self.command_input.setText(text.strip())
        except Exception:
            pass

    def _on_model_changed(self, name: str) -> None:
        """
        Update the default model in settings when the user selects a new
        model from the dropdown. This ensures the AgentCore uses the
        selected model for subsequent interactions.
        """
        try:
            if not name:
                return
            self.core.settings.default_model = name
            self.core.settings.save()
        except Exception:
            pass

    def _on_show_model_manager(self) -> None:
        """
        Show (or raise) the model manager dock. If the dock was
        previously hidden, it will be shown; if it is already visible,
        this will bring it to the front. A dock must be built in
        ``_build_model_manager()`` prior to showing.
        """
        try:
            if self.model_dock.isVisible():
                # already visible: raise to top
                self.model_dock.raise_()
            else:
                self.model_dock.show()
                self.model_dock.raise_()
        except Exception:
            pass
            
            
    def _on_model_error(self, error: str) -> None:
        """Handles errors from ModelWorker threads."""
        print(f"[ERROR] ModelWorker failed:\n{error}")

        # Show in chat window
        self._append_message("System", f"❌ Model error:\n{error}", role_key="system")

        # Optionally log or alert
        try:
            self.core.logger.error(f"ModelWorker Error: {error}")
        except Exception:
            pass

        # Re-enable send button in case it wasn't via .finished
        self.btn_send.setEnabled(True)
            

    # ────────────────────────── settings toggles
    def _on_auto_schema_toggled(self, checked: bool) -> None:
        try:
            self.core.settings.auto_schema_enabled = bool(checked)
            self.core.settings.save()
        except Exception:
            pass
        self.statusBar().showMessage(f"Auto Schema Evolution {'enabled' if checked else 'disabled'}", 2500)

    def _on_google_stt_toggled(self, checked: bool) -> None:
        """
        Opt-in/out of using Google Cloud Speech-to-Text. When enabling the
        toggle for the first time in a session, show a warning that
        recordings will be sent to Google’s servers under their privacy
        policy. If declined, the checkbox will be turned off again.
        """
        # Only show the dialog when transitioning from unchecked → checked
        try:
            current = bool(getattr(self.core.settings, "use_google_stt", False))
        except Exception:
            current = False
        if checked and not current:
            ok = QtWidgets.QMessageBox.question(
                self,
                "Enable Google STT?",
                "Audio will be uploaded to Google Cloud for transcription\n"
                "under Google's privacy policy. Continue?",
                QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No,
            )
            if ok != QtWidgets.QMessageBox.Yes:
                # revert checkbox silently
                self.chk_google_stt.blockSignals(True)
                self.chk_google_stt.setChecked(False)
                self.chk_google_stt.blockSignals(False)
                return
        # persist the new state
        try:
            self.core.settings.use_google_stt = bool(checked)
            self.core.settings.save()
        except Exception:
            pass

    # ────────────────────────── spell suggestions
    def _show_input_context_menu(self, pos: QtCore.QPoint) -> None:
        """
        Custom context menu on the input field that offers spelling
        suggestions when the user right-clicks a misspelled word. Only
        appears if pyspellchecker is available.
        """
        menu = self.input_edit.createStandardContextMenu()
        # compute suggestions only if SpellChecker is available
        if SpellChecker:
            cursor = self.input_edit.cursorForPosition(pos)
            # select the word under cursor
            cursor.select(QtGui.QTextCursor.WordUnderCursor)
            word = cursor.selectedText()
            if word and len(word) >= 3:
                sc = SpellChecker()
                suggestions = list(sc.candidates(word.lower()))
                # sort by Levenshtein distance and frequency; keep top 5
                suggestions = sorted(suggestions, key=lambda w: sc.word_probability(w), reverse=True)[:5]
                if suggestions and suggestions != [word.lower()]:
                    suggest_menu = menu.addMenu("Spelling suggestions")
                    for s in suggestions:
                        act = suggest_menu.addAction(s)
                        act.triggered.connect(lambda chk=False, repl=s, c=cursor: self._replace_word(c, repl))
        menu.exec_(self.input_edit.mapToGlobal(pos))

    def _replace_word(self, cursor: QtGui.QTextCursor, replacement: str) -> None:
        """
        Replace the word at the given cursor with a suggestion. This
        method is connected dynamically for each suggestion action.
        """
        try:
            cursor.beginEditBlock()
            cursor.removeSelectedText()
            cursor.insertText(replacement)
            cursor.endEditBlock()
        except Exception:
            pass

    def _on_semantic_toggled(self, checked: bool) -> None:
        """Persist semantic awareness per persona+set."""
        persona = self._current_persona()
        set_name = self.current_set.get(persona, "default")
        try:
            schema = self.core.schema_mgr.load_schema(persona, set_name)
            flags = dict(schema.get("flags") or {})
            flags["semantic_awareness"] = bool(checked)
            schema["flags"] = flags
            self.core.schema_mgr.save_schema(persona, set_name, schema)
        except Exception:
            pass
        self._reset_idle_timer()

    def _sync_semantic_checkbox_from_schema(self) -> None:
        """Load semantic_awareness from current schema into the checkbox."""
        persona = self._current_persona()
        set_name = self.current_set.get(persona, "default")
        try:
            schema = self.core.schema_mgr.load_schema(persona, set_name)
            flags = schema.get("flags", {})
            val = bool(flags.get("semantic_awareness", True))
        except Exception:
            val = True
        self.chk_semantic.blockSignals(True)
        self.chk_semantic.setChecked(val)
        self.chk_semantic.blockSignals(False)

    # ────────────────────────── status helper
    def _flash_status(self, msg: str) -> None:
        self.statusBar().showMessage(msg, 3000)


# ────────────────────────── Dock tray & titlebar
class DockTray(QtWidgets.QWidget):
    restoreRequested = QtCore.pyqtSignal(QtWidgets.QDockWidget)

    def __init__(self, parent: Optional[QtWidgets.QWidget] = None) -> None:
        super().__init__(parent)
        self._map: Dict[QtWidgets.QDockWidget, QtWidgets.QPushButton] = {}
        lay = QtWidgets.QHBoxLayout(self)
        lay.setContentsMargins(6, 4, 6, 4)
        lay.setSpacing(6)
        self._layout = lay
        self._title = QtWidgets.QLabel("Minimized panels:")
        self._title.setStyleSheet("color: #f0f0f0; font-weight: bold;")
        self._layout.addWidget(self._title, 0)
        self._layout.addStretch(1)
        self.setStyleSheet("background-color: #3c4a6b;")

    def register_dock(self, dock: QtWidgets.QDockWidget) -> None:
        dock.visibilityChanged.connect(lambda vis, d=dock: self._on_visibility_changed(d, vis))
        if not dock.isVisible():
            self._add_button(dock)

    def _on_visibility_changed(self, dock: QtWidgets.QDockWidget, visible: bool) -> None:
        if visible:
            self._remove_button(dock)
        else:
            self._add_button(dock)

    def _add_button(self, dock: QtWidgets.QDockWidget) -> None:
        if dock in self._map:
            return
        btn = QtWidgets.QPushButton(dock.windowTitle())
        btn.setToolTip(f"Restore {dock.windowTitle()}")
        btn.setStyleSheet(
            "background-color: #4a5b78; color: #ffffff; padding: 4px 6px; border: none; border-radius: 3px;"
        )
        btn.clicked.connect(lambda checked=False, d=dock: self._restore(d))
        self._layout.insertWidget(self._layout.count() - 1, btn)
        self._map[dock] = btn

    def _remove_button(self, dock: QtWidgets.QDockWidget) -> None:
        btn = self._map.pop(dock, None)
        if btn:
            self._layout.removeWidget(btn)
            btn.deleteLater()

    def _restore(self, dock: QtWidgets.QDockWidget) -> None:
        dock.show()
        dock.raise_()
        self.restoreRequested.emit(dock)


class DockTitleBar(QtWidgets.QWidget):
    def __init__(self, dock: QtWidgets.QDockWidget, title: str) -> None:
        super().__init__(dock)
        self._dock = dock
        h = QtWidgets.QHBoxLayout(self)
        h.setContentsMargins(6, 2, 6, 2)
        h.setSpacing(6)
        self.lbl = QtWidgets.QLabel(title)
        h.addWidget(self.lbl)
        h.addStretch()
        self.btn_min = QtWidgets.QToolButton()
        self.btn_min.setText("–")
        self.btn_min.setToolTip("Minimize to bottom tray")
        self.btn_min.clicked.connect(lambda checked=False: self._dock.hide())
        h.addWidget(self.btn_min)
        self.btn_max = QtWidgets.QToolButton()
        self.btn_max.setText("□")
        self.btn_max.setToolTip("Enlarge / Restore")
        self.btn_max.clicked.connect(self._on_toggle_maximize)
        h.addWidget(self.btn_max)
        self.btn_close = QtWidgets.QToolButton()
        self.btn_close.setText("×")
        self.btn_close.setToolTip("Close (send to bottom tray)")
        self.btn_close.clicked.connect(lambda checked=False: self._dock.hide())
        h.addWidget(self.btn_close)
        self.installEventFilter(self)

    def eventFilter(self, _obj: QtCore.QObject, evt: QtCore.QEvent) -> bool:
        if evt.type() == QtCore.QEvent.MouseButtonDblClick:
            self._dock.setFloating(not self._dock.isFloating())
            return True
        return False

    def _on_toggle_maximize(self) -> None:
        mw: Optional[QtWidgets.QMainWindow] = self._dock.parentWidget()  # type: ignore
        while mw and not isinstance(mw, QtWidgets.QMainWindow):
            mw = mw.parentWidget()  # type: ignore
        if not isinstance(mw, QtWidgets.QMainWindow):
            self._dock.setFloating(not self._dock.isFloating())
            return
        if not self._dock.isFloating():
            self._dock.setFloating(True)
            mw_geo = mw.geometry()
            w = int(mw_geo.width() * 0.9)
            h = int(mw_geo.height() * 0.85)
            self._dock.resize(w, h)
            center = mw_geo.center()
            self._dock.move(center.x() - w // 2, center.y() - h // 2)
        else:
            self._dock.setFloating(False)


# ────────────────────────── dataset manager dialog
class DatasetManagerDialog(QtWidgets.QDialog):
    def __init__(self, dataset_mgr, parent: Optional[QtWidgets.QWidget] = None) -> None:
        super().__init__(parent)
        self.setWindowTitle("Dataset Manager")
        self.resize(520, 420)
        self.dataset_mgr = dataset_mgr
        v = QtWidgets.QVBoxLayout(self)
        self.list_widget = QtWidgets.QListWidget()
        v.addWidget(self.list_widget, 1)
        h = QtWidgets.QHBoxLayout()
        self.btn_add = QtWidgets.QPushButton("Add Dataset")
        self.btn_del = QtWidgets.QPushButton("Delete Dataset")
        h.addWidget(self.btn_add)
        h.addWidget(self.btn_del)
        h.addStretch()
        v.addLayout(h)
        self._populate()
        self.btn_add.clicked.connect(self._on_add)
        self.btn_del.clicked.connect(self._on_delete)
        self.list_widget.itemChanged.connect(self._on_item)

    def _populate(self) -> None:
        self.list_widget.clear()
        for name, entry in sorted(self.dataset_mgr.entries.items()):
            item = QtWidgets.QListWidgetItem(name)
            item.setFlags(item.flags() | QtCore.Qt.ItemIsUserCheckable)
            item.setCheckState(QtCore.Qt.Checked if entry.active else QtCore.Qt.Unchecked)
            self.list_widget.addItem(item)

    def _on_add(self) -> None:
        name, ok = QtWidgets.QInputDialog.getText(self, "New Dataset", "Enter dataset name:")
        if not ok or not name.strip():
            return
        path, _ = QtWidgets.QFileDialog.getOpenFileName(self, "Select .txt or .pdf", "", "Text/PDF (*.txt *.pdf)")
        if not path:
            return
        try:
            self.dataset_mgr.add_dataset(name.strip(), path)
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "Error", str(e))
            return
        self._populate()

    def _on_delete(self) -> None:
        item = self.list_widget.currentItem()
        if not item:
            return
        name = item.text()
        if QtWidgets.QMessageBox.question(
            self, "Delete Dataset", f"Delete '{name}'?", QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No
        ) != QtWidgets.QMessageBox.Yes:
            return
        try:
            self.dataset_mgr.delete_dataset(name)
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "Error", str(e))
            return
        self._populate()

    def _on_item(self, item: QtWidgets.QListWidgetItem) -> None:
        self.dataset_mgr.toggle_active(item.text(), item.checkState() == QtCore.Qt.Checked)


# ────────────────────────── run as script
if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    win = AppWindow()
    win.show()
    sys.exit(app.exec_())
```

main_ui.py
===========

This module contains the top-level ``AppWindow`` class for the AI TTS
Agent.  It orchestrates all layout and docking behaviour, integrates
the control panel and persona tabs provided by ``commands_panel`` and
``persona_tab``, and exposes a unified interface for the rest of the
application.  None of the core agent logic lives here – that remains in
the ``core_*`` modules.  This refactor pulls the bulky UI building
logic out of the monolithic script and into dedicated modules while
preserving all existing behaviour and wiring.
**Classes:** _SpellHighlighter, AppWindow, DockTray, DockTitleBar, DatasetManagerDialog


## Module `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\_burner_scripts\migration_tool.py`

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
migration_tool.py
=================

Stand-alone CLI for *one-shot* migration of legacy AI-TTS-Agent files
(JSON schemas, commands.json, reinforcement.jsonl …) into the new
SQLite-backed **agent_store.db**.

Typical usage
-------------
$ python migration_tool.py /path/to/AI_TTS_AGENT
    → runs migrate (if needed) and prints a coloured diff table.

$ python migration_tool.py . --dry-run
    → shows what *would* be imported without touching the DB.

Exit codes
----------
0  success – nothing failed
1  fatal error (bad path, SQLite locked, etc.)
2  migration aborted by --check-upgrade only
"""

from __future__ import annotations

import argparse
import os
import sys
from pathlib import Path
from typing import Dict

# Import AFTER adjusting sys.path so the script also works when executed
# from outside the project root.
PROJECT_ROOT = Path(__file__).resolve().parent
if PROJECT_ROOT not in map(Path, map(Path.resolve, map(Path, sys.path))):
    sys.path.insert(0, str(PROJECT_ROOT))

try:
    from agent_store import AgentStore, DB_VERSION
except ImportError as exc:  # pragma: no cover
    print(f"[migration_tool] Cannot import agent_store: {exc}", file=sys.stderr)
    sys.exit(1)


# ------------------------------ helpers ------------------------------ #
def _colour(txt: str, colour: str) -> str:
    colours = {
        "green": "\033[92m",
        "yellow": "\033[93m",
        "red": "\033[91m",
        "cyan": "\033[96m",
        "end": "\033[0m",
    }
    return f"{colours.get(colour, '')}{txt}{colours['end']}"


def _print_report(report: Dict[str, int]) -> None:
    print("\nMigration report")
    print("----------------")
    for k in ("schemas", "commands", "beans"):
        val = report.get(k, 0)
        colour = "green" if val else "yellow"
        print(f"  {k:<10}: {_colour(str(val), colour)}")


# ----------------------------- CLI entry ----------------------------- #
def main() -> None:
    ap = argparse.ArgumentParser(
        description="Run or inspect migration from legacy flat-file storage "
        "to agent_store.db (schema v%d)." % DB_VERSION
    )
    ap.add_argument(
        "base_dir",
        metavar="BASE_DIR",
        help="Root folder where AI-TTS-Agent project lives",
    )
    ap.add_argument(
        "--dry-run",
        action="store_true",
        help="Scan legacy artefacts and show how many items WOULD be migrated "
        "without actually writing to the DB.",
    )
    ap.add_argument(
        "--check-upgrade",
        action="store_true",
        help="Exit code 2 if the DB is below current version (use for CI).",
    )
    args = ap.parse_args()
    base_dir = os.path.abspath(args.base_dir)

    if not os.path.isdir(base_dir):
        print(_colour(f"[migration_tool] No such directory: {base_dir}", "red"), file=sys.stderr)
        sys.exit(1)

    store = AgentStore(base_dir)

    with store._pool.get() as c:  # type: ignore[attr-defined, arg-type]
        cur = c.execute("SELECT value FROM meta WHERE key='user_version'")
        current_ver = int(cur.fetchone()[0])

    if args.check_upgrade:
        if current_ver < DB_VERSION:
            print(_colour(f"DB version {current_ver} < required {DB_VERSION}", "yellow"))
            sys.exit(2)
        print(_colour("DB is up to date.", "green"))
        return

    if current_ver >= DB_VERSION and not args.dry_run:
        print(_colour("Nothing to migrate – database already at latest schema.", "green"))
        return

    if args.dry_run:
        print(_colour("[dry-run] Scanning legacy artefacts…", "cyan"))
        report = store.migrate_from_files()  # writes, but we’ll roll back
        _print_report(report)
        # rollback by deleting DB to keep promise of dry-run
        os.remove(store.db_path)
        print(_colour("\n[dry-run] Database left untouched.", "cyan"))
        return

    # Real migration
    print(_colour("Running migration…", "cyan"))
    report = store.migrate_from_files()
    _print_report(report)
    print(_colour("\nMigration completed.\n", "green"))


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\nInterrupted.")
        sys.exit(1)
```

migration_tool.py
=================

Stand-alone CLI for *one-shot* migration of legacy AI-TTS-Agent files
(JSON schemas, commands.json, reinforcement.jsonl …) into the new
SQLite-backed **agent_store.db**.

Typical usage
-------------
$ python migration_tool.py /path/to/AI_TTS_AGENT
    → runs migrate (if needed) and prints a coloured diff table.

$ python migration_tool.py . --dry-run
    → shows what *would* be imported without touching the DB.

Exit codes
----------
0  success – nothing failed
1  fatal error (bad path, SQLite locked, etc.)
2  migration aborted by --check-upgrade only
**Functions:** _colour(txt, colour), _print_report(report), main()


## Module `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\_burner_scripts\persona_tab.py`

```python
#!/usr/bin/env python3
"""
persona_tab.py
==============

**Schema-Editor 2.0**

This version upgrades the old free-text schema editor to a structured,
two-pane interface:

    • **Left:**   Category tree (actions, questions, etc.)  
    • **Right:**  Multiline editor for the selected node’s JSON value  
    • **Bottom:** “Expose as /command” checkbox (per category)  
    • **Top-right:** “Auto-Evolution” toggle for the whole set

Other improvements

* Autosave is now routed through **SchemaEngine.save()** (SQL-backed).
* Edits are debounced (500 ms) and validated before committing.
* When “Expose as /command” is ticked, a synthetic slash-command is written
  to *AgentStore.commands* for immediate use by the orchestrator.
"""

from __future__ import annotations

import json
import os
from typing import Dict, Any, Optional

from PyQt5 import QtCore, QtGui, QtWidgets


# --------------------------------------------------------------------------- helpers


def nice_json(value: Any) -> str:
    """Pretty JSON helper that survives non-serialisable objects."""
    try:
        return json.dumps(value, indent=2, ensure_ascii=False)
    except Exception:
        return str(value)


def parse_json(text: str) -> Any:
    """Parse or return raw string if JSON fails."""
    try:
        return json.loads(text)
    except Exception:
        return text.strip()


# --------------------------------------------------------------------------- main widget


class PersonaTab(QtWidgets.QWidget):
    """Persona & schema management panel (one instance shared across personas)."""

    # Emitted after a schema field is *persisted* (category, persona, set)
    schemaFieldUpdated = QtCore.pyqtSignal(str, str, str)

    # --------------------------------------------------------------------- init
    def __init__(
        self,
        app: "AppWindow",  # quotes to avoid circular import typing
        parent: Optional[QtWidgets.QWidget] = None,
    ) -> None:
        super().__init__(parent)
        self.app = app
        self.core = app.core
        self.schema_engine = self.core.schema_engine  # ← SQL façade
        self.current_set: Dict[str, str] = app.current_set

        # Label summarising active names/sets
        self.lbl_active = QtWidgets.QLabel()
        self.lbl_active.setObjectName("lblActiveSchemas")
        # Alias for main_ui compatibility (it expects persona_panel.lbl_active_names)
        self.lbl_active_names = self.lbl_active

        # Tabs per persona  ---------------------------------------------------
        self.tabs = QtWidgets.QTabWidget(movable=False, documentMode=True)
        self.tab_widgets: Dict[str, QtWidgets.QWidget] = {}
        for persona in self.schema_engine.personas():
            tab = QtWidgets.QWidget()
            self.tab_widgets[persona] = tab
            self.tabs.addTab(tab, persona.capitalize())

        # Operators tab (read-only)
        self.operator_tab = QtWidgets.QWidget()
        self.tabs.addTab(self.operator_tab, "Operators")

        self.tabs.currentChanged.connect(self._on_tab_changed)

        # Master layout
        v = QtWidgets.QVBoxLayout(self)
        v.setContentsMargins(7, 7, 7, 7)
        v.setSpacing(7)
        v.addWidget(self.lbl_active)
        v.addWidget(self.tabs, 1)

        # Build each persona sub-panel
        for p, w in self.tab_widgets.items():
            self._build_persona_subpanel(p, w)
        self._build_operators_tab(self.operator_tab)

        # Prime active-names label
        self._refresh_active_label()

    # ----------------------------------------------------------------- builders
    def _build_persona_subpanel(self, persona: str, root: QtWidgets.QWidget) -> None:
        """Creates the Schema-Editor 2.0 layout for a single persona."""
        # ───── set selector row ────────────────────────────────────────────
        top = QtWidgets.QHBoxLayout()
        top.addWidget(QtWidgets.QLabel("Set:"))

        set_combo = QtWidgets.QComboBox(objectName=f"setCombo_{persona}")
        self._populate_set_combo(persona, set_combo)
        set_combo.currentTextChanged.connect(
            lambda name, p=persona, c=set_combo: self._switch_set(p, name, c)
        )
        top.addWidget(set_combo)

        btn_clone = QtWidgets.QPushButton("Clone")
        btn_clone.clicked.connect(lambda _=False, p=persona, c=set_combo: self.app._on_clone_set(p, c))
        btn_new = QtWidgets.QPushButton("New")
        btn_new.clicked.connect(lambda _=False, p=persona, c=set_combo: self.app._on_new_set(p, c))
        btn_del = QtWidgets.QPushButton("Delete")
        btn_del.clicked.connect(lambda _=False, p=persona, c=set_combo: self.app._on_delete_set(p, c))
        for b in (btn_clone, btn_new, btn_del):
            top.addWidget(b)
        top.addStretch()

        # Auto-Evolution toggle (per-set)
        chk_auto = QtWidgets.QCheckBox("Auto Evolution")
        chk_auto.setObjectName(f"chkAutoEvo_{persona}")
        chk_auto.stateChanged.connect(lambda _=0, p=persona: self._toggle_auto_evo(p))
        top.addWidget(chk_auto)

        # ───── splitter: category tree | editor ────────────────────────────
        splitter = QtWidgets.QSplitter(QtCore.Qt.Horizontal)
        splitter.setChildrenCollapsible(False)

        # Category tree
        tree = QtWidgets.QTreeWidget(objectName=f"schemaTree_{persona}")
        tree.setHeaderHidden(True)
        tree.itemClicked.connect(lambda item, _col, p=persona: self._load_category(p, item))
        splitter.addWidget(tree)

        # Right-side editor + extras
        right = QtWidgets.QWidget()
        rv = QtWidgets.QVBoxLayout(right)
        rv.setContentsMargins(0, 0, 0, 0)
        rv.setSpacing(4)

        editor = QtWidgets.QPlainTextEdit(objectName=f"schemaEditor_{persona}")
        editor.setLineWrapMode(QtWidgets.QPlainTextEdit.NoWrap)
        rv.addWidget(editor, 1)

        row = QtWidgets.QHBoxLayout()
        self.chk_expose = QtWidgets.QCheckBox("Expose as /command")
        row.addWidget(self.chk_expose)
        row.addStretch()
        btn_format = QtWidgets.QPushButton("Reformat JSON")
        row.addWidget(btn_format)
        rv.addLayout(row)

        splitter.addWidget(right)
        splitter.setStretchFactor(1, 2)

        # ───── assemble persona tab ────────────────────────────────────────
        vbox = QtWidgets.QVBoxLayout(root)
        vbox.setContentsMargins(4, 4, 4, 4)
        vbox.setSpacing(6)
        vbox.addLayout(top)
        vbox.addWidget(splitter, 1)

        # ───── state & autosave timer  ─────────────────────────────────────
        timer = QtCore.QTimer(self)
        timer.setSingleShot(True)
        timer.setInterval(500)  # 500 ms debounce

        def start_debounce() -> None:
            timer.start()

        editor.textChanged.connect(start_debounce)

        def persist() -> None:
            cat = tree.currentItem().text(0) if tree.currentItem() else ""
            if not cat:
                return
            try:
                payload = parse_json(editor.toPlainText())
                persona_set = self.current_set.get(persona, "default")
                self.schema_engine.update_field(persona, persona_set, cat, payload)
                # expose as /command if requested
                expose = self.chk_expose.isChecked()
                self.schema_engine.set_command_exposure(persona, cat, expose)
                self.schemaFieldUpdated.emit(persona, persona_set, cat)
            except Exception as e:
                QtWidgets.QMessageBox.warning(self, "Schema Error", str(e))

        timer.timeout.connect(persist)

        # Re-format button
        btn_format.clicked.connect(lambda: editor.setPlainText(nice_json(parse_json(editor.toPlainText()))))

        # Populate first load
        self._reload_tree(persona, tree)

    # ----------------------------------------------------------------- GUI helpers
    def _populate_set_combo(self, persona: str, combo: QtWidgets.QComboBox) -> None:
        combo.blockSignals(True)
        combo.clear()
        for s in self.schema_engine.set_list(persona):
            combo.addItem(s)
        current = self.current_set.get(persona, "default")
        idx = combo.findText(current)
        combo.setCurrentIndex(max(idx, 0))
        combo.blockSignals(False)

    def _switch_set(self, persona: str, set_name: str, combo: QtWidgets.QComboBox) -> None:
        self.current_set[persona] = set_name
        self._reload_tree(persona, self.findChild(QtWidgets.QTreeWidget, f"schemaTree_{persona}"))
        self._refresh_active_label()

    def _toggle_auto_evo(self, persona: str) -> None:
        set_name = self.current_set.get(persona, "default")
        chk: QtWidgets.QCheckBox = self.sender()  # type: ignore
        self.schema_engine.set_auto_evolution(persona, set_name, bool(chk.isChecked()))

    def _reload_tree(self, persona: str, tree: QtWidgets.QTreeWidget) -> None:
        """Repopulate category tree for the current set."""
        tree.clear()
        set_name = self.current_set.get(persona, "default")
        data = self.schema_engine.load_schema(persona, set_name) or {}
        for key in sorted(data.keys()):
            QtWidgets.QTreeWidgetItem(tree, [key])
        if tree.topLevelItemCount():
            tree.setCurrentItem(tree.topLevelItem(0))

    def _load_category(self, persona: str, item: QtWidgets.QTreeWidgetItem) -> None:
        """Load selected category into editor."""
        cat = item.text(0)
        set_name = self.current_set.get(persona, "default")
        value = self.schema_engine.get_field(persona, set_name, cat)
        editor: QtWidgets.QPlainTextEdit = self.findChild(
            QtWidgets.QPlainTextEdit, f"schemaEditor_{persona}"
        )
        editor.blockSignals(True)
        editor.setPlainText(nice_json(value))
        editor.blockSignals(False)
        # set expose-command checkbox
        self.chk_expose.blockSignals(True)
        self.chk_expose.setChecked(self.schema_engine.is_exposed_as_command(persona, cat))
        self.chk_expose.blockSignals(False)

    def _refresh_active_label(self) -> None:
        try:
            bot_name = self.schema_engine.get_field(
                self.app.active_persona, self.current_set[self.app.active_persona], "name"
            )
        except Exception:
            bot_name = self.app.active_persona.capitalize()
        user_name = self.schema_engine.get_field("user", self.current_set.get("user", "default"), "name") or "User"
        bot_set = self.current_set.get(self.app.active_persona, "default")
        user_set = self.current_set.get("user", "default")
        self.lbl_active.setText(f"{bot_name}: {bot_set} — User: {user_name}: {user_set}")

    # ----------------------------------------------------------------- operators tab
    def _build_operators_tab(self, tab: QtWidgets.QWidget) -> None:
        """Simple list of installed operators with descriptions."""
        lay = QtWidgets.QVBoxLayout(tab)
        lay.setContentsMargins(4, 4, 4, 4)
        lay.setSpacing(6)

        ops = self.core.operator_mgr.list_operators()
        if not ops:
            lay.addWidget(QtWidgets.QLabel("No operators installed."))
        else:
            for name in sorted(ops):
                schema = self.core.operator_mgr.load_schema(name)
                box = QtWidgets.QGroupBox(name)
                v = QtWidgets.QVBoxLayout(box)
                v.addWidget(QtWidgets.QLabel(schema.get("description", "")))
                lay.addWidget(box)
        lay.addStretch()

    # ----------------------------------------------------------------- UI tab change
    def _on_tab_changed(self, idx: int) -> None:
        # keep memo of which persona is active so main_ui can react
        persona = self.tabs.tabText(idx).lower()
        if persona in self.tab_widgets:
            self.app.active_persona = persona
            self._refresh_active_label()
```

persona_tab.py
==============

**Schema-Editor 2.0**

This version upgrades the old free-text schema editor to a structured,
two-pane interface:

    • **Left:**   Category tree (actions, questions, etc.)  
    • **Right:**  Multiline editor for the selected node’s JSON value  
    • **Bottom:** “Expose as /command” checkbox (per category)  
    • **Top-right:** “Auto-Evolution” toggle for the whole set

Other improvements

* Autosave is now routed through **SchemaEngine.save()** (SQL-backed).
* Edits are debounced (500 ms) and validated before committing.
* When “Expose as /command” is ticked, a synthetic slash-command is written
  to *AgentStore.commands* for immediate use by the orchestrator.
**Classes:** PersonaTab
**Functions:** nice_json(value), parse_json(text)


## Module `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\_burner_scripts\run_agent.py`

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
run_agent.py — bootstrap launcher for AI TTS Agent (v3, 2025-08-04)

• Ensures the sqlite store exists (agent_store.ensure_db()) and runs
  legacy-data migration when user_version < 4.
• Accepts one optional command-line arg: <profile-dir>. Defaults to
  ./ai_agent_state relative to CWD.
• Starts the Qt GUI (main_ui.AppWindow).
• Catches early exceptions and prints a clean error trace instead of a
  raw stack-dump so newcomers understand what went wrong.
"""

from __future__ import annotations

import os
import sys
import traceback
from typing import Optional

from PyQt5 import QtWidgets

# --- local imports ----------------------------------------------------------
try:
    from agent_store import ensure_db, get_user_version, migrate_from_files
except ImportError:
    # fall back: no sql store yet, skip migration helpers
    def ensure_db(_): ...
    def get_user_version(_): return 0
    def migrate_from_files(_): return 0, 0  # migrated_rows, warnings


def _bootstrap_state(base_dir: str) -> None:
    """Create DB if missing and run legacy migration (if needed), then show UI."""
    os.makedirs(base_dir, exist_ok=True)
    ensure_db(base_dir)

    try:
        if get_user_version(base_dir) < 4:
            rows, warns = migrate_from_files(base_dir)
            print(f"[migration] imported {rows} rows ({warns} warnings)")
    except Exception as e:
        print(f"[migration] warning: migration failed: {e}")

    # Import the GUI class, catching import-time errors
    try:
        from main_ui import AppWindow
    except Exception:
        print("\n[run_agent] FATAL — failed to import main_ui:\n")
        traceback.print_exc()
        print("\nPress Enter to exit…")
        input()
        sys.exit(1)

    # Instantiate and show the main window, catching UI init errors
    try:
        win = AppWindow()
        win.show()
    except Exception:
        print("\n[run_agent] FATAL — UI failed to initialize:\n")
        traceback.print_exc()
        print("\nPress Enter to exit…")
        input()
        sys.exit(1)


def main() -> None:
    """Entry point: initialize QApplication, bootstrap state, and start event loop."""
    base_dir = (
        sys.argv[1]
        if len(sys.argv) > 1
        else os.path.join(os.getcwd(), "ai_agent_state")
    )

    app = QtWidgets.QApplication(sys.argv)
    _bootstrap_state(base_dir)
    sys.exit(app.exec_())


if __name__ == "__main__":
    try:
        main()
    except Exception:
        print("\n[run_agent] FATAL — an unexpected error occurred:\n")
        traceback.print_exc()
        print("\nPress Enter to exit…")
        input()
```

run_agent.py — bootstrap launcher for AI TTS Agent (v3, 2025-08-04)

• Ensures the sqlite store exists (agent_store.ensure_db()) and runs
  legacy-data migration when user_version < 4.
• Accepts one optional command-line arg: <profile-dir>. Defaults to
  ./ai_agent_state relative to CWD.
• Starts the Qt GUI (main_ui.AppWindow).
• Catches early exceptions and prints a clean error trace instead of a
  raw stack-dump so newcomers understand what went wrong.
**Functions:** _bootstrap_state(base_dir), main()


## Module `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\_burner_scripts\schema_ops.py`

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
schema_ops.py  (2025-08-04  ▸  v2)
==================================

Declarative dispatcher that maps **string op-codes → mutator callables**
operating on core_schema.SchemaEngine / Schema rows.

Updates (v2)
------------
• Added category & prompt removal / update helpers
• Added action list mutators
• Added runtime-introspection helpers: available_ops(), describe_op()
• Strict type-checking & richer logging

Usage example
-------------
>>> from schema_ops import execute_op, available_ops
>>> print(available_ops())
['add_category', 'append_actions', 'delete_action', ...]
>>> execute_op("append_actions", engine,
...            persona="zira", set_name="default",
...            actions=["wave warmly", "offer coffee"])
"""

from __future__ import annotations

import inspect
from typing import Callable, Dict, Any, List

from core_schema import SchemaEngine, Schema
from core_base import logger


# ╔═══════════════════════════════════════════════════════════════════════╗
# ║  Internal helpers                                                     ║
# ╚═══════════════════════════════════════════════════════════════════════╝
def _load(engine: SchemaEngine, persona: str, set_name: str) -> Schema:
    """Return schema or raise ValueError on bad keys."""
    if persona not in engine.personas:
        raise ValueError(f"Unknown persona: {persona}")
    return engine.load(persona, set_name)


def _save(engine: SchemaEngine, persona: str, set_name: str, sch: Schema):
    engine.save(persona, set_name, sch)


def _signal_category_created(engine: SchemaEngine, persona: str, set_name: str, category: str):
    """
    Emit schemaEvolved + categoryCreated if those Qt signals exist.
    No hard dependency —  graceful if running headless.
    """
    try:
        # pylint: disable=protected-access
        engine.schemaEvolved.emit(persona, set_name)        # type: ignore[attr-defined]
        engine.categoryCreated.emit(category)               # type: ignore[attr-defined]
    except Exception:
        pass


# ╔═══════════════════════════════════════════════════════════════════════╗
# ║  Operation implementations                                            ║
# ╚═══════════════════════════════════════════════════════════════════════╝
def op_add_category(
    engine: SchemaEngine,
    *,
    persona: str,
    set_name: str,
    category: str,
    values: List[str] | None = None,
):
    """Create new dynamic_overlay list with optional initial *values*."""
    sch = _load(engine, persona, set_name)
    overlay = sch.dynamic_overlay or {}
    if category in overlay:
        raise ValueError(f"Category '{category}' already exists.")
    overlay[category] = values or []
    sch.dynamic_overlay = overlay
    _save(engine, persona, set_name, sch)
    _signal_category_created(engine, persona, set_name, category)
    logger.info("Added category '%s' to %s/%s", category, persona, set_name)


def op_remove_category(
    engine: SchemaEngine,
    *,
    persona: str,
    set_name: str,
    category: str,
):
    """Remove an entire category from dynamic_overlay."""
    sch = _load(engine, persona, set_name)
    overlay = sch.dynamic_overlay or {}
    if category not in overlay:
        raise ValueError(f"No such category '{category}'.")
    overlay.pop(category)
    sch.dynamic_overlay = overlay
    _save(engine, persona, set_name, sch)
    logger.info("Removed category '%s' from %s/%s", category, persona, set_name)


def op_update_category(
    engine: SchemaEngine,
    *,
    persona: str,
    set_name: str,
    category: str,
    new_values: List[str],
):
    """Replace the value-list of an existing category."""
    sch = _load(engine, persona, set_name)
    overlay = sch.dynamic_overlay or {}
    if category not in overlay:
        raise ValueError(f"Category '{category}' not found.")
    overlay[category] = list(new_values)
    sch.dynamic_overlay = overlay
    _save(engine, persona, set_name, sch)
    logger.info("Updated category '%s' in %s/%s", category, persona, set_name)


def op_toggle_autoevo(
    engine: SchemaEngine,
    *,
    persona: str,
    set_name: str,
    enable: bool,
):
    """Flip semantic_awareness_enabled flag."""
    sch = _load(engine, persona, set_name)
    cur = bool(getattr(sch, "semantic_awareness_enabled", False))
    if cur == enable:
        return
    sch.semantic_awareness_enabled = enable
    _save(engine, persona, set_name, sch)
    logger.info("semantic_awareness %s for %s/%s", enable, persona, set_name)


def op_inject_prompt_variant(
    engine: SchemaEngine,
    *,
    persona: str,
    set_name: str,
    variant_name: str,
    prompt_template: str,
):
    """Append new prompt template to rewrite_prompts list."""
    sch = _load(engine, persona, set_name)
    lst: List[str] = sch.rewrite_prompts or []
    entry = f"[{variant_name}] {prompt_template}"
    lst.append(entry)
    sch.rewrite_prompts = lst
    _save(engine, persona, set_name, sch)
    logger.info("Injected prompt variant '%s' into %s/%s", variant_name, persona, set_name)


def op_remove_prompt_variant(
    engine: SchemaEngine,
    *,
    persona: str,
    set_name: str,
    variant_tag: str,
):
    """
    Delete a rewrite prompt that contains *variant_tag* (case-insensitive).
    """
    sch = _load(engine, persona, set_name)
    lst: List[str] = sch.rewrite_prompts or []
    new_lst = [p for p in lst if variant_tag.lower() not in p.lower()]
    if len(new_lst) == len(lst):
        raise ValueError(f"No prompt containing '{variant_tag}' found.")
    sch.rewrite_prompts = new_lst
    _save(engine, persona, set_name, sch)
    logger.info("Removed prompt variant '%s' from %s/%s", variant_tag, persona, set_name)


def op_replace_rewrite_list(
    engine: SchemaEngine,
    *,
    persona: str,
    set_name: str,
    new_list: List[str],
):
    """Replace entire rewrite_prompts list."""
    sch = _load(engine, persona, set_name)
    sch.rewrite_prompts = list(new_list)
    _save(engine, persona, set_name, sch)
    logger.info("rewrite_prompts replaced for %s/%s", persona, set_name)


def op_append_actions(
    engine: SchemaEngine,
    *,
    persona: str,
    set_name: str,
    actions: List[str],
):
    """Append new action strings (deduplicated)."""
    sch = _load(engine, persona, set_name)
    cur: List[str] = sch.actions or []
    for a in actions:
        if a not in cur:
            cur.append(a)
    sch.actions = cur
    _save(engine, persona, set_name, sch)
    logger.info("Appended %d actions to %s/%s", len(actions), persona, set_name)


def op_delete_action(
    engine: SchemaEngine,
    *,
    persona: str,
    set_name: str,
    action_text: str,
):
    """Remove an action entry matching *action_text* exactly."""
    sch = _load(engine, persona, set_name)
    cur: List[str] = sch.actions or []
    if action_text not in cur:
        raise ValueError("Action not found.")
    cur.remove(action_text)
    sch.actions = cur
    _save(engine, persona, set_name, sch)
    logger.info("Deleted action '%s' from %s/%s", action_text, persona, set_name)


def op_rename_schema_set(
    engine: SchemaEngine,
    *,
    persona: str,
    old_set: str,
    new_set: str,
):
    """Rename a schema set atomically."""
    if new_set == old_set:
        raise ValueError("new_set equals old_set")
    if new_set in engine.list_sets(persona):
        raise ValueError("Target set already exists")
    sch = _load(engine, persona, old_set)
    engine.save(persona, new_set, sch, auto_expand=False)
    engine.store.conn.execute(
        "DELETE FROM schemas WHERE persona_key=? AND set_name=?",
        (persona, old_set),
    )
    engine.store.conn.commit()
    logger.info("Renamed set %s/%s -> %s", persona, old_set, new_set)


# ╔═══════════════════════════════════════════════════════════════════════╗
# ║  Declarative operation registry                                       ║
# ╚═══════════════════════════════════════════════════════════════════════╝
OPS: Dict[str, Callable[..., None]] = {
    # Category ops
    "add_category": op_add_category,
    "remove_category": op_remove_category,
    "update_category": op_update_category,
    # Rewrite-prompt ops
    "inject_prompt_variant": op_inject_prompt_variant,
    "remove_prompt_variant": op_remove_prompt_variant,
    "replace_rewrite_list": op_replace_rewrite_list,
    # Semantic awareness flag
    "toggle_autoevo": op_toggle_autoevo,
    # Actions list
    "append_actions": op_append_actions,
    "delete_action": op_delete_action,
    # Set management
    "rename_schema_set": op_rename_schema_set,
}

# ╔═══════════════════════════════════════════════════════════════════════╗
# ║  Public utility wrappers                                              ║
# ╚═══════════════════════════════════════════════════════════════════════╝
def execute_op(op_name: str, engine: SchemaEngine, **payload):
    """Dispatch *op_name*; raise KeyError on unknown op."""
    fn = OPS.get(op_name)
    if not fn:
        raise KeyError(f"Unknown op: {op_name}")
    return fn(engine, **payload)


def available_ops() -> List[str]:
    """Return sorted list of registered op-codes."""
    return sorted(OPS)


def describe_op(op_name: str) -> str:
    """Return docstring of a registered op."""
    fn = OPS.get(op_name)
    if not fn:
        raise KeyError(op_name)
    return inspect.getdoc(fn) or ""


__all__ = [
    "OPS",
    "execute_op",
    "available_ops",
    "describe_op",
]
```

schema_ops.py  (2025-08-04  ▸  v2)
==================================

Declarative dispatcher that maps **string op-codes → mutator callables**
operating on core_schema.SchemaEngine / Schema rows.

Updates (v2)
------------
• Added category & prompt removal / update helpers
• Added action list mutators
• Added runtime-introspection helpers: available_ops(), describe_op()
• Strict type-checking & richer logging

Usage example
-------------
>>> from schema_ops import execute_op, available_ops
>>> print(available_ops())
['add_category', 'append_actions', 'delete_action', ...]
>>> execute_op("append_actions", engine,
...            persona="zira", set_name="default",
...            actions=["wave warmly", "offer coffee"])
**Functions:** _load(engine, persona, set_name), _save(engine, persona, set_name, sch), _signal_category_created(engine, persona, set_name, category), op_add_category(engine), op_remove_category(engine), op_update_category(engine), op_toggle_autoevo(engine), op_inject_prompt_variant(engine), op_remove_prompt_variant(engine), op_replace_rewrite_list(engine), op_append_actions(engine), op_delete_action(engine), op_rename_schema_set(engine), execute_op(op_name, engine), available_ops(), describe_op(op_name)


## Module `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\_burner_scripts\snapshot_worker.py`

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
snapshot_worker.py

This script defines ModelWorker, which runs inference on a given model in a separate thread.
Used by the UI to offload prompt evaluation from the main thread.
"""

from PyQt5 import QtCore
from typing import Optional
import traceback

class ModelWorker(QtCore.QThread):
    resultReady = QtCore.pyqtSignal(str)
    errorOccurred = QtCore.pyqtSignal(str)

    def __init__(self, model_slug: str, prompt: str, parent: Optional[QtCore.QObject] = None) -> None:
        super().__init__(parent)
        self.model_slug = model_slug
        self.prompt = prompt

    def run(self):
        try:
            # TODO: Replace this mock logic with actual model inference
            import time
            time.sleep(0.8)  # Simulate response time

            # Simulated output - replace with LLM backend output
            response = f"[{self.model_slug}] Response to: {self.prompt}"

            # Emit response back to UI
            self.resultReady.emit(response)

        except Exception as e:
            tb = traceback.format_exc()
            self.errorOccurred.emit(f"{e}\n{tb}")
```

snapshot_worker.py

This script defines ModelWorker, which runs inference on a given model in a separate thread.
Used by the UI to offload prompt evaluation from the main thread.
**Classes:** ModelWorker


## Module `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\_burner_scripts\spatial_engine.py`

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
spatial_engine.py
=================

Headless avatar movement & visual-action logger for the AI TTS Agent.

Features:
- Stateful finite-state machine (idle, thinking, moving).
- decide_move(response_text): simple NLP heuristics to pick a target cell.
- Animated, step-by-step movement on a configurable grid.
- Logs each position to AgentStore.spatial_positions and each completed move to AgentStore.visual_actions.
- Emits Qt signals for UI binding (positionChanged, actionLogged).
"""

import threading
import time
from typing import Tuple

from PyQt5 import QtCore
from core_store import FathomStore


class SpatialEngine(QtCore.QObject):
    # Emitted on each step: (x, y, facing)
    positionChanged = QtCore.pyqtSignal(int, int, str)
    # Emitted when a visual action is logged: (action, location, justification)
    actionLogged = QtCore.pyqtSignal(str, str, str)

    def __init__(
        self,
        store: FathomStore,
        entity: str = "zira",
        grid_size: Tuple[int, int] = (20, 20),
        parent: QtCore.QObject = None,
    ) -> None:
        super().__init__(parent)
        self.store = store
        self.entity = entity
        self.grid_width, self.grid_height = grid_size

        # FSM state
        self.state = "idle"
        self.current_x = 0
        self.current_y = 0
        self.facing = "right"

        # Threading
        self._lock = threading.Lock()
        self._stop_event = threading.Event()

    def decide_move(self, response_text: str) -> None:
        """
        Decide where to move based on the content of the last AI response.
        Spawns a background thread to animate the movement.
        """
        target = self._infer_target(response_text)
        justification = f"Decided move based on response keywords."
        worker = threading.Thread(
            target=self._animate_move, args=(target, justification), daemon=True
        )
        worker.start()

    def _infer_target(self, text: str) -> Tuple[int, int]:
        """
        Simple heuristics mapping keywords to grid locations:
        - 'file', 'project' -> top-right (computer terminal)
        - 'database', 'memory' -> bottom-left (storage console)
        - 'think', 'ponder' -> center (thinking zone)
        - otherwise: stay in place
        """
        t = text.lower()
        if any(k in t for k in ("file", "project")):
            return (self.grid_width - 1, 0)
        if any(k in t for k in ("database", "memory", "store")):
            return (0, self.grid_height - 1)
        if any(k in t for k in ("think", "ponder", "reflect")):
            return (self.grid_width // 2, self.grid_height // 2)
        # default: remain where you are
        return (self.current_x, self.current_y)

    def _animate_move(self, target: Tuple[int, int], justification: str) -> None:
        """
        Step-by-step move from current position to target.
        Logs each step and emits positionChanged, then logs final visual action.
        """
        with self._lock:
            self.state = "moving"
            tx, ty = target

            while (self.current_x, self.current_y) != (tx, ty):
                if self._stop_event.is_set():
                    break

                # Compute one-step delta
                dx = tx - self.current_x
                dy = ty - self.current_y
                new_x = self.current_x + (1 if dx > 0 else -1 if dx < 0 else 0)
                new_y = self.current_y + (1 if dy > 0 else -1 if dy < 0 else 0)

                # Determine facing direction
                if new_x > self.current_x:
                    self.facing = "right"
                elif new_x < self.current_x:
                    self.facing = "left"

                self.current_x, self.current_y = new_x, new_y

                # Timestamp for persistence
                ts = time.time()

                # Persist to store
                self.store.add_spatial_position(
                    entity=self.entity,
                    x=new_x,
                    y=new_y,
                    facing=self.facing,
                    timestamp=ts,
                )

                # Emit for UI
                self.positionChanged.emit(new_x, new_y, self.facing)

                # Pause between steps
                time.sleep(0.15)

            # Log completion action
            loc_str = f"{self.current_x},{self.current_y}"
            ts = time.time()
            self.store.add_visual_action(
                action="move_complete",
                location=loc_str,
                justification=justification,
                timestamp=ts,
            )
            self.actionLogged.emit("move_complete", loc_str, justification)
            self.state = "idle"

    def stop(self) -> None:
        """Signal any in-progress movement to halt."""
        self._stop_event.set()
        # Clear the event so future movements can proceed
        self._stop_event.clear()
```

spatial_engine.py
=================

Headless avatar movement & visual-action logger for the AI TTS Agent.

Features:
- Stateful finite-state machine (idle, thinking, moving).
- decide_move(response_text): simple NLP heuristics to pick a target cell.
- Animated, step-by-step movement on a configurable grid.
- Logs each position to AgentStore.spatial_positions and each completed move to AgentStore.visual_actions.
- Emits Qt signals for UI binding (positionChanged, actionLogged).
**Classes:** SpatialEngine


## Module `Rant_PDD\Projects\AI_TTS_AGENT\project_info\repository\AI_TTS_AGENT\_burner_scripts\__init__.py`

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
LLM Checkpoint Builder plug-in
==============================

Offline-first tool that distils a persona’s knowledge into a custom
checkpoint (LoRA adapter or full fine-tune).  After the **first** run the
plug-in works 100 % offline thanks to its private *vendor/* wheel cache.

Folder layout (auto-created on import)
└─ plugins/
   └─ llm_checkpoint_builder/
      ├─ vendor/        → cached wheels (transformers, datasets, peft …)
      ├─ datasets/      → auto-built JSON-Lines shards (profile-scoped)
      ├─ checkpoints/   → finished checkpoints / LoRA adapters
      └─ schemas/       → saved user-generated training schemas
"""
from __future__ import annotations

import json
import os
import shutil
import subprocess
import sys
import textwrap
import threading
import time
from pathlib import Path
from typing import Callable, Dict, List

from PyQt5 import QtCore, QtGui, QtWidgets

# ────────────────────────────────────────────────────────────────────────────
#  Folder bootstrap
# ────────────────────────────────────────────────────────────────────────────
PLUGIN_NAME = "checkpoint_builder"           # concise, function–based name
ROOT = Path(__file__).resolve().parent
VENDOR         = ROOT / "vendor"
DATASETS_DIR   = ROOT / "datasets"
CHECKPOINTS_DIR = ROOT / "checkpoints"
SCHEMAS_DIR    = ROOT / "schemas"

for _d in (VENDOR, DATASETS_DIR, CHECKPOINTS_DIR, SCHEMAS_DIR):
    _d.mkdir(parents=True, exist_ok=True)

# ────────────────────────────────────────────────────────────────────────────
#  Dependency bootstrap  –  download **once**, then always run offline
# ────────────────────────────────────────────────────────────────────────────
REQUIRED_PKGS: list[str] = [
    "transformers==4.42.2",
    "datasets==2.19.0",
    "peft==0.11.1",
    "accelerate==0.29.2",
    # ‼ bitsandbytes has no official Windows wheels → load only on *nix
    *([] if os.name == "nt" else ["bitsandbytes==0.43.0"]),
    # 0.15.0 is last version with CPython-3.13 universal wheel
    "tokenizers==0.15.0",
]


def _have_all_wheels() -> bool:
    """Every required wheel already cached?"""
    need = {pkg.split("==")[0] for pkg in REQUIRED_PKGS}
    got  = {p.name.split("-")[0] for p in VENDOR.glob("*.whl")}
    return need.issubset(got)


def _ensure_vendor() -> None:
    """
    Cache pinned wheels into *vendor/* and prepend that path so all imports
    resolve offline.  Fail-fast (no sdist build) if a wheel is missing.
    """
    if _have_all_wheels():
        sys.path.insert(0, str(VENDOR))
        return

    print(f"[{PLUGIN_NAME}] Downloading wheels into {VENDOR} …")
    cmd = [
        sys.executable,
        "-m", "pip", "download",
        "--dest", str(VENDOR),
        "--only-binary", ":all:",        # never fall back to source dists
        "--prefer-binary",
        "--no-deps",
        *REQUIRED_PKGS,
    ]
    try:
        subprocess.check_call(cmd)
    except subprocess.CalledProcessError as exc:
        print(textwrap.dedent(f"""
            [!] Failed to cache dependencies (exit {exc.returncode})
            • Connect briefly to the Internet **or**
            • Manually drop the required *.whl files into {VENDOR}

            The plug-in stays disabled until all wheels are present.
        """).strip())
        raise

    sys.path.insert(0, str(VENDOR))


try:
    _ensure_vendor()
except Exception:
    # Graceful disable so the main Agent UI still launches.
    sys.modules[__name__] = object()          # type: ignore
    raise

# ────────────────────────────────────────────────────────────────────────────
#  Small helper – tolerate missing Core APIs across versions
# ────────────────────────────────────────────────────────────────────────────
def _safe(core, method: str, default: Callable | None = None):
    return getattr(core, method, default or (lambda *a, **k: None))

# ────────────────────────────────────────────────────────────────────────────
#  GUI A – Schema Designer  (Architect-bot chat)
# ────────────────────────────────────────────────────────────────────────────
class SchemaDesigner(QtWidgets.QWidget):
    """Chat with an *Architect* bot that turns prompts into Q&A schemas."""
    schema_ready = QtCore.pyqtSignal(dict)

    def __init__(self, core):
        super().__init__()
        self.core = core
        self._build_ui()

    # ---------- UI scaffold -------------------------------------------------
    def _build_ui(self) -> None:
        lay = QtWidgets.QVBoxLayout(self)

        self._schema_combo = QtWidgets.QComboBox()
        self._schema_combo.addItem("<default>")
        self._schema_combo.addItems([p.stem for p in SCHEMAS_DIR.glob("*.json")])
        lay.addWidget(self._schema_combo)

        row = QtWidgets.QHBoxLayout()
        self._btn_save = QtWidgets.QPushButton("Save current")
        self._btn_del = QtWidgets.QPushButton("Delete selected")
        row.addWidget(self._btn_save), row.addWidget(self._btn_del)
        lay.addLayout(row)

        self._chat_log  = QtWidgets.QTextEdit(readOnly=True)
        self._arch_resp = QtWidgets.QTextEdit(readOnly=True)

        # monospaced JSON render
        mono = QtGui.QFontDatabase.systemFont(QtGui.QFontDatabase.FixedFont)
        self._arch_resp.document().setDefaultFont(mono)

        self._entry   = QtWidgets.QLineEdit()
        self._btn_send = QtWidgets.QPushButton("Send")

        lay.addWidget(QtWidgets.QLabel("Conversation"))
        lay.addWidget(self._chat_log, 3)
        lay.addWidget(QtWidgets.QLabel("Architect-bot response"))
        lay.addWidget(self._arch_resp, 3)

        row2 = QtWidgets.QHBoxLayout()
        row2.addWidget(self._entry, 3), row2.addWidget(self._btn_send)
        lay.addLayout(row2)

        # signals
        self._btn_send.clicked.connect(self._on_send)
        self._btn_save.clicked.connect(self._save_schema)
        self._btn_del.clicked.connect(self._delete_schema)

    # ---------- chat round-trip --------------------------------------------
    def _on_send(self) -> None:
        txt = self._entry.text().strip()
        if not txt:
            return
        self._chat_log.append(f"<b>You:</b> {QtGui.QTextDocument(txt).toHtml()}")
        self._entry.clear()
        threading.Thread(target=self._architect_worker, args=(txt,), daemon=True).start()

    def _architect_worker(self, prompt: str) -> None:
        schema = _safe(self.core, "generate_schema_from_prompt",
                       lambda *_: {"questions": []})(prompt)
        QtCore.QMetaObject.invokeMethod(
            self, "_present_schema", QtCore.Qt.QueuedConnection,
            QtCore.Q_ARG(dict, schema)
        )

    @QtCore.pyqtSlot(dict)
    def _present_schema(self, schema: dict) -> None:
        self._arch_resp.append(f"<pre>{json.dumps(schema, indent=2)}</pre>")
        self.schema_ready.emit(schema)

    # ---------- schema persistence -----------------------------------------
    def _save_schema(self) -> None:
        raw = self._arch_resp.toPlainText().strip()
        if not raw:
            QtWidgets.QMessageBox.warning(self, "Nothing to save", "No schema present")
            return
        try:
            schema = json.loads(raw)
        except json.JSONDecodeError:
            QtWidgets.QMessageBox.warning(self, "Invalid JSON", "Fix the schema first")
            return
        name, ok = QtWidgets.QInputDialog.getText(self, "Schema name", "Enter name:")
        if ok and name:
            with open(SCHEMAS_DIR / f"{name}.json", "w", encoding="utf-8") as fh:
                json.dump(schema, fh, indent=2)
            self._schema_combo.addItem(name)

    def _delete_schema(self) -> None:
        name = self._schema_combo.currentText()
        if name not in {"", "<default>"}:
            (SCHEMAS_DIR / f"{name}.json").unlink(missing_ok=True)
            self._schema_combo.removeItem(self._schema_combo.currentIndex())

# ────────────────────────────────────────────────────────────────────────────
#  GUI B – Trainer Panel
# ────────────────────────────────────────────────────────────────────────────
class TrainerPanel(QtWidgets.QWidget):
    training_requested = QtCore.pyqtSignal(dict)

    def __init__(self, core):
        super().__init__()
        self.core = core
        self._build_ui()

    def _build_ui(self) -> None:
        form = QtWidgets.QFormLayout(self)

        self._name = QtWidgets.QLineEdit()

        self._base = QtWidgets.QComboBox()
        self._base.addItems(_safe(self.core, "list_models", lambda: [])())

        self._epochs = QtWidgets.QSpinBox(range=(1, 20))
        self._epochs.setValue(3)

        self._rank = QtWidgets.QSpinBox(range=(4, 256))
        self._rank.setValue(16)

        self._full = QtWidgets.QCheckBox("Full fine-tune (disable LoRA)")
        self._full.toggled.connect(self._rank.setDisabled)

        form.addRow("New model name:", self._name)
        form.addRow("Base model:", self._base)
        form.addRow("Epochs:", self._epochs)
        form.addRow("LoRA rank:", self._rank)
        form.addRow("", self._full)

        btn = QtWidgets.QPushButton("Start training")
        form.addRow("", btn)
        btn.clicked.connect(self._emit_params)

    def _emit_params(self) -> None:
        name = self._name.text().strip()
        if not name:
            QtWidgets.QMessageBox.critical(self, "Name required", "Enter a model name.")
            return
        self.training_requested.emit(
            dict(
                new_name=name,
                base_model=self._base.currentText(),
                epochs=self._epochs.value(),
                lora_rank=self._rank.value(),
                full=self._full.isChecked(),
            )
        )

# ────────────────────────────────────────────────────────────────────────────
#  GUI C – Main Builder Window
# ────────────────────────────────────────────────────────────────────────────
class BuilderWindow(QtWidgets.QMainWindow):
    def __init__(self, core):
        super().__init__()
        self.setWindowTitle("LLM Checkpoint Builder")
        self.setUnifiedTitleAndToolBarOnMac(True)
        self.core = core

        splitter = QtWidgets.QSplitter()
        self.setCentralWidget(splitter)

        self._designer = SchemaDesigner(core)
        self._trainer  = TrainerPanel(core)
        splitter.addWidget(self._designer)
        splitter.addWidget(self._trainer)

        self._designer.schema_ready.connect(self._build_dataset)
        self._trainer.training_requested.connect(self._kickoff_training)

        self._dataset_path: Path | None = None

    # ---------- dataset pipe -----------------------------------------------
    def _build_dataset(self, schema: dict) -> None:
        ts = int(time.time())
        profile = getattr(self.core, "persona",
                   getattr(self.core, "active_profile", "unknown"))
        self._dataset_path = DATASETS_DIR / f"{profile}_{ts}.jsonl"
        _run_bg(
            target=_dataset_from_schema,
            args=(self.core, schema, self._dataset_path),
            gui=self,
            done="Dataset written to " + str(self._dataset_path),
        )

    # ---------- training pipe ----------------------------------------------
    def _kickoff_training(self, p: dict) -> None:
        if not self._dataset_path or not self._dataset_path.exists():
            QtWidgets.QMessageBox.warning(self, "No dataset", "Build a dataset first.")
            return
        p = {**p, "dataset": str(self._dataset_path)}
        _run_bg(
            target=_train_worker,
            args=(self.core, p),
            gui=self,
            done=f"Training finished – new model “{p['new_name']}” registered",
        )

# ────────────────────────────────────────────────────────────────────────────
#  Thread helper – run *target* in a daemon thread & pop toast on finish
# ────────────────────────────────────────────────────────────────────────────
def _run_bg(*, target, args, gui: QtWidgets.QWidget, done: str) -> None:
    def worker():
        try:
            target(*args)
            QtCore.QMetaObject.invokeMethod(gui, "_notify",
                                            QtCore.Qt.QueuedConnection,
                                            QtCore.Q_ARG(str, done))
        except Exception as exc:
            QtCore.QMetaObject.invokeMethod(gui, "_notify",
                                            QtCore.Qt.QueuedConnection,
                                            QtCore.Q_ARG(str, f"❌ {exc}"))

    threading.Thread(target=worker, daemon=True).start()


def _notify(self, msg: str) -> None:                          # noqa: D401
    QtWidgets.QMessageBox.information(self, "LLM Builder", msg)

BuilderWindow._notify = _notify                               # type: ignore

# ────────────────────────────────────────────────────────────────────────────
#  Dataset constructor – ask the profile for every question
# ────────────────────────────────────────────────────────────────────────────
def _dataset_from_schema(core, schema: dict, out_path: Path) -> None:
    import random

    qs: List[str] = schema.get("questions") or []
    records: List[Dict[str, str]] = []
    for q in qs:
        ans = _safe(core, "ask_profile", lambda *_: "")(q)
        records.append({"prompt": q, "response": ans})

    random.shuffle(records)
    with open(out_path, "w", encoding="utf-8") as fh:
        for rec in records:
            fh.write(json.dumps(rec) + "\n")

# ────────────────────────────────────────────────────────────────────────────
#  Training worker – LoRA by default, full fine-tune on demand
# ────────────────────────────────────────────────────────────────────────────
def _train_worker(core, p: dict) -> None:
    os.environ["TRANSFORMERS_OFFLINE"] = "1"
    sys.path.insert(0, str(VENDOR))

    import torch                     # type: ignore
    from datasets import load_dataset          # type: ignore
    from transformers import (                 # type: ignore
        AutoModelForCausalLM,
        AutoTokenizer,
        TrainingArguments,
        Trainer,
    )
    from peft import LoraConfig, get_peft_model    # type: ignore

    ds = load_dataset("json", data_files=p["dataset"], split="train")
    tok = AutoTokenizer.from_pretrained(p["base_model"])
    tok.pad_token = tok.eos_token

    def encode(ex):
        out = tok(
            ex["prompt"] + tok.eos_token + ex["response"],
            truncation=True,
            padding="max_length",
            max_length=1024,
        )
        out["labels"] = out["input_ids"].copy()
        return out

    ds = ds.map(encode, batched=False)
    model = AutoModelForCausalLM.from_pretrained(p["base_model"], device_map="auto")

    if not p["full"]:
        cfg = LoraConfig(
            r=p["lora_rank"],
            lora_alpha=p["lora_rank"] * 2,
            lora_dropout=0.05,
            bias="none",
            task_type="CAUSAL_LM",
        )
        model = get_peft_model(model, cfg)

    out_dir = CHECKPOINTS_DIR / p["new_name"]
    args = TrainingArguments(
        output_dir=str(out_dir),
        per_device_train_batch_size=1,
        num_train_epochs=p["epochs"],
        learning_rate=2e-4,
        fp16=torch.cuda.is_available(),
        logging_steps=25,
        save_strategy="epoch",
        report_to=[],
    )
    Trainer(model=model, args=args, train_dataset=ds).train()
    model.save_pretrained(out_dir)
    tok.save_pretrained(out_dir)

    # copy ⇢ Agent’s models/local/  then register live
    models_root = Path(getattr(core.settings, "models_dir",
                     Path(core.base_dir) / "models"))
    target = models_root / "local" / p["new_name"]
    if target.exists():
        shutil.rmtree(target)
    shutil.copytree(out_dir, target)
    _safe(core, "register_local_model")(p["new_name"], target)

# ────────────────────────────────────────────────────────────────────────────
#  Plug-in entry-point
# ────────────────────────────────────────────────────────────────────────────
def start(host_core):
    win = BuilderWindow(host_core)
    win.resize(1024, 640)
    return win
```

LLM Checkpoint Builder plug-in
==============================

Offline-first tool that distils a persona’s knowledge into a custom
checkpoint (LoRA adapter or full fine-tune).  After the **first** run the
plug-in works 100 % offline thanks to its private *vendor/* wheel cache.

Folder layout (auto-created on import)
└─ plugins/
   └─ llm_checkpoint_builder/
      ├─ vendor/        → cached wheels (transformers, datasets, peft …)
      ├─ datasets/      → auto-built JSON-Lines shards (profile-scoped)
      ├─ checkpoints/   → finished checkpoints / LoRA adapters
      └─ schemas/       → saved user-generated training schemas
**Classes:** SchemaDesigner, TrainerPanel, BuilderWindow
**Functions:** _have_all_wheels(), _ensure_vendor(), _safe(core, method, default), _run_bg(), _notify(self, msg), _dataset_from_schema(core, schema, out_path), _train_worker(core, p), start(host_core)



---
**Generation Parameters**


```text

You are an expert software engineer.  Carefully read every
file under the target directory (skipping any virtual environment
folders) and produce a comprehensive, well‑structured README in
Markdown.  Focus most of your attention on Python (.py) files: parse
their module‑level docstrings, enumerate classes and functions, and
describe what each does.  Summarise the purpose of non‑Python files
(such as JSON, YAML, text, images) briefly.  Provide an overview of
the project architecture and any dependencies you can infer from the
code.  Include usage notes or examples where appropriate.  Do not
invent information – base your summary solely on the source content.
Use headings, subheadings and lists to organise the README.

```