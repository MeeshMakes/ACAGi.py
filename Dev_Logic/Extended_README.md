# Project Documentation

## Table of Contents
- [Overview](#overview)
- [Python Modules](#python-modules)
- [Other Files](#other-files)
- [Binaries](#binaries)

## Overview
This README was generated automatically by analyzing the project contents. Python modules are parsed for docstrings, classes, and functions. Image files are embedded as previews. Executable files (.exe) are listed by name; their contents are intentionally skipped.

## Python Modules

- `background\__init__.py`
- `background\base.py`
- `background\gif.py`
- `background\gl.py`
- `background\live_engine.py`
- `background\static.py`
- `background\video.py`
- `code_editor.py`
- `Codex_Terminal.py`
- `editor\__init__.py`
- `editor\card.py`
- `editor\logic_doc.py`
- `error_center.py`
- `error_console.py`
- `errors\__init__.py`
- `errors\process_error_card.py`
- `external_app_card.py`
- `image_pipeline.py`
- `memory_manager.py`
- `metrics_manager.py`
- `operator_manager.py`
- `prompt_loader.py`
- `repo_reference_helper.py`
- `safety.py`
- `simple_codex_terminal.py`
- `tasks\__init__.py`
- `tasks\bus.py`
- `tasks\card.py`
- `tasks\diffs.py`
- `tasks\drawer.py`
- `tasks\models.py`
- `tasks\panel.py`
- `tasks\task_panel.py`
- `tests\__init__.py`
- `tests\conftest.py`
- `tests\test_chat_input_repo_reference.py`
- `tests\test_codex_approval_prompts.py`
- `tests\test_codex_terminal_embedding.py`
- `tests\test_codex_terminal_run_checked.py`
- `tests\test_conversation_retrieve.py`
- `tests\test_editor_card.py`
- `tests\test_error_console.py`
- `tests\test_external_app_embed_timeout.py`
- `tests\test_external_app_forced_shutdown.py`
- `tests\test_image_path_insertion.py`
- `tests\test_image_pipeline.py`
- `tests\test_live_engine.py`
- `tests\test_logic_doc.py`
- `tests\test_manage_tests.py`
- `tests\test_memory_manager.py`
- `tests\test_metrics_manager.py`
- `tests\test_process_error_card.py`
- `tests\test_prompt_loader.py`
- `tests\test_repo_index.py`
- `tests\test_repo_reference_helper.py`
- `tests\test_safety.py`
- `tests\test_send_to_codex.py`
- `tests\test_session_memory.py`
- `tests\test_settings_dialog.py`
- `tests\test_start_panel_icons.py`
- `tests\test_system_metrics.py`
- `tests\test_system_overview.py`
- `tests\test_task_panel.py`
- `tests\test_taskbar_geometry.py`
- `tests\test_tasks_bus.py`
- `tests\test_tasks_diffs.py`
- `tests\test_tasks_models.py`
- `tests\test_terminal_desktop_context_menu.py`
- `tests\test_user_guided_notes_layout.py`
- `tests\test_virtual_desktop_card_scale.py`
- `tests\test_virtual_desktop_codex_workspace.py`
- `tests\test_virtual_desktop_drop_import.py`
- `tests\test_virtual_desktop_external_launch.py`
- `tests\test_virtual_desktop_native_icons.py`
- `tests\test_virtual_desktop_search.py`
- `tests\test_virtual_desktop_single_card.py`
- `tests\test_vision_toggle.py`
- `tests\test_workspace_config.py`
- `tests\test_write_console_line.py`
- `token_budget.py`
- `tools\codex_pr_sentinel.py`
- `tools\index_repo.py`
- `tools\logic_inbox.py`
- `tools\manage_tests.py`
- `tools\system_metrics.py`
- `User_Guided_Notes.py`
- `Virtual_Desktop.py`
- `Virtual_Desktop\game_creator.py`

## Other Files

- `.git\config`
- `.git\description`
- `.git\FETCH_HEAD`
- `.git\HEAD`
- `.git\hooks\applypatch-msg.sample`
- `.git\hooks\commit-msg.sample`
- `.git\hooks\fsmonitor-watchman.sample`
- `.git\hooks\post-update.sample`
- `.git\hooks\pre-applypatch.sample`
- `.git\hooks\pre-commit.sample`
- `.git\hooks\pre-merge-commit.sample`
- `.git\hooks\pre-push.sample`
- `.git\hooks\pre-rebase.sample`
- `.git\hooks\pre-receive.sample`
- `.git\hooks\prepare-commit-msg.sample`
- `.git\hooks\push-to-checkout.sample`
- `.git\hooks\sendemail-validate.sample`
- `.git\hooks\update.sample`
- `.git\index`
- `.git\info\exclude`
- `.git\logs\HEAD`
- `.git\logs\refs\heads\main`
- `.git\logs\refs\remotes\origin\HEAD`
- `.git\objects\pack\pack-f013e895fead8721a2c5f5e51feed0cdfb88c6e9.idx`
- `.git\objects\pack\pack-f013e895fead8721a2c5f5e51feed0cdfb88c6e9.pack`
- `.git\objects\pack\pack-f013e895fead8721a2c5f5e51feed0cdfb88c6e9.rev`
- `.git\packed-refs`
- `.git\refs\heads\main`
- `.git\refs\remotes\origin\HEAD`
- `.github\codex_sentinel.yml`
- `.github\workflows\codex-pr-sentinel.yml`
- `.gitignore`
- `__pycache__\code_editor.cpython-313.pyc`
- `__pycache__\Codex_Terminal.cpython-313.pyc`
- `__pycache__\error_center.cpython-313.pyc`
- `__pycache__\error_console.cpython-313.pyc`
- `__pycache__\external_app_card.cpython-313.pyc`
- `__pycache__\image_pipeline.cpython-313.pyc`
- `__pycache__\memory_manager.cpython-313.pyc`
- `__pycache__\metrics_manager.cpython-313.pyc`
- `__pycache__\operator_manager.cpython-313.pyc`
- `__pycache__\prompt_loader.cpython-313.pyc`
- `__pycache__\repo_reference_helper.cpython-313.pyc`
- `__pycache__\safety.cpython-313.pyc`
- `__pycache__\token_budget.cpython-313.pyc`
- `__pycache__\User_Guided_Notes.cpython-313.pyc`
- `Agent.md`
- `Agent_Codex_Standalone\.codex_agent\archives\.gitkeep`
- `Agent_Codex_Standalone\.codex_agent\sessions\term_20250929133133_eda629\conversation.md`
- `Agent_Codex_Standalone\.codex_agent\sessions\term_20250929133133_eda629\session.meta.json`
- `Agent_Codex_Standalone\Terminal Desktop\codex-x86_64-pc-windows-msvc.exe.zip`
- `Agent_Codex_Standalone\Terminal Desktop\settings.json`
- `Archived Conversations\.gitkeep`
- `background\__pycache__\__init__.cpython-313.pyc`
- `background\__pycache__\base.cpython-313.pyc`
- `background\__pycache__\gif.cpython-313.pyc`
- `background\__pycache__\gl.cpython-313.pyc`
- `background\__pycache__\live_engine.cpython-313.pyc`
- `background\__pycache__\static.cpython-313.pyc`
- `background\__pycache__\video.cpython-313.pyc`
- `CHANGELOG.md`
- `datasets\repo_index\index.jsonl`
- `datasets\repo_index\manifest.json`
- `datasets\system_metrics.db`
- `Dev_Logic\2025-12-05-virtual-desktop-dnd-sync.md`
- `editor\__pycache__\__init__.cpython-313.pyc`
- `editor\__pycache__\card.cpython-313.pyc`
- `editor\__pycache__\logic_doc.cpython-313.pyc`
- `errors\.gitignore`
- `errors\__pycache__\__init__.cpython-313.pyc`
- `errors\__pycache__\process_error_card.cpython-313.pyc`
- `logs\session_2025-09-26.md`
- `memory\codex_memory.json`
- `memory\logic_inbox.jsonl`
- `prompts\chat_system.overlay.txt`
- `prompts\chat_system.txt`
- `prompts\codex_shell.overlay.txt`
- `prompts\codex_shell.txt`
- `prompts\codex_system.overlay.txt`
- `prompts\codex_system.txt`
- `prompts\voice_system.overlay.txt`
- `prompts\voice_system.txt`
- `tasks\__pycache__\__init__.cpython-313.pyc`
- `tasks\__pycache__\bus.cpython-313.pyc`
- `tasks\__pycache__\card.cpython-313.pyc`
- `tasks\__pycache__\diffs.cpython-313.pyc`
- `tasks\__pycache__\drawer.cpython-313.pyc`
- `tasks\__pycache__\models.cpython-313.pyc`
- `tasks\__pycache__\panel.cpython-313.pyc`
- `tasks\__pycache__\task_panel.cpython-313.pyc`
- `tasks\live_engine_design.md`
- `Terminal Desktop\.gitkeep`
- `tools\__pycache__\system_metrics.cpython-313.pyc`
- `User_Guided_Notes\prompts\index.json`
- `User_Guided_Notes\settings.json`
- `vd_state.json`
- `vd_system.log`
- `Virtual_Desktop\.codex_agent\archives\.gitkeep`
- `Virtual_Desktop\.codex_agent\sessions\term_20250927050154_9a76ba\conversation.md`
- `Virtual_Desktop\.codex_agent\sessions\term_20250927050154_9a76ba\session.meta.json`
- `Virtual_Desktop\.codex_agent\sessions\term_20250927142116_97dec4\conversation.jsonl`
- `Virtual_Desktop\.codex_agent\sessions\term_20250927142116_97dec4\conversation.md`
- `Virtual_Desktop\.codex_agent\sessions\term_20250927142116_97dec4\dataset.jsonl`
- `Virtual_Desktop\.codex_agent\sessions\term_20250927142116_97dec4\session.meta.json`
- `Virtual_Desktop\.codex_agent\sessions\term_20250928173837_266120\conversation.md`
- `Virtual_Desktop\.codex_agent\sessions\term_20250928173837_266120\session.meta.json`
- `Virtual_Desktop\.codex_agent\sessions\term_20250929133121_9b3cca\conversation.md`
- `Virtual_Desktop\.codex_agent\sessions\term_20250929133121_9b3cca\session.meta.json`
- `Virtual_Desktop\.gitkeep`
- `Virtual_Desktop\Sample Shortcut.shortcut.json`
- `Virtual_Desktop\Terminal Desktop\settings.json`
- `Virtual_Desktop\untitled.blend`

## Binaries

- `Agent_Codex_Standalone\Terminal Desktop\codex-x86_64-pc-windows-msvc.exe` (content skipped)


## Detailed Module Analyses


## Module `Codex_Terminal.py`

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Agent Virtual Desktop — Codex-Terminal (All-in-One)
- Virtual Desktop canvas (bright blue), draggable chat/terminal card
- Local-first Chat (Ollama-only) + OCR/Vision pipeline
- Dataset persistence (JSONL + embeddings) + user-memory (lightweight)
- **Codex Rust CLI bridge for Windows**:
    • Download/verify/launch Codex CLI
    • Mirror CMD output (snapshots)
    • Inject text to CMD
    • **Press Enter reliably** (WriteConsoleInputW + SendInput fallback)
    • Start/Stop/Show/Hide controls
    • Tri-state LED (red/yellow/green) for bridge health

Requires: PySide6>=6.6, requests, Pillow (optional), local ollama, Windows 10+ for bridge.
"""

from __future__ import annotations

# --- DPI policy MUST be set before QApplication is created ---
from PySide6.QtGui import QGuiApplication
from PySide6.QtCore import Qt


def _ensure_high_dpi_rounding_policy() -> None:
    """Apply the pass-through rounding policy before a QApplication exists."""

    if QGuiApplication.instance() is not None:
        return
    QGuiApplication.setHighDpiScaleFactorRoundingPolicy(
        Qt.HighDpiScaleFactorRoundingPolicy.PassThrough
    )


_ensure_high_dpi_rounding_policy()

import argparse
import base64
import copy
import ctypes
import hashlib
import io
import json
import logging
import math
import os
import platform
import re
import shlex
import shutil
import subprocess
import sys
import threading
import traceback
import time
import traceback
import uuid
import zipfile
from collections import deque
from dataclasses import dataclass
from datetime import UTC, datetime
from pathlib import Path
from typing import Any, Callable, Deque, Dict, List, Optional, Sequence, Set, Tuple
import token_budget

# Optional deps
try:
    import requests  # type: ignore
except Exception:
    requests = None  # surfaced in UI

try:
    from PIL import Image  # type: ignore
    PIL_AVAILABLE = True
except Exception:
    PIL_AVAILABLE = False

from PySide6.QtCore import (
    QRect,
    QRectF,
    QTimer,
    Signal,
    Slot,
    QSize,
    QEvent,
    QMimeData,
    QPoint,
    QUrl,
    QFileSystemWatcher,
)
from PySide6.QtGui import (
    QAction, QCloseEvent, QColor, QCursor, QDesktopServices, QKeyEvent, QKeySequence,
    QPainter, QPalette, QLinearGradient, QPainterPath, QImage, QPixmap, QIcon,
    QTextCharFormat, QTextCursor,
)
from PySide6.QtWidgets import (
    QApplication, QDialog, QFrame, QHBoxLayout,
    QLabel, QLineEdit, QMainWindow, QMessageBox, QPushButton,
    QTextBrowser, QTextEdit, QVBoxLayout, QWidget, QFileDialog, QComboBox,
    QSlider, QFormLayout, QGroupBox, QTabWidget, QScrollArea,
    QToolButton, QCheckBox, QSpinBox, QSpacerItem, QSizePolicy, QInputDialog,
    QMenu, QStyle, QListWidget, QListWidgetItem, QAbstractItemView,
)

from tasks import record_diff
from tasks.bus import publish, subscribe, Subscription
from tasks.drawer import TaskDrawer
from tasks.models import (
    Task,
    TaskEvent,
    append_event,
    append_run_log,
    append_run_output,
    append_task,
    update_task,
)
from error_console import ErrorConsole, StderrRedirector, log_exception
from safety import SafetyViolation, manager as safety_manager
from image_pipeline import analyze_image, perform_ocr
from prompt_loader import get_prompt_watcher, iter_prompt_definitions, prompt_text
from background import (
    BackgroundConfig,
    BackgroundFit,
    BackgroundManager,
    BackgroundMode,
    GifBg,
    GLViewportBg,
    StaticImageBg,
    VideoBg,
)
from repo_reference_helper import RepoReference, RepoReferenceHelper

VD_LOGGER_NAME = "VirtualDesktop"
VD_LOG_FILENAME = "vd_system.log"
VD_LOG_PATH = Path(__file__).resolve().with_name(VD_LOG_FILENAME)


def _shared_log_handler_attached(logger: logging.Logger) -> bool:
    for handler in logger.handlers:
        if isinstance(handler, logging.FileHandler):
            try:
                if Path(handler.baseFilename).resolve() == VD_LOG_PATH:
                    return True
            except Exception:
                continue
    return False


def configure_shared_logger() -> logging.Logger:
    """Return a logger that writes to the shared Virtual Desktop log file."""

    logger = logging.getLogger(VD_LOGGER_NAME)
    if not _shared_log_handler_attached(logger):
        VD_LOG_PATH.parent.mkdir(parents=True, exist_ok=True)
        handler = logging.FileHandler(VD_LOG_PATH, mode="a", encoding="utf-8")
        handler.setFormatter(logging.Formatter("%(asctime)s [%(levelname)s] %(message)s"))
        logger.addHandler(handler)
    if logger.level == logging.NOTSET:
        logger.setLevel(logging.INFO)
    return logger

# --------------------------------------------------------------------------------------
# Crash capture
# --------------------------------------------------------------------------------------

class ErrorPopup(QDialog):
    def __init__(self, title: str, message: str, details: str, parent: Optional[QWidget] = None):
        super().__init__(parent)
        self.setWindowTitle(title)
        self.setModal(True)
        self.resize(900, 580)
        layout = QVBoxLayout(self)

        msg = QLabel(message, self); msg.setWordWrap(True)
        layout.addWidget(msg)

        self.details = QTextBrowser(self)
        self.details.setPlainText(details)
        self.details.setReadOnly(True)
        layout.addWidget(self.details, 1)

        btns = QHBoxLayout()
        copy_btn = QPushButton("Copy to Clipboard", self)
        copy_btn.clicked.connect(lambda: QApplication.clipboard().setText(self.details.toPlainText()))
        close_btn = QPushButton("Close", self)
        close_btn.clicked.connect(self.accept)
        btns.addStretch(1); btns.addWidget(copy_btn); btns.addWidget(close_btn)
        layout.addLayout(btns)

def install_global_exception_handler(logger: Optional[logging.Logger] = None):
    shared_logger = logger or configure_shared_logger()

    def _hook(exc_type, exc, tb):
        shared_logger.error(
            "Unhandled exception in Codex Terminal",
            exc_info=(exc_type, exc, tb),
        )
        for handler in shared_logger.handlers:
            try:
                handler.flush()
            except Exception:
                continue

        text = "".join(traceback.format_exception(exc_type, exc, tb))
        try:
            dlg = ErrorPopup("Unhandled Error", "An unexpected error occurred.", text)
            dlg.exec()
        except Exception:
            shared_logger.error(
                "Failed to display unhandled error dialog",
                exc_info=True,
            )

    sys.excepthook = _hook

# --------------------------------------------------------------------------------------
# Paths / constants
# --------------------------------------------------------------------------------------

APP_NAME = "Agent Virtual Desktop — Codex-Terminal"

def here() -> Path:
    return Path(os.path.abspath(os.path.dirname(__file__)))

def _resolve_directory(path: Path) -> Path:
    try:
        resolved = path.expanduser().resolve()
    except Exception:
        resolved = path.expanduser()
    resolved.mkdir(parents=True, exist_ok=True)
    return resolved


def base_dir() -> Path:
    env = os.environ.get("CODEX_WORKSPACE")
    if env:
        try:
            return _resolve_directory(Path(env))
        except Exception:
            pass
    fallback = Path(__file__).resolve().with_name("Agent_Codex_Standalone")
    return _resolve_directory(fallback)


def workspace_root() -> Path:
    return base_dir()


def agent_data_root() -> Path:
    """Root directory scoped to the workspace for Codex-managed assets."""

    root = workspace_root() / ".codex_agent"
    root.mkdir(parents=True, exist_ok=True)
    return root


def _agent_subdir(name: str) -> Path:
    path = agent_data_root() / name
    path.mkdir(parents=True, exist_ok=True)
    return path


def agent_images_dir() -> Path:
    return _agent_subdir("images")


def agent_sessions_dir() -> Path:
    return _agent_subdir("sessions")


def agent_logs_dir() -> Path:
    return _agent_subdir("logs")


def agent_archives_dir() -> Path:
    return _agent_subdir("archives")


def agent_data_dir() -> Path:
    return _agent_subdir("data")


def agent_lexicons_dir() -> Path:
    return _agent_subdir("lexicons")


for _name in ("images", "sessions", "logs", "archives", "data", "lexicons"):
    _agent_subdir(_name)


def _clamp_to_agent_subdir(raw: Optional[Path | str], *, subdir: Path) -> Path:
    if raw is None or (isinstance(raw, str) and not raw.strip()):
        return subdir

    try:
        candidate = Path(raw).expanduser()
    except Exception:
        return subdir

    if not candidate.is_absolute():
        candidate = subdir / candidate

    try:
        resolved = candidate.resolve(strict=False)
    except Exception:
        resolved = candidate

    try:
        agent_root = agent_data_root().resolve(strict=False)
    except Exception:
        agent_root = agent_data_root()

    if resolved == agent_root or agent_root in resolved.parents:
        resolved.mkdir(parents=True, exist_ok=True)
        return resolved

    target = subdir / resolved.name
    target.mkdir(parents=True, exist_ok=True)
    return target


def styles_path() -> Path:
    p = here() / "Styles"
    p.mkdir(parents=True, exist_ok=True)
    return p / "advanced_styles.json"

def _legacy_transit_candidates() -> list[Path]:
    return [here() / "Codex-Transit"]


def _migrate_legacy_transit(target: Path) -> None:
    for legacy in _legacy_transit_candidates():
        if not legacy.exists() or not legacy.is_dir():
            continue
        try:
            if legacy.resolve() == target.resolve():
                continue
        except Exception:
            pass

        if not target.exists():
            try:
                legacy.rename(target)
                return
            except OSError:
                pass

        target.mkdir(parents=True, exist_ok=True)

        for child in list(legacy.iterdir()):
            destination = target / child.name
            if destination.exists():
                continue
            try:
                child.rename(destination)
            except OSError:
                shutil.move(str(child), str(destination))

        try:
            legacy.rmdir()
        except OSError:
            pass


def transit_dir() -> Path:
    target = workspace_root() / "Terminal Desktop"
    _migrate_legacy_transit(target)
    target.mkdir(parents=True, exist_ok=True)
    return target


def terminal_desktop_dir() -> Path:
    """Location for the standalone terminal's desktop workspace."""
    return transit_dir()

def lexicons_dir() -> Path:
    return agent_lexicons_dir()

def ensure_dir(p: Path) -> Path:
    p.mkdir(parents=True, exist_ok=True)
    return p

MEMORY_PATH = here() / "memory" / "codex_memory.json"
MEMORY_LOCK = threading.Lock()

def _read_codex_memory() -> Dict[str, Any]:
    if not MEMORY_PATH.exists():
        return {"sessions": [], "work_items": []}
    try:
        data = json.loads(MEMORY_PATH.read_text(encoding="utf-8"))
    except Exception:
        return {"sessions": [], "work_items": []}
    if not isinstance(data, dict):
        return {"sessions": [], "work_items": []}
    sessions = data.get("sessions")
    if not isinstance(sessions, list):
        sessions = []
    work_items = data.get("work_items")
    if not isinstance(work_items, list):
        work_items = []
    return {"sessions": sessions, "work_items": work_items}

def load_session_notes() -> List[Dict[str, str]]:
    data = _read_codex_memory()
    notes: List[Dict[str, str]] = []
    for entry in data.get("sessions", []):
        if isinstance(entry, dict):
            note = entry.get("notes", "")
            ts = entry.get("timestamp", "")
            if isinstance(note, str) and note.strip():
                notes.append({
                    "timestamp": str(ts) if isinstance(ts, str) else str(ts),
                    "notes": note.strip(),
                })
    return notes

def _utc_iso() -> str:
    return datetime.now(UTC).isoformat().replace("+00:00", "Z")


def append_session_note(note: str) -> Dict[str, str]:
    entry = {"timestamp": _utc_iso(), "notes": note.strip()}
    with MEMORY_LOCK:
        data = _read_codex_memory()
        sessions = data.get("sessions", [])
        sessions.append(entry)
        data["sessions"] = sessions
        data.setdefault("work_items", [])
        MEMORY_PATH.parent.mkdir(parents=True, exist_ok=True)
        MEMORY_PATH.write_text(json.dumps(data, indent=2), encoding="utf-8")
    return entry

def is_windows() -> bool:
    return os.name == "nt" or platform.system().lower().startswith("win")

# Ollama
DEFAULT_CHAT_MODEL = "qwen3:8b"
DEFAULT_VISION_MODEL = "llava-llama3:latest"
DEFAULT_VISION_OCR_MODEL = "benhaotang/Nanonets-OCR-s:latest"
DEFAULT_EMBED_MODEL = "snowflake-arctic-embed2:latest"
OLLAMA_HOST = os.environ.get("OLLAMA_HOST", "http://127.0.0.1:11434")

# Codex portable transit
DEFAULT_CODEX_EXE = transit_dir() / "codex-x86_64-pc-windows-msvc.exe"
SETTINGS_JSON = transit_dir() / "settings.json"
INSTALL_MANIFEST = transit_dir() / "INSTALL_MANIFEST.md"

# Demo asset URL/signature (adjust if you use a different build)
RELEASE_TAG = "rust-v0.34.0"
ASSET_ZIP = "codex-x86_64-pc-windows-msvc.exe.zip"
ASSET_ZIP_SHA256 = "789563e58e6126de96329c8e154718409378831abcef3856c8b46527b20c08ac"
RELEASE_BASE = f"https://github.com/openai/codex/releases/download/{RELEASE_TAG}"
ASSET_URL = f"{RELEASE_BASE}/{ASSET_ZIP}"

logger = logging.getLogger(__name__)

# --------------------------------------------------------------------------------------
# Theme (bright blue desktop variant + high contrast)
# --------------------------------------------------------------------------------------

@dataclass
class Theme:
    desktop_top: str = "#0f58ff"
    desktop_mid: str = "#2f7cff"
    desktop_edge_glow: str = "#70c3ff"

    card_bg: str = "#0e1624"
    card_border: str = "#2B3B4C"
    card_radius: int = 12

    header_bg: str = "#111b2b"
    header_text: str = "#eaf2ff"

    user_bubble: str = "#0d3a84"
    user_text: str = "#eaf2ff"
    ai_bubble: str = "#0f1a2d"
    ai_text: str = "#ffffff"
    think_text: str = "#6fb2b2"
    model_name: str = "#00a7a7"

    accent: str = "#1E5AFF"
    accent_hover: str = "#2f72ff"
    muted: str = "#1c2a3b"

    live_ok: str = "#00d17a"    # green
    live_warn: str = "#ffb300"  # yellow
    live_err: str = "#ff3b30"   # red

    @classmethod
    def load(cls, path: str | Path) -> "Theme":
        p = Path(path)
        if p.is_file():
            try:
                data = json.loads(p.read_text(encoding="utf-8"))
                base = cls()
                for k, v in data.items():
                    if hasattr(base, k):
                        setattr(base, k, v)
                return base
            except Exception:
                return cls()
        return cls()

# --------------------------------------------------------------------------------------
# Live pill + small LED
# --------------------------------------------------------------------------------------

class LivePill(QFrame):
    def __init__(self, theme: Theme, parent: Optional[QWidget] = None):
        super().__init__(parent)
        self.theme = theme
        self._alpha = 1.0
        self.setFixedHeight(24)
        self._timer = QTimer(self)
        self._timer.timeout.connect(self._tick)
        self._timer.start(40)

    def _tick(self):
        t = time.time() * 2.0
        self._alpha = 0.6 + 0.4 * (0.5 + 0.5 * math.sin(t))
        self.update()

    def sizeHint(self) -> QSize:
        return QSize(96, 24)

    def paintEvent(self, _e):
        p = QPainter(self); p.setRenderHint(QPainter.Antialiasing, True)
        rect = self.rect().adjusted(0, 0, -1, -1)

        bg = QColor(self.theme.muted); bg.setAlphaF(0.90)
        path = QPainterPath(); path.addRoundedRect(QRectF(rect), 12, 12)
        p.fillPath(path, bg)

        p.setPen(QColor("#bcd5ff"))
        font = p.font(); font.setPointSizeF(9.5); font.setBold(True); p.setFont(font)
        text = "LIVE"
        metrics = p.fontMetrics()
        tw = metrics.horizontalAdvance(text)
        margin = 10
        dot_d = 8
        p.drawText(QRect(margin, 0, tw + 2, rect.height()), Qt.AlignVCenter | Qt.AlignLeft, text)

        dot_x = rect.right() - margin - dot_d
        dot_y = rect.center().y() - dot_d // 2
        live = QColor(self.theme.live_ok)
        live.setAlphaF(self._alpha)
        p.setBrush(live); p.setPen(Qt.NoPen)
        p.drawEllipse(QRect(dot_x, dot_y, dot_d, dot_d))

class BridgeLED(QWidget):
    def __init__(self, theme: Theme, tooltip: str = "Bridge", parent: Optional[QWidget] = None):
        super().__init__(parent)
        self.theme = theme
        self._state = "red"  # red -> error/off, yellow -> starting/awaiting, green -> healthy
        self.setToolTip(tooltip)
        self.setFixedSize(14, 14)

    def set_state(self, state: str):
        self._state = state
        self.update()

    def paintEvent(self, _):
        p = QPainter(self); p.setRenderHint(QPainter.Antialiasing, True)
        rect = self.rect().adjusted(1, 1, -1, -1)
        color = {
            "green": self.theme.live_ok,
            "yellow": self.theme.live_warn,
            "red": self.theme.live_err,
        }.get(self._state, self.theme.live_warn)
        p.setPen(Qt.NoPen)
        p.setBrush(QColor(color))
        p.drawEllipse(rect)


class ToggleSwitch(QCheckBox):
    """High-contrast slider-style checkbox."""

    def __init__(self, theme: Theme, parent: Optional[QWidget] = None):
        super().__init__(parent)
        self.theme = theme
        self.setCursor(Qt.PointingHandCursor)
        self.setTristate(False)
        self.setSizePolicy(QSizePolicy(QSizePolicy.Fixed, QSizePolicy.Fixed))
        self.setAccessibleName("Interpreter automation toggle")

    def sizeHint(self) -> QSize:  # pragma: no cover - Qt provides layout sizing
        return QSize(56, 30)

    def paintEvent(self, event):  # pragma: no cover - visual styling only
        del event
        painter = QPainter(self)
        painter.setRenderHint(QPainter.Antialiasing, True)
        rect = self.rect().adjusted(1, 1, -1, -1)

        radius = rect.height() / 2
        active = self.isChecked()
        enabled = self.isEnabled()

        bg_color = QColor(self.theme.accent if active else self.theme.card_border)
        if not enabled:
            bg_color.setAlphaF(0.4)
        painter.setPen(Qt.NoPen)
        painter.setBrush(bg_color)
        painter.drawRoundedRect(rect, radius, radius)

        knob_diameter = rect.height() - 8
        knob_y = rect.top() + 4
        if active:
            knob_x = rect.right() - knob_diameter - 4
            knob_color = QColor("#ffffff")
        else:
            knob_x = rect.left() + 4
            knob_color = QColor(self.theme.header_text)
            if not enabled:
                knob_color.setAlphaF(0.4)
        painter.setBrush(knob_color)
        painter.drawEllipse(QRectF(knob_x, knob_y, knob_diameter, knob_diameter))

# --------------------------------------------------------------------------------------
# Helpers
# --------------------------------------------------------------------------------------

def run_checked(
    cmd: List[str],
    cwd: Optional[Path] = None,
    env: Optional[Dict[str, str]] = None,
    timeout: Optional[int] = None,
    *,
    task: Optional[Task] = None,
    dataset_root: Optional[Path] = None,
    workspace: Optional[Path] = None,
    cancelled: bool = False,
) -> Tuple[int, str, str]:
    """Execute ``cmd`` and update task bookkeeping when provided."""

    stdout = ""
    stderr = ""
    return_code = 1

    header_logged = False
    if task is not None:
        try:
            command_display = shlex.join(cmd)
        except Exception:
            command_display = " ".join(cmd)
        suffix: List[str] = []
        if cwd:
            try:
                suffix.append(f"cwd={Path(cwd).resolve()}")
            except Exception:
                suffix.append(f"cwd={cwd}")
        header = f"{_utc_iso()} $ {command_display}"
        if suffix:
            header += f" ({', '.join(suffix)})"
        try:
            append_run_log(task, header, dataset_root, channel="action")
            header_logged = True
        except Exception as exc:
            log_exception("Task run-log header failed", exc)

    try:
        blocked = False
        try:
            safety_manager.ensure_command_allowed(cmd)
        except SafetyViolation as exc:
            blocked = True
            stderr = str(exc)

        if not blocked:
            try:
                cp = subprocess.run(
                    cmd,
                    cwd=str(cwd) if cwd else None,
                    env=env,
                    capture_output=True,
                    text=True,
                    timeout=timeout,
                )
                return_code = cp.returncode
                stdout = cp.stdout or ""
                stderr = cp.stderr or ""
            except Exception as exc:
                stderr = str(exc)
                log_exception("run_checked execution failed", exc)
    finally:
        if task is not None:
            try:
                if stdout or stderr:
                    append_run_output(
                        task,
                        stdout=stdout,
                        stderr=stderr,
                        dataset_root=dataset_root,
                    )
                if header_logged or stdout or stderr:
                    append_run_log(
                        task,
                        f"{_utc_iso()} exit {return_code}",
                        dataset_root,
                        channel="action",
                    )
            except Exception as log_exc:
                log_exception("Task run-log update failed", log_exc)

            workspace_path: Path
            try:
                if workspace is not None:
                    workspace_path = Path(workspace)
                elif cwd is not None:
                    workspace_path = Path(cwd)
                else:
                    workspace_path = Path.cwd()
            except Exception:
                workspace_path = Path.cwd()

            diff_snapshot = None
            try:
                diff_snapshot = record_diff(task.id, workspace_root=workspace_path)
            except Exception as diff_exc:
                log_exception("Task diff capture failed", diff_exc)

            next_status: Optional[str] = None
            if cancelled:
                next_status = "cancelled"
            elif return_code == 0:
                if diff_snapshot and (diff_snapshot.added > 0 or diff_snapshot.removed > 0):
                    next_status = "merged"
            else:
                next_status = "failed"

            if next_status:
                now = datetime.now(UTC).timestamp()
                source = task.source or "terminal"
                try:
                    updated_task = update_task(task.id, status=next_status, updated_ts=now)
                    event_payload: Dict[str, Any] = {
                        "exit_code": return_code,
                        "diff_added": updated_task.diffs.added,
                        "diff_removed": updated_task.diffs.removed,
                        "cancelled": bool(cancelled),
                    }
                    append_event(
                        TaskEvent(
                            ts=now,
                            task_id=task.id,
                            event="status",
                            by=source,
                            to=next_status,
                            data=event_payload,
                        )
                    )
                except Exception as status_exc:
                    log_exception("Task status auto-update failed", status_exc)
                else:
                    publish("task.status", {"id": updated_task.id, "status": updated_task.status})
                    publish("task.updated", updated_task.to_dict())

    return return_code, stdout, stderr

def slug(s: str) -> str:
    t = re.sub(r"[^A-Za-z0-9_.-]+", "-", s.strip())
    t = re.sub(r"-{2,}", "-", t).strip("-")
    return t or f"item-{uuid.uuid4().hex[:8]}"

# --------------------------------------------------------------------------------------
# Ollama client (local only)
# --------------------------------------------------------------------------------------

class OllamaClient:
    def __init__(self, host: str = OLLAMA_HOST):
        self.host = host.rstrip("/")

    def _http(self) -> bool:
        return requests is not None

    def health(self) -> Tuple[bool, str]:
        if not self._http():
            return False, "requests not installed"
        try:
            r = requests.get(self.host, timeout=3)
            return (r.ok, "OK" if r.ok else f"{r.status_code}")
        except Exception as e:
            return False, str(e)

    def list_models(self) -> Tuple[bool, List[str], str]:
        if self._http():
            try:
                r = requests.get(f"{self.host}/api/tags", timeout=5)
                if r.ok:
                    data = r.json()
                    names = [m.get("name") or m.get("model") for m in data.get("models", []) if m.get("name") or m.get("model")]
                    return True, sorted(set(n for n in names if n)), ""
            except Exception:
                pass
        rc, out, err = run_checked(["ollama", "list"])
        if rc != 0:
            return False, [], err or out or "Ollama Not found"
        try:
            lines = [ln.strip().split()[0] for ln in out.splitlines()[1:] if ln.strip()]
            return True, sorted(set(lines)), ""
        except Exception:
            return True, [], ""

    def embeddings(self, model: str, text: str) -> Tuple[bool, List[float], str]:
        if not self._http():
            return False, [], "requests not installed"
        try:
            payload = {"model": model, "input": text}
            r = requests.post(f"{self.host}/api/embeddings", json=payload, timeout=120)
            if not r.ok:
                return False, [], f"{r.status_code} {r.text[:200]}"
            obj = r.json()
            vec = obj.get("embedding") or (obj.get("data") or [{}])[0].get("embedding")
            if not isinstance(vec, list):
                return False, [], "bad embedding response"
            return True, vec, ""
        except Exception as e:
            return False, [], str(e)

    def chat(self, model: str, messages: List[Dict[str, Any]], images: Optional[List[str]] = None) -> Tuple[bool, str, str]:
        if not self._http():
            return False, "", "requests not installed"
        try:
            body: Dict[str, Any] = {"model": model, "messages": messages, "stream": False}
            if images:
                for msg in reversed(messages):
                    if msg.get("role") == "user":
                        msg["images"] = images
                        break
            r = requests.post(f"{self.host}/api/chat", json=body, timeout=600, headers={"Content-Type": "application/json"})
            if not r.ok:
                return False, "", f"{r.status_code} {r.text[:200]}"
            try:
                data = r.json()
            except Exception:
                txt = r.text.strip()
                last = txt.splitlines()[-1] if txt else "{}"
                data = json.loads(last)
            content = (data.get("message") or {}).get("content", "") or data.get("response", "")
            return True, content, ""
        except Exception as e:
            return False, "", str(e)

# --------------------------------------------------------------------------------------
# Lexicons (minimal)
# --------------------------------------------------------------------------------------

DEFAULT_LEXICONS: Dict[str, Dict[str, Any]] = {
    "lang/markdown": {"type": "language", "name": "markdown",
                      "snippets": [{"label": "image", "pattern": "![alt](path.png)"}],
                      "keywords": ["# ", "```", "[", "]", "(", ")"]},
    "shells/cmd": {"type": "shell", "name": "cmd",
                   "snippets": [{"label": "dir", "pattern": "dir"}],
                   "keywords": ["dir", "cd", "copy", "del"]},
}

class LexiconManager:
    def __init__(self, folder: Path):
        self.folder = folder
        self.data: Dict[str, Dict[str, Any]] = {}
        self.enabled: Dict[str, bool] = {}
        self.reload()

    def reload(self):
        self.data.clear()
        self.enabled.clear()
        for key, val in DEFAULT_LEXICONS.items():
            self.data[key] = val
            self.enabled[key] = True
        if self.folder.is_dir():
            for p in self.folder.glob("*.json"):
                try:
                    obj = json.loads(p.read_text(encoding="utf-8"))
                    if isinstance(obj, dict):
                        key = obj.get("id") or p.stem
                        self.data[key] = obj
                        self.enabled[key] = True
                except Exception:
                    continue

    def toggle(self, key: str, state: bool):
        if key in self.data:
            self.enabled[key] = state

    def list_keys(self) -> List[str]:
        return sorted(self.data.keys())

    def active_items(self) -> Dict[str, Dict[str, Any]]:
        return {k: v for k, v in self.data.items() if self.enabled.get(k, True)}

    def auto_tags(self, text: str) -> List[str]:
        tags: List[str] = []
        for key, node in self.active_items().items():
            kws = node.get("keywords") or []
            for kw in kws:
                if kw and kw.lower() in text.lower():
                    tags.append(key)
                    break
        return tags

# --------------------------------------------------------------------------------------
# Dataset + conversation persistence + user memory
# --------------------------------------------------------------------------------------

def cosine(a: List[float], b: List[float]) -> float:
    if not a or not b or len(a) != len(b): return 0.0
    num = sum(x*y for x, y in zip(a, b))
    da = math.sqrt(sum(x*x for x in a)); db = math.sqrt(sum(y*y for y in b))
    if da == 0 or db == 0: return 0.0
    return num / (da * db)

class DatasetManager:
    def __init__(self, session_dir: Path, embedder: str, ollama: OllamaClient, data_root: Optional[Path] = None, enable_semantic: bool = True):
        self.session_dir = ensure_dir(session_dir)
        self.dataset_path = self.session_dir / "dataset.jsonl"
        self.embedder = embedder
        self.ollama = ollama
        self.lock = threading.Lock()
        self.enable_semantic = enable_semantic
        self.data_root = ensure_dir(data_root) if data_root else self.session_dir.parent

    def add_entry(self, role: str, text: str, images: List[Path], tags: Optional[List[str]] = None, extra: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        entry: Dict[str, Any] = {
            "id": uuid.uuid4().hex, "ts": time.time(),
            "role": role, "text": text, "images": [ip.name for ip in images], "tags": tags or [], "embedding": [],
        }
        if extra: entry.update(extra)
        if self.enable_semantic and text.strip():
            ok, vec, _ = self.ollama.embeddings(self.embedder, text)
            if ok and isinstance(vec, list): entry["embedding"] = vec
        with self.lock:
            with self.dataset_path.open("a", encoding="utf-8") as f:
                f.write(json.dumps(entry, ensure_ascii=False) + "\n")
        return entry

    def _all_dataset_files(self) -> List[Path]:
        files: List[Path] = []
        for p in self.data_root.rglob("dataset.jsonl"):
            files.append(p)
        if self.dataset_path not in files and self.dataset_path.exists():
            files.append(self.dataset_path)
        return files

    def retrieve(self, query: str, k: int = 5) -> List[Dict[str, Any]]:
        if not self.enable_semantic:
            return []
        ok, qvec, _ = self.ollama.embeddings(self.embedder, query)
        if not ok: return []
        rows: List[Dict[str, Any]] = []
        for fp in self._all_dataset_files():
            try:
                with fp.open("r", encoding="utf-8") as f:
                    for ln in f:
                        rows.append(json.loads(ln))
            except Exception:
                continue
        scored = []
        for obj in rows:
            vec = obj.get("embedding") or []
            sc = cosine(qvec, vec) if isinstance(vec, list) and vec else 0.0
            scored.append((sc, obj))
        scored.sort(key=lambda t: t[0], reverse=True)
        return [o for _, o in scored[:k]]

@dataclass(slots=True)
class ConversationPaths:
    identifier: str
    root: Path
    jsonl_path: Path
    markdown_path: Path
    source: str
    meta_path: Optional[Path] = None


class ConversationIO:
    _DEFAULT_MAX_ENTRIES = 1_000
    _DEFAULT_MAX_BYTES = 1_048_576  # 1 MiB

    def __init__(
        self,
        session_dir: Path,
        embedder: str,
        ollama: OllamaClient,
        enable_embeddings: bool,
        *,
        session_token: Optional[str] = None,
        archive_root: Optional[Path] = None,
        max_entries: int = _DEFAULT_MAX_ENTRIES,
        max_bytes: int = _DEFAULT_MAX_BYTES,
    ):
        self.session_dir = ensure_dir(session_dir)
        self.md_path = self.session_dir / "conversation.md"
        self.jsonl_path = self.session_dir / "conversation.jsonl"
        self.vec_path = self.session_dir / "conversation.vec"
        self.session_meta_path = self.session_dir / "session.meta.json"
        self.embedder = embedder
        self.ollama = ollama
        self.enable_embeddings = enable_embeddings
        self.lock = threading.RLock()
        self.session_token = session_token or ""
        target_archive_root = archive_root or agent_archives_dir()
        self.archive_root = ensure_dir(target_archive_root)
        self.repo_archive_root = ensure_dir(here() / "Archived Conversations")
        self.max_entries = max(0, int(max_entries))
        self.max_bytes = max(0, int(max_bytes))
        self._entry_count = 0

        self._ensure_archive_placeholder(self.archive_root)
        self._ensure_archive_placeholder(self.repo_archive_root)
        self._prepare_session()

    def _prepare_session(self) -> None:
        stored_token = self._read_session_token()
        with self.lock:
            if stored_token and self.session_token and stored_token != self.session_token:
                self._archive_current_logs_locked("session-rollover", stored_token)
            elif not stored_token and self.session_token and self._has_existing_logs_locked():
                self._archive_current_logs_locked("session-rollover", None)

            if self.session_token:
                self._write_session_token_locked(self.session_token)
            elif stored_token:
                self.session_token = stored_token

            self._ensure_header_locked()
            self._entry_count = self._count_entries_locked()

    def _ensure_archive_placeholder(self, root: Path) -> None:
        gitkeep = root / ".gitkeep"
        if not gitkeep.exists():
            gitkeep.write_text("", encoding="utf-8")

    def _mirror_archive_to_repo(self, archive_dir: Path) -> None:
        try:
            mirror_dir = ensure_dir(self.repo_archive_root / archive_dir.name)
        except Exception:
            logger.exception("Failed to prepare archive mirror directory")
            return

        for item in archive_dir.iterdir():
            if not item.is_file():
                continue
            dest = mirror_dir / item.name
            try:
                shutil.copy2(item, dest)
            except Exception:
                logger.exception("Failed to mirror archive file %s", item)

    def _write_session_token_locked(self, token: str) -> None:
        data = {"id": token, "updated": datetime.now(UTC).isoformat()}
        with self.session_meta_path.open("w", encoding="utf-8") as fh:
            json.dump(data, fh, ensure_ascii=False, indent=2)

    def _read_session_token(self) -> str:
        if not self.session_meta_path.exists():
            return ""
        try:
            data = json.loads(self.session_meta_path.read_text(encoding="utf-8"))
            token = data.get("id")
            return str(token) if isinstance(token, str) else ""
        except Exception:
            return ""

    def _has_existing_logs_locked(self) -> bool:
        for path in (self.md_path, self.jsonl_path, self.vec_path):
            if path.exists() and path.stat().st_size > 0:
                return True
        return False

    def _write_header_unlocked(self) -> None:
        self.md_path.write_text("# Conversation\n\n", encoding="utf-8")

    def _ensure_header_locked(self) -> None:
        if not self.md_path.exists():
            self._write_header_unlocked()

    def _count_entries_locked(self) -> int:
        if not self.jsonl_path.exists():
            return 0
        try:
            with self.jsonl_path.open("r", encoding="utf-8") as fh:
                return sum(1 for _ in fh)
        except Exception:
            return 0

    def _current_log_size_locked(self) -> int:
        size = 0
        for path in (self.md_path, self.jsonl_path, self.vec_path):
            if path.exists():
                try:
                    size += path.stat().st_size
                except OSError:
                    continue
        return size

    def _next_archive_dir_locked(self, base_label: str) -> Path:
        timestamp = datetime.now(UTC).strftime("%Y%m%d-%H%M%S")
        label = slug(base_label or "session")
        candidate = self.archive_root / f"{timestamp}_{label}"
        counter = 1
        while candidate.exists():
            counter += 1
            candidate = self.archive_root / f"{timestamp}_{label}_{counter:02d}"
        candidate.mkdir(parents=True, exist_ok=False)
        return candidate

    def _archive_current_logs_locked(self, reason: str, previous_token: Optional[str]) -> Optional[Path]:
        if not self._has_existing_logs_locked():
            for path in (self.md_path, self.jsonl_path, self.vec_path):
                if path.exists():
                    path.unlink()
            self._entry_count = 0
            return None

        base_label = previous_token or self.session_token or self.session_dir.name
        archive_dir = self._next_archive_dir_locked(base_label)
        metadata = {
            "reason": reason,
            "archived_at": datetime.now(UTC).isoformat(),
            "session_token": previous_token or self.session_token,
            "source": str(self.session_dir),
            "entry_count": self._entry_count,
            "total_bytes": self._current_log_size_locked(),
        }

        for path in (self.md_path, self.jsonl_path, self.vec_path):
            if path.exists():
                shutil.move(str(path), archive_dir / path.name)

        (archive_dir / "meta.json").write_text(json.dumps(metadata, indent=2), encoding="utf-8")
        self._mirror_archive_to_repo(archive_dir)

        self._entry_count = 0
        self._write_header_unlocked()
        return archive_dir

    def _rollover_if_needed_locked(self, reason: str) -> None:
        trigger = False
        if self.max_entries and self._entry_count >= self.max_entries:
            trigger = True
        elif self.max_bytes and self._current_log_size_locked() >= self.max_bytes:
            trigger = True

        if trigger:
            self._archive_current_logs_locked(reason, self.session_token)
            if self.session_token:
                self._write_session_token_locked(self.session_token)

    def _write_header(self):
        with self.lock:
            self._write_header_unlocked()

    def append(
        self,
        role: str,
        text: str,
        images: List[Path],
        *,
        references: Optional[List[Dict[str, str]]] = None,
    ):
        ts = _utc_iso()
        rec: Dict[str, Any] = {"timestamp": ts, "role": role, "text": text}
        if references:
            rec["references"] = references
        with self.lock:
            self._rollover_if_needed_locked("length-threshold")
            self._ensure_header_locked()

            with self.md_path.open("a", encoding="utf-8") as f:
                lab = "User" if role == "user" else ("Assistant" if role == "assistant" else "System")
                f.write(f"\n**{lab}:**\n\n{text}\n\n")
                for ip in images:
                    f.write(f"![image](images/{ip.name})\n")

            with self.jsonl_path.open("a", encoding="utf-8") as jf:
                jf.write(json.dumps(rec, ensure_ascii=False) + "\n")
            self._entry_count += 1

            if self.enable_embeddings and text.strip():
                ok, vec, _ = self.ollama.embeddings(self.embedder, text)
                if ok and isinstance(vec, list):
                    with self.vec_path.open("a", encoding="utf-8") as vf:
                        vf.write(json.dumps(vec) + "\n")

    def retrieve(self, query: str, k: int = 5) -> List[Dict[str, Any]]:
        if not self.enable_embeddings or not self.jsonl_path.exists() or not self.vec_path.exists():
            return []
        ok, qvec, _ = self.ollama.embeddings(self.embedder, query)
        if not ok:
            return []
        entries: List[Tuple[Dict[str, Any], List[float]]] = []
        with self.jsonl_path.open("r", encoding="utf-8") as jf, self.vec_path.open("r", encoding="utf-8") as vf:
            for jline, vline in zip(jf, vf):
                try:
                    rec = json.loads(jline)
                    vec = json.loads(vline)
                    if isinstance(vec, list):
                        entries.append((rec, vec))
                except Exception:
                    continue
        scored = [(cosine(qvec, vec), rec) for rec, vec in entries]
        scored.sort(key=lambda t: t[0], reverse=True)
        return [rec for _, rec in scored[:k]]

    def resolve_conversation(self, identifier: str) -> Optional[ConversationPaths]:
        conv_id = (identifier or "").strip()
        if not conv_id:
            return None
        with self.lock:
            live_token = self.session_token or self._read_session_token()
        if live_token == conv_id:
            return ConversationPaths(
                identifier=conv_id,
                root=self.session_dir,
                jsonl_path=self.jsonl_path,
                markdown_path=self.md_path,
                source="live",
                meta_path=self.session_meta_path if self.session_meta_path.exists() else None,
            )

        slug_id = slug(conv_id)
        try:
            candidates = sorted((p for p in self.archive_root.iterdir() if p.is_dir()), reverse=True)
        except FileNotFoundError:
            return None

        for candidate in candidates:
            meta_path = candidate / "meta.json"
            token = ""
            if meta_path.exists():
                try:
                    meta = json.loads(meta_path.read_text(encoding="utf-8"))
                    raw = meta.get("session_token") or meta.get("session_id") or meta.get("token")
                    if isinstance(raw, str):
                        token = raw.strip()
                except Exception:
                    token = ""
            if token == conv_id or (slug_id and slug_id in candidate.name):
                return ConversationPaths(
                    identifier=conv_id,
                    root=candidate,
                    jsonl_path=candidate / "conversation.jsonl",
                    markdown_path=candidate / "conversation.md",
                    source="archive",
                    meta_path=meta_path if meta_path.exists() else None,
                )
        return None

    def recent(self, k: int = 5) -> List[Dict[str, Any]]:
        if not self.jsonl_path.exists() or k <= 0:
            return []
        from collections import deque
        dq = deque(maxlen=k)
        with self.jsonl_path.open("r", encoding="utf-8") as jf:
            for line in jf:
                dq.append(line)
        recs: List[Dict[str, Any]] = []
        for line in dq:
            try:
                recs.append(json.loads(line))
            except Exception:
                continue
        return recs

# --------------------------------------------------------------------------------------
# Codex Bootstrap + Bridge (Windows)
# --------------------------------------------------------------------------------------

def sha256_file(p: Path, chunk: int = 1024 * 1024) -> str:
    h = hashlib.sha256()
    with p.open("rb") as f:
        for b in iter(lambda: f.read(chunk), b""):
            h.update(b)
    return h.hexdigest()

DEFAULT_SETTINGS = {
    "default_launch_mode": "bridge",
    "working_folder": str(transit_dir()),
    "model": DEFAULT_CHAT_MODEL,
    "enable_interpreter": False,
    "reference_embed_contents": True,
    "reference_case_sensitive": False,
    "reference_token_guard": True,
    "reference_token_headroom": 80,
    "scan_roots": [],
    "terminal_desktop": {
        "width": 980,
        "height": 620,
        "x": -1,
        "y": -1,
        "icon_size": "medium",
        "sort_mode": "name",
        "icon_positions": {},
        "background": BackgroundConfig().to_state(),
    },
    "sandbox": {
        "level": "restricted",
        "approval_policy": "require_approval",
        "full_auto": False,
        "encryption_enabled": False,
        "access_control_enforced": False,
    },
}


def _merge_settings(defaults: Dict[str, Any], target: Dict[str, Any]) -> Dict[str, Any]:
    for key, value in defaults.items():
        if isinstance(value, dict):
            node = target.get(key)
            if isinstance(node, dict):
                _merge_settings(value, node)
            else:
                target[key] = copy.deepcopy(value)
        elif isinstance(value, list):
            existing = target.get(key)
            if not isinstance(existing, list):
                target[key] = list(value)
        else:
            target.setdefault(key, value)
    return target


def _is_transit_path(candidate: str) -> bool:
    if not candidate:
        return False
    try:
        path = Path(candidate).expanduser().resolve()
    except Exception:
        return False
    targets = [workspace_root() / "Terminal Desktop"] + _legacy_transit_candidates()
    for target in targets:
        try:
            if path == target.expanduser().resolve():
                return True
        except Exception:
            pass
        if str(path) == str(target):
            return True
    return False


def _normalize_scan_roots(raw: Any) -> List[str]:
    roots: List[str] = []
    if isinstance(raw, (list, tuple)):
        seen: Set[str] = set()
        for entry in raw:
            if not entry:
                continue
            try:
                normalized = str(Path(entry).expanduser().resolve())
            except Exception:
                normalized = str(entry)
            if normalized in seen:
                continue
            seen.add(normalized)
            roots.append(normalized)
    return roots


def load_codex_settings() -> dict:
    workspace = str(transit_dir())
    if SETTINGS_JSON.exists():
        migrated = False
        try:
            obj = json.loads(SETTINGS_JSON.read_text(encoding="utf-8"))
            if isinstance(obj, dict):
                if "enable_interpreter" not in obj and "codex_auto_continue" in obj:
                    obj["enable_interpreter"] = bool(obj.get("codex_auto_continue", False))
                obj.pop("codex_auto_continue", None)

                raw_wf = str(obj.get("working_folder") or "").strip()
                if not raw_wf or _is_transit_path(raw_wf):
                    obj["working_folder"] = workspace
                    migrated = True

                obj["scan_roots"] = _normalize_scan_roots(obj.get("scan_roots"))

                merged = _merge_settings(DEFAULT_SETTINGS, obj)
                if migrated:
                    SETTINGS_JSON.write_text(json.dumps(merged, indent=2), encoding="utf-8")
                return merged
        except Exception:
            pass
    DEFAULT_SETTINGS["working_folder"] = workspace
    DEFAULT_SETTINGS["scan_roots"] = []
    SETTINGS_JSON.write_text(json.dumps(DEFAULT_SETTINGS, indent=2), encoding="utf-8")
    return copy.deepcopy(DEFAULT_SETTINGS)

def save_codex_settings(d: dict) -> None:
    payload = dict(d)
    payload["scan_roots"] = _normalize_scan_roots(payload.get("scan_roots"))
    SETTINGS_JSON.write_text(json.dumps(payload, indent=2), encoding="utf-8")

_READY_PATTERNS = [
    r"You are using OpenAI Codex",
    r"/status\s+-\s+show current session configuration",
    r"Ctrl\+J newline",
]
def codex_ready_banner(text: str) -> bool:
    if not text: return False
    for pat in _READY_PATTERNS:
        if re.search(pat, text, re.IGNORECASE):
            return True
    return False

# ---- Windows console helpers ----
if is_windows():
    from ctypes import wintypes

    kernel32 = ctypes.WinDLL("kernel32", use_last_error=True)
    user32 = ctypes.WinDLL("user32", use_last_error=True)

    # Find visible console window for PID (best-effort)
    GetWindowThreadProcessId = user32.GetWindowThreadProcessId
    GetWindowThreadProcessId.argtypes = [wintypes.HWND, ctypes.POINTER(wintypes.DWORD)]
    GetWindowThreadProcessId.restype  = wintypes.DWORD
    EnumWindows = user32.EnumWindows
    EnumWindows.argtypes = [ctypes.WINFUNCTYPE(wintypes.BOOL, wintypes.HWND, wintypes.LPARAM), wintypes.LPARAM]
    EnumWindows.restype  = wintypes.BOOL
    IsWindowVisible = user32.IsWindowVisible
    IsWindowVisible.argtypes = [wintypes.HWND]
    IsWindowVisible.restype  = wintypes.BOOL
    ShowWindow = user32.ShowWindow
    ShowWindow.argtypes = [wintypes.HWND, ctypes.c_int]
    SetForegroundWindow = user32.SetForegroundWindow
    SetForegroundWindow.argtypes = [wintypes.HWND]
    GetForegroundWindow = user32.GetForegroundWindow
    GetForegroundWindow.restype = wintypes.HWND
    GetWindowThreadProcessId.restype = wintypes.DWORD
    AttachThreadInput = user32.AttachThreadInput
    AttachThreadInput.argtypes = [wintypes.DWORD, wintypes.DWORD, wintypes.BOOL]
    GetCurrentThreadId = kernel32.GetCurrentThreadId

    SW_MINIMIZE, SW_RESTORE = 6, 9

    # Console attach/io
    ATTACH_PARENT_PROCESS = ctypes.c_uint(-1).value
    AttachConsole = kernel32.AttachConsole
    AttachConsole.argtypes = [wintypes.DWORD]
    FreeConsole = kernel32.FreeConsole
    FreeConsole.argtypes = []

    CreateFileW = kernel32.CreateFileW
    CreateFileW.argtypes = [wintypes.LPCWSTR, wintypes.DWORD, wintypes.DWORD, wintypes.LPVOID, wintypes.DWORD, wintypes.DWORD, wintypes.HANDLE]
    CreateFileW.restype  = wintypes.HANDLE

    GENERIC_READ, GENERIC_WRITE = 0x80000000, 0x40000000
    FILE_SHARE_READ, FILE_SHARE_WRITE = 0x1, 0x2
    OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL = 3, 0x80
    INVALID_HANDLE_VALUE = wintypes.HANDLE(-1).value

    class COORD(ctypes.Structure):
        _fields_ = [("X", wintypes.SHORT), ("Y", wintypes.SHORT)]
    class SMALL_RECT(ctypes.Structure):
        _fields_ = [("Left", wintypes.SHORT), ("Top", wintypes.SHORT), ("Right", wintypes.SHORT), ("Bottom", wintypes.SHORT)]
    class CONSOLE_SCREEN_BUFFER_INFO(ctypes.Structure):
        _fields_ = [("dwSize", COORD), ("dwCursorPosition", COORD), ("wAttributes", wintypes.WORD), ("srWindow", SMALL_RECT), ("dwMaximumWindowSize", COORD)]
    GetConsoleScreenBufferInfo = kernel32.GetConsoleScreenBufferInfo
    GetConsoleScreenBufferInfo.argtypes = [wintypes.HANDLE, ctypes.POINTER(CONSOLE_SCREEN_BUFFER_INFO)]
    ReadConsoleOutputCharacterW = kernel32.ReadConsoleOutputCharacterW
    ReadConsoleOutputCharacterW.argtypes = [wintypes.HANDLE, wintypes.LPWSTR, wintypes.DWORD, COORD, ctypes.POINTER(wintypes.DWORD)]
    CloseHandle = kernel32.CloseHandle

    KEY_EVENT = 0x0001
    VK_RETURN = 0x0D
    ENABLE_MOUSE_INPUT = 0x0010
    ENABLE_QUICK_EDIT_MODE = 0x0040
    ENABLE_EXTENDED_FLAGS = 0x0080
    GetConsoleMode = kernel32.GetConsoleMode
    GetConsoleMode.argtypes = [wintypes.HANDLE, ctypes.POINTER(wintypes.DWORD)]
    SetConsoleMode = kernel32.SetConsoleMode
    SetConsoleMode.argtypes = [wintypes.HANDLE, wintypes.DWORD]

    class _CHAR_UNION(ctypes.Union):
        _fields_ = [("UnicodeChar", wintypes.WCHAR)]
    class KEY_EVENT_RECORD(ctypes.Structure):
        _fields_ = [("bKeyDown", wintypes.BOOL), ("wRepeatCount", wintypes.WORD),
                    ("wVirtualKeyCode", wintypes.WORD), ("wVirtualScanCode", wintypes.WORD),
                    ("uChar", _CHAR_UNION), ("dwControlKeyState", wintypes.DWORD)]
    class _EVENT_UNION(ctypes.Union):
        _fields_ = [("KeyEvent", KEY_EVENT_RECORD)]
    class INPUT_RECORD(ctypes.Structure):
        _fields_ = [("EventType", wintypes.WORD), ("Event", _EVENT_UNION)]
    WriteConsoleInputW = kernel32.WriteConsoleInputW
    WriteConsoleInputW.argtypes = [wintypes.HANDLE, ctypes.POINTER(INPUT_RECORD), wintypes.DWORD, ctypes.POINTER(wintypes.DWORD)]

    # SendInput fallback (foreground)
    class KEYBDINPUT(ctypes.Structure):
        _fields_ = [("wVk", wintypes.WORD), ("wScan", wintypes.WORD), ("dwFlags", wintypes.DWORD), ("time", wintypes.DWORD), ("dwExtraInfo", ctypes.c_void_p)]
    class MOUSEINPUT(ctypes.Structure):
        _fields_ = [("dx", wintypes.LONG), ("dy", wintypes.LONG), ("mouseData", wintypes.DWORD), ("dwFlags", wintypes.DWORD), ("time", wintypes.DWORD), ("dwExtraInfo", ctypes.c_void_p)]
    class HARDWAREINPUT(ctypes.Structure):
        _fields_ = [("uMsg", wintypes.DWORD), ("wParamL", wintypes.WORD), ("wParamH", wintypes.WORD)]
    class INPUT(ctypes.Structure):
        _fields_ = [("type", wintypes.DWORD), ("ki", KEYBDINPUT)]
    SendInput = user32.SendInput
    SendInput.argtypes = [wintypes.UINT, ctypes.POINTER(INPUT), ctypes.c_int]
    INPUT_KEYBOARD = 1
    KEYEVENTF_KEYUP = 0x0002

    def _sendinput_vk(vk: int):
        arr = (INPUT * 2)(
            INPUT(INPUT_KEYBOARD, KEYBDINPUT(vk, 0, 0, 0, None)),
            INPUT(INPUT_KEYBOARD, KEYBDINPUT(vk, 0, KEYEVENTF_KEYUP, 0, None)),
        )
        SendInput(2, arr, ctypes.sizeof(INPUT))

    def _find_hwnd_by_pid(pid: int) -> int:
        res = {"hwnd": 0}
        @ctypes.WINFUNCTYPE(wintypes.BOOL, wintypes.HWND, wintypes.LPARAM)
        def cb(hwnd, _):
            if not IsWindowVisible(hwnd): return True
            p = wintypes.DWORD(0)
            GetWindowThreadProcessId(hwnd, ctypes.byref(p))
            if int(p.value) == int(pid):
                res["hwnd"] = hwnd
                return False
            return True
        EnumWindows(cb, 0)
        return int(res["hwnd"])

    def _attach(pid: int) -> bool:
        FreeConsole()
        if AttachConsole(int(pid)):
            return True
        time.sleep(0.05)
        return bool(AttachConsole(int(pid)))

    def _open_conout_read() -> int:
        return CreateFileW("CONOUT$", GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, None, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, None)

    def _open_conin_write() -> int:
        return CreateFileW("CONIN$", GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, None, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, None)

    def read_console_snapshot(pid: int) -> str:
        if not _attach(pid): return ""
        try:
            h = _open_conout_read()
            if int(h) == INVALID_HANDLE_VALUE: return ""
            try:
                csbi = CONSOLE_SCREEN_BUFFER_INFO()
                if not GetConsoleScreenBufferInfo(h, ctypes.byref(csbi)): return ""
                width, height = int(csbi.dwSize.X), int(csbi.dwSize.Y)
                buf = []
                for y in range(height):
                    coord = COORD(0, y)
                    count = ctypes.wintypes.DWORD(0)
                    tmp = ctypes.create_unicode_buffer(width)
                    ok = ReadConsoleOutputCharacterW(h, tmp, width, coord, ctypes.byref(count))
                    if not ok: break
                    s = tmp.value.rstrip("\x00").rstrip()
                    if s:
                        buf.append(s)
                return ("\n".join(buf).rstrip() + "\n")
            finally:
                CloseHandle(h)
        finally:
            FreeConsole()

    def _records_for_text_only(text: str) -> list[INPUT_RECORD]:
        recs: list[INPUT_RECORD] = []
        def push_char(ch: str):
            # Try to include proper VK for letters/numbers? For simplicity, rely on UnicodeChar.
            ke_down = KEY_EVENT_RECORD(True, 1, ord(ch.upper()) if ch.isalpha() else 0, 0, _CHAR_UNION(ch), 0)
            ke_up   = KEY_EVENT_RECORD(False,1, ord(ch.upper()) if ch.isalpha() else 0, 0, _CHAR_UNION(ch), 0)
            r1 = INPUT_RECORD(KEY_EVENT, _EVENT_UNION()); r1.Event.KeyEvent = ke_down
            r2 = INPUT_RECORD(KEY_EVENT, _EVENT_UNION()); r2.Event.KeyEvent = ke_up
            recs.append(r1); recs.append(r2)
        for ch in text:
            push_char(ch)
        return recs

    def _records_for_enter() -> list[INPUT_RECORD]:
        down = KEY_EVENT_RECORD(True, 1, VK_RETURN, 0, _CHAR_UNION('\r'), 0)
        up   = KEY_EVENT_RECORD(False,1, VK_RETURN, 0, _CHAR_UNION('\r'), 0)
        r1 = INPUT_RECORD(KEY_EVENT, _EVENT_UNION()); r1.Event.KeyEvent = down
        r2 = INPUT_RECORD(KEY_EVENT, _EVENT_UNION()); r2.Event.KeyEvent = up
        return [r1, r2]

    def write_console_input_text(pid: int, text: str) -> bool:
        if not _attach(pid): return False
        try:
            h = _open_conin_write()
            if int(h) == INVALID_HANDLE_VALUE: return False
            try:
                mode = ctypes.wintypes.DWORD(0)
                if GetConsoleMode(h, ctypes.byref(mode)):
                    new_mode = mode.value
                    new_mode &= ~(ENABLE_QUICK_EDIT_MODE | ENABLE_MOUSE_INPUT)
                    new_mode |= ENABLE_EXTENDED_FLAGS
                    SetConsoleMode(h, new_mode)
                recs = _records_for_text_only(text)
                if not recs: return True
                arr = (INPUT_RECORD * len(recs))(*recs)
                written = ctypes.wintypes.DWORD(0)
                ok = WriteConsoleInputW(h, arr, len(recs), ctypes.byref(written))
                return bool(ok) and written.value == len(recs)
            finally:
                CloseHandle(h)
        finally:
            FreeConsole()

    def write_console_input_enter(pid: int) -> bool:
        if not _attach(pid): return False
        try:
            h = _open_conin_write()
            if int(h) == INVALID_HANDLE_VALUE: return False
            try:
                mode = ctypes.wintypes.DWORD(0)
                if GetConsoleMode(h, ctypes.byref(mode)):
                    new_mode = mode.value
                    new_mode &= ~(ENABLE_QUICK_EDIT_MODE | ENABLE_MOUSE_INPUT)
                    new_mode |= ENABLE_EXTENDED_FLAGS
                    SetConsoleMode(h, new_mode)
                recs = _records_for_enter()
                arr = (INPUT_RECORD * len(recs))(*recs)
                written = ctypes.wintypes.DWORD(0)
                ok = WriteConsoleInputW(h, arr, len(recs), ctypes.byref(written))
                return bool(ok) and written.value == len(recs)
            finally:
                CloseHandle(h)
        finally:
            FreeConsole()

    def foreground_enter_fallback(hwnd_cmd: int, hwnd_restore: int):
        """Briefly foreground CMD, send Enter, then restore focus."""
        if not hwnd_cmd:
            return
        tid_cmd = user32.GetWindowThreadProcessId(hwnd_cmd, None)
        cur_tid = GetCurrentThreadId()
        AttachThreadInput(cur_tid, tid_cmd, True)
        try:
            ShowWindow(hwnd_cmd, SW_RESTORE)
            SetForegroundWindow(hwnd_cmd)
            time.sleep(0.02)
            _sendinput_vk(VK_RETURN)
            time.sleep(0.02)
            if hwnd_restore:
                SetForegroundWindow(hwnd_restore)
        finally:
            AttachThreadInput(cur_tid, tid_cmd, False)

    def show_window_by_pid(pid: int, how: int):
        hwnd = _find_hwnd_by_pid(pid)
        if hwnd:
            ShowWindow(hwnd, how)
else:
    def read_console_snapshot(pid: int) -> str: return ""
    def write_console_input_text(pid: int, text: str) -> bool: return False
    def write_console_input_enter(pid: int) -> bool: return False
    def foreground_enter_fallback(hwnd_cmd: int, hwnd_restore: int): return
    def show_window_by_pid(pid: int, how: int): return
    def _find_hwnd_by_pid(pid: int) -> int: return 0

class CodexBootstrap:
    def __init__(self, ollama: OllamaClient):
        self.ollama = ollama

    def ensure_ollama(self) -> None:
        ok, _ = self.ollama.health()
        if ok: return
        raise RuntimeError("Ollama not reachable at http://127.0.0.1:11434")

    def download_with_progress(self, url: str, dest: Path, progress_cb=None, chunk: int = 128 * 1024) -> Path:
        from urllib import request
        dest.parent.mkdir(parents=True, exist_ok=True)
        tmp = dest.with_suffix(dest.suffix + ".part")
        req = request.Request(url, headers={"User-Agent": "Mozilla/5.0"})
        with request.urlopen(req, timeout=60) as r, tmp.open("wb") as f:
            total = int(r.headers.get("Content-Length") or 0)
            read = 0
            while True:
                buf = r.read(chunk)
                if not buf: break
                f.write(buf)
                read += len(buf)
                if progress_cb and total:
                    progress_cb(int(read * 100 / total))
        tmp.replace(dest)
        return dest

    def extract_zip(self, zip_path: Path, out_dir: Path) -> Path:
        with zipfile.ZipFile(zip_path, "r") as z:
            z.extractall(out_dir)
        for p in out_dir.iterdir():
            if p.suffix.lower() == ".exe" and "codex" in p.name.lower():
                return p
        raise FileNotFoundError("codex exe not found after extraction")

    def ensure_release(self, progress_cb=None) -> Path:
        if DEFAULT_CODEX_EXE.exists():
            return DEFAULT_CODEX_EXE
        root = transit_dir()
        zip_path = root / ASSET_ZIP
        self.download_with_progress(ASSET_URL, zip_path, progress_cb=progress_cb)
        digest = sha256_file(zip_path)
        if digest.lower() != ASSET_ZIP_SHA256.lower():
            raise RuntimeError("SHA-256 mismatch for downloaded zip.")
        exe = self.extract_zip(zip_path, root)
        return exe

    def codex_version(self, bin_path: Path) -> str:
        try:
            out = subprocess.run([str(bin_path), "--version"], capture_output=True, text=True, timeout=8)
            return (out.stdout or out.stderr or "").strip()
        except Exception as e:
            return f"(version check failed: {e})"

    def write_config_toml(self, model: str) -> Path:
        cfg_dir = Path.home() / ".codex"
        cfg_dir.mkdir(parents=True, exist_ok=True)
        cfg = cfg_dir / "config.toml"
        txt = (
            f'model = "{model}"\n'
            f'model_provider = "ollama"\n\n'
            f'[model_providers.ollama]\n'
            f'name = "Ollama"\n'
            f'base_url = "http://127.0.0.1:11434/v1"\n'
            f'wire_api = "chat"\n'
        )
        cfg.write_text(txt, encoding="utf-8")
        return cfg

    def write_install_manifest(self, selected_model: str, exe_path: Path) -> Path:
        version = self.codex_version(exe_path)
        cfg = self.write_config_toml(selected_model)
        lines = [
            f"# Install Manifest and Integration Guide\n",
            f"**Generated:** {datetime.now().isoformat(sep=' ', timespec='seconds')}\n",
            f"**Transit:** `{transit_dir()}`\n",
            f"**Binary:** `{exe_path}`\n",
            f"**Config:** `{cfg}`\n",
            f"**Codex version:** `{version}`\n",
        ]
        out = INSTALL_MANIFEST
        out.write_text("\n".join(lines), encoding="utf-8")
        return out

    def launch_codex_cmd(self, exe: Path, model: str, cwd: Path) -> subprocess.Popen:
        title = f"CODEX_CMD_{int(time.time())}"
        # Launch a new console window running CMD, then codex
        proc = subprocess.Popen(["cmd", "/k", "title", title, "&&", str(exe), "--model", model],
                                cwd=str(cwd), creationflags=subprocess.CREATE_NEW_CONSOLE)
        return proc

class CodexBridge:
    """Mirrors Codex CMD, injects text and **presses Enter**."""

    def __init__(self, status_append_fn, led_setter_fn, output_append_fn):
        self._pid: Optional[int] = None
        self._running = False
        self._stop_evt = threading.Event()
        self._busy_evt = threading.Event()
        self._last_hash = ""
        self._last_snapshot = ""
        self._last_injected: Optional[str] = None
        self._status = status_append_fn       # callable(str)
        self._set_led = led_setter_fn         # callable(str)
        self._output = output_append_fn       # callable(str)
        self._ready_seen = False

    @property
    def pid(self) -> Optional[int]: return self._pid
    def running(self) -> bool: return self._running

    def attach(self, pid: int):
        self._pid = int(pid)

    def start(self):
        if not self._pid: return
        self._stop_evt.clear()
        self._running = True
        self._set_led("yellow")
        threading.Thread(target=self._idle_loop, daemon=True).start()

    def stop(self):
        self._stop_evt.set()
        self._running = False
        self._set_led("red")
        self._last_injected = None

    def show(self): 
        if self._pid: show_window_by_pid(self._pid, SW_RESTORE if is_windows() else 9)
    def hide(self): 
        if self._pid: show_window_by_pid(self._pid, SW_MINIMIZE if is_windows() else 6)

    # --- text then Enter (two steps) ---
    def send_text(self, text: str) -> bool:
        if not self._pid: return False
        ok = write_console_input_text(self._pid, text)
        if ok:
            self._busy_evt.set()
            self._last_injected = text
            self._status("[Codex] Text injected.")
        else:
            self._last_injected = None
            self._status("[Codex] Text injection failed.")
            self._set_led("red")
        return ok

    def press_enter_async(self, hwnd_ui: int):
        if not self._pid: return
        threading.Thread(target=self._press_enter_sequence, args=(hwnd_ui,), daemon=True).start()

    def busy(self) -> bool:
        return self._busy_evt.is_set()

    def _press_enter_sequence(self, hwnd_ui: int):
        # Try primary (console input)
        ok = write_console_input_enter(self._pid)
        if not ok:
            # Fallback: brief foreground hop
            hwnd_cmd = _find_hwnd_by_pid(self._pid) if is_windows() else 0
            foreground_enter_fallback(hwnd_cmd, hwnd_ui)
        self._status("[Codex] Enter sent.")
        threading.Thread(target=self._settle_loop, daemon=True).start()

    # --- loops ---
    def _idle_loop(self):
        while not self._stop_evt.is_set():
            if self._busy_evt.is_set():
                time.sleep(0.2); continue
            snap = read_console_snapshot(self._pid)
            if snap:
                if snap != self._last_snapshot:
                    old_lines = self._last_snapshot.splitlines()
                    new_lines = snap.splitlines()
                    if len(new_lines) > len(old_lines):
                        delta = "\n".join(new_lines[len(old_lines):])
                        if delta:
                            if self._last_injected:
                                injected = self._last_injected.strip().lower()
                                if delta.strip().lower() == injected:
                                    self._last_injected = None
                                    delta = ""
                            if delta:
                                self._output(delta)
                                self._last_injected = None
                    self._last_snapshot = snap
                digest = hashlib.sha256(snap.encode("utf-8", "replace")).hexdigest()
                if digest != self._last_hash:
                    self._last_hash = digest
                    if codex_ready_banner(snap) and not self._ready_seen:
                        self._ready_seen = True
                        self._set_led("green")
                        self._status("[Codex] Ready.")
            time.sleep(0.9)

    def _settle_loop(self):
        last = ""
        last_change = time.time()
        while not self._stop_evt.is_set():
            snap = read_console_snapshot(self._pid)
            if snap != last:
                last = snap; last_change = time.time()
            if time.time() - last_change > 1.2:
                self._busy_evt.clear()
                if codex_ready_banner(last):
                    self._set_led("green")
                return
            time.sleep(0.16)

# --------------------------------------------------------------------------------------
# Settings dialog (models + codex quick defaults)
# --------------------------------------------------------------------------------------

class SettingsDialog(QDialog):
    def __init__(self, theme: Theme, parent: Optional[QWidget], ollama: OllamaClient, lex_mgr: LexiconManager):
        super().__init__(parent)
        self.setWindowTitle("Settings")
        self.setModal(True)
        self.resize(920, 680)
        self.theme = theme
        self.ollama = ollama
        self.lex_mgr = lex_mgr

        layout = QVBoxLayout(self)

        # Models
        models_box = QGroupBox("Models (Local Ollama only)")
        self.chat_model = QComboBox(models_box)
        self.vision_ocr_model = QComboBox(models_box)
        self.vision_model = QComboBox(models_box)
        self.embed_model = QComboBox(models_box)
        self.context_pairs = QSlider(Qt.Horizontal, models_box)
        self.context_pairs.setMinimum(1); self.context_pairs.setMaximum(100); self.context_pairs.setValue(25)
        self.context_val = QLabel("25", models_box)
        self.share_context = QCheckBox("Share conversation context", models_box)
        self.share_limit = QSpinBox(models_box); self.share_limit.setRange(1, 50); self.share_limit.setValue(5)
        self.enable_embeddings = QCheckBox("Enable embeddings", models_box)
        self.enable_vision = QCheckBox("Enable vision (OCR + summary)", models_box)
        mform = QFormLayout(models_box)
        mform.addRow("Chat", self.chat_model)
        mform.addRow("Vision-OCR (markdown)", self.vision_ocr_model)
        mform.addRow("Vision (creative)", self.vision_model)
        mform.addRow("Embeddings", self.embed_model)
        mform.addRow("History depth", self.context_pairs)
        mform.addRow("", self.context_val)
        mform.addRow(self.share_context)
        mform.addRow("Context limit", self.share_limit)
        mform.addRow(self.enable_embeddings)
        mform.addRow(self.enable_vision)

        # Shells
        shells_box = QGroupBox("Shells")
        self.chk_cmd = QCheckBox("CMD", shells_box)
        self.chk_powershell = QCheckBox("PowerShell", shells_box)
        self.chk_bash = QCheckBox("Bash", shells_box)
        self.chk_zsh = QCheckBox("Zsh", shells_box)
        self.chk_wsl = QCheckBox("WSL Ubuntu", shells_box)
        slyt = QVBoxLayout(shells_box)
        for w in (self.chk_cmd, self.chk_powershell, self.chk_bash, self.chk_zsh, self.chk_wsl):
            slyt.addWidget(w)

        # Data
        data_box = QGroupBox("Data")
        self.data_root_edit = QLineEdit(str(agent_data_dir()), data_box)
        self.data_root_btn = QPushButton("Browse…", data_box)
        dform = QFormLayout(data_box)
        dform.addRow("Data Root", self._row(self.data_root_edit, self.data_root_btn))

        def _browse_data_root():
            p = QFileDialog.getExistingDirectory(self, "Pick data root", str(agent_data_dir()))
            if p: self.data_root_edit.setText(p)
        self.data_root_btn.clicked.connect(_browse_data_root)

        # Codex defaults
        codex_box = QGroupBox("Codex Defaults")
        codex_box.setObjectName("CodexDefaultsBox")
        self.codex_mode_bridge = QCheckBox("Default launch: Codex + Bridge", codex_box); self.codex_mode_bridge.setChecked(True)
        self.codex_working = QLineEdit(str(workspace_root()), codex_box)
        browse = QPushButton("Browse…", codex_box)
        self.enable_interpreter = ToggleSwitch(theme, codex_box)
        self.enable_interpreter.setObjectName("InterpreterSwitch")
        self.enable_interpreter.setToolTip(
            "When enabled, Codex automatically sends follow-up commands whenever the interpreter detects"
            " a continuation or actionable plan in the bridge output."
        )
        self.reference_embed_contents = QCheckBox(
            "Embed reference contents in chat", codex_box
        )
        self.reference_embed_contents.setToolTip(
            "Automatically attach referenced file contents when inserting workspace references."
        )
        self.reference_case_sensitive = QCheckBox(
            "Match references with case sensitivity", codex_box
        )
        self.reference_case_sensitive.setToolTip(
            "Only surface reference suggestions that respect the exact casing of your query."
        )
        self.reference_token_guard = QCheckBox(
            "Guard reference inserts with token safety", codex_box
        )
        self.reference_token_guard.setToolTip(
            "Prevents oversized reference payloads from being inserted when token budgets are tight."
        )
        self.reference_token_headroom = QSpinBox(codex_box)
        self.reference_token_headroom.setRange(10, 100)
        self.reference_token_headroom.setValue(
            DEFAULT_SETTINGS.get("reference_token_headroom", 80)
        )
        self.reference_token_headroom.setSuffix("%")
        self.reference_token_headroom.setToolTip(
            "Percentage of the model's context window available for prompts before attaching reference contents."
        )

        def _pick():
            p = QFileDialog.getExistingDirectory(self, "Pick working folder", str(workspace_root()))
            if p:
                self.codex_working.setText(p)

        browse.clicked.connect(_pick)

        codex_layout = QVBoxLayout(codex_box)
        codex_layout.setContentsMargins(12, 12, 12, 12)
        codex_layout.setSpacing(12)

        cf = QFormLayout()
        cf.addRow(self.codex_mode_bridge)
        interpreter_row = QWidget(codex_box)
        interpreter_layout = QHBoxLayout(interpreter_row)
        interpreter_layout.setContentsMargins(0, 0, 0, 0)
        interpreter_layout.setSpacing(6)
        interpreter_layout.addWidget(self.enable_interpreter, 0, Qt.AlignLeft)
        interpreter_layout.addStretch(1)
        cf.addRow("Interpreter automation", interpreter_row)
        roww = QWidget()
        rw = QHBoxLayout(roww)
        rw.setContentsMargins(0, 0, 0, 0)
        rw.addWidget(self.codex_working, 1)
        rw.addWidget(browse)
        cf.addRow("Working folder:", roww)

        scan_widget = QWidget(codex_box)
        scan_layout = QVBoxLayout(scan_widget)
        scan_layout.setContentsMargins(0, 0, 0, 0)
        scan_layout.setSpacing(6)
        self.scan_roots_list = QListWidget(scan_widget)
        self.scan_roots_list.setSelectionMode(QAbstractItemView.ExtendedSelection)
        scan_layout.addWidget(self.scan_roots_list)

        scan_btns = QHBoxLayout()
        scan_btns.setContentsMargins(0, 0, 0, 0)
        scan_btns.setSpacing(6)
        self.scan_root_add = QPushButton("Add…", scan_widget)
        self.scan_root_remove = QPushButton("Remove", scan_widget)
        self.scan_root_remove.setEnabled(False)
        scan_btns.addWidget(self.scan_root_add)
        scan_btns.addWidget(self.scan_root_remove)
        scan_btns.addStretch(1)
        scan_layout.addLayout(scan_btns)

        self.scan_root_add.clicked.connect(self._on_add_scan_root)
        self.scan_root_remove.clicked.connect(self._on_remove_selected_scan_roots)
        self.scan_roots_list.itemSelectionChanged.connect(self._update_scan_root_remove_enabled)

        cf.addRow("Additional scan roots", scan_widget)
        cf.addRow(self.reference_embed_contents)
        cf.addRow(self.reference_case_sensitive)
        cf.addRow(self.reference_token_guard)
        cf.addRow("Reference token headroom", self.reference_token_headroom)
        codex_layout.addLayout(cf)

        sandbox_box = QGroupBox("Sandbox")
        sandbox_box.setObjectName("SandboxBox")
        sb_layout = QVBoxLayout(sandbox_box)
        sb_layout.setContentsMargins(12, 12, 12, 12)
        sb_layout.setSpacing(10)

        self.sandbox_level = QComboBox(sandbox_box)
        self.sandbox_level.addItem("Isolated (maximum containment)", "isolated")
        self.sandbox_level.addItem("Restricted (balanced)", "restricted")
        self.sandbox_level.addItem("Trusted (broad access)", "trusted")

        self.sandbox_policy = QComboBox(sandbox_box)
        self.sandbox_policy.addItem("Require approval for all actions", "require_approval")
        self.sandbox_policy.addItem("Auto-approve safe actions", "auto_safe")
        self.sandbox_policy.addItem("Auto-approve trusted workflows", "auto_trust")

        self.sandbox_full_auto = QCheckBox("Enable full auto mode", sandbox_box)
        self.sandbox_level.currentIndexChanged.connect(self._update_scan_roots_enabled)

        sandbox_form = QFormLayout()
        sandbox_form.addRow("Level", self.sandbox_level)
        sandbox_form.addRow("Approval policy", self.sandbox_policy)
        sandbox_form.addRow(self.sandbox_full_auto)
        sb_layout.addLayout(sandbox_form)

        status_header = QLabel("Safety status", sandbox_box)
        status_header.setObjectName("SandboxStatusHeader")
        sb_layout.addWidget(status_header)

        status_form = QFormLayout()
        self.sandbox_ollama_status = QLabel("", sandbox_box)
        self.sandbox_encryption_status = QLabel("", sandbox_box)
        self.sandbox_access_status = QLabel("", sandbox_box)
        for label in (self.sandbox_ollama_status, self.sandbox_encryption_status, self.sandbox_access_status):
            label.setObjectName("SandboxStatusValue")
            label.setWordWrap(True)
        status_form.addRow("Ollama connection", self.sandbox_ollama_status)
        status_form.addRow("Encryption", self.sandbox_encryption_status)
        status_form.addRow("Access control", self.sandbox_access_status)
        sb_layout.addLayout(status_form)
        sb_layout.addStretch(1)

        sandbox_box.setStyleSheet(
            f"""
            QGroupBox#SandboxBox {{
                background-color: {self.theme.card_bg};
                border: 1px solid {self.theme.card_border};
                border-radius: {self.theme.card_radius}px;
                margin-top: 4px;
                padding-top: 18px;
            }}
            QGroupBox#SandboxBox::title {{
                subcontrol-origin: margin;
                subcontrol-position: top left;
                padding: 0 12px;
                color: {self.theme.header_text};
                font-weight: 600;
            }}
            QLabel#SandboxStatusHeader {{
                color: {self.theme.think_text};
                font-weight: 600;
            }}
            QLabel#SandboxStatusValue {{
                font-weight: 600;
            }}
            """
        )

        self._sandbox_encryption_enabled = False
        self._sandbox_access_control_enforced = False
        codex_layout.addWidget(sandbox_box)
        codex_layout.addStretch(1)

        self.update_sandbox_status(
            ollama_ok=False,
            ollama_detail="Status unknown",
            encryption_enabled=False,
            access_control_enabled=False,
        )

        self._update_scan_roots_enabled()

        prompts_box = QWidget(self)
        pb_layout = QVBoxLayout(prompts_box)
        pb_layout.setContentsMargins(12, 12, 12, 12)
        pb_layout.setSpacing(12)
        intro = QLabel(
            "Prompt files live in the prompts/ directory. Base text defines the persona and "
            "overlay files append additional guidance without editing the default instructions.",
            prompts_box,
        )
        intro.setWordWrap(True)
        pb_layout.addWidget(intro)

        for definition in iter_prompt_definitions():
            row = QFrame(prompts_box)
            row.setObjectName("PromptRow")
            row_layout = QVBoxLayout(row)
            row_layout.setContentsMargins(12, 12, 12, 12)
            row_layout.setSpacing(6)

            title = QLabel(definition.title, row)
            title.setObjectName("PromptTitle")
            title.setWordWrap(True)
            desc = QLabel(definition.description, row)
            desc.setObjectName("PromptDesc")
            desc.setWordWrap(True)

            btn_row = QHBoxLayout()
            base_btn = QPushButton("Open Base", row)
            base_btn.setToolTip(str(definition.base_path))
            base_btn.clicked.connect(lambda _=False, p=definition.base_path: self._open_prompt_path(p, ensure_exists=True))
            overlay_btn = QPushButton("Open Overlay", row)
            overlay_btn.setToolTip(str(definition.overlay_path))
            overlay_btn.clicked.connect(lambda _=False, p=definition.overlay_path: self._open_prompt_path(p, ensure_exists=True))
            btn_row.addWidget(base_btn)
            btn_row.addWidget(overlay_btn)
            btn_row.addStretch(1)

            row_layout.addWidget(title)
            row_layout.addWidget(desc)
            row_layout.addLayout(btn_row)

            row.setStyleSheet(
                """
                QFrame#PromptRow {
                    background-color: %s;
                    border: 1px solid %s;
                    border-radius: 10px;
                }
                QFrame#PromptRow QLabel {
                    color: %s;
                }
                QFrame#PromptRow QLabel#PromptDesc {
                    color: %s;
                    font-size: 10pt;
                }
                QFrame#PromptRow QPushButton {
                    padding: 6px 12px;
                }
                """
                % (self.theme.card_bg, self.theme.card_border, self.theme.ai_text, self.theme.think_text)
            )

            pb_layout.addWidget(row)

        pb_layout.addStretch(1)

        tabs = QTabWidget(self)
        tabs.addTab(models_box, "Models")
        tabs.addTab(shells_box, "Shells")
        tabs.addTab(data_box, "Data")
        tabs.addTab(codex_box, "Codex")
        tabs.addTab(prompts_box, "Prompts")
        layout.addWidget(tabs)

        btns = QHBoxLayout()
        btns.addStretch(1)
        okb = QPushButton("OK", self); cb = QPushButton("Cancel", self)
        btns.addWidget(okb); btns.addWidget(cb)
        layout.addLayout(btns)

        self.populate_models()
        self.context_pairs.valueChanged.connect(lambda v: self.context_val.setText(str(v)))
        okb.clicked.connect(self.accept); cb.clicked.connect(self.reject)

        self.setStyleSheet(f"""
        QDialog, QWidget {{ background:{theme.card_bg}; color:{theme.header_text}; }}
        QTabWidget::pane {{ background:{theme.card_bg}; border:1px solid {theme.card_border}; }}
        QTabBar::tab {{
            background:{theme.card_bg};
            color:{theme.muted};
            padding:6px 12px;
            border:1px solid {theme.card_border};
            border-bottom:0px;
            border-top-left-radius:6px;
            border-top-right-radius:6px;
            margin-right:2px;
        }}
        QTabBar::tab:hover {{
            background:{theme.card_border};
            color:{theme.header_text};
        }}
        QTabBar::tab:selected {{
            background:{theme.accent};
            color:#ffffff;
        }}
        QGroupBox {{ border:1px solid {theme.card_border}; border-radius:8px; margin-top:14px; padding-top:10px; color:{theme.header_text}; }}
        QGroupBox::title {{ color:{theme.header_text}; }}
        QComboBox, QTextEdit, QLineEdit {{
            background:#0d1a2b; color:#eaf2ff; border:1px solid {theme.card_border}; border-radius:6px; padding:6px;
        }}
        QSlider::groove:horizontal {{ background:#263a50; height:6px; border-radius:3px; }}
        QSlider::handle:horizontal {{ background:{theme.accent}; width:14px; border-radius:7px; }}
        QPushButton {{ color:#ffffff; background:{theme.accent}; border:1px solid {theme.card_border}; border-radius:6px; padding:6px 10px; }}
        QPushButton:hover {{ background:{theme.accent_hover}; }}
        QLabel {{ color:{theme.header_text}; }}
        QCheckBox {{ color:#eaf2ff; }}
        """)

    def apply_sandbox_settings(self, sandbox: Dict[str, Any]) -> None:
        defaults = DEFAULT_SETTINGS.get("sandbox", {})
        sandbox = sandbox if isinstance(sandbox, dict) else {}

        level_value = sandbox.get("level", defaults.get("level", "restricted"))
        level_idx = self.sandbox_level.findData(level_value)
        if level_idx < 0:
            level_idx = self.sandbox_level.findData(defaults.get("level", "restricted"))
        if level_idx < 0:
            level_idx = 0
        self.sandbox_level.setCurrentIndex(level_idx)

        policy_value = sandbox.get("approval_policy", defaults.get("approval_policy", "require_approval"))
        policy_idx = self.sandbox_policy.findData(policy_value)
        if policy_idx < 0:
            policy_idx = self.sandbox_policy.findData(defaults.get("approval_policy", "require_approval"))
        if policy_idx < 0:
            policy_idx = 0
        self.sandbox_policy.setCurrentIndex(policy_idx)

        self.sandbox_full_auto.setChecked(bool(sandbox.get("full_auto", defaults.get("full_auto", False))))

        encryption_enabled = bool(sandbox.get("encryption_enabled", defaults.get("encryption_enabled", False)))
        access_enforced = bool(
            sandbox.get("access_control_enforced", defaults.get("access_control_enforced", False))
            or sandbox.get("access_control", False)
        )

        try:
            healthy, detail = self.ollama.health()
        except Exception:
            healthy, detail = False, "unavailable"

        self.update_sandbox_status(
            ollama_ok=healthy,
            ollama_detail=detail,
            encryption_enabled=encryption_enabled,
            access_control_enabled=access_enforced,
        )
        self._update_scan_roots_enabled()

    def update_sandbox_status(
        self,
        *,
        ollama_ok: bool,
        ollama_detail: str,
        encryption_enabled: bool,
        access_control_enabled: bool,
    ) -> None:
        detail = (ollama_detail or "").strip()
        if ollama_ok:
            text = "Connected"
            if detail and detail.upper() not in {"OK", "200"}:
                text = f"Connected ({detail})"
            self._set_status_label(self.sandbox_ollama_status, text, self.theme.live_ok)
        else:
            offline_text = "Offline" if not detail else f"Offline ({detail})"
            self._set_status_label(self.sandbox_ollama_status, offline_text, self.theme.live_err)

        encryption_text = "Enabled" if encryption_enabled else "Disabled"
        encryption_color = self.theme.live_ok if encryption_enabled else self.theme.live_warn
        self._set_status_label(self.sandbox_encryption_status, encryption_text, encryption_color)

        access_text = "Enforced" if access_control_enabled else "Open"
        access_color = self.theme.live_ok if access_control_enabled else self.theme.live_warn
        self._set_status_label(self.sandbox_access_status, access_text, access_color)

        self._sandbox_encryption_enabled = encryption_enabled
        self._sandbox_access_control_enforced = access_control_enabled

    def _set_status_label(self, label: QLabel, text: str, color: str) -> None:
        label.setText(text)
        label.setStyleSheet(f"color: {color}; font-weight: 600;")

    def populate_models(self):
        ok, names, _ = OllamaClient().list_models()
        names = sorted(names) if ok else []
        def fill(box: QComboBox, default_name: str):
            box.clear()
            if names:
                box.addItems(names)
                idx = box.findText(default_name)
                if idx >= 0: box.setCurrentIndex(idx)
                else:
                    box.insertItem(0, default_name); box.setCurrentIndex(0)
            else:
                box.addItem(default_name)
        fill(self.chat_model, DEFAULT_CHAT_MODEL)
        fill(self.vision_ocr_model, DEFAULT_VISION_OCR_MODEL)
        fill(self.vision_model, DEFAULT_VISION_MODEL)
        fill(self.embed_model, DEFAULT_EMBED_MODEL)

    def values(self) -> Dict[str, Any]:
        level_value = self.sandbox_level.currentData()
        if not level_value:
            level_text = self.sandbox_level.currentText().strip().lower()
            level_value = level_text.split()[0] if level_text else DEFAULT_SETTINGS["sandbox"]["level"]

        policy_value = self.sandbox_policy.currentData()
        if not policy_value:
            policy_text = self.sandbox_policy.currentText().strip().lower()
            policy_value = policy_text.split()[0] if policy_text else DEFAULT_SETTINGS["sandbox"]["approval_policy"]

        embed_contents = self.reference_embed_contents.isChecked()
        case_sensitive = self.reference_case_sensitive.isChecked()
        token_guard = self.reference_token_guard.isChecked()
        headroom = int(self.reference_token_headroom.value())

        scan_roots: List[str] = []
        if level_value == "trusted":
            scan_roots = _normalize_scan_roots(self._collect_scan_roots())

        return {
            "chat_model": self.chat_model.currentText().strip(),
            "vision_ocr_model": self.vision_ocr_model.currentText().strip(),
            "vision_model": self.vision_model.currentText().strip(),
            "embed_model": self.embed_model.currentText().strip(),
            "context_pairs": int(self.context_pairs.value()),
            "share_context": self.share_context.isChecked(),
            "share_limit": int(self.share_limit.value()),
            "enable_semantic": self.enable_embeddings.isChecked(),
            "enable_vision": self.enable_vision.isChecked(),
            "enable_interpreter": self.enable_interpreter.isChecked(),
            "reference_embed_contents": embed_contents,
            "reference_case_sensitive": case_sensitive,
            "reference_token_guard": token_guard,
            "reference_token_headroom": headroom,
            "data_root": _clamp_to_agent_subdir(self.data_root_edit.text().strip(), subdir=agent_data_dir()),
            "scan_roots": scan_roots,
            "shells": {
                "cmd": self.chk_cmd.isChecked(),
                "powershell": self.chk_powershell.isChecked(),
                "bash": self.chk_bash.isChecked(),
                "zsh": self.chk_zsh.isChecked(),
                "wsl": self.chk_wsl.isChecked(),
            },
            "codex": {
                "default_launch_mode": "bridge" if self.codex_mode_bridge.isChecked() else "normal",
                "working_folder": self.codex_working.text().strip() or str(workspace_root()),
                "sandbox": {
                    "level": level_value,
                    "approval_policy": policy_value,
                    "full_auto": self.sandbox_full_auto.isChecked(),
                    "encryption_enabled": self._sandbox_encryption_enabled,
                    "access_control_enforced": self._sandbox_access_control_enforced,
                },
                "reference_embed_contents": embed_contents,
                "reference_case_sensitive": case_sensitive,
                "reference_token_guard": token_guard,
                "reference_token_headroom": headroom,
                "scan_roots": scan_roots,
            }
        }

    def set_scan_roots(self, roots: Sequence[str]) -> None:
        self.scan_roots_list.clear()
        for root in _normalize_scan_roots(roots):
            self.scan_roots_list.addItem(root)
        self._update_scan_root_remove_enabled()
        self._update_scan_roots_enabled()

    def _collect_scan_roots(self) -> List[str]:
        values: List[str] = []
        for index in range(self.scan_roots_list.count()):
            item = self.scan_roots_list.item(index)
            if not item:
                continue
            text = item.text().strip()
            if text:
                values.append(text)
        return values

    def _on_add_scan_root(self) -> None:
        directory = QFileDialog.getExistingDirectory(
            self,
            "Select additional scan root",
            self.codex_working.text().strip() or str(workspace_root()),
        )
        if not directory:
            return
        normalized = _normalize_scan_roots([directory])
        if not normalized:
            return
        new_root = normalized[0]
        existing = {
            self.scan_roots_list.item(i).text()
            for i in range(self.scan_roots_list.count())
        }
        if new_root in existing:
            return
        self.scan_roots_list.addItem(new_root)
        self._update_scan_root_remove_enabled()

    def _on_remove_selected_scan_roots(self) -> None:
        for item in list(self.scan_roots_list.selectedItems()):
            row = self.scan_roots_list.row(item)
            self.scan_roots_list.takeItem(row)
        self._update_scan_root_remove_enabled()

    def _update_scan_root_remove_enabled(self) -> None:
        enabled = self.scan_roots_list.isEnabled() and bool(self.scan_roots_list.selectedItems())
        self.scan_root_remove.setEnabled(enabled)

    def _update_scan_roots_enabled(self, *_args) -> None:
        trusted = (self.sandbox_level.currentData() == "trusted")
        self.scan_roots_list.setEnabled(trusted)
        self.scan_root_add.setEnabled(trusted)
        if not trusted:
            self.scan_roots_list.clearSelection()
        self._update_scan_root_remove_enabled()

    def _row(self, *widgets: QWidget) -> QWidget:
        w = QWidget(self); h = QHBoxLayout(w); h.setContentsMargins(0,0,0,0)
        for wd in widgets: h.addWidget(wd)
        return w

    def _open_prompt_path(self, path: Path, ensure_exists: bool = False) -> None:
        path = Path(path)
        try:
            path.parent.mkdir(parents=True, exist_ok=True)
            if ensure_exists and not path.exists():
                path.touch()
        except Exception as exc:  # pragma: no cover - UI feedback only
            QMessageBox.warning(self, "Open Prompt", f"Failed to prepare prompt file:\n{exc}")
            return
        opened = QDesktopServices.openUrl(QUrl.fromLocalFile(str(path)))
        if not opened:  # pragma: no cover - depends on host OS handlers
            QMessageBox.information(
                self,
                "Open Prompt",
                f"Prompt file located at:\n{path}\nOpen it manually to edit the persona.",
            )

# --------------------------------------------------------------------------------------
# Chat UI + vision pipeline
# --------------------------------------------------------------------------------------

class ChatMessage:
    def __init__(
        self,
        role: str,
        text: str,
        images: Optional[List[Path]] = None,
        model_name: str = "",
        *,
        kind: str = "text",
        meta: Optional[Dict[str, Any]] = None,
    ) -> None:
        self.role = role
        self.text = text
        self.images = images or []
        self.model_name = model_name
        self.kind = kind
        self.meta = meta or {}


@dataclass
class ApprovalPrompt:
    header: str
    body: str
    options: Dict[str, str]

    def as_text(self) -> str:
        body = self.body.strip()
        if body:
            return f"{self.header}\n{body}"
        return self.header


@dataclass
class ParsedCodexEvent:
    kind: str  # "text" | "prompt" | "dismissal"
    payload: Any


class CodexInterpreter:
    """Auto-respond to Codex prompts when enabled."""

    _CONTINUE_PATTERNS: Tuple[re.Pattern[str], ...] = (
        re.compile(r"would you like me to continue", re.IGNORECASE),
        re.compile(r"should i keep going", re.IGNORECASE),
        re.compile(r"do you want me to continue", re.IGNORECASE),
        re.compile(r"can i continue", re.IGNORECASE),
    )
    _PLAN_PATTERN = re.compile(r"(?:^|\n)\s*(?:plan|next steps|todo)[:?]", re.IGNORECASE)
    _PLAN_BULLET_PATTERN = re.compile(r"^\s*(?:[-*]|\d+\.)", re.MULTILINE)
    _COMPLETION_PATTERNS: Tuple[re.Pattern[str], ...] = (
        re.compile(r"completed .*file", re.IGNORECASE),
        re.compile(r"finished .*file", re.IGNORECASE),
        re.compile(r"all changes (?:have been )?(?:applied|completed)", re.IGNORECASE),
        re.compile(r"no further (?:changes|actions) required", re.IGNORECASE),
    )
    _MAX_PLAN_CHARS = 400

    def __init__(
        self,
        *,
        bridge: CodexBridge,
        get_busy: Callable[[], bool],
        get_hwnd: Callable[[], int],
        on_auto: Optional[Callable[[str], None]] = None,
        send_command: Optional[Callable[[str], bool]] = None,
        enabled: bool = True,
    ) -> None:
        self.bridge = bridge
        self.enabled = enabled
        self._get_busy = get_busy
        self._get_hwnd = get_hwnd
        self._on_auto = on_auto or (lambda command: None)
        self._send_command = send_command
        self._last_user_instruction: str = ""
        self._last_auto_command: Optional[str] = None
        self._recent_plan: Deque[str] = deque(maxlen=2)
        self._auto_active = False
        self._auto_completed = False

    def observe_user(self, text: str) -> None:
        if text:
            self._last_user_instruction = self._trim(text)
        else:
            self._last_user_instruction = ""
        self._last_auto_command = None
        self._recent_plan.clear()
        self._auto_active = False
        self._auto_completed = False

    def set_enabled(self, enabled: bool) -> None:
        self.enabled = bool(enabled)
        if not self.enabled:
            self._recent_plan.clear()
            self._auto_active = False
            self._auto_completed = False
            self._last_auto_command = None

    def observe_codex_output(self, text: str) -> None:
        if not self.enabled:
            return
        snippet = (text or "").strip()
        if not snippet:
            return
        if self._matches(snippet, self._COMPLETION_PATTERNS):
            self._handle_completion()
            return
        if self._auto_completed or self._auto_active:
            return
        if not self._ready():
            return
        if self._matches(snippet, self._CONTINUE_PATTERNS):
            self._schedule_follow_up(self._build_follow_up())
            return
        if self._looks_like_plan(snippet):
            key = self._normalize_plan(snippet)
            if key:
                self._recent_plan.append(key)
                if len(self._recent_plan) == self._recent_plan.maxlen and len(set(self._recent_plan)) == 1:
                    self._schedule_follow_up(self._build_follow_up())
                    self._recent_plan.clear()
                    return
        else:
            self._recent_plan.clear()

    def _schedule_follow_up(self, command: Optional[str]) -> None:
        if not command:
            return
        message = command.strip()
        if not message:
            return
        if self._auto_completed:
            return
        if self._auto_active and message == self._last_auto_command:
            return

        if not self._ready():
            return
        sender = self._send_command
        if sender:
            ok = sender(message)
            if not ok:
                return
        else:
            ok = self.bridge.send_text(message)
            if not ok:
                return
            self.bridge.press_enter_async(self._get_hwnd())
        self._last_auto_command = message
        self._auto_active = True
        self._on_auto(message)

    def _ready(self) -> bool:
        if not self.bridge or not self.bridge.running():
            return False
        try:
            if self.bridge.busy():
                return False
        except Exception:
            pass
        try:
            if self._get_busy():
                return False
        except Exception:
            return False
        return True

    def _build_follow_up(self) -> str:
        base = self._last_user_instruction.strip()
        if not base:
            return "continue"
        if len(base) > 160:
            base = base[:157].rstrip() + "..."
        return f"continue, focusing on {base}"

    @staticmethod
    def _trim(text: str) -> str:
        collapsed = " ".join(text.split())
        return collapsed.strip()

    @staticmethod
    def _normalize_plan(text: str) -> str:
        return " ".join(text.lower().split())

    @staticmethod
    def _matches(snippet: str, patterns: Sequence[re.Pattern[str]]) -> bool:
        return any(p.search(snippet) for p in patterns)

    def _looks_like_plan(self, text: str) -> bool:
        if len(text) > self._MAX_PLAN_CHARS:
            return False
        if self._PLAN_PATTERN.search(text):
            return True
        if self._PLAN_BULLET_PATTERN.search(text):
            return True
        return False

    def _handle_completion(self) -> None:
        if self._auto_active:
            self._auto_completed = True
        self._auto_active = False
        self._last_auto_command = None
        self._recent_plan.clear()

DEFAULT_APPROVAL_TOKENS: Dict[str, str] = {
    "yes": "y",
    "always": "always",
    "no": "n",
    "feedback": "feedback",
}

_APPROVAL_TOKEN_STRINGS: Set[str] = (
    {action.lower() for action in DEFAULT_APPROVAL_TOKENS.keys()}
    | {token.lower() for token in DEFAULT_APPROVAL_TOKENS.values()}
)

APPROVAL_ACTION_TITLES: Dict[str, str] = {
    "yes": "Yes",
    "always": "Always",
    "no": "No",
    "feedback": "Provide feedback",
}

_APPROVAL_ACTION_ALIASES: Dict[str, Tuple[str, ...]] = {
    "yes": ("yes", "y", "approve", "allow", "run", "execute"),
    "always": ("always", "a", "always allow", "always approve"),
    "no": ("no", "n", "deny", "don't", "cancel", "abort"),
    "feedback": ("feedback", "f", "provide feedback", "report", "complaint"),
}

_APPROVAL_HEADER_RE = re.compile(
    r"^\s*(?:allow|approve|authorization|authorize)\b.*(?:\?|:).*$",
    re.IGNORECASE,
)
_APPROVAL_HEADER_PREFIXES: Tuple[str, ...] = (
    "select",
    "choose",
    "pick",
    "make a selection",
    "action required",
    "selection required",
)
_APPROVAL_DISMISS_RE = re.compile(r"(prompt|approval).*(dismissed|cancell?ed|aborted)", re.IGNORECASE)


def _normalize_display_text(value: str) -> str:
    return value.replace("\r\n", "\n").replace("\r", "\n")


class ChatBubbleWidget(QFrame):
    def __init__(
        self,
        theme: Theme,
        role: str,
        text: str,
        *,
        model_name: str = "",
        thinks: Optional[Sequence[str]] = None,
        images: Optional[Sequence[Path]] = None,
        parent: Optional[QWidget] = None,
    ) -> None:
        super().__init__(parent)
        self.theme = theme
        self.role = role
        self.setObjectName("ChatBubbleWidget")
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(4)

        if role in ("user", "assistant"):
            name = "You" if role == "user" else "Codex"
            name_label = QLabel(name, self)
            name_label.setObjectName("MessageName")
            name_label.setProperty("role", role)
            align = Qt.AlignRight if role == "user" else Qt.AlignLeft
            name_label.setAlignment(align)
            layout.addWidget(name_label, 0, align)

        bubble = QFrame(self)
        bubble.setObjectName("MessageBubble")
        bubble.setProperty("role", role)
        bubble_layout = QVBoxLayout(bubble)
        bubble_layout.setContentsMargins(14, 10, 14, 12)
        bubble_layout.setSpacing(8)
        bubble.setSizePolicy(QSizePolicy.Maximum, QSizePolicy.Maximum)
        bubble.setMaximumWidth(720)

        if role == "assistant" and model_name:
            model_label = QLabel(model_name, bubble)
            model_label.setObjectName("ModelNameLabel")
            model_label.setAlignment(Qt.AlignLeft)
            bubble_layout.addWidget(model_label)

        if role == "assistant":
            for raw_think in thinks or []:
                think_text = _normalize_display_text(raw_think).strip()
                if not think_text:
                    continue
                think_label = QLabel(think_text, bubble)
                think_label.setObjectName("ThinkText")
                think_label.setProperty("role", role)
                think_label.setTextFormat(Qt.PlainText)
                think_label.setWordWrap(True)
                think_label.setAlignment(Qt.AlignLeft)
                think_label.setTextInteractionFlags(
                    Qt.TextSelectableByMouse | Qt.TextSelectableByKeyboard
                )
                bubble_layout.addWidget(think_label)

        body_text = _normalize_display_text(text)
        body_label = QLabel(body_text if body_text else "", bubble)
        body_label.setObjectName("MessageText")
        body_label.setProperty("role", role)
        body_label.setTextFormat(Qt.PlainText)
        body_label.setWordWrap(True)
        body_label.setAlignment(Qt.AlignLeft)
        body_label.setTextInteractionFlags(
            Qt.TextSelectableByMouse | Qt.TextSelectableByKeyboard | Qt.LinksAccessibleByMouse
        )
        bubble_layout.addWidget(body_label)

        for img_path in images or []:
            caption = QLabel(img_path.name, bubble)
            caption.setObjectName("AttachmentLabel")
            caption.setAlignment(Qt.AlignLeft)
            caption.setTextInteractionFlags(Qt.TextSelectableByMouse | Qt.TextSelectableByKeyboard)
            bubble_layout.addWidget(caption)

            img_label = QLabel(bubble)
            img_label.setObjectName("AttachmentImage")
            pixmap = QPixmap(str(img_path)) if img_path.exists() else QPixmap()
            if not pixmap.isNull():
                if pixmap.width() > 320:
                    pixmap = pixmap.scaledToWidth(320, Qt.SmoothTransformation)
                img_label.setPixmap(pixmap)
            else:
                img_label.setText("(image unavailable)")
                img_label.setTextFormat(Qt.PlainText)
            img_label.setAlignment(Qt.AlignLeft)
            bubble_layout.addWidget(img_label)

        layout.addWidget(bubble)
        self.setSizePolicy(QSizePolicy.Preferred, QSizePolicy.Maximum)


class ConversationView(QFrame):
    def __init__(self, theme: Theme, parent: Optional[QWidget] = None) -> None:
        super().__init__(parent)
        self.theme = theme
        self.setObjectName("ConversationView")
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)

        self.scroll = QScrollArea(self)
        self.scroll.setObjectName("ConversationScroll")
        self.scroll.setWidgetResizable(True)
        self.scroll.setFrameShape(QFrame.NoFrame)
        self.scroll.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        layout.addWidget(self.scroll)

        self.container = QWidget(self.scroll)
        self.container.setObjectName("ConversationContainer")
        self.scroll.setWidget(self.container)

        self.container_layout = QVBoxLayout(self.container)
        self.container_layout.setContentsMargins(12, 12, 12, 12)
        self.container_layout.setSpacing(12)
        self._spacer = QSpacerItem(0, 0, QSizePolicy.Minimum, QSizePolicy.Expanding)
        self.container_layout.addItem(self._spacer)

    def clear(self) -> None:
        while self.container_layout.count() > 1:
            item = self.container_layout.takeAt(0)
            widget = item.widget()
            if widget:
                widget.deleteLater()

    def append_message(
        self,
        role: str,
        text: str,
        *,
        model_name: str = "",
        thinks: Optional[Sequence[str]] = None,
        images: Optional[Sequence[Path]] = None,
    ) -> None:
        bubble = ChatBubbleWidget(
            self.theme,
            role,
            text,
            model_name=model_name,
            thinks=thinks,
            images=images,
        )
        self._append_row(role, bubble)
        self._refresh_bubble_styles()
        QTimer.singleShot(0, self._scroll_to_bottom)

    def append_widget(
        self,
        widget: QWidget,
        *,
        role: str = "assistant",
        alignment: Optional[Qt.AlignmentFlag] = None,
    ) -> None:
        self._append_row(role, widget, alignment)
        QTimer.singleShot(0, self._scroll_to_bottom)

    def _append_row(
        self,
        role: str,
        widget: QWidget,
        alignment: Optional[Qt.AlignmentFlag] = None,
    ) -> None:
        row = QFrame(self.container)
        row.setObjectName("MessageRow")
        hbox = QHBoxLayout(row)
        hbox.setContentsMargins(0, 0, 0, 0)
        hbox.setSpacing(0)

        align = alignment if alignment is not None else (Qt.AlignRight if role == "user" else Qt.AlignLeft)
        if align == Qt.AlignRight:
            hbox.addStretch(1)
            hbox.addWidget(widget, 0, Qt.AlignRight)
        elif align == Qt.AlignCenter:
            hbox.addStretch(1)
            hbox.addWidget(widget, 0, Qt.AlignCenter)
            hbox.addStretch(1)
        else:
            hbox.addWidget(widget, 0, Qt.AlignLeft)
            hbox.addStretch(1)

        insert_at = max(0, self.container_layout.count() - 1)
        self.container_layout.insertWidget(insert_at, row)

    def _refresh_bubble_styles(self) -> None:
        for index in range(self.container_layout.count() - 1):
            item = self.container_layout.itemAt(index)
            row = item.widget()
            if not row:
                continue
            bubble = row.findChild(ChatBubbleWidget)
            if not bubble:
                continue
            bubble.style().unpolish(bubble)
            bubble.style().polish(bubble)
            for label in bubble.findChildren(QLabel):
                label.style().unpolish(label)
                label.style().polish(label)

    def _scroll_to_bottom(self) -> None:
        bar = self.scroll.verticalScrollBar()
        if bar:
            bar.setValue(bar.maximum())


class ApprovalPromptWidget(QFrame):
    def __init__(
        self,
        theme: Theme,
        prompt: ApprovalPrompt,
        on_decision,
        parent: Optional[QWidget] = None,
    ) -> None:
        super().__init__(parent)
        self.theme = theme
        self.prompt = prompt
        self._on_decision = on_decision
        self._buttons: Dict[str, QPushButton] = {}
        self._state: str = "pending"
        self._pending_action: str = ""
        self.setObjectName("ApprovalPrompt")

        layout = QVBoxLayout(self)
        layout.setContentsMargins(14, 12, 14, 12)
        layout.setSpacing(10)

        header = QLabel(prompt.header, self)
        header.setObjectName("ApprovalHeader")
        header.setWordWrap(True)
        header.setTextInteractionFlags(Qt.TextSelectableByMouse | Qt.TextSelectableByKeyboard)
        layout.addWidget(header)

        body_text = prompt.body.strip()
        if body_text:
            body = QLabel(body_text, self)
            body.setObjectName("ApprovalBody")
            body.setWordWrap(True)
            body.setTextInteractionFlags(
                Qt.TextSelectableByMouse | Qt.TextSelectableByKeyboard | Qt.LinksAccessibleByMouse
            )
            layout.addWidget(body)

        btn_row = QHBoxLayout()
        btn_row.setSpacing(8)
        btn_row.setContentsMargins(0, 0, 0, 0)
        layout.addLayout(btn_row)

        for action, title in APPROVAL_ACTION_TITLES.items():
            btn = QPushButton(title, self)
            btn.setObjectName("ApprovalButton")
            btn.setProperty("approvalAction", action)
            btn.clicked.connect(lambda _=False, a=action: self._handle_click(a))
            self._buttons[action] = btn
            btn_row.addWidget(btn)

        btn_row.addStretch(1)

        self._status = QLabel("", self)
        self._status.setObjectName("ApprovalStatus")
        self._status.setWordWrap(True)
        layout.addWidget(self._status)

    def _handle_click(self, action: str) -> None:
        if self._state not in {"pending"}:
            return
        token = self.prompt.options.get(action) or DEFAULT_APPROVAL_TOKENS.get(action, action)
        self._pending_action = action
        self._state = "responding"
        self._set_buttons_enabled(False)
        try:
            self._on_decision(self, action, token)
        except Exception:
            self._state = "pending"
            self._set_buttons_enabled(True)
            self._pending_action = ""
            raise

    def mark_submitted(self, action: Optional[str] = None) -> None:
        action = action or self._pending_action
        title = APPROVAL_ACTION_TITLES.get(action, action.title())
        self._status.setText(f"Sent: {title}")
        self._state = "submitted"
        self._pending_action = ""
        self._set_buttons_enabled(False)

    def mark_failed(self, reason: str) -> None:
        self._status.setText(f"Send failed: {reason}")
        self._state = "pending"
        self._pending_action = ""
        self._set_buttons_enabled(True)

    def mark_dismissed(self, reason: str) -> None:
        note = reason.strip() if reason else "Approval dismissed."
        self._status.setText(note)
        self._state = "dismissed"
        self._pending_action = ""
        self._set_buttons_enabled(False)

    def is_active(self) -> bool:
        return self._state in {"pending", "responding"}

    def _set_buttons_enabled(self, enabled: bool) -> None:
        for btn in self._buttons.values():
            btn.setEnabled(enabled)

class ChatInput(QTextEdit):
    imagesReady = Signal(list)
    referenceAccepted = Signal(dict)

    _TOKEN_BREAKS = " \n\t\r\f\v'\"()[]{}<>:,"

    def __init__(self, parent_card: "ChatCard", *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.card = parent_card
        self.setAcceptDrops(True)
        self.setLayoutDirection(Qt.LeftToRight)

        ref_settings = parent_card.settings if isinstance(parent_card.settings, dict) else {}
        embed_contents = bool(
            ref_settings.get(
                "reference_embed_contents",
                DEFAULT_SETTINGS.get("reference_embed_contents", True),
            )
        )
        case_sensitive = bool(
            ref_settings.get(
                "reference_case_sensitive",
                DEFAULT_SETTINGS.get("reference_case_sensitive", False),
            )
        )
        token_guard = bool(
            ref_settings.get(
                "reference_token_guard",
                DEFAULT_SETTINGS.get("reference_token_guard", True),
            )
        )

        self._repo_helper = RepoReferenceHelper(
            parent_card.workspace,
            parent=self,
            embed_contents=embed_contents,
            case_sensitive=case_sensitive,
            token_guard=token_guard,
            extra_roots=parent_card.scan_roots,
        )
        self._repo_helper.refreshed.connect(self._handle_repo_refresh)

        self._suggestion_popup = QListWidget(self)
        self._suggestion_popup.setWindowFlags(Qt.Popup | Qt.FramelessWindowHint)
        self._suggestion_popup.setFocusPolicy(Qt.NoFocus)
        self._suggestion_popup.setUniformItemSizes(True)
        self._suggestion_popup.hide()
        self._suggestion_popup.itemClicked.connect(self._handle_item_clicked)

        self._accepted_references: List[Dict[str, str]] = []

        self.textChanged.connect(self._handle_text_changed)

    # ----- clipboard & drag/drop -----
    def canInsertFromMimeData(self, source: QMimeData) -> bool:
        if source.hasImage() or source.hasUrls():
            return True
        return super().canInsertFromMimeData(source)

    def insertFromMimeData(self, source: QMimeData):
        if source.hasImage():
            img = source.imageData()
            if PIL_AVAILABLE and img:
                name = f"paste_{int(time.time())}_{uuid.uuid4().hex[:6]}.png"
                out = agent_images_dir() / name
                ensure_dir(out.parent)
                try:
                    if isinstance(img, QImage):
                        buf = QImage(img).convertToFormat(QImage.Format_RGBA8888)
                        ptr = buf.constBits()
                        ptr.setsize(buf.sizeInBytes())
                        pil = Image.frombytes("RGBA", (buf.width(), buf.height()), bytes(ptr))
                    else:
                        raise RuntimeError("Unsupported image type from clipboard")
                    pil = pil.convert("RGBA")
                    pil.save(out, "PNG", optimize=True)
                    self.imagesReady.emit([out])
                    return
                except Exception as e:
                    QMessageBox.warning(self, "Paste Image", f"Failed to paste image: {e}")
        if source.hasUrls():
            imgs: List[Path] = []
            for url in source.urls():
                p = Path(url.toLocalFile())
                if p.is_file():
                    try:
                        imgs.append(self.card._convert_to_png(p))
                    except Exception:
                        pass
            if imgs:
                self.imagesReady.emit(imgs)
                return
        super().insertFromMimeData(source)

    def dragEnterEvent(self, e):
        if e.mimeData().hasImage() or e.mimeData().hasUrls():
            e.acceptProposedAction()
        else:
            super().dragEnterEvent(e)

    def dropEvent(self, e):
        md = e.mimeData()
        imgs: List[Path] = []
        if md.hasUrls():
            for url in md.urls():
                p = Path(url.toLocalFile())
                if p.is_file():
                    try:
                        imgs.append(self.card._convert_to_png(p))
                    except Exception:
                        pass
        if imgs:
            self.imagesReady.emit(imgs)
            e.acceptProposedAction()
            return
        super().dropEvent(e)

    # ----- repository suggestions -----
    def clear(self) -> None:  # type: ignore[override]
        self._accepted_references.clear()
        self._hide_suggestions()
        super().clear()

    def consume_references(self) -> List[Dict[str, str]]:
        refs = [
            {"path": ref["path"], "type": ref["type"]}
            for ref in self._accepted_references
        ]
        self._accepted_references.clear()
        return refs

    def keyPressEvent(self, event: QKeyEvent) -> None:  # type: ignore[override]
        if self._suggestion_popup.isVisible():
            if event.key() in (Qt.Key_Tab, Qt.Key_Return, Qt.Key_Enter):
                event.accept()
                self._accept_current_suggestion()
                return
            if event.key() == Qt.Key_Down and self._suggestion_popup.count():
                event.accept()
                row = (self._suggestion_popup.currentRow() + 1) % self._suggestion_popup.count()
                self._suggestion_popup.setCurrentRow(row)
                return
            if event.key() == Qt.Key_Up and self._suggestion_popup.count():
                event.accept()
                row = self._suggestion_popup.currentRow() - 1
                if row < 0:
                    row = self._suggestion_popup.count() - 1
                self._suggestion_popup.setCurrentRow(row)
                return
            if event.key() == Qt.Key_Escape:
                event.accept()
                self._hide_suggestions()
                return
        super().keyPressEvent(event)

    def focusOutEvent(self, event):  # type: ignore[override]
        self._hide_suggestions()
        super().focusOutEvent(event)

    def _handle_repo_refresh(self) -> None:
        self._update_suggestions()

    def _handle_item_clicked(self, item: QListWidgetItem) -> None:
        ref = item.data(Qt.UserRole)
        if isinstance(ref, RepoReference):
            self._apply_reference(ref)

    def _handle_text_changed(self) -> None:
        if not self.toPlainText().strip():
            self._accepted_references.clear()
        self._update_suggestions()

    def _token_info(self) -> tuple[str, int, int]:
        text = self.toPlainText()
        cursor = self.textCursor()
        pos = cursor.position()
        start = pos
        while start > 0 and text[start - 1] not in self._TOKEN_BREAKS:
            start -= 1
        return text[start:pos], start, pos

    def _update_suggestions(self) -> None:
        token, _, _ = self._token_info()
        if len(token.strip()) < 2:
            self._hide_suggestions()
            return

        matches = self._repo_helper.suggestions(token, limit=6)
        if not matches:
            self._hide_suggestions()
            return

        self._suggestion_popup.clear()
        for ref in matches:
            item = QListWidgetItem(ref.display_label())
            item.setData(Qt.UserRole, ref)
            item.setToolTip(ref.absolute_path.as_posix())
            self._suggestion_popup.addItem(item)
        self._suggestion_popup.setCurrentRow(0)

        rect = self.cursorRect()
        popup_width = max(260, rect.width() * 3)
        popup_height = self._suggestion_popup.sizeHintForRow(0) * min(6, self._suggestion_popup.count()) + 8
        global_pos = self.mapToGlobal(rect.bottomLeft())
        self._suggestion_popup.setFixedSize(popup_width, popup_height)
        self._suggestion_popup.move(global_pos)
        self._suggestion_popup.show()

    def _hide_suggestions(self) -> None:
        self._suggestion_popup.hide()

    def _accept_current_suggestion(self) -> None:
        item = self._suggestion_popup.currentItem()
        if item is None and self._suggestion_popup.count():
            item = self._suggestion_popup.item(0)
        if not item:
            return
        ref = item.data(Qt.UserRole)
        if isinstance(ref, RepoReference):
            self._apply_reference(ref)

    def _apply_reference(self, ref: "RepoReference") -> None:
        token, start, end = self._token_info()
        cursor = self.textCursor()
        cursor.beginEditBlock()
        cursor.setPosition(start)
        cursor.setPosition(end, QTextCursor.KeepAnchor)
        cursor.removeSelectedText()
        cursor.insertText(ref.relative_path)
        cursor.endEditBlock()
        self.setTextCursor(cursor)

        highlight = self.textCursor()
        highlight.setPosition(cursor.position() - len(ref.relative_path))
        highlight.setPosition(cursor.position(), QTextCursor.KeepAnchor)
        fmt = QTextCharFormat()
        fmt.setBackground(self.palette().alternateBase())
        highlight.mergeCharFormat(fmt)

        payload = {"path": ref.relative_path, "type": ref.kind, "token": ref.relative_path}
        self._accepted_references.append(payload)
        self.referenceAccepted.emit({"path": ref.relative_path, "type": ref.kind})
        self._hide_suggestions()

class ChatCard(QFrame):
    append_signal = Signal(ChatMessage)
    state_signal = Signal(bool)
    codex_status_signal = Signal(str)     # status text
    codex_led_signal = Signal(str)        # "red"/"yellow"/"green"
    codex_output_signal = Signal(str)     # new Codex output
    error_signal = Signal(str)

    _TASK_STATUSES = {"open", "merged", "closed", "cancelled", "failed", "deleted"}

    def __init__(self, theme: Theme, ollama: OllamaClient, settings: Dict[str, Any], lex_mgr: LexiconManager, parent: Optional[QWidget] = None):
        super().__init__(parent)
        self.theme = theme; self.ollama = ollama; self.settings = settings; self.lex = lex_mgr
        self._chat_prompt = get_prompt_watcher("chat_system")
        self.setObjectName("ChatCard"); self.setStyleSheet(self._qss(theme)); self.setLayoutDirection(Qt.LeftToRight)
        self.busy = False; self.messages: List[ChatMessage] = []; self.context_pairs = int(settings.get("context_pairs", 25))
        self.share_context = bool(settings.get("share_context", True))
        self.share_limit = int(settings.get("share_limit", 5))
        self.workspace: Path = Path(settings.get("workspace") or workspace_root())
        sandbox_cfg = settings.get("sandbox")
        if not isinstance(sandbox_cfg, dict):
            sandbox_cfg = copy.deepcopy(DEFAULT_SETTINGS.get("sandbox", {}))
        self.settings["sandbox"] = sandbox_cfg
        raw_scan_roots = settings.get("scan_roots")
        normalized_scan_roots = _normalize_scan_roots(
            raw_scan_roots if isinstance(raw_scan_roots, (list, tuple)) else []
        )
        self.settings["scan_roots"] = normalized_scan_roots
        self._sandbox_level = str(
            sandbox_cfg.get("level", DEFAULT_SETTINGS.get("sandbox", {}).get("level", "restricted"))
        ).strip().lower()
        allowed_scan_roots: List[Path] = []
        if self._sandbox_level == "trusted":
            seen_paths: Set[Path] = set()
            try:
                workspace_resolved = self.workspace.resolve()
            except Exception:
                workspace_resolved = self.workspace
            for root_text in normalized_scan_roots:
                try:
                    candidate = Path(root_text).expanduser().resolve()
                except Exception:
                    continue
                if candidate in seen_paths or candidate == workspace_resolved:
                    continue
                if not candidate.exists() or not candidate.is_dir():
                    continue
                seen_paths.add(candidate)
                allowed_scan_roots.append(candidate)
        self.scan_roots = allowed_scan_roots
        self.session_id = f"term_{datetime.now(UTC).strftime('%Y%m%d%H%M%S')}_{uuid.uuid4().hex[:6]}"
        self.session_dir = ensure_dir(agent_sessions_dir() / self.session_id)
        self.data_root: Path = _clamp_to_agent_subdir(settings.get("data_root"), subdir=agent_data_dir())
        self.settings["data_root"] = str(self.data_root)
        interpreter_default = bool(settings.get("enable_interpreter", settings.get("codex_auto_continue", False)))
        self.settings["enable_interpreter"] = interpreter_default
        self._interpreter_tooltip = (
            "When enabled, Codex automatically sends follow-up commands whenever the interpreter detects"
            " a continuation prompt or actionable plan in the bridge output."
        )
        self._led_state = "red"

        embed_model = settings.get("embed_model", DEFAULT_EMBED_MODEL)
        enable_embed = settings.get("enable_semantic", True)
        self.conv = ConversationIO(
            self.session_dir,
            embed_model,
            self.ollama,
            enable_embed,
            session_token=self.session_id,
            archive_root=agent_archives_dir(),
        )
        self.dataset = DatasetManager(self.session_dir, embed_model, self.ollama, data_root=self.data_root, enable_semantic=enable_embed)
        self.pending_images: List[Path] = []
        self.session_notes: List[Dict[str, str]] = self._load_session_notes()
        self._safety_notifier_id: str = ""
        self._approval_widgets: List[ApprovalPromptWidget] = []
        self._task_bus_handles: List[Subscription] = []
        self._loaded_conversation_id: Optional[str] = None
        self._recent_input_references: Deque[Dict[str, str]] = deque(maxlen=10)

        self.codex = CodexBootstrap(self.ollama)
        self.bridge = CodexBridge(
            status_append_fn=self._codex_status,
            led_setter_fn=lambda s: self.codex_led_signal.emit(s),
            output_append_fn=lambda t: self.codex_output_signal.emit(t),
        )
        self.codex_interpreter = CodexInterpreter(
            bridge=self.bridge,
            get_busy=lambda: self.busy or self.bridge.busy(),
            get_hwnd=self._ui_hwnd,
            on_auto=self._handle_auto_follow_up,
            send_command=self._send_codex_auto,
            enabled=interpreter_default,
        )

        self.error_signal.connect(self._log_error_center)
        self.error_signal.connect(self._handle_error_notice)
        self._safety_notifier_id = safety_manager.add_notifier(self.error_signal.emit)

        # UI
        outer = QHBoxLayout(self)
        outer.setContentsMargins(0, 0, 0, 0)
        outer.setSpacing(0)

        main_frame = QFrame(self)
        main_frame.setObjectName("ChatMainColumn")
        root = QVBoxLayout(main_frame)
        root.setContentsMargins(0, 0, 0, 0)
        root.setSpacing(0)

        header = QFrame(main_frame)
        header.setObjectName("Header")
        hbox = QHBoxLayout(header)
        hbox.setContentsMargins(12, 8, 12, 8)
        hbox.setSpacing(8)
        self.title = QLabel("Terminal", header)
        self.title.setObjectName("Title")
        hbox.addWidget(self.title)

        self.drawer_toggle = QToolButton(header)
        self.drawer_toggle.setObjectName("TaskDrawerToggle")
        self.drawer_toggle.setArrowType(Qt.RightArrow)
        self.drawer_toggle.setAutoRaise(True)
        self.drawer_toggle.setFocusPolicy(Qt.NoFocus)
        self.drawer_toggle.setToolTip("Show Tasks (Alt+T)")
        self.drawer_toggle.clicked.connect(self._toggle_task_drawer)
        hbox.addWidget(self.drawer_toggle)

        hbox.addStretch(1)

        self.led = BridgeLED(self.theme, tooltip="Codex Bridge")
        hbox.addWidget(self.led, 0, Qt.AlignVCenter)
        self.interpreter_caption = QLabel("Interpreter: On" if interpreter_default else "Interpreter: Off", header)
        self.interpreter_caption.setObjectName("InterpreterCaption")
        hbox.addWidget(self.interpreter_caption, 0, Qt.AlignVCenter)
        self.interpreter_toggle = ToggleSwitch(self.theme, header)
        self.interpreter_toggle.setObjectName("InterpreterToggle")
        self.interpreter_toggle.setChecked(interpreter_default)
        self.interpreter_toggle.setToolTip(self._interpreter_tooltip)
        self.interpreter_toggle.toggled.connect(self._on_interpreter_toggled)
        hbox.addWidget(self.interpreter_toggle, 0, Qt.AlignVCenter)
        self.model_label = QLabel(self._model_label_text(), header)
        self.model_label.setObjectName("ModelLabel")
        hbox.addWidget(self.model_label)

        self.btn_codex_start = QPushButton("Start Codex + Bridge", header)
        self.btn_codex_start.setObjectName("AccentBtn")
        self.btn_codex_start.clicked.connect(self._start_codex_bridge)
        hbox.addWidget(self.btn_codex_start)

        self.btn_codex_stop = QPushButton("Stop", header)
        self.btn_codex_stop.setObjectName("AccentBtn")
        self.btn_codex_stop.clicked.connect(self._stop_codex_bridge)
        self.btn_codex_stop.setEnabled(False)
        hbox.addWidget(self.btn_codex_stop)

        self.btn_show = QPushButton("Show CMD", header)
        self.btn_show.clicked.connect(lambda: self.bridge.show())
        hbox.addWidget(self.btn_show)
        self.btn_hide = QPushButton("Hide CMD", header)
        self.btn_hide.clicked.connect(lambda: self.bridge.hide())
        hbox.addWidget(self.btn_hide)

        self.attach_btn = QPushButton("Attach Image", header)
        self.attach_btn.setObjectName("AccentBtn")
        self.attach_btn.clicked.connect(self._attach_image)
        hbox.addWidget(self.attach_btn)
        root.addWidget(header)

        self.view = ConversationView(self.theme, main_frame)
        root.addWidget(self.view, 1)
        self.view.append_message("system", self._intro_message())

        ibar = QFrame(main_frame)
        ibar.setObjectName("InputBar")
        ibox = QHBoxLayout(ibar)
        ibox.setContentsMargins(10, 8, 10, 10)
        ibox.setSpacing(8)
        self.input = ChatInput(self, ibar)
        self.input.setObjectName("InputMulti")
        self.input.setPlaceholderText("Type a message…  (Ctrl+Enter → Codex • Alt+Enter local reply)")
        self.input.setFixedHeight(4 * self.input.fontMetrics().lineSpacing())
        self.input.imagesReady.connect(self._on_images_from_editor)
        self.input.referenceAccepted.connect(self._on_reference_accepted)
        ibox.addWidget(self.input, 1)
        self.send_codex_btn = QPushButton("Send → Codex", ibar)
        self.send_codex_btn.clicked.connect(self._send_to_codex)
        ibox.addWidget(self.send_codex_btn)
        self.send_btn = QPushButton("Local Reply", ibar)
        self.send_btn.setObjectName("AccentBtn")
        self.send_btn.clicked.connect(self._on_send_local)
        ibox.addWidget(self.send_btn)
        root.addWidget(ibar)

        outer.addWidget(main_frame, 1)
        self.task_drawer = TaskDrawer(session_id=self.session_id, parent=self)
        self.task_drawer.hide()
        outer.addWidget(self.task_drawer, 0)
        self._drawer_width = self.task_drawer.width()

        self._base_min_width = 980
        self._base_min_height = 600
        self.setMinimumSize(self._base_min_width, self._base_min_height)
        self._update_drawer_toggle(False)
        QTimer.singleShot(0, self._propagate_minimums)

        # Signals
        self.append_signal.connect(self._render_message)
        self.state_signal.connect(self._set_busy)
        self.codex_status_signal.connect(self._on_codex_status)
        self.codex_led_signal.connect(self._handle_led_state)
        self.codex_output_signal.connect(self._on_codex_output)

        try:
            self._task_bus_handles.append(subscribe("task.conversation", self._handle_task_conversation))
        except Exception:
            logger.exception("Failed to subscribe to task conversation events")
        self.destroyed.connect(lambda *_: self._teardown_task_bus())

        # Shortcuts
        self._add_shortcut("Ctrl+Return", self._send_to_codex)  # primary to Codex
        self._add_shortcut("Alt+Return", self._on_send_local)
        self._add_shortcut("Alt+T", self._toggle_task_drawer)
        self._refresh_interpreter_toggle_enabled()

    # ----- helpers -----
    def _ui_hwnd(self) -> int:
        try:
            wh = self.window().windowHandle()
            return int(wh.winId()) if wh else 0
        except Exception:
            return 0

    def _add_shortcut(self, key: str, fn):
        act = QAction(self); act.setShortcut(QKeySequence(key)); act.triggered.connect(fn); self.addAction(act)

    def _update_interpreter_caption(self, enabled: bool) -> None:
        if hasattr(self, "interpreter_caption"):
            text = "Interpreter: On" if enabled else "Interpreter: Off"
            self.interpreter_caption.setText(text)

    def _refresh_interpreter_toggle_enabled(self) -> None:
        if not hasattr(self, "interpreter_toggle"):
            return
        allow = self.bridge.running() and self._led_state in {"yellow", "green"}
        self.interpreter_toggle.setEnabled(allow)
        tooltip = self._interpreter_tooltip
        if not allow:
            tooltip = (
                f"{self._interpreter_tooltip}\nBridge offline — start Codex to change automation."
            )
        self.interpreter_toggle.setToolTip(tooltip)
        self._update_interpreter_caption(self.interpreter_toggle.isChecked())

    def _current_min_width(self, opened: Optional[bool] = None) -> int:
        if opened is None:
            opened = self.task_drawer.isVisible()
        extra = self._drawer_width if opened else 0
        return self._base_min_width + extra

    def _propagate_minimums(self, opened: Optional[bool] = None) -> None:
        min_width = self._current_min_width(opened)
        min_height = self._base_min_height
        self.setMinimumSize(min_width, min_height)
        parent = self.parentWidget()
        handled = False
        while parent is not None:
            if hasattr(parent, "set_content_min_size"):
                parent.set_content_min_size(min_width, min_height)
                handled = True
                break
            if hasattr(parent, "setMinimumSize"):
                parent.setMinimumSize(max(parent.minimumWidth(), min_width), max(parent.minimumHeight(), min_height))
            if hasattr(parent, "resize"):
                parent.resize(max(parent.width(), min_width), max(parent.height(), min_height))
            parent = parent.parentWidget()
        if not handled:
            parent = self.parentWidget()
            if parent and hasattr(parent, "setMinimumSize"):
                parent.setMinimumSize(max(parent.minimumWidth(), min_width), max(parent.minimumHeight(), min_height))

    def _update_drawer_toggle(self, opened: bool) -> None:
        arrow = Qt.LeftArrow if opened else Qt.RightArrow
        self.drawer_toggle.setArrowType(arrow)
        tooltip = "Hide Tasks (Alt+T)" if opened else "Show Tasks (Alt+T)"
        self.drawer_toggle.setToolTip(tooltip)

    def _toggle_task_drawer(self):
        focus_before = QApplication.focusWidget()
        visible = self.task_drawer.isVisible()
        if visible:
            self.task_drawer.hide()
            self._propagate_minimums(False)
        else:
            self.task_drawer.refresh()
            self.task_drawer.show()
            self._drawer_width = max(self._drawer_width, self.task_drawer.width())
            self._propagate_minimums(True)
        self._update_drawer_toggle(not visible)
        if (
            focus_before
            and focus_before is not self.drawer_toggle
            and not self.task_drawer.isAncestorOf(focus_before)
        ):
            QTimer.singleShot(0, lambda w=focus_before: w.setFocus(Qt.ShortcutFocusReason))

    def _codex_status(self, msg: str):
        self.codex_status_signal.emit(msg)

    @Slot(str)
    def _on_codex_status(self, message: str) -> None:
        self.view.append_message("system", message)

    @Slot(str)
    def _handle_led_state(self, state: str) -> None:
        self._led_state = state or "red"
        self.led.set_state(state)
        self._refresh_interpreter_toggle_enabled()

    def _on_interpreter_toggled(self, checked: bool) -> None:
        enabled = bool(checked)
        self.settings["enable_interpreter"] = enabled
        self._update_interpreter_caption(enabled)
        if hasattr(self, "codex_interpreter"):
            self.codex_interpreter.set_enabled(enabled)
        settings = load_codex_settings()
        settings["enable_interpreter"] = enabled
        save_codex_settings(settings)
        self._refresh_interpreter_toggle_enabled()

    def _load_session_notes(self) -> List[Dict[str, str]]:
        try:
            return load_session_notes()
        except Exception:
            return []

    def _memory_messages(self) -> List[Dict[str, str]]:
        if not self.session_notes:
            return []
        recent = self.session_notes[-5:]
        lines = [f"- {entry.get('notes', '')}" for entry in recent if entry.get("notes")]
        payload = "\n".join(lines).strip()
        if not payload:
            return []
        return [{"role": "system", "content": f"Prior session notes:\n{payload}"}]

    def _summarize_memory_note(self, text: str, images: List[Path]) -> Optional[str]:
        base = text.strip()
        if not base:
            if images:
                names = ", ".join(ip.name for ip in images)
                base = f"User shared images: {names}"
            else:
                return None
        if len(base) > 240:
            base = base[:237].rstrip() + "..."
        return base

    def _store_session_note(self, text: str, images: List[Path]) -> None:
        summary = self._summarize_memory_note(text, images)
        if not summary:
            return
        entry = append_session_note(summary)
        self.session_notes.append(entry)

    @staticmethod
    def _parse_codex_approval_events(delta: str) -> List[ParsedCodexEvent]:
        if not delta:
            return []

        def strip_prompt_leader(value: str) -> str:
            if not value:
                return value
            idx = 0
            saw_prompt = False
            length = len(value)
            while idx < length:
                ch = value[idx]
                if ch.isspace():
                    idx += 1
                    continue
                code_point = ord(ch)
                if 0x2500 <= code_point <= 0x259F:
                    saw_prompt = True
                    idx += 1
                    continue
                break
            if saw_prompt:
                while idx < length and value[idx].isspace():
                    idx += 1
                return value[idx:]
            return value

        lines = [strip_prompt_leader(line) for line in delta.splitlines()]
        events: List[ParsedCodexEvent] = []
        buffer: List[str] = []
        pending_actions: List[str] = []

        def flush_buffer() -> None:
            if not buffer:
                return
            text = "\n".join(buffer).strip("\n")
            if text.strip():
                events.append(ParsedCodexEvent("text", text))
            buffer.clear()

        def is_header(line: str) -> bool:
            normalized = strip_prompt_leader(line)
            stripped = normalized.strip()
            if not stripped:
                return False
            if _APPROVAL_HEADER_RE.match(stripped):
                return True
            lowered = stripped.lower()
            if ":" in stripped:
                prefix = stripped.split(":", 1)[0].strip().lower()
                if any(prefix.startswith(p) for p in _APPROVAL_HEADER_PREFIXES):
                    return True
            if any(lowered.startswith(p) for p in _APPROVAL_HEADER_PREFIXES):
                if "?" in stripped or "option" in lowered or "action" in lowered or "selection" in lowered:
                    return True
            if any(phrase in lowered for phrase in ("select an option", "choose an option", "make a selection")):
                return True
            return False

        def is_dismissal(line: str) -> bool:
            return bool(_APPROVAL_DISMISS_RE.search(line))

        def line_is_prompt_content(line: str) -> bool:
            normalized_line = strip_prompt_leader(line)
            stripped = normalized_line.strip()
            if not stripped:
                return False
            if stripped.startswith((">", "-", "•")):
                return True
            if normalized_line.startswith(" "):
                return True
            if re.match(r"^[\[(<].+[\])>]", stripped):
                return True
            if re.match(r"^\d+\s*[\).:-]", stripped):
                return True
            lowered = stripped.lower()
            for aliases in _APPROVAL_ACTION_ALIASES.values():
                if any(alias in lowered for alias in aliases):
                    return True
            if any(keyword in lowered for keyword in ("allow", "approve", "command", "run")):
                return True
            return False

        def _split_option_columns(text: str) -> List[str]:
            parts = re.split(r"\s{2,}", text.strip())
            return [part.strip() for part in parts if part.strip()]

        def _clean_token(value: str) -> str:
            return value.strip().strip("[](){}<>")

        def parse_option_line(line: str) -> Tuple[List[Tuple[str, str]], bool]:
            nonlocal pending_actions
            stripped = strip_prompt_leader(line).strip()
            if not stripped:
                pending_actions = []
                return [], False

            match = re.match(r"^[\s>*-]*[\[(<]\s*([^\])>]+)\s*[\])>]\s*(.+)$", stripped)
            if match:
                return [(match.group(1).strip(), match.group(2).strip())], True
            match = re.match(r"^[\s>*-]*([A-Za-z0-9]+)\s*[:\).\-]\s*(.+)$", stripped)
            if match:
                return [(match.group(1).strip(), match.group(2).strip())], True
            match = re.match(r"^(.+?)\s*[\[(<]\s*([^\])>]+)\s*[\])>]\s*$", stripped)
            if match:
                label = match.group(1).strip()
                token = match.group(2).strip()
                return [(token, label)], True

            columns = _split_option_columns(stripped)

            if pending_actions:
                if not columns and pending_actions:
                    columns = stripped.split()
                if columns:
                    if len(columns) >= len(pending_actions):
                        tokens: List[Tuple[str, str]] = []
                        for label, token in zip(pending_actions, columns):
                            cleaned = _clean_token(token)
                            if cleaned:
                                tokens.append((cleaned, label))
                        pending_actions = []
                        return tokens, True
                    pending_actions = []
                    return [], True
                pending_actions = []
                return [], False

            if len(columns) >= 2:
                recognized_labels: List[str] = []
                for column in columns:
                    if not canonical_action(column):
                        recognized_labels = []
                        break
                    recognized_labels.append(column)
                if len(recognized_labels) >= 2:
                    pending_actions = recognized_labels
                    return [], True

            return [], False

        def canonical_action(text: str) -> Optional[str]:
            lowered = text.lower()
            for action, aliases in _APPROVAL_ACTION_ALIASES.items():
                if any(alias in lowered for alias in aliases):
                    return action
            return None

        def build_prompt(block_lines: List[str]) -> Optional[ApprovalPrompt]:
            if not block_lines:
                return None
            header = block_lines[0].strip()
            body_lines: List[str] = []
            tokens: Dict[str, str] = {}
            for raw in block_lines[1:]:
                if is_dismissal(raw):
                    continue
                options, consumed = parse_option_line(raw)
                if options:
                    for token, label in options:
                        action = canonical_action(label)
                        if action:
                            tokens[action] = token.strip()
                    continue
                if consumed:
                    continue
                body_lines.append(raw)

            while body_lines and not body_lines[0].strip():
                body_lines.pop(0)
            while body_lines and not body_lines[-1].strip():
                body_lines.pop()

            body = "\n".join(body_lines)
            options = DEFAULT_APPROVAL_TOKENS.copy()
            for action, token in tokens.items():
                if token:
                    options[action] = token
            return ApprovalPrompt(header=header, body=body, options=options)

        def collect_block(start: int) -> Tuple[List[str], int, Optional[str]]:
            block = [lines[start]]
            idx = start + 1
            dismissal: Optional[str] = None
            while idx < len(lines):
                current = lines[idx]
                if is_header(current):
                    break
                if is_dismissal(current):
                    dismissal = current.strip()
                    block.append(current)
                    idx += 1
                    break
                block.append(current)
                if not current.strip():
                    lookahead = idx + 1
                    while lookahead < len(lines) and not lines[lookahead].strip():
                        block.append(lines[lookahead])
                        lookahead += 1
                    if lookahead >= len(lines):
                        idx = lookahead
                        break
                    if not line_is_prompt_content(lines[lookahead]):
                        idx = lookahead
                        break
                    idx = lookahead
                    continue
                idx += 1
            return block, idx, dismissal

        i = 0
        while i < len(lines):
            line = lines[i]
            if is_dismissal(line):
                flush_buffer()
                events.append(ParsedCodexEvent("dismissal", line.strip()))
                i += 1
                continue
            if is_header(line):
                flush_buffer()
                block, i, dismissal = collect_block(i)
                prompt = build_prompt(block)
                if prompt:
                    events.append(ParsedCodexEvent("prompt", prompt))
                else:
                    text = "\n".join(block).strip("\n")
                    if text.strip():
                        events.append(ParsedCodexEvent("text", text))
                if dismissal:
                    events.append(ParsedCodexEvent("dismissal", dismissal))
                continue
            buffer.append(line)
            i += 1

        flush_buffer()
        return events

    def _dismiss_active_approvals(self, reason: str) -> None:
        note = reason.strip() if reason else "Approval dismissed."
        for widget in self._approval_widgets:
            if widget.is_active():
                widget.mark_dismissed(note)

    def _handle_approval_decision(
        self,
        widget: ApprovalPromptWidget,
        action: str,
        token: str,
    ) -> None:
        if not self.bridge.running() or not self.bridge.pid:
            widget.mark_failed("Bridge inactive")
            self.view.append_message("system", "[Codex] Bridge not active. Unable to send approval.")
            return
        ok = self.bridge.send_text(token)
        if not ok:
            widget.mark_failed("Send failed")
            self._codex_status("[Codex] Approval send failed.")
            self.codex_led_signal.emit("red")
            return
        widget.mark_submitted(action)
        label = APPROVAL_ACTION_TITLES.get(action, action.title())
        self._codex_status(f"[Codex] Approval → {label}")
        self.codex_led_signal.emit("yellow")
        self.bridge.press_enter_async(self._ui_hwnd())

    @Slot(str)
    def _on_codex_output(self, reply_text: str):
        trimmed = reply_text.strip()
        if not trimmed:
            return
        if trimmed.lower() in _APPROVAL_TOKEN_STRINGS:
            return
        self._record_message("assistant", reply_text, [])
        events = self._parse_codex_approval_events(reply_text)
        if hasattr(self, "codex_interpreter"):
            self.codex_interpreter.observe_codex_output(reply_text)
        if not events:
            self.append_signal.emit(ChatMessage("assistant", reply_text, []))
            return

        for event in events:
            if event.kind == "text":
                text = str(event.payload)
                if text.strip():
                    self.append_signal.emit(ChatMessage("assistant", text, []))
            elif event.kind == "prompt":
                prompt = event.payload
                if isinstance(prompt, ApprovalPrompt):
                    self.append_signal.emit(
                        ChatMessage(
                            "assistant",
                            prompt.as_text(),
                            [],
                            kind="approval",
                            meta={"prompt": prompt},
                        )
                    )
                else:
                    text = str(prompt)
                    if text.strip():
                        self.append_signal.emit(ChatMessage("assistant", text, []))
            elif event.kind == "dismissal":
                reason = str(event.payload)
                self._dismiss_active_approvals(reason)
                if reason.strip():
                    self.append_signal.emit(ChatMessage("system", reason, []))

    def _model_label_text(self) -> str:
        return "Model: " f"<span style='color:{self.theme.model_name};font-weight:600'>{self.settings.get('chat_model', DEFAULT_CHAT_MODEL)}</span>"

    def _intro_message(self) -> str:
        return (
            f"{self.settings.get('chat_model', DEFAULT_CHAT_MODEL)} ready. "
            f"Local Ollama only (OCR/vision/embeddings). Context={self.context_pairs} pairs.\n"
            f"Vision-OCR={self.settings.get('vision_ocr_model', DEFAULT_VISION_OCR_MODEL)}. "
            f"Vision={self.settings.get('vision_model', DEFAULT_VISION_MODEL)}. "
            f"Embedder={self.settings.get('embed_model', DEFAULT_EMBED_MODEL)}.\n"
            "Codex-first terminal: Send → Codex (Ctrl+Enter). LED shows bridge health."
            " Type a file or folder fragment and press Tab to insert a workspace reference."
        )

    # ----- images -----
    @Slot(list)
    def _on_images_from_editor(self, paths: List[Path]):
        if not paths: return
        attached: List[Path] = []
        for p in paths:
            try:
                if p.suffix.lower() != ".png": p = self._convert_to_png(p)
                attached.append(p)
            except Exception: pass
        if attached:
            self.pending_images.extend(attached)
            lines = [f"Attached: {a.name}" for a in attached]
            if self.settings.get("enable_vision", True):
                lines.append("Images will be summarized on your next message.")
            self.view.append_message("system", "\n".join(lines))
            for a in attached:
                self.input.append(f'view_image "{a.as_posix()}"')

    @Slot(dict)
    def _on_reference_accepted(self, payload: Dict[str, str]) -> None:
        if not isinstance(payload, dict):
            return
        path = str(payload.get("path") or "").strip()
        if not path:
            return
        kind = str(payload.get("type") or "file")
        self._recent_input_references.append({"path": path, "type": kind})

    @Slot()
    def _attach_image(self):
        paths, _ = QFileDialog.getOpenFileNames(
            self,
            "Attach image(s)",
            str(agent_images_dir()),
            "Images (*.png *.jpg *.jpeg *.webp *.bmp *.gif)",
        )
        if not paths: return
        attached: List[Path] = []
        for sp in paths:
            p = Path(sp)
            try:
                out = self._convert_to_png(p); attached.append(out)
            except Exception as e:
                self.view.append_message("assistant", f"Image attach failed: {e}")
        if attached:
            self.pending_images.extend(attached)
            lines = [f"Attached: {a.name}" for a in attached]
            if self.settings.get("enable_vision", True):
                lines.append("Images will be summarized on your next message.")
            self.view.append_message("system", "\n".join(lines))
            for a in attached:
                self.input.append(f'view_image "{a.as_posix()}"')

    def _convert_to_png(self, p: Path) -> Path:
        out = agent_images_dir() / (slug(p.stem) + ".png")
        ensure_dir(out.parent)
        if PIL_AVAILABLE:
            with Image.open(p) as im:
                im = im.convert("RGBA"); im.save(out, "PNG", optimize=True)
        else:
            shutil.copy2(p, out)
        return out

    # ----- local reply flow -----
    @Slot()
    def _on_send_local(self):
        if self.busy: return
        text = self.input.toPlainText().strip()
        images = self.pending_images
        if not text and not images:
            return
        references = self.input.consume_references()
        if text.startswith("/"):
            if images:
                self.pending_images = []
                self._emit_system_notice("Commands cannot include attached images.")
                self.input.clear()
                return
            handled = self._handle_command(text, references)
            if handled:
                self.pending_images = []
                self.input.clear()
                return
        self.pending_images = []
        self._record_message("user", text or "(image)", images, references=references)
        self.append_signal.emit(ChatMessage("user", text or "(image)", images))
        self.input.clear()
        threading.Thread(target=self._infer_thread, args=(text, images), daemon=True).start()

    def _handle_command(self, text: str, references: List[Dict[str, str]]) -> bool:
        try:
            tokens = shlex.split(text)
        except ValueError as exc:
            self._record_message("user", text, [], references=references)
            self.append_signal.emit(ChatMessage("user", text, []))
            self._emit_system_notice(f"Command parse error: {exc}")
            return True
        if not tokens:
            return False
        cmd = tokens[0].lower()
        if cmd == "/tasks":
            self._record_message("user", text, [], references=references)
            self.append_signal.emit(ChatMessage("user", text, []))
            self._command_tasks_list()
            return True
        if cmd != "/task":
            return False

        if len(tokens) < 2:
            self._record_message("user", text, [], references=references)
            self.append_signal.emit(ChatMessage("user", text, []))
            self._emit_system_notice(
                "Usage: /task \"title\" | /task <id> status <state> | /task <id> note <text>"
            )
            return True

        subject = tokens[1]
        is_task_id = self._looks_like_task_id(subject)

        if is_task_id and len(tokens) >= 3:
            action = tokens[2].lower()
            self._record_message("user", text, [], references=references)
            self.append_signal.emit(ChatMessage("user", text, []))
            if action == "status":
                status = tokens[3].lower() if len(tokens) >= 4 else ""
                self._command_task_status(subject, status)
                return True
            if action == "note":
                note_text = " ".join(tokens[3:]).strip()
                self._command_task_note(subject, note_text)
                return True
            self._emit_system_notice(
                "Usage: /task <id> status <state> | /task <id> note <text>"
            )
            return True

        title = " ".join(tokens[1:]).strip()
        self._record_message("user", text, [], references=references)
        self.append_signal.emit(ChatMessage("user", text, []))
        if not title:
            self._emit_system_notice("Task title required.")
        else:
            self._command_task_create(title)
        return True

    def _command_task_create(self, title: str) -> None:
        now = datetime.now(UTC).timestamp()
        task_id = f"tsk_{datetime.now(UTC).strftime('%Y%m%d%H%M%S')}_{uuid.uuid4().hex[:6]}"
        task = Task(
            id=task_id,
            title=title,
            status="open",
            created_ts=now,
            updated_ts=now,
            session_id=self.session_id,
            source="terminal",
            codex_conversation_id=self.session_id,
        )
        try:
            append_task(task)
            append_event(TaskEvent(ts=now, task_id=task_id, event="created", by="terminal"))
        except Exception as exc:
            log_exception("Task creation failed", exc)
            self._emit_system_notice(f"Failed to create task: {exc}")
            return

        publish("task.created", task.to_dict())
        publish("task.updated", task.to_dict())
        self._emit_system_notice(f"Task created [{task_id}]: {title}")

    def _command_task_status(self, task_id: str, status: str) -> None:
        status_key = status.lower().strip()
        if status_key not in self._TASK_STATUSES:
            allowed = ", ".join(sorted(self._TASK_STATUSES))
            self._emit_system_notice(f"Unknown status '{status}'. Allowed: {allowed}.")
            return
        now = datetime.now(UTC).timestamp()
        try:
            updated = update_task(task_id, status=status_key, updated_ts=now)
            append_event(
                TaskEvent(
                    ts=now,
                    task_id=task_id,
                    event="status",
                    by="terminal",
                    to=status_key,
                )
            )
        except ValueError:
            self._emit_system_notice(f"Task not found: {task_id}")
            return
        except Exception as exc:
            log_exception("Task status update failed", exc)
            self._emit_system_notice(f"Failed to update task {task_id}: {exc}")
            return

        publish("task.status", {"id": updated.id, "status": updated.status})
        publish("task.updated", updated.to_dict())
        if status_key == "deleted":
            publish("task.deleted", {"id": updated.id})
        self._emit_system_notice(f"Task {task_id} status → {status_key}")

    def _command_task_note(self, task_id: str, note_text: str) -> None:
        note = note_text.strip()
        if not note:
            self._emit_system_notice("Task note cannot be empty.")
            return
        task = self._load_task(task_id)
        if task is None:
            self._emit_system_notice(f"Task not found: {task_id}")
            return

        dataset_dir = self.task_drawer.panel.dataset_path.parent
        try:
            _, relative, created = append_run_log(
                task,
                f"[{_utc_iso()}] {note}",
                dataset_dir,
            )
        except Exception as exc:
            log_exception("Task run-log write failed", exc)
            self._emit_system_notice(f"Failed to record note for {task_id}: {exc}")
            return

        now = datetime.now(UTC).timestamp()
        changes: Dict[str, Any] = {"updated_ts": now}
        if not task.run_log_path or created:
            changes["run_log_path"] = relative
        try:
            updated = update_task(task_id, **changes)
            append_event(
                TaskEvent(
                    ts=now,
                    task_id=task_id,
                    event="note",
                    by="terminal",
                    data={"text": note},
                )
            )
        except ValueError:
            self._emit_system_notice(f"Task not found: {task_id}")
            return
        except Exception as exc:
            log_exception("Task dataset update failed", exc)
            self._emit_system_notice(f"Failed to update task {task_id}: {exc}")
            return

        publish("task.updated", {**updated.to_dict(), "last_note": note})
        self._emit_system_notice(f"Task {task_id} note recorded.")

    def _command_tasks_list(self) -> None:
        self.task_drawer.refresh()
        tasks = [task for task in self._load_tasks() if task.session_id == self.session_id]
        if not tasks:
            self._emit_system_notice("No tasks recorded for this session yet.")
            return
        tasks.sort(key=lambda t: t.updated_ts, reverse=True)
        lines = []
        for task in tasks:
            added = task.diffs.added if task.diffs else 0
            removed = task.diffs.removed if task.diffs else 0
            timestamp = self._format_timestamp(task.updated_ts)
            lines.append(
                f"- [{task.status}] {task.id}: {task.title} (+{added} −{removed}) @ {timestamp}"
            )
        body = "Tasks for this session:\n" + "\n".join(lines)
        self._emit_system_notice(body)

    def _load_tasks(self) -> List[Task]:
        path = self.task_drawer.panel.dataset_path
        if not path.exists():
            return []
        records: List[Task] = []
        with path.open("r", encoding="utf-8") as fh:
            for line in fh:
                line = line.strip()
                if not line:
                    continue
                try:
                    payload = json.loads(line)
                    records.append(Task.from_dict(payload))
                except Exception:
                    continue
        return records

    @staticmethod
    def _looks_like_task_id(candidate: str) -> bool:
        return bool(candidate) and bool(re.match(r"^tsk_[\w-]+", candidate))

    @staticmethod
    def _format_timestamp(ts: float) -> str:
        try:
            dt = datetime.fromtimestamp(float(ts))
        except Exception:
            return "--"
        return dt.strftime("%H:%M:%S")

    def _emit_system_notice(self, message: str) -> None:
        self._record_message("system", message, [])
        self.append_signal.emit(ChatMessage("system", message, []))

    def _error_console(self) -> Optional[ErrorConsole]:
        window = self.window()
        if window and hasattr(window, "error_console"):
            console = getattr(window, "error_console")
            if isinstance(console, ErrorConsole):
                return console
        return None

    @Slot(str)
    def _log_error_center(self, message: str) -> None:
        console = self._error_console()
        if console:
            console.log(message)

    @Slot(str)
    def _handle_error_notice(self, message: str) -> None:
        self._emit_system_notice(message)

    def detach_safety_notifier(self) -> None:
        if self._safety_notifier_id:
            safety_manager.remove_notifier(self._safety_notifier_id)
            self._safety_notifier_id = ""

    # ----- send to Codex -----
    @Slot()
    def _send_to_codex(self):
        txt = self.input.toPlainText().strip()
        if not txt:
            return
        if not self.bridge.running() or not self.bridge.pid:
            self.view.append_message("system", "[Codex] Bridge not active. Use Start Codex + Bridge.")
            return

        snapshot_refs: List[Dict[str, str]] = list(getattr(self.input, "_accepted_references", []))
        send_txt, notices = self._build_codex_prompt(txt, snapshot_refs, include_context=True)
        if not send_txt:
            self.view.append_message("system", f"→ Codex: {txt} ✗")
            return

        ok = self.bridge.send_text(send_txt)
        if ok:
            references = self.input.consume_references()
            self._record_message("user", txt, [], references=references)
            if hasattr(self, "codex_interpreter"):
                self.codex_interpreter.observe_user(txt)
            self.view.append_message("system", f"→ Codex: {txt} ✓")
            self.input.clear()
            # Immediately press Enter (non-blocking) and bring focus back
            self.bridge.press_enter_async(self._ui_hwnd())
            for note in notices:
                self._emit_system_notice(note)
        else:
            self.view.append_message("system", f"→ Codex: {txt} ✗")

    def _send_codex_auto(self, text: str) -> bool:
        payload, notices = self._build_codex_prompt(text.strip(), [], include_context=False)
        if not payload:
            return False
        ok = self.bridge.send_text(payload)
        if not ok:
            return False
        self.bridge.press_enter_async(self._ui_hwnd())
        for note in notices:
            self._emit_system_notice(note)
        return True

    def _handle_auto_follow_up(self, command: str) -> None:
        message = command.strip()
        if not message:
            return
        note = f"[Codex] Auto-continue → {message}"
        self._record_message("system", note, [])
        self.messages.append(ChatMessage("system", note, []))
        self.view.append_message("system", note)

    def _build_codex_prompt(
        self,
        text: str,
        references: Optional[List[Dict[str, str]]],
        *,
        include_context: bool,
    ) -> Tuple[str, List[str]]:
        references = references or []
        context_lines: List[str] = []
        if include_context and self.share_context:
            k = max(1, self.share_limit)
            if self.settings.get("enable_semantic", True):
                recs = self.conv.retrieve(text, k=k)
            else:
                recs = self.conv.recent(k)
            context_lines = [f"{r.get('role', 'user')}: {r.get('text', '')}" for r in recs]

        model = str(self.settings.get("chat_model", DEFAULT_CHAT_MODEL))
        guard_enabled = bool(
            self.settings.get(
                "reference_token_guard",
                DEFAULT_SETTINGS.get("reference_token_guard", True),
            )
        )
        headroom_pct = int(
            self.settings.get(
                "reference_token_headroom",
                DEFAULT_SETTINGS.get("reference_token_headroom", 80),
            )
        )
        budget = token_budget.prompt_token_budget(model, headroom_pct) if guard_enabled else 0
        message_tokens = token_budget.count_tokens(text, model)

        context_entries: List[Tuple[str, int]] = []
        for line in context_lines:
            context_entries.append((line, token_budget.count_tokens(line, model)))

        base_tokens = message_tokens + sum(tokens for _, tokens in context_entries)
        notices: List[str] = []

        if guard_enabled and budget > 0:
            dropped = 0
            while context_entries and base_tokens > budget:
                _, tokens = context_entries.pop(0)
                base_tokens -= tokens
                dropped += 1
            if dropped:
                plural = "s" if dropped != 1 else ""
                notices.append(
                    f"[Codex] Dropped {dropped} context item{plural} to fit the token budget."
                )
            if base_tokens > budget:
                notices.append(
                    "[Codex] Message exceeds the available token budget; reference contents skipped."
                )
                base_tokens = message_tokens
                context_entries.clear()

        context_lines = [line for line, _ in context_entries]
        payloads, payload_notices = self._reference_payloads(references)
        notices.extend(payload_notices)

        if guard_enabled and budget > 0:
            available = max(0, budget - base_tokens)
            included: List[str] = []
            skipped = 0
            for payload in payloads:
                tokens = token_budget.count_tokens(payload, model)
                if tokens <= available:
                    included.append(payload)
                    available -= tokens
                else:
                    skipped += 1
            if skipped:
                plural = "s" if skipped != 1 else ""
                notices.append(
                    f"[Codex] Skipped {skipped} reference payload{plural} due to token limits."
                )
            payloads = included

        base_section = "\n".join(context_lines + [text]) if context_lines else text
        parts: List[str] = []
        if base_section.strip():
            parts.append(base_section.strip())
        for payload in payloads:
            segment = payload.strip()
            if segment:
                parts.append(segment)
        return "\n\n".join(parts), notices

    def _reference_payloads(
        self, references: List[Dict[str, str]]
    ) -> Tuple[List[str], List[str]]:
        payloads: List[str] = []
        notices: List[str] = []
        embed_contents = bool(
            self.settings.get(
                "reference_embed_contents",
                DEFAULT_SETTINGS.get("reference_embed_contents", True),
            )
        )
        if not embed_contents:
            return payloads, notices

        for ref in references:
            path = str(ref.get("path") or "").strip()
            if not path:
                continue
            display = path
            candidate = Path(path)
            if not candidate.is_absolute():
                candidate = (self.workspace / path).resolve()
            else:
                candidate = candidate.resolve()

            if not candidate.exists():
                notices.append(f"[Codex] Reference missing: {display}")
                continue

            if candidate.is_dir():
                try:
                    entries = sorted(p.name for p in candidate.iterdir())
                except Exception as exc:
                    notices.append(f"[Codex] Could not read directory {display}: {exc}")
                    continue
                listing = "\n".join(entries[:50])
                payloads.append(f"# Directory: {display}\n{listing}")
                continue

            try:
                content = candidate.read_text(encoding="utf-8", errors="replace")
            except Exception as exc:
                notices.append(f"[Codex] Could not read {display}: {exc}")
                continue

            body = content.rstrip()
            if body:
                payloads.append(f"# Reference: {display}\n```\n{body}\n```")
            else:
                payloads.append(f"# Reference: {display}\n(Empty file.)")

        return payloads, notices

    def _teardown_task_bus(self) -> None:
        if not getattr(self, "_task_bus_handles", None):
            return
        for handle in self._task_bus_handles:
            try:
                handle.unsubscribe()
            except Exception:
                logger.exception("Failed to unsubscribe task conversation handle")
        self._task_bus_handles.clear()

    def _handle_task_conversation(self, payload: dict) -> None:
        if not isinstance(payload, dict):
            return
        conv = str(payload.get("conversation_id") or payload.get("session_id") or "").strip()
        if not conv:
            return
        label = str(payload.get("id") or conv)
        self._load_conversation_transcript(conv, label=label)

    def _load_conversation_transcript(self, conversation_id: str, *, label: str = "") -> None:
        record = self.conv.resolve_conversation(conversation_id)
        if record is None:
            self.view.append_message("system", f"[Tasks] Conversation not found: {conversation_id}")
            return
        entries: List[ChatMessage] = []
        if record.jsonl_path.exists():
            try:
                with record.jsonl_path.open("r", encoding="utf-8") as fh:
                    for line in fh:
                        line = line.strip()
                        if not line:
                            continue
                        try:
                            data = json.loads(line)
                        except json.JSONDecodeError:
                            continue
                        role = str(data.get("role") or "").strip()
                        text = data.get("text")
                        if not role or text is None:
                            continue
                        entries.append(ChatMessage(role, str(text), []))
            except Exception as exc:
                self.view.append_message("system", f"[Tasks] Failed to read conversation: {exc}")
                return
        elif record.markdown_path.exists():
            try:
                md_text = record.markdown_path.read_text(encoding="utf-8").strip()
            except Exception as exc:
                self.view.append_message("system", f"[Tasks] Failed to read conversation markdown: {exc}")
                return
            if md_text:
                entries.append(ChatMessage("system", md_text, []))

        self.messages = []
        self.view.clear()

        if entries:
            for msg in entries:
                self.messages.append(msg)
                self.view.append_message(msg.role, msg.text)
        else:
            empty_msg = ChatMessage("system", "[Tasks] Conversation log is empty.", [])
            self.messages.append(empty_msg)
            self.view.append_message(empty_msg.role, empty_msg.text)

        self._loaded_conversation_id = conversation_id
        origin = "archive" if record.source == "archive" else "session"
        note_label = label or conversation_id
        notice = ChatMessage("system", f"[Tasks] Conversation loaded ({origin}): {note_label}", [])
        self.messages.append(notice)
        self.view.append_message(notice.role, notice.text)

        if hasattr(self, "codex_interpreter") and self.codex_interpreter:
            last_user = next((m.text for m in reversed(self.messages) if m.role == "user"), "")
            if last_user:
                self.codex_interpreter.observe_user(last_user)

    # ----- Codex controls -----
    @Slot()
    def _start_codex_bridge(self):
        try:
            self.codex.ensure_ollama()
            exe = self.codex.ensure_release()
            s = load_codex_settings()
            model = s.get("model") or self.settings.get("chat_model", DEFAULT_CHAT_MODEL)

            raw_folder = str(s.get("working_folder") or "").strip()
            working_dir: Path = transit_dir()
            fallback_reason: Optional[str] = None
            candidate: Optional[Path] = None
            if raw_folder:
                try:
                    candidate = Path(raw_folder).expanduser()
                except Exception as exc:
                    fallback_reason = f"Working folder '{raw_folder}' is invalid ({exc})"
                else:
                    try:
                        if candidate.exists() and candidate.is_dir():
                            working_dir = candidate
                        elif candidate.exists():
                            fallback_reason = f"Working folder '{candidate}' is not a directory"
                        else:
                            fallback_reason = f"Working folder '{candidate}' does not exist"
                    except OSError as exc:
                        fallback_reason = f"Working folder '{candidate}' cannot be accessed ({exc})"
            else:
                fallback_reason = "Working folder not set"

            if fallback_reason:
                self.view.append_message(
                    "system",
                    (
                        f"[Codex] {fallback_reason}. Using default transit folder: "
                        f"{transit_dir()}"
                    ),
                )

            self.codex.write_config_toml(model)
            proc = self.codex.launch_codex_cmd(exe, model, working_dir)
            self.view.append_message("system", f"[Codex] Launched. PID={proc.pid}")
            self.bridge.attach(proc.pid)
            self.bridge.start()
            self.codex_led_signal.emit("yellow")
            self.btn_codex_start.setEnabled(False)
            self.btn_codex_stop.setEnabled(True)
            self._refresh_interpreter_toggle_enabled()
        except Exception as e:
            self.codex_led_signal.emit("red")
            self.view.append_message("system", f"[Codex Error] {e}")

    @Slot()
    def _stop_codex_bridge(self):
        try:
            self.bridge.stop()
            self.btn_codex_start.setEnabled(True)
            self.btn_codex_stop.setEnabled(False)
            self.view.append_message("system", "[Codex] Bridge stopped.")
            self._refresh_interpreter_toggle_enabled()
        except Exception as e:
            self.view.append_message("system", f"[Codex Error] {e}")

    # ----- core inference -----
    def _system_prompt(self) -> str:
        if hasattr(self, "_chat_prompt"):
            return self._chat_prompt.text()
        return prompt_text("chat_system")

    def _summarize_images_dual(self, images: List[Path], user_text: str) -> Tuple[List[str], List[str], str]:
        if not images:
            return [], [], ""

        ocr_list: List[str] = []
        vis_list: List[str] = []
        combined_parts: List[str] = []

        for original in images:
            path = original
            if path.suffix.lower() != ".png":
                try:
                    path = self._convert_to_png(path)
                except Exception as exc:
                    err = f"Image conversion failed for {original.name}: {exc}"
                    self.error_signal.emit(err)
                    ocr_list.append(f"[ocr-error] {err}")
                    vis_list.append("[vision-error] skipped — conversion failed")
                    continue

            ocr_res = perform_ocr(path)
            if not ocr_res.ok:
                err = f"OCR failed for {path.name}: {ocr_res.error}"
                self.error_signal.emit(err)
                ocr_md = f"[ocr-error] {ocr_res.error}"
            else:
                ocr_md = ocr_res.markdown

            try:
                ocr_path = path.with_suffix(path.suffix + ".ocr.md")
                ensure_dir(ocr_path.parent)
                ocr_path.write_text(ocr_md, encoding="utf-8")
            except Exception as exc:
                self.error_signal.emit(f"Failed to write OCR markdown for {path.name}: {exc}")

            ocr_list.append(ocr_md)

            vision_res = analyze_image(
                path,
                ocr_res.markdown if ocr_res.ok else "",
                client=self.ollama,
                model=self.settings.get("vision_model", DEFAULT_VISION_MODEL),
                user_text=user_text,
            )
            if not vision_res.ok:
                err = f"Vision summary failed for {path.name}: {vision_res.error}"
                self.error_signal.emit(err)
                vis_txt = f"[vision-error] {vision_res.error}"
            else:
                vis_txt = vision_res.summary

            try:
                vis_path = path.with_suffix(path.suffix + ".vision.md")
                ensure_dir(vis_path.parent)
                vis_path.write_text(vis_txt, encoding="utf-8")
            except Exception as exc:
                self.error_signal.emit(f"Failed to write vision markdown for {path.name}: {exc}")

            vis_list.append(vis_txt)
            combined_parts.append(f"## OCR (Markdown)\n{ocr_md}\n\n## Vision Interpretation\n{vis_txt}")

        combined = "\n\n".join(combined_parts)
        return ocr_list, vis_list, combined

    def _conversation_context(self, query: str) -> List[Dict[str, str]]:
        if not self.share_context:
            return []
        k = max(1, self.share_limit)
        if self.settings.get("enable_semantic", True):
            recs = self.conv.retrieve(query, k=k)
        else:
            recs = self.conv.recent(k)
        return [{"role": r.get("role", "user"), "content": r.get("text", "")} for r in recs]

    def _gather_context(self, query: str) -> List[Dict[str, str]]:
        memory_msgs = self._memory_messages()
        ctx = self._conversation_context(query)
        window = [{"role": m.role, "content": m.text} for m in self.messages[-2 * self.context_pairs:]]
        return memory_msgs + ctx + window

    def _record_message(
        self,
        role: str,
        text: str,
        images: List[Path],
        *,
        references: Optional[List[Dict[str, str]]] = None,
    ) -> None:
        refs: List[Dict[str, str]] = []
        if references:
            for item in references:
                if not isinstance(item, dict):
                    continue
                path = str(item.get("path") or "").strip()
                if not path:
                    continue
                kind = str(item.get("type") or "file")
                refs.append({"path": path, "type": kind})

        self.conv.append(role, text, images, references=refs or None)
        tags = self.lex.auto_tags(text)
        extra = {"references": refs} if refs else None
        self.dataset.add_entry(role, text, images, tags=tags, extra=extra)
        if role == "user":
            self._store_session_note(text, images)

    def _infer_thread(self, text: str, images: List[Path]):
        self.state_signal.emit(True)
        try:
            chat_model = self.settings.get("chat_model", DEFAULT_CHAT_MODEL)
            msgs: List[Dict[str, Any]] = [{"role": "system", "content": self._system_prompt()}]
            msgs += self._gather_context(text)
            if images and self.settings.get("enable_vision", True):
                ocr_list, vis_list, combo = self._summarize_images_dual(images, text)
                for ocr_md in ocr_list:
                    self.dataset.add_entry("assistant", ocr_md, images, tags=["vision_ocr"])
                    self.append_signal.emit(ChatMessage("assistant", f"## OCR (Markdown)\n{ocr_md}", []))
                for vis_txt in vis_list:
                    self.dataset.add_entry("assistant", vis_txt, images, tags=["vision_interpret"])
                    self.append_signal.emit(ChatMessage("assistant", f"## Vision Interpretation\n{vis_txt}", []))
                if combo:
                    self.dataset.add_entry("assistant", combo, images, tags=["vision_summary"])
                    self.conv.append("system", "_Image(s) summarized via OCR + Vision. Injected into context._", [])
                    msgs.append({"role": "system", "content": f"Image context:\n{combo}"})
            user_msg = {"role": "user", "content": text or "(image)"}
            ok, content, err = self.ollama.chat(model=chat_model, messages=msgs + [user_msg])
            if not ok: content = f"[Error] Ollama: {err or 'Unknown error'}"
            self.dataset.add_entry("assistant", content, [], tags=self.lex.auto_tags(content))
            self._record_message("assistant", content, [])
            self.append_signal.emit(ChatMessage("assistant", content, [], chat_model))
        except Exception as e:
            err = f"[Error] {e}"
            self.dataset.add_entry("assistant", err, [], tags=["error"])
            self._record_message("assistant", err, [])
            self.append_signal.emit(ChatMessage("assistant", err, []))
        finally:
            self.state_signal.emit(False)

    @Slot(ChatMessage)
    def _render_message(self, msg: ChatMessage):
        self.messages.append(msg)
        if msg.kind == "approval":
            prompt = msg.meta.get("prompt")
            if isinstance(prompt, ApprovalPrompt):
                widget = ApprovalPromptWidget(self.theme, prompt, self._handle_approval_decision)
                self._approval_widgets.append(widget)
                self.view.append_widget(widget, role="assistant", alignment=Qt.AlignLeft)
                return
        text = msg.text
        thinks = re.findall(r"<think>(.*?)</think>", text, flags=re.DOTALL)
        text = re.sub(r"<think>(.*?)</think>", "", text, flags=re.DOTALL)
        think_lines = [t.strip() for t in thinks if t.strip()] if msg.role == "assistant" else []
        model_name = msg.model_name if msg.role == "assistant" else ""
        self.view.append_message(
            msg.role,
            text,
            model_name=model_name,
            thinks=think_lines,
            images=msg.images,
        )

    @Slot(bool)
    def _set_busy(self, state: bool):
        self.busy = state
        enabled = not state
        self.send_btn.setEnabled(enabled)
        self.attach_btn.setEnabled(enabled)
        self.send_codex_btn.setEnabled(True if self.bridge.running() else True)

    @staticmethod
    def _qss(t: Theme) -> str:
        return f"""
        QFrame#ChatCard {{
            background-color: {t.card_bg};
            border: 1px solid {t.card_border};
            border-radius: {t.card_radius}px;
        }}
        QFrame#Header {{
            background-color: {t.header_bg};
            border-top-left-radius: {t.card_radius}px;
            border-top-right-radius: {t.card_radius}px;
        }}
        QLabel#Title {{ color: {t.header_text}; font-weight: 600; letter-spacing: 0.5px; }}
        QLabel#ModelLabel {{ color: {t.header_text}; }}
        QLabel#InterpreterCaption {{ color: {t.header_text}; font-weight: 600; }}
        QFrame#ConversationView {{
            background: {t.card_bg};
            border-top: 1px solid {t.card_border};
            border-bottom: 1px solid {t.card_border};
        }}
        QScrollArea#ConversationScroll {{
            background: transparent;
            border: none;
        }}
        QWidget#ConversationContainer {{
            background: {t.card_bg};
        }}
        QFrame#MessageRow {{
            background: transparent;
        }}
        QFrame#MessageBubble[role="user"] {{
            background: {t.user_bubble};
            color: {t.user_text};
            border: 1px solid {t.card_border};
            border-radius: 10px;
        }}
        QFrame#MessageBubble[role="assistant"] {{
            background: {t.ai_bubble};
            color: {t.ai_text};
            border: 1px solid {t.card_border};
            border-radius: 10px;
        }}
        QFrame#MessageBubble[role="system"] {{
            background: {t.muted};
            color: {t.ai_text};
            border: 1px solid {t.card_border};
            border-radius: 10px;
        }}
        QLabel#MessageName[role="user"] {{
            color: {t.user_text};
            font-weight: 600;
        }}
        QLabel#MessageName[role="assistant"] {{
            color: {t.model_name};
            font-weight: 600;
        }}
        QLabel#ModelNameLabel {{
            color: {t.model_name};
            font-weight: 600;
        }}
        QLabel#ThinkText {{
            color: {t.think_text};
            font-style: italic;
            font-size: 11pt;
        }}
        QLabel#MessageText {{
            font-size: 12.5pt;
        }}
        QLabel#MessageText[role="assistant"] {{
            color: {t.ai_text};
        }}
        QLabel#MessageText[role="user"] {{
            color: {t.user_text};
        }}
        QFrame#ApprovalPrompt {{
            background: {t.ai_bubble};
            border: 1px solid {t.card_border};
            border-radius: 10px;
        }}
        QLabel#ApprovalHeader {{
            color: {t.model_name};
            font-weight: 600;
        }}
        QLabel#ApprovalBody {{
            color: {t.ai_text};
            font-size: 12.5pt;
        }}
        QLabel#ApprovalStatus {{
            color: {t.think_text};
            font-style: italic;
        }}
        QPushButton#ApprovalButton {{
            background: {t.accent};
            color: #ffffff;
            border: 1px solid {t.card_border};
            border-radius: 6px;
            padding: 6px 10px;
            font-weight: 600;
        }}
        QPushButton#ApprovalButton:disabled {{
            background: #1f2d42;
            color: #8aa4c2;
            border-color: {t.card_border};
        }}
        QLabel#AttachmentLabel {{
            color: {t.header_text};
            font-family: "Cascadia Code", "Fira Code", monospace;
        }}
        QFrame#InputBar {{
            background-color: {t.card_bg};
            border-bottom-left-radius: {t.card_radius}px;
            border-bottom-right-radius: {t.card_radius}px;
        }}
        QTextEdit#InputMulti {{
            background: #0c1524;
            color: {t.ai_text};
            border: 1px solid {t.card_border};
            border-radius: 6px;
            padding: 8px 10px;
            selection-background-color: {t.accent};
            selection-color: #ffffff;
        }}
        QPushButton {{
            color: #ffffff;
            background-color: {t.accent};
            border: 1px solid {t.card_border};
            border-radius: 6px;
            padding: 6px 12px;
        }}
        QPushButton:hover {{ background-color: {t.accent_hover}; }}
        QPushButton:disabled {{ background-color: #2a3a59; color: #9fb3d4; }}
        """

# --------------------------------------------------------------------------------------
# Virtual desktop (canvas + draggable card)
# --------------------------------------------------------------------------------------

class VirtualCanvas(QWidget):
    def __init__(self, theme: Theme, parent: Optional[QWidget] = None):
        super().__init__(parent)
        self.theme = theme
        self.setAttribute(Qt.WA_OpaquePaintEvent, True)
        self.setAutoFillBackground(False)
        self._bg_manager = BackgroundManager(self)
        self._bg_manager.register(BackgroundMode.STATIC, lambda canvas: StaticImageBg(canvas))
        self._bg_manager.register(BackgroundMode.GIF, lambda canvas: GifBg(canvas))
        self._bg_manager.register(BackgroundMode.VIDEO, lambda canvas: VideoBg(canvas))
        self._bg_manager.register(BackgroundMode.GL, lambda canvas: GLViewportBg(canvas))
        self._bg_config = BackgroundConfig()

    def ensure_minimum(self, viewport_size: QSize):
        screen = self.window().windowHandle().screen() if self.window() and self.window().windowHandle() else None
        geo = (screen.availableGeometry() if screen else QGuiApplication.primaryScreen().availableGeometry())
        min_w = max(viewport_size.width(), geo.width())
        min_h = max(viewport_size.height(), geo.height())
        if self.width() != min_w or self.height() != min_h:
            self.resize(min_w, min_h)

    def paintEvent(self, _e):
        p = QPainter(self); p.setRenderHint(QPainter.Antialiasing, True)
        rect = self.rect()
        painted = self._bg_manager.paint(p, rect)
        if not painted:
            grad = QLinearGradient(rect.topLeft(), rect.bottomLeft())
            grad.setColorAt(0.0, QColor(self.theme.desktop_top))
            grad.setColorAt(0.55, QColor(self.theme.desktop_mid))
            grad.setColorAt(1.0, QColor(self.theme.desktop_top))
            p.fillRect(rect, grad)
        glow = QColor(self.theme.desktop_edge_glow); glow.setAlphaF(0.18); p.setPen(glow)
        for i in range(20):
            r = rect.adjusted(10 + i, 10 + i, -10 - i, -10 - i); p.drawRoundedRect(r, 18, 18)
        vignette = QColor(0, 0, 0, 120); p.setPen(Qt.NoPen); p.setBrush(vignette)
        path = QPainterPath(); path.addRect(rect)
        inner = rect.adjusted(30, 30, -30, -30); inner_path = QPainterPath(); inner_path.addRoundedRect(QRectF(inner), 26, 26)
        path = path.subtracted(inner_path); p.drawPath(path)

    def resizeEvent(self, event):  # pragma: no cover - Qt plumbing
        super().resizeEvent(event)
        self._bg_manager.resize(event.size())

    def background_config(self) -> BackgroundConfig:
        return BackgroundConfig.from_state(self._bg_config.to_state())

    def set_background_config(self, config: BackgroundConfig) -> None:
        self._apply_background_config(config)

    def _apply_background_config(self, config: BackgroundConfig) -> None:
        self._bg_config = BackgroundConfig.from_state(config.to_state())
        mode = self._bg_config.mode
        source = self._bg_config.source
        if mode == BackgroundMode.SOLID or not source:
            self._bg_manager.clear()
            self.update()
            return
        src_path = Path(source)
        if not src_path.exists():
            self._bg_manager.clear()
            self.update()
            return
        self._bg_manager.apply(self._bg_config)
        self.update()

class CameraView(QScrollArea):
    def __init__(self, canvas: VirtualCanvas, parent=None):
        super().__init__(parent)
        self.setFrameShape(QFrame.NoFrame)
        self.setWidgetResizable(False)
        self.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        self.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        self.setContentsMargins(0, 0, 0, 0)
        self.setViewportMargins(0, 0, 0, 0)
        self.setWidget(canvas)
        self.canvas = canvas

    def resizeEvent(self, e):
        super().resizeEvent(e)
        self.canvas.ensure_minimum(self.viewport().size())


class TerminalDesktopIcon(QToolButton):
    def __init__(
        self,
        theme: Theme,
        path: str,
        parent: QWidget,
        grid_size: Tuple[int, int],
        size_mode: str,
    ):
        super().__init__(parent)
        self.theme = theme
        self.path = path
        self._grid_size = grid_size
        self._size_mode = size_mode
        self._drag_active = False
        self._press_pos = QPoint()
        self._moved = False
        self.setAcceptDrops(False)
        self.setAutoRaise(True)
        self.setToolButtonStyle(Qt.ToolButtonTextUnderIcon)
        self.setCursor(Qt.OpenHandCursor)
        base = os.path.basename(path)
        self.setText(os.path.splitext(base)[0] if os.path.isfile(path) else base)
        self._apply_size_mode()
        self._pick_icon()
        self.setStyleSheet("QToolButton{color:#eaf2ff;}")

    # ------------------------------------------------------------------
    def set_size_mode(self, mode: str) -> None:
        mode = mode if mode in {"small", "medium", "large"} else "medium"
        if mode == self._size_mode:
            return
        self._size_mode = mode
        self._apply_size_mode()

    def _apply_size_mode(self) -> None:
        if self._size_mode == "small":
            self.setIconSize(QSize(32, 32))
        elif self._size_mode == "large":
            self.setIconSize(QSize(64, 64))
        else:
            self.setIconSize(QSize(48, 48))

    def _pick_icon(self) -> None:
        p = Path(self.path)
        style = QApplication.style()
        if p.is_dir():
            self.setIcon(style.standardIcon(QStyle.SP_DirIcon))
            return
        ext = p.suffix.lower()
        if ext in {".txt", ".md", ".log", ".ini", ".cfg", ".json"}:
            icon = QIcon.fromTheme("text-x-generic") or style.standardIcon(QStyle.SP_FileIcon)
        elif ext in {".png", ".jpg", ".jpeg", ".gif", ".bmp"}:
            icon = QIcon.fromTheme("image-x-generic") or style.standardIcon(QStyle.SP_FileIcon)
        elif ext == ".py":
            icon = QIcon.fromTheme("text-x-python") or style.standardIcon(QStyle.SP_FileIcon)
        else:
            icon = style.standardIcon(QStyle.SP_FileIcon)
        self.setIcon(icon)

    # ------------------------------------------------------------------
    def mousePressEvent(self, event):
        if event.button() == Qt.LeftButton:
            self.setCursor(Qt.ClosedHandCursor)
            self._drag_active = True
            self._press_pos = event.position().toPoint()
            self._moved = False
        super().mousePressEvent(event)

    def mouseMoveEvent(self, event):
        if self._drag_active:
            delta = event.position().toPoint() - self._press_pos
            if delta.manhattanLength() > 4:
                self._moved = True
                new_pos = self.pos() + delta
                parent_rect = self.parentWidget().rect()
                new_pos.setX(max(6, min(new_pos.x(), parent_rect.width() - self.width() - 6)))
                new_pos.setY(max(30, min(new_pos.y(), parent_rect.height() - self.height() - 30)))
                self.move(new_pos)
                self._press_pos = event.position().toPoint()
        super().mouseMoveEvent(event)

    def mouseReleaseEvent(self, event):
        if self._drag_active:
            self.setCursor(Qt.OpenHandCursor)
            moved = self._moved
            self._drag_active = False
            self._moved = False
            canvas: Optional[TerminalDesktopCanvas] = self.parentWidget()  # type: ignore
            if moved and isinstance(canvas, TerminalDesktopCanvas):
                grid_w, grid_h = self._grid_size
                x = round(self.x() / grid_w) * grid_w
                y = round(self.y() / grid_h) * grid_h
                self.move(x, y)
                for sibling in canvas.findChildren(TerminalDesktopIcon):
                    if (
                        sibling is not self
                        and sibling.geometry().contains(
                            self.mapToParent(QPoint(0, 0)) + self.rect().center()
                        )
                        and os.path.isdir(sibling.path)
                    ):
                        canvas._move_file_to_folder(self.path, sibling.path)
                        break
                canvas.save_icon_position(self.path, self.pos())
            elif isinstance(canvas, TerminalDesktopCanvas):
                canvas.open_path(self.path)
        super().mouseReleaseEvent(event)

    def mouseDoubleClickEvent(self, event):
        if event.button() == Qt.LeftButton:
            canvas: Optional[TerminalDesktopCanvas] = self.parentWidget()  # type: ignore
            if isinstance(canvas, TerminalDesktopCanvas):
                canvas.open_path(self.path)
        super().mouseDoubleClickEvent(event)

    # ------------------------------------------------------------------
    def contextMenuEvent(self, event):
        menu = QMenu(self)
        act_open = menu.addAction("Open")
        act_rename = menu.addAction("Rename")
        act_delete = menu.addAction("Delete")
        act_props = menu.addAction("Properties")
        chosen = menu.exec(event.globalPos())
        canvas: Optional[TerminalDesktopCanvas] = self.parentWidget()  # type: ignore
        if not isinstance(canvas, TerminalDesktopCanvas):
            return
        if chosen == act_open:
            canvas.open_path(self.path)
        elif chosen == act_rename:
            new_name, ok = QInputDialog.getText(
                self,
                "Rename",
                "New name (extensions allowed):",
                text=os.path.basename(self.path),
            )
            if ok and new_name:
                new_name = new_name.strip()
                if not new_name:
                    return
                dst = os.path.join(os.path.dirname(self.path), new_name)
                try:
                    os.rename(self.path, dst)
                    owner = canvas.parent_desktop()
                    if owner:
                        owner.forget_icon_position(self.path)
                except Exception as exc:  # pragma: no cover - UI feedback path
                    QMessageBox.warning(self, "Rename", f"Rename failed: {exc}")
                finally:
                    canvas._refresh_icons()
        elif chosen == act_delete:
            try:
                if os.path.isdir(self.path):
                    shutil.rmtree(self.path)
                else:
                    os.remove(self.path)
                owner = canvas.parent_desktop()
                if owner:
                    owner.forget_icon_position(self.path)
            except Exception as exc:  # pragma: no cover - UI feedback path
                QMessageBox.warning(self, "Delete", f"Delete failed: {exc}")
            finally:
                canvas._refresh_icons()
        elif chosen == act_props:
            size = 0
            try:
                if os.path.isdir(self.path):
                    for entry in Path(self.path).rglob("*"):
                        if entry.is_file():
                            size += entry.stat().st_size
                else:
                    size = os.path.getsize(self.path)
            except Exception:
                size = 0
            QMessageBox.information(
                self,
                "Properties",
                f"Path: {self.path}\nSize: {size} bytes",
            )


class TerminalDesktopCanvas(VirtualCanvas):
    def __init__(self, theme: Theme, parent: Optional[QWidget] = None):
        super().__init__(theme, parent)
        ensure_dir(terminal_desktop_dir())
        self._icons: Dict[str, TerminalDesktopIcon] = {}
        self._grid_size = (92, 90)
        self._last_sorted_paths: List[str] = []
        self._watcher = QFileSystemWatcher(self)
        try:
            self._watcher.addPath(str(terminal_desktop_dir()))
        except Exception:
            pass
        self._watcher.directoryChanged.connect(lambda _path: self._refresh_icons())
        self._watcher.fileChanged.connect(lambda _path: self._refresh_icons())
        self.setContextMenuPolicy(Qt.CustomContextMenu)
        self.customContextMenuRequested.connect(self._desktop_context)
        QTimer.singleShot(0, self._refresh_icons)

    # ------------------------------------------------------------------
    def parent_desktop(self) -> Optional["TerminalDesktop"]:
        parent = self.parentWidget()
        return parent if isinstance(parent, TerminalDesktop) else None

    def resizeEvent(self, event):
        super().resizeEvent(event)
        self._arrange_icons()

    def _refresh_icons(self) -> None:
        ensure_dir(terminal_desktop_dir())
        entries = self._sorted_workspace_entries()
        want_paths = [str(p) for p in entries]
        want_set = set(want_paths)
        current_paths = set(self._icons.keys())
        removed = current_paths - want_set
        parent = self.parent_desktop()
        for path in list(removed):
            icon = self._icons.pop(path, None)
            if icon:
                icon.setParent(None)
                icon.deleteLater()
            if parent:
                parent.forget_icon_position(path)
        for idx, path in enumerate(want_paths):
            icon = self._icons.get(path)
            if not icon:
                icon = TerminalDesktopIcon(
                    self.theme,
                    path,
                    self,
                    self._grid_size,
                    self._current_icon_size(),
                )
                icon.show()
                self._icons[path] = icon
                stored = self.restore_icon_position(path)
                if stored is not None:
                    icon.move(stored)
                else:
                    self._position_icon(icon, idx)
            else:
                icon.path = path
                icon.set_size_mode(self._current_icon_size())
        self._last_sorted_paths = want_paths
        self._arrange_icons_if_needed()
        QApplication.processEvents()

    def _position_icon(self, icon: TerminalDesktopIcon, index: int) -> None:
        cols = max(1, int((self.width() - 60) / self._grid_size[0]))
        row, col = divmod(index, cols)
        pos = QPoint(30 + col * self._grid_size[0], 40 + row * self._grid_size[1])
        icon.move(pos)
        self.save_icon_position(icon.path, pos)

    def _arrange_icons(self) -> None:
        if not self._icons:
            return
        if self.parent_desktop() and self.parent_desktop().sort_mode() in {"type", "date"}:
            self._arrange_icons_if_needed(force=True)

    def _arrange_icons_if_needed(self, force: bool = False) -> None:
        parent = self.parent_desktop()
        if not parent:
            return
        if not force and parent.sort_mode() not in {"type", "date"}:
            return
        paths = self._last_sorted_paths or [str(p) for p in self._sorted_workspace_entries()]
        cols = max(1, int((self.width() - 60) / self._grid_size[0]))
        for idx, path in enumerate(paths):
            icon = self._icons.get(path)
            if not icon:
                continue
            row, col = divmod(idx, cols)
            pos = QPoint(30 + col * self._grid_size[0], 40 + row * self._grid_size[1])
            icon.move(pos)
            self.save_icon_position(path, pos)

    def _sorted_workspace_entries(self) -> List[Path]:
        root = terminal_desktop_dir()
        try:
            entries = list(root.iterdir())
        except Exception:
            return []
        mode = self.parent_desktop().sort_mode() if self.parent_desktop() else "name"
        mode = mode if mode in {"name", "type", "date"} else "name"

        def base_key(path: Path) -> int:
            return 0 if path.is_dir() else 1

        if mode == "type":
            entries.sort(key=lambda p: (base_key(p), p.suffix.lower(), p.name.lower()))
        elif mode == "date":
            def mtime(path: Path) -> float:
                try:
                    return float(path.stat().st_mtime)
                except Exception:
                    return 0.0

            entries.sort(key=lambda p: (base_key(p), -mtime(p), p.name.lower()))
        else:
            entries.sort(key=lambda p: (base_key(p), p.name.lower()))
        return entries

    # ------------------------------------------------------------------
    def _current_icon_size(self) -> str:
        parent = self.parent_desktop()
        return parent.icon_size() if parent else "medium"

    def _current_background_config(self) -> BackgroundConfig:
        parent = self.parent_desktop()
        return parent.background_config() if parent else BackgroundConfig()

    def save_icon_position(self, path: str, pos: QPoint) -> None:
        parent = self.parent_desktop()
        if parent:
            parent.save_icon_position(path, pos)

    def restore_icon_position(self, path: str) -> Optional[QPoint]:
        parent = self.parent_desktop()
        return parent.restore_icon_position(path) if parent else None

    # ------------------------------------------------------------------
    def _set_icon_size(self, mode: str) -> None:
        parent = self.parent_desktop()
        if parent:
            parent.set_icon_size(mode)
        for icon in self._icons.values():
            icon.set_size_mode(self._current_icon_size())

    def _set_sort_mode(self, mode: str) -> None:
        parent = self.parent_desktop()
        if parent:
            parent.set_sort_mode(mode)
        self._refresh_icons()

    def _set_background_fit(self, fit: BackgroundFit) -> None:
        parent = self.parent_desktop()
        if not parent:
            return
        config = parent.background_config()
        config.fit = fit
        parent.set_background_config(config)

    def _select_background(self, mode: BackgroundMode) -> None:
        parent = self.parent_desktop()
        if not parent:
            return
        config = parent.background_config()
        config.mode = mode
        if mode == BackgroundMode.SOLID:
            config.source = ""
            parent.set_background_config(config)
            return
        path = self._prompt_background_path(mode)
        if not path:
            return
        config.source = path
        if mode in (BackgroundMode.STATIC, BackgroundMode.GIF) and not isinstance(config.fit, BackgroundFit):
            config.fit = BackgroundFit.FILL
        if mode == BackgroundMode.VIDEO:
            config.loop = True
            config.mute = True
        parent.set_background_config(config)

    def _background_prompt_details(self, mode: BackgroundMode) -> Tuple[str, str]:
        filters = {
            BackgroundMode.STATIC: "Images (*.png *.jpg *.jpeg *.bmp *.gif)",
            BackgroundMode.GIF: "GIF images (*.gif)",
            BackgroundMode.VIDEO: "Videos (*.mp4 *.mov *.mkv *.avi *.webm)",
            BackgroundMode.GL: "Python Scripts (*.py)",
        }
        captions = {
            BackgroundMode.STATIC: "Choose Background Image",
            BackgroundMode.GIF: "Choose Animated GIF",
            BackgroundMode.VIDEO: "Choose Background Video",
            BackgroundMode.GL: "Choose GL Background Script",
        }
        return filters.get(mode, "*"), captions.get(mode, "Choose Background")

    def _prompt_background_path(self, mode: BackgroundMode) -> Optional[str]:
        filt, caption = self._background_prompt_details(mode)
        path, _ = QFileDialog.getOpenFileName(self, caption, str(terminal_desktop_dir()), filt)
        if not path or not os.path.isfile(path):
            return None
        return path

    # ------------------------------------------------------------------
    def _desktop_context(self, pos: QPoint) -> None:
        menu = QMenu(self)
        view_menu = menu.addMenu("View")
        size_mode = self._current_icon_size()
        size_actions = {
            "large": view_menu.addAction("Large icons"),
            "medium": view_menu.addAction("Medium icons"),
            "small": view_menu.addAction("Small icons"),
        }
        for key, action in size_actions.items():
            action.setCheckable(True)
            action.setChecked(size_mode == key)
            action.triggered.connect(lambda _checked, mode=key: self._set_icon_size(mode))

        sort_menu = menu.addMenu("Sort by")
        current_sort = self.parent_desktop().sort_mode() if self.parent_desktop() else "name"
        for key, label in (("name", "Name"), ("type", "Type"), ("date", "Date modified")):
            action = sort_menu.addAction(label)
            action.setCheckable(True)
            action.setChecked(current_sort == key)
            action.triggered.connect(lambda _checked, mode=key: self._set_sort_mode(mode))

        menu.addAction("Refresh", self._refresh_icons)
        menu.addSeparator()
        new_menu = menu.addMenu("New")
        new_menu.addAction("Folder", self._new_folder_desktop)
        new_menu.addAction("Text File", self._new_text_desktop)
        new_menu.addAction("Markdown File", self._new_markdown_desktop)
        new_menu.addAction("JSON File", self._new_json_desktop)
        new_menu.addAction("Python File", self._new_python_desktop)
        new_menu.addAction("PowerShell Script", self._new_powershell_desktop)
        new_menu.addAction("ZIP Archive", self._new_zip_desktop)
        new_menu.addAction("Shortcut", self._new_shortcut_desktop)
        menu.addSeparator()
        personalize = menu.addMenu("Personalize")
        personalize.addAction("Solid color", lambda: self._select_background(BackgroundMode.SOLID))
        personalize.addAction("Image…", lambda: self._select_background(BackgroundMode.STATIC))
        personalize.addAction("Animated GIF…", lambda: self._select_background(BackgroundMode.GIF))
        personalize.addAction("Video…", lambda: self._select_background(BackgroundMode.VIDEO))
        personalize.addAction("Live GL viewport…", lambda: self._select_background(BackgroundMode.GL))
        fit_menu = personalize.addMenu("Image fit")
        cfg = self._current_background_config()
        fit_menu.setEnabled(cfg.mode in (BackgroundMode.STATIC, BackgroundMode.GIF))
        for fit, label in (
            (BackgroundFit.FILL, "Fill"),
            (BackgroundFit.FIT, "Fit"),
            (BackgroundFit.CENTER, "Center"),
            (BackgroundFit.TILE, "Tile"),
        ):
            action = fit_menu.addAction(label)
            action.setCheckable(True)
            action.setChecked(cfg.fit == fit)
            action.triggered.connect(lambda _checked, f=fit: self._set_background_fit(f))
        menu.exec(self.mapToGlobal(pos))

    # ------------------------------------------------------------------
    def _unique_path(self, base_name: str, extension: str = "") -> Path:
        root = terminal_desktop_dir()
        candidate = root / f"{base_name}{extension}"
        if not candidate.exists():
            return candidate
        idx = 1
        while True:
            alt = root / f"{base_name} ({idx}){extension}"
            if not alt.exists():
                return alt
            idx += 1

    def _create_text_file(self, base_name: str, extension: str, contents: str = "") -> None:
        try:
            path = self._unique_path(base_name, extension)
            path.write_text(contents, encoding="utf-8")
            self._refresh_icons()
        except Exception as exc:  # pragma: no cover - log only path
            logger.warning("terminal desktop new file failed: %s", exc)

    def _new_folder_desktop(self) -> None:
        try:
            path = self._unique_path("New Folder")
            path.mkdir()
            self._refresh_icons()
        except Exception as exc:  # pragma: no cover - log only path
            logger.warning("terminal desktop new folder failed: %s", exc)

    def _new_text_desktop(self) -> None:
        self._create_text_file("New Text File", ".txt")

    def _new_markdown_desktop(self) -> None:
        self._create_text_file("New Markdown File", ".md", "# New Markdown File\n\n")

    def _new_json_desktop(self) -> None:
        self._create_text_file("New JSON File", ".json", "{\n\n}\n")

    def _new_python_desktop(self) -> None:
        self._create_text_file("New Python File", ".py", "#!/usr/bin/env python3\n\n\"\"\"New script.\"\"\"\n\n")

    def _new_powershell_desktop(self) -> None:
        self._create_text_file("New PowerShell Script", ".ps1", "Write-Host 'Hello from Codex Terminal'\n")

    def _new_zip_desktop(self) -> None:
        try:
            path = self._unique_path("New Archive", ".zip")
            with zipfile.ZipFile(path, "w"):
                pass
            self._refresh_icons()
        except Exception as exc:  # pragma: no cover - log only path
            logger.warning("terminal desktop new zip failed: %s", exc)

    def _new_shortcut_desktop(self) -> None:
        try:
            path = self._unique_path("New Shortcut", ".shortcut.json")
            payload = {"target": "", "args": [], "working_dir": ""}
            path.write_text(json.dumps(payload, indent=2) + "\n", encoding="utf-8")
            self._refresh_icons()
        except Exception as exc:  # pragma: no cover - log only path
            logger.warning("terminal desktop new shortcut failed: %s", exc)

    # ------------------------------------------------------------------
    def _move_file_to_folder(self, src: str, dst_folder: str) -> None:
        try:
            shutil.move(src, dst_folder)
            self._refresh_icons()
        except Exception as exc:  # pragma: no cover - log only path
            logger.warning("terminal desktop move failed: %s", exc)

    def open_path(self, path: str) -> None:
        target = Path(path)
        if not target.exists():
            return
        if not QDesktopServices.openUrl(QUrl.fromLocalFile(str(target))):
            QMessageBox.information(
                self,
                "Open",
                f"Unable to open {target}. Open it manually if needed.",
            )

class DraggableProxy(QFrame):
    geometry_changed = Signal(QRect)

    _EDGE_MARGIN = 12
    _LEFT = 0x01
    _RIGHT = 0x02
    _TOP = 0x04
    _BOTTOM = 0x08

    def __init__(self, inner: QWidget, parent: Optional[QWidget] = None):
        super().__init__(parent)
        self.setFrameShape(QFrame.NoFrame)
        lay = QVBoxLayout(self); lay.setContentsMargins(0, 0, 0, 0); lay.addWidget(inner)
        self.inner = inner
        self._drag_active = False
        self._mode: Optional[str] = None
        self._resize_edges = 0
        self._press_pos = QPoint(0, 0)
        self._start_geom = QRect()
        self._user_min = QSize(980, 600)
        self._cursor_edges = 0

    # ----- sizing helpers -----
    def _effective_min_width(self) -> int:
        inner_hint = self.inner.minimumSizeHint().width()
        inner_min = self.inner.minimumWidth()
        return max(self._user_min.width(), inner_hint, inner_min)

    def _effective_min_height(self) -> int:
        inner_hint = self.inner.minimumSizeHint().height()
        inner_min = self.inner.minimumHeight()
        return max(self._user_min.height(), inner_hint, inner_min)

    def minimum_size(self) -> QSize:
        return QSize(self._effective_min_width(), self._effective_min_height())

    def set_content_min_size(self, width: int, height: int) -> None:
        width = max(width, 0)
        height = max(height, 0)
        new_min = QSize(width, height)
        if new_min != self._user_min:
            self._user_min = new_min
        target_w = max(self.width(), self._effective_min_width())
        target_h = max(self.height(), self._effective_min_height())
        if target_w != self.width() or target_h != self.height():
            self.resize(target_w, target_h)
            self._keep_within_parent()
            self._emit_geometry()

    # ----- cursor helpers -----
    def _hit_edges(self, pos: QPoint) -> int:
        rect = self.rect()
        edges = 0
        if pos.x() <= self._EDGE_MARGIN:
            edges |= self._LEFT
        elif pos.x() >= rect.width() - self._EDGE_MARGIN:
            edges |= self._RIGHT
        if pos.y() <= self._EDGE_MARGIN:
            edges |= self._TOP
        elif pos.y() >= rect.height() - self._EDGE_MARGIN:
            edges |= self._BOTTOM
        return edges

    def _cursor_for_edges(self, edges: int) -> Qt.CursorShape:
        if edges & self._LEFT and edges & self._TOP:
            return Qt.SizeFDiagCursor
        if edges & self._RIGHT and edges & self._BOTTOM:
            return Qt.SizeFDiagCursor
        if edges & self._RIGHT and edges & self._TOP:
            return Qt.SizeBDiagCursor
        if edges & self._LEFT and edges & self._BOTTOM:
            return Qt.SizeBDiagCursor
        if edges & (self._LEFT | self._RIGHT):
            return Qt.SizeHorCursor
        if edges & (self._TOP | self._BOTTOM):
            return Qt.SizeVerCursor
        return Qt.ArrowCursor

    def _update_cursor(self, edges: int) -> None:
        if edges == self._cursor_edges:
            return
        self._cursor_edges = edges
        self.setCursor(QCursor(self._cursor_for_edges(edges)))

    # ----- geometry helpers -----
    def _keep_within_parent(self) -> None:
        parent = self.parentWidget()
        if not parent:
            return
        max_x = max(0, parent.width() - self.width())
        max_y = max(0, parent.height() - self.height())
        new_x = min(max(self.x(), 0), max_x)
        new_y = min(max(self.y(), 0), max_y)
        if new_x != self.x() or new_y != self.y():
            self.move(new_x, new_y)

    def ensure_within_parent(self) -> None:
        self._keep_within_parent()

    def _emit_geometry(self) -> None:
        self.geometry_changed.emit(self.geometry())

    def mousePressEvent(self, e):
        if e.button() != Qt.LeftButton:
            e.ignore()
            return
        edges = self._hit_edges(e.position().toPoint())
        self._drag_active = True
        self._resize_edges = edges
        self._mode = "resize" if edges else "move"
        self._press_pos = e.position().toPoint()
        self._start_geom = self.geometry()
        e.accept()

    def mouseMoveEvent(self, e):
        if not self._drag_active:
            self._update_cursor(self._hit_edges(e.position().toPoint()))
            e.ignore()
            return
        if self._mode == "move":
            self._move_proxy(e)
        else:
            self._resize_proxy(e)

    def mouseReleaseEvent(self, e):
        if not self._drag_active:
            e.ignore()
            return
        self._drag_active = False
        self._mode = None
        self._resize_edges = 0
        self._update_cursor(self._hit_edges(e.position().toPoint()))
        self._emit_geometry()
        e.accept()

    def leaveEvent(self, _e):
        if not self._drag_active:
            self._update_cursor(0)

    # ----- internal actions -----
    def _move_proxy(self, e) -> None:
        parent = self.parentWidget()
        if not parent:
            e.ignore()
            return
        delta = e.position().toPoint() - self._press_pos
        new_pos = self._start_geom.topLeft() + delta
        nx = max(0, min(new_pos.x(), parent.width() - self.width()))
        ny = max(0, min(new_pos.y(), parent.height() - self.height()))
        self.move(nx, ny)
        e.accept()

    def _resize_proxy(self, e) -> None:
        parent = self.parentWidget()
        delta = e.position().toPoint() - self._press_pos
        geom = QRect(self._start_geom)
        x, y, w, h = geom.x(), geom.y(), geom.width(), geom.height()
        min_w = self._effective_min_width()
        min_h = self._effective_min_height()

        if self._resize_edges & self._LEFT:
            new_x = x + delta.x()
            max_x = x + w - min_w
            new_x = max(0, min(new_x, max_x))
            w = w + (x - new_x)
            x = new_x
        elif self._resize_edges & self._RIGHT:
            new_w = w + delta.x()
            max_w = parent.width() - x if parent else new_w
            w = max(min_w, min(new_w, max_w))

        if self._resize_edges & self._TOP:
            new_y = y + delta.y()
            max_y = y + h - min_h
            new_y = max(0, min(new_y, max_y))
            h = h + (y - new_y)
            y = new_y
        elif self._resize_edges & self._BOTTOM:
            new_h = h + delta.y()
            max_h = parent.height() - y if parent else new_h
            h = max(min_h, min(new_h, max_h))

        if parent:
            w = min(w, max(1, parent.width() - x))
            h = min(h, max(1, parent.height() - y))

        if w < min_w:
            w = min_w
        if h < min_h:
            h = min_h

        self.setGeometry(QRect(x, y, w, h))
        self._keep_within_parent()
        e.accept()

class TerminalDesktop(QFrame):
    def __init__(self, theme: Theme, chat_card: ChatCard, parent: Optional[QWidget] = None):
        super().__init__(parent)
        self.theme = theme
        self.setObjectName("TerminalDesktop")
        self.setAutoFillBackground(False)
        self.setContentsMargins(0, 0, 0, 0)

        ensure_dir(terminal_desktop_dir())
        self.canvas = TerminalDesktopCanvas(theme, self)
        self.camera = CameraView(self.canvas, self)

        self._codex_settings = load_codex_settings()
        self.canvas.set_background_config(self.background_config())
        self.proxy = DraggableProxy(chat_card, self.canvas)
        base_height = max(540, chat_card.sizeHint().height())
        self.proxy.resize(980, base_height)
        self.proxy.set_content_min_size(980, base_height)
        self.proxy.geometry_changed.connect(self._on_proxy_geometry_changed)
        self.proxy.move(max(0, self.canvas.width() // 2 - self.proxy.width() // 2),
                        max(0, self.canvas.height() // 2 - self.proxy.height() // 2))
        QTimer.singleShot(0, self._apply_saved_geometry)

        live_row = QHBoxLayout(); live_row.setContentsMargins(0,0,6,6); live_row.addStretch(1)
        self.live = LivePill(theme, self); self.live.setFixedWidth(96); live_row.addWidget(self.live, 0, Qt.AlignRight | Qt.AlignBottom)

        root = QVBoxLayout(self); root.setContentsMargins(0, 0, 0, 0); root.addWidget(self.camera, 1)
        overlay = QFrame(self); overlay.setLayout(live_row); overlay.setAttribute(Qt.WA_TransparentForMouseEvents, True)
        root.addWidget(overlay, 0)

    def resizeEvent(self, event):
        super().resizeEvent(event)
        self.proxy.ensure_within_parent()

    def _apply_saved_geometry(self) -> None:
        geom = self._codex_settings.get("terminal_desktop", {})
        if not isinstance(geom, dict):
            geom = {}
        min_size = self.proxy.minimum_size()
        width = int(geom.get("width", self.proxy.width()))
        height = int(geom.get("height", self.proxy.height()))
        width = max(min_size.width(), width)
        height = max(min_size.height(), height)

        canvas_w = self.canvas.width()
        canvas_h = self.canvas.height()
        if canvas_w == 0 or canvas_h == 0:
            QTimer.singleShot(0, self._apply_saved_geometry)
            return
        width = min(width, canvas_w)
        height = min(height, canvas_h)

        x = geom.get("x", -1)
        y = geom.get("y", -1)
        max_x = max(0, canvas_w - width)
        max_y = max(0, canvas_h - height)
        default_x = max(0, (canvas_w - width) // 2)
        default_y = max(0, (canvas_h - height) // 2)
        if not isinstance(x, int) or x < 0 or x > max_x:
            x = default_x
        if not isinstance(y, int) or y < 0 or y > max_y:
            y = default_y

        self.proxy.setGeometry(QRect(x, y, width, height))
        self.proxy.ensure_within_parent()
        self._persist_proxy_geometry()

    def _on_proxy_geometry_changed(self, rect: QRect) -> None:
        self._persist_proxy_geometry(rect)

    def _persist_proxy_geometry(self, rect: Optional[QRect] = None) -> None:
        current = rect or self.proxy.geometry()
        settings = load_codex_settings()
        node = settings.get("terminal_desktop")
        if not isinstance(node, dict):
            node = {}
        node.update({
            "width": current.width(),
            "height": current.height(),
            "x": current.x(),
            "y": current.y(),
        })
        settings["terminal_desktop"] = node
        save_codex_settings(settings)
        self._codex_settings = settings

    # ------------------------------------------------------------------
    def _terminal_state(self) -> Dict[str, Any]:
        node = self._codex_settings.get("terminal_desktop")
        if not isinstance(node, dict):
            node = {}
            self._codex_settings["terminal_desktop"] = node
        node.setdefault("icon_size", "medium")
        node.setdefault("sort_mode", "name")
        node.setdefault("icon_positions", {})
        node.setdefault("background", BackgroundConfig().to_state())
        return node

    def _update_terminal_state(self, mutator) -> None:
        settings = load_codex_settings()
        node = settings.get("terminal_desktop")
        if not isinstance(node, dict):
            node = {}
        node.setdefault("icon_size", "medium")
        node.setdefault("sort_mode", "name")
        node.setdefault("icon_positions", {})
        node.setdefault("background", BackgroundConfig().to_state())
        mutator(node)
        settings["terminal_desktop"] = node
        save_codex_settings(settings)
        self._codex_settings = settings

    def icon_size(self) -> str:
        mode = str(self._terminal_state().get("icon_size", "medium"))
        return mode if mode in {"small", "medium", "large"} else "medium"

    def set_icon_size(self, mode: str) -> None:
        if mode not in {"small", "medium", "large"}:
            mode = "medium"

        def mutate(node: Dict[str, Any]) -> None:
            node["icon_size"] = mode

        self._update_terminal_state(mutate)

    def sort_mode(self) -> str:
        mode = str(self._terminal_state().get("sort_mode", "name"))
        return mode if mode in {"name", "type", "date"} else "name"

    def set_sort_mode(self, mode: str) -> None:
        if mode not in {"name", "type", "date"}:
            mode = "name"

        def mutate(node: Dict[str, Any]) -> None:
            node["sort_mode"] = mode

        self._update_terminal_state(mutate)

    def save_icon_position(self, path: str, pos: QPoint) -> None:

        def mutate(node: Dict[str, Any]) -> None:
            positions = node.setdefault("icon_positions", {})
            positions[path] = [int(pos.x()), int(pos.y())]

        self._update_terminal_state(mutate)

    def restore_icon_position(self, path: str) -> Optional[QPoint]:
        positions = self._terminal_state().get("icon_positions", {})
        coords = positions.get(path)
        if not isinstance(coords, (list, tuple)) or len(coords) != 2:
            return None
        try:
            return QPoint(int(coords[0]), int(coords[1]))
        except Exception:
            return None

    def forget_icon_position(self, path: str) -> None:

        def mutate(node: Dict[str, Any]) -> None:
            positions = node.setdefault("icon_positions", {})
            positions.pop(path, None)

        self._update_terminal_state(mutate)

    def background_config(self) -> BackgroundConfig:
        state = self._terminal_state()
        return BackgroundConfig.from_state(state.get("background"))

    def set_background_config(self, config: BackgroundConfig) -> None:
        normalized = BackgroundConfig.from_state(config.to_state())
        self.canvas.set_background_config(normalized)

        def mutate(node: Dict[str, Any]) -> None:
            node["background"] = normalized.to_state()

        self._update_terminal_state(mutate)

# --------------------------------------------------------------------------------------
# Main window
# --------------------------------------------------------------------------------------

def _default_settings() -> Dict[str, Any]:
    root = transit_dir()
    data_root = agent_data_dir()
    return {
        "chat_model": DEFAULT_CHAT_MODEL,
        "vision_ocr_model": DEFAULT_VISION_OCR_MODEL,
        "vision_model": DEFAULT_VISION_MODEL,
        "embed_model": DEFAULT_EMBED_MODEL,
        "context_pairs": 25,
        "workspace": root,
        "data_root": data_root,
        "enable_semantic": True,
        "enable_vision": True,
        "enable_interpreter": False,
        "reference_embed_contents": DEFAULT_SETTINGS.get("reference_embed_contents", True),
        "reference_case_sensitive": DEFAULT_SETTINGS.get("reference_case_sensitive", False),
        "reference_token_guard": DEFAULT_SETTINGS.get("reference_token_guard", True),
        "reference_token_headroom": DEFAULT_SETTINGS.get("reference_token_headroom", 80),
        "scan_roots": [],
        "shells": {
            "cmd": True,
            "powershell": False,
            "bash": False,
            "zsh": False,
            "wsl": False,
        },
    }


class MainWindow(QMainWindow):
    def __init__(self, theme: Theme, parent: Optional[QWidget] = None, *, embedded: bool = False):
        super().__init__(parent)
        self.theme = theme
        self._embedded = embedded
        self.setWindowTitle(APP_NAME)
        self.resize(1280, 800)
        self.setContentsMargins(0, 0, 0, 0)

        pal = self.palette()
        pal.setColor(QPalette.Window, QColor("#0a1430"))
        pal.setColor(QPalette.Base, QColor("#0a1430"))
        pal.setColor(QPalette.Text, QColor("#e6f0ff"))
        pal.setColor(QPalette.WindowText, QColor("#e6f0ff"))
        self.setPalette(pal)

        self.ollama = OllamaClient()
        self.lex_mgr = LexiconManager(lexicons_dir())

        self.settings = _default_settings()
        saved_codex = load_codex_settings()
        if isinstance(saved_codex, dict):
            self.settings["enable_interpreter"] = bool(
                saved_codex.get("enable_interpreter", saved_codex.get("codex_auto_continue", False))
            )
            self.settings["reference_embed_contents"] = bool(
                saved_codex.get(
                    "reference_embed_contents",
                    DEFAULT_SETTINGS.get("reference_embed_contents", True),
                )
            )
            self.settings["reference_case_sensitive"] = bool(
                saved_codex.get(
                    "reference_case_sensitive",
                    DEFAULT_SETTINGS.get("reference_case_sensitive", False),
                )
            )
            self.settings["reference_token_guard"] = bool(
                saved_codex.get(
                    "reference_token_guard",
                    DEFAULT_SETTINGS.get("reference_token_guard", True),
                )
            )
            self.settings["reference_token_headroom"] = int(
                saved_codex.get(
                    "reference_token_headroom",
                    DEFAULT_SETTINGS.get("reference_token_headroom", 80),
                )
            )
            self.settings["scan_roots"] = _normalize_scan_roots(saved_codex.get("scan_roots", []))
            sandbox_cfg = saved_codex.get("sandbox")
            if isinstance(sandbox_cfg, dict):
                self.settings["sandbox"] = copy.deepcopy(sandbox_cfg)
            else:
                self.settings["sandbox"] = copy.deepcopy(DEFAULT_SETTINGS.get("sandbox", {}))
        else:
            self.settings["sandbox"] = copy.deepcopy(DEFAULT_SETTINGS.get("sandbox", {}))
            self.settings["scan_roots"] = []

        # Error console setup
        self.error_console = ErrorConsole(parent=self)
        self.addDockWidget(Qt.BottomDockWidgetArea, self.error_console)
        self.error_console.hide()
        self._orig_stderr = None
        self._orig_excepthook = None
        if not self._embedded:
            ensure_dir(terminal_desktop_dir())
            self._orig_stderr = sys.stderr
            sys.stderr = StderrRedirector(self.error_console, sys.stderr)
            self._orig_excepthook = sys.excepthook
            sys.excepthook = self._handle_exception

        self.desktop: Optional[TerminalDesktop] = None
        self.chat = ChatCard(self.theme, self.ollama, self.settings, self.lex_mgr, self)
        if self._embedded:
            self.setCentralWidget(self.chat)
        else:
            self.desktop = TerminalDesktop(theme, self.chat, self)
            self.setCentralWidget(self.desktop)
        safety_manager.set_confirmer(self._confirm_risky_command)

        self._init_menu()
        self._init_shortcuts()
        self._check_ollama()

    def _init_menu(self):
        bar = self.menuBar()

        file_menu = bar.addMenu("&File")
        open_styles = QAction("Load Styles JSON…", self)
        open_styles.triggered.connect(self._load_styles_json)
        file_menu.addAction(open_styles)
        file_menu.addSeparator()
        quit_act = QAction("Quit", self)
        quit_act.setShortcut(QKeySequence.Quit)
        quit_act.triggered.connect(self.close)
        file_menu.addAction(quit_act)

        tools_menu = bar.addMenu("&Settings")
        settings_act = QAction("Preferences…", self)
        settings_act.triggered.connect(self._open_settings)
        tools_menu.addAction(settings_act)

        view_menu = bar.addMenu("&View")
        self.fullscreen_act = QAction("Toggle Fullscreen (Alt+Enter)", self)
        self.fullscreen_act.setShortcut("Alt+Return")
        self.fullscreen_act.triggered.connect(self._toggle_fullscreen)
        view_menu.addAction(self.fullscreen_act)

    def _init_shortcuts(self):
        focus_input = QAction(self); focus_input.setShortcut(QKeySequence("Ctrl+`"))
        focus_input.triggered.connect(lambda: self.chat.input.setFocus(Qt.ShortcutFocusReason)); self.addAction(focus_input)

        send_codex = QAction(self); send_codex.setShortcut(QKeySequence("Ctrl+Return"))
        send_codex.triggered.connect(self.chat._send_to_codex); self.addAction(send_codex)

        send_local = QAction(self); send_local.setShortcut(QKeySequence("Alt+Return"))
        send_local.triggered.connect(self.chat._on_send_local); self.addAction(send_local)

    def _check_ollama(self):
        ok, msg = self.ollama.health()
        if not ok:
            QMessageBox.warning(self, "Ollama", f"Ollama Not found: {msg}")

    def _confirm_risky_command(self, prompt: str, command: Sequence[str]) -> bool:
        if QApplication.instance() is None:
            return False
        joined = shlex.join(command)
        message = (
            f"{prompt}\n\n"
            f"Command:\n{joined}\n\nProceed with execution?"
        )
        result = QMessageBox.warning(
            self,
            "Safety Confirmation",
            message,
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.No,
        )
        return result == QMessageBox.Yes

    # ------------------------------------------------------------------
    def _handle_exception(self, exc_type, exc, tb) -> None:
        """Log uncaught exceptions without terminating the app."""
        log_exception(self.error_console, exc_type, exc, tb)

    @Slot()
    def _toggle_fullscreen(self):
        if self.isFullScreen(): self.showNormal()
        else: self.showFullScreen()

    @Slot()
    def _load_styles_json(self):
        path, _ = QFileDialog.getOpenFileName(self, "Select Styles JSON", str(styles_path().parent), "JSON Files (*.json)")
        if not path: return
        new_theme = Theme.load(path)
        self.theme = new_theme
        old_chat = getattr(self, "chat", None)
        self.setCentralWidget(None)
        if hasattr(old_chat, "detach_safety_notifier"):
            old_chat.detach_safety_notifier()
        self.chat = ChatCard(self.theme, self.ollama, self.settings, self.lex_mgr, self)
        if self._embedded:
            self.desktop = None
            self.setCentralWidget(self.chat)
        else:
            self.desktop = TerminalDesktop(self.theme, self.chat, self)
            self.setCentralWidget(self.desktop)

    @Slot()
    def _open_settings(self):
        dlg = SettingsDialog(self.theme, self, self.ollama, self.lex_mgr)
        dlg.context_pairs.setValue(int(self.settings.get("context_pairs", 25)))
        dlg.share_context.setChecked(self.settings.get("share_context", True))
        dlg.share_limit.setValue(int(self.settings.get("share_limit", 5)))
        dlg.enable_embeddings.setChecked(self.settings.get("enable_semantic", True))
        dlg.enable_vision.setChecked(self.settings.get("enable_vision", True))
        current_data_root = _clamp_to_agent_subdir(self.settings.get("data_root"), subdir=agent_data_dir())
        dlg.data_root_edit.setText(str(current_data_root))
        shells = self.settings.get("shells", {})
        dlg.chk_cmd.setChecked(shells.get("cmd", True))
        dlg.chk_powershell.setChecked(shells.get("powershell", False))
        dlg.chk_bash.setChecked(shells.get("bash", False))
        dlg.chk_zsh.setChecked(shells.get("zsh", False))
        dlg.chk_wsl.setChecked(shells.get("wsl", False))
        s = load_codex_settings()
        dlg.codex_mode_bridge.setChecked(s.get("default_launch_mode","bridge") == "bridge")
        dlg.codex_working.setText(s.get("working_folder", str(workspace_root())))
        dlg.enable_interpreter.setChecked(
            bool(self.settings.get("enable_interpreter", s.get("enable_interpreter", False)))
        )
        dlg.reference_embed_contents.setChecked(
            bool(
                self.settings.get(
                    "reference_embed_contents",
                    s.get(
                        "reference_embed_contents",
                        DEFAULT_SETTINGS.get("reference_embed_contents", True),
                    ),
                )
            )
        )
        dlg.reference_case_sensitive.setChecked(
            bool(
                self.settings.get(
                    "reference_case_sensitive",
                    s.get(
                        "reference_case_sensitive",
                        DEFAULT_SETTINGS.get("reference_case_sensitive", False),
                    ),
                )
            )
        )
        dlg.reference_token_guard.setChecked(
            bool(
                self.settings.get(
                    "reference_token_guard",
                    s.get(
                        "reference_token_guard",
                        DEFAULT_SETTINGS.get("reference_token_guard", True),
                    ),
                )
            )
        )
        dlg.reference_token_headroom.setValue(
            int(
                self.settings.get(
                    "reference_token_headroom",
                    s.get(
                        "reference_token_headroom",
                        DEFAULT_SETTINGS.get("reference_token_headroom", 80),
                    ),
                )
            )
        )
        dlg.set_scan_roots(s.get("scan_roots", []))
        dlg.apply_sandbox_settings(s.get("sandbox", {}))

        if dlg.exec() == QDialog.Accepted:
            vals = dlg.values()
            self.settings.update({
                "chat_model": vals["chat_model"],
                "vision_ocr_model": vals["vision_ocr_model"],
                "vision_model": vals["vision_model"],
                "embed_model": vals["embed_model"],
                "context_pairs": vals["context_pairs"],
                "share_context": vals["share_context"],
                "share_limit": vals["share_limit"],
                "enable_semantic": vals["enable_semantic"],
                "enable_vision": vals["enable_vision"],
                "enable_interpreter": vals["enable_interpreter"],
                "reference_embed_contents": vals["reference_embed_contents"],
                "reference_case_sensitive": vals["reference_case_sensitive"],
                "reference_token_guard": vals["reference_token_guard"],
                "reference_token_headroom": vals["reference_token_headroom"],
                "data_root": vals["data_root"],
                "scan_roots": vals["scan_roots"],
                "shells": vals["shells"],
            })
            self.settings["sandbox"] = vals["codex"]["sandbox"]
            self.settings["scan_roots"] = vals["codex"]["scan_roots"]
            codex_settings = load_codex_settings()
            codex_settings.update({
                "default_launch_mode": vals["codex"]["default_launch_mode"],
                "working_folder": vals["codex"]["working_folder"],
                "model": self.settings["chat_model"],
                "sandbox": vals["codex"]["sandbox"],
                "enable_interpreter": vals["enable_interpreter"],
                "reference_embed_contents": vals["reference_embed_contents"],
                "reference_case_sensitive": vals["reference_case_sensitive"],
                "reference_token_guard": vals["reference_token_guard"],
                "reference_token_headroom": vals["reference_token_headroom"],
                "scan_roots": vals["codex"]["scan_roots"],
            })
            save_codex_settings(codex_settings)
            old_chat = self.chat
            self.setCentralWidget(None)
            if hasattr(old_chat, "detach_safety_notifier"):
                old_chat.detach_safety_notifier()
            self.chat = ChatCard(self.theme, self.ollama, self.settings, self.lex_mgr, self)
            if self._embedded:
                self.desktop = None
                self.setCentralWidget(self.chat)
            else:
                self.desktop = TerminalDesktop(self.theme, self.chat, self)
                self.setCentralWidget(self.desktop)

    def closeEvent(self, event: QCloseEvent) -> None:
        if hasattr(self, "chat") and hasattr(self.chat, "detach_safety_notifier"):
            self.chat.detach_safety_notifier()
        if self._orig_stderr is not None:
            sys.stderr = self._orig_stderr
            self._orig_stderr = None
        if self._orig_excepthook is not None:
            sys.excepthook = self._orig_excepthook
            self._orig_excepthook = None
        super().closeEvent(event)

# --------------------------------------------------------------------------------------
# Embeddable factory
# --------------------------------------------------------------------------------------

def build_widget(parent: Optional[QWidget] = None, embedded: bool = False) -> Tuple[QWidget, str]:
    """Create the Codex Terminal widget for embedding or standalone usage."""
    theme_json = locate_styles_json()
    theme = Theme.load(theme_json) if theme_json else Theme()
    window = MainWindow(theme, parent=parent, embedded=embedded)
    return window, APP_NAME


# --------------------------------------------------------------------------------------
# Entry
# --------------------------------------------------------------------------------------

def locate_styles_json() -> str:
    p = styles_path()
    return str(p) if p.is_file() else ""

def main():
    shared_logger = configure_shared_logger()
    install_global_exception_handler(shared_logger)
    shared_logger.info("Codex Terminal starting up (pid=%s)", os.getpid())
    for handler in shared_logger.handlers:
        try:
            handler.flush()
        except Exception:
            continue

    parser = argparse.ArgumentParser(description=APP_NAME)
    parser.add_argument(
        "--workspace",
        metavar="PATH",
        help="Path to use for CODEX_WORKSPACE before launching the UI.",
    )
    args, qt_args = parser.parse_known_args()
    if args.workspace:
        candidate = os.path.abspath(os.path.expanduser(args.workspace))
        os.environ["CODEX_WORKSPACE"] = candidate
    os.environ.setdefault("QT_ENABLE_HIGHDPI_SCALING", "1")
    os.environ.setdefault("QT_SCALE_FACTOR_ROUNDING_POLICY", "PassThrough")

    _ensure_high_dpi_rounding_policy()

    sys.argv = [sys.argv[0]] + qt_args
    app = QApplication(sys.argv)
    app.setApplicationName(APP_NAME)

    widget, _ = build_widget()
    widget.show()
    sys.exit(app.exec())

if __name__ == "__main__":
    main()
```

Agent Virtual Desktop — Codex-Terminal (All-in-One)
- Virtual Desktop canvas (bright blue), draggable chat/terminal card
- Local-first Chat (Ollama-only) + OCR/Vision pipeline
- Dataset persistence (JSONL + embeddings) + user-memory (lightweight)
- **Codex Rust CLI bridge for Windows**:
    • Download/verify/launch Codex CLI
    • Mirror CMD output (snapshots)
    • Inject text to CMD
    • **Press Enter reliably** (WriteConsoleInputW + SendInput fallback)
    • Start/Stop/Show/Hide controls
    • Tri-state LED (red/yellow/green) for bridge health

Requires: PySide6>=6.6, requests, Pillow (optional), local ollama, Windows 10+ for bridge.
**Classes:** ErrorPopup, Theme, LivePill, BridgeLED, ToggleSwitch, OllamaClient, LexiconManager, DatasetManager, ConversationPaths, ConversationIO, CodexBootstrap, CodexBridge, SettingsDialog, ChatMessage, ApprovalPrompt, ParsedCodexEvent, CodexInterpreter, ChatBubbleWidget, ConversationView, ApprovalPromptWidget, ChatInput, ChatCard, VirtualCanvas, CameraView, TerminalDesktopIcon, TerminalDesktopCanvas, DraggableProxy, TerminalDesktop, MainWindow
**Functions:** _ensure_high_dpi_rounding_policy(), _shared_log_handler_attached(logger), configure_shared_logger(), install_global_exception_handler(logger), here(), _resolve_directory(path), base_dir(), workspace_root(), agent_data_root(), _agent_subdir(name), agent_images_dir(), agent_sessions_dir(), agent_logs_dir(), agent_archives_dir(), agent_data_dir(), agent_lexicons_dir(), _clamp_to_agent_subdir(raw), styles_path(), _legacy_transit_candidates(), _migrate_legacy_transit(target), transit_dir(), terminal_desktop_dir(), lexicons_dir(), ensure_dir(p), _read_codex_memory(), load_session_notes(), _utc_iso(), append_session_note(note), is_windows(), run_checked(cmd, cwd, env, timeout), slug(s), cosine(a, b), sha256_file(p, chunk), _merge_settings(defaults, target), _is_transit_path(candidate), _normalize_scan_roots(raw), load_codex_settings(), save_codex_settings(d), codex_ready_banner(text), _normalize_display_text(value), _default_settings(), build_widget(parent, embedded), locate_styles_json(), main()


## Module `code_editor.py`

```python
"""Compatibility wrapper that exposes the Editor card factory."""

from __future__ import annotations

from editor.card import EditorCard, build_widget

__all__ = ["EditorCard", "build_widget"]
```

Compatibility wrapper that exposes the Editor card factory.


## Module `error_center.py`

```python
"""Error Center card for the Virtual Desktop.

Provides filtered log tabs, severity highlighting, and task shortcuts
based on guidance from `concepts/dev_logic/Virtual_Desktop logic.md`.
"""

from __future__ import annotations

import html
import logging
import re
from dataclasses import dataclass
from datetime import datetime
from typing import Callable, Dict, Optional, Sequence, Set

from PySide6.QtCore import QTimer, Signal
from PySide6.QtGui import QTextCursor, QTextOption
from PySide6.QtWidgets import (
    QHBoxLayout,
    QLabel,
    QPushButton,
    QTabWidget,
    QTextBrowser,
    QTextEdit,
    QVBoxLayout,
    QWidget,
)

from tasks.models import ErrorRecord, append_error_record

LOGGER = logging.getLogger(__name__)


@dataclass(frozen=True)
class _CategoryProfile:
    name: str
    keywords: Sequence[str]


_CATEGORY_PROFILES: Sequence[_CategoryProfile] = (
    _CategoryProfile("Runtime", ("[runtime]", " runtime", "process", "worker", "card", "canvas")),
    _CategoryProfile("UI", ("[ui]", " ui", "widget", "qt", "paint", "hover", "button", "window", "start panel")),
    _CategoryProfile("I/O", ("[io]", "i/o", "io ", "filesystem", "disk", "read", "write", "socket", "network", "save", "load", "path")),
    _CategoryProfile("Security", ("[security]", " security", "auth", "permission", "policy", "denied", "sandbox")),
)

_SEVERITY_COLORS: Dict[str, str] = {
    "[ERROR]": "#ff5c5c",
    "[ERR]": "#ff5c5c",
    "[CRITICAL]": "#ff5c5c",
    "[WARN]": "#ffb347",
    "[WARNING]": "#ffb347",
}

_TASK_PATTERN = re.compile(r"task_id=([A-Za-z0-9_-]+)")
_LOG_LINE_PATTERN = re.compile(
    r"^(?P<ts>\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}(?:,\d{3})?)\s+\[(?P<level>[A-Z]+)\]\s+(?P<msg>.*)$"
)
_PATH_PATTERN = re.compile(r"(?P<path>(?:[A-Za-z]:\\|/)[^\s]+)")
_ERROR_LEVELS = {"ERROR", "CRITICAL"}


class ErrorCenterCard(QWidget):
    """Movable Error Center card with filtered log tails."""

    task_requested = Signal(str)

    def __init__(
        self,
        theme,
        log_path: str,
        open_task: Optional[Callable[[str], None]] = None,
        parent: Optional[QWidget] = None,
    ) -> None:
        super().__init__(parent)
        self._theme = theme
        self._log_path = log_path
        self._open_task_cb = open_task
        self._last_pos = 0
        self._buffer = ""
        self._latest_task_id: Optional[str] = None
        self._max_blocks = 2000
        self._tabs: Dict[str, QTextBrowser] = {}

        self.setObjectName("ErrorCenterCard")
        root = QVBoxLayout(self)
        root.setContentsMargins(12, 12, 12, 12)
        root.setSpacing(10)

        title = QLabel("Error Center")
        title.setStyleSheet("color:#eaf2ff;font:700 12pt 'Cascadia Code';")
        root.addWidget(title)

        self._tab_widget = QTabWidget(self)
        self._tab_widget.setTabPosition(QTabWidget.North)
        self._tab_widget.setDocumentMode(True)
        self._tab_widget.setStyleSheet(
            "QTabWidget::pane{border:1px solid #1f2b3a;border-radius:10px;}"
            "QTabBar::tab{background:#0b1624;color:#dfe9ff;padding:6px 12px;border:1px solid #1f2b3a;"
            "border-radius:8px;margin-right:4px;}"
            "QTabBar::tab:selected{background:#1e5aff;}"
        )
        root.addWidget(self._tab_widget, 1)

        for profile in _CATEGORY_PROFILES:
            view = QTextBrowser(self)
            view.setAcceptRichText(True)
            view.setOpenExternalLinks(False)
            view.setLineWrapMode(QTextEdit.NoWrap)
            view.setWordWrapMode(QTextOption.NoWrap)
            view.document().setDefaultStyleSheet(
                "body{font-family:'Cascadia Code',Consolas,monospace;font-size:10pt;"
                "color:%s;background:%s;}" % (self._theme.editor_fg, self._theme.editor_bg)
            )
            view.document().setMaximumBlockCount(self._max_blocks)
            view.setStyleSheet(
                "QTextBrowser{background:%s;color:%s;border:1px solid %s;border-radius:10px;padding:8px;}" % (
                    self._theme.editor_bg,
                    self._theme.editor_fg,
                    self._theme.card_border,
                )
            )
            self._tab_widget.addTab(view, profile.name)
            self._tabs[profile.name] = view

        footer = QHBoxLayout()
        footer.setSpacing(8)
        self._task_label = QLabel("No task reference detected.")
        self._task_label.setStyleSheet("color:#bcd5ff;font:500 9pt 'Segoe UI';")
        footer.addWidget(self._task_label, 1)

        self._task_button = QPushButton("Open related task")
        self._task_button.setEnabled(False)
        self._task_button.setStyleSheet(
            "QPushButton{background:%s;color:#ffffff;border:1px solid %s;border-radius:6px;padding:6px 12px;}"
            "QPushButton:disabled{background:#1b2c44;color:#6c7a96;border:1px solid #1b2c44;}"
            % (self._theme.accent, self._theme.card_border)
        )
        self._task_button.clicked.connect(self._handle_task_button)
        footer.addWidget(self._task_button, 0)
        root.addLayout(footer)

        self._timer = QTimer(self)
        self._timer.setInterval(800)
        self._timer.timeout.connect(self.refresh)
        self._timer.start()
        QTimer.singleShot(0, self.refresh)

    # ------------------------------------------------------------------
    def refresh(self) -> None:
        """Read any new log bytes and append them to the tab views."""

        chunk = ""
        try:
            with open(self._log_path, "r", encoding="utf-8", errors="replace") as fh:
                fh.seek(self._last_pos)
                chunk = fh.read()
                self._last_pos = fh.tell()
        except FileNotFoundError:
            return
        except Exception as exc:  # pragma: no cover - defensive guard
            LOGGER.debug("ErrorCenter refresh failed: %s", exc)
            return

        if not chunk:
            return

        text = self._buffer + chunk
        lines = text.splitlines()
        if text and not text.endswith("\n"):
            self._buffer = lines[-1] if lines else text
            lines = lines[:-1]
        else:
            self._buffer = ""

        for line in lines:
            self._process_line(line)

    # ------------------------------------------------------------------
    def _process_line(self, line: str) -> None:
        categories = self._categorise(line)
        formatted = self._format_line(line)
        task_id = self._extract_task_id(line)
        parsed = self._parse_log_line(line)

        for name in categories:
            view = self._tabs.get(name)
            if not view:
                continue
            view.append(f"<span>{formatted}</span>")
            view.moveCursor(QTextCursor.End)

        if task_id:
            self._latest_task_id = task_id
            self._task_label.setText(f"Latest task reference: {task_id}")
            self._task_button.setEnabled(True)
        elif self._latest_task_id is None:
            self._task_label.setText("No task reference detected.")
            self._task_button.setEnabled(False)

        if parsed and parsed[1] in _ERROR_LEVELS:
            self._persist_error(parsed, categories, task_id)

    # ------------------------------------------------------------------
    def _categorise(self, line: str) -> Set[str]:
        lowered = line.lower()
        matches: Set[str] = set()
        for profile in _CATEGORY_PROFILES:
            if any(keyword in lowered for keyword in profile.keywords):
                matches.add(profile.name)
        if not matches:
            matches.add("Runtime")
        return matches

    # ------------------------------------------------------------------
    def _format_line(self, line: str) -> str:
        safe = html.escape(line.rstrip())
        for token, color in _SEVERITY_COLORS.items():
            if token in safe:
                safe = safe.replace(token, f"<span style='color:{color};font-weight:600;'>{token}</span>")
        return safe

    # ------------------------------------------------------------------
    def _extract_task_id(self, line: str) -> Optional[str]:
        match = _TASK_PATTERN.search(line)
        if match:
            return match.group(1)
        return None

    # ------------------------------------------------------------------
    def _parse_log_line(self, line: str) -> Optional[tuple[str, str, str]]:
        match = _LOG_LINE_PATTERN.match(line.strip())
        if not match:
            return None
        return match.group("ts"), match.group("level"), match.group("msg")

    # ------------------------------------------------------------------
    def _extract_path(self, message: str) -> Optional[str]:
        match = _PATH_PATTERN.search(message)
        if match:
            return match.group("path")
        return None

    # ------------------------------------------------------------------
    def _primary_category(self, categories: Set[str]) -> str:
        if not categories:
            return "Runtime"
        ordered = sorted(categories)
        for name in ordered:
            if name != "Runtime":
                return name
        return ordered[0]

    # ------------------------------------------------------------------
    def _persist_error(
        self,
        parsed: tuple[str, str, str],
        categories: Set[str],
        task_id: Optional[str],
    ) -> None:
        ts_raw, level, message = parsed
        try:
            dt = datetime.strptime(ts_raw, "%Y-%m-%d %H:%M:%S,%f")
            ts_value = dt.timestamp()
        except ValueError:
            try:
                dt = datetime.strptime(ts_raw, "%Y-%m-%d %H:%M:%S")
                ts_value = dt.timestamp()
            except ValueError:
                ts_value = datetime.utcnow().timestamp()
        kind = self._primary_category(categories)
        path = self._extract_path(message)
        record = ErrorRecord(
            ts=ts_value,
            level=level,
            kind=kind,
            msg=message,
            path=path,
            task_id=task_id,
        )
        try:
            append_error_record(record)
        except Exception as exc:  # pragma: no cover - persistence guard
            LOGGER.debug("Unable to persist error record: %s", exc)

    # ------------------------------------------------------------------
    def _handle_task_button(self) -> None:
        if not self._latest_task_id:
            return
        task_id = self._latest_task_id
        self.task_requested.emit(task_id)
        if self._open_task_cb:
            try:
                self._open_task_cb(task_id)
            except Exception as exc:  # pragma: no cover - guard callbacks
                LOGGER.debug("Error Center task callback failed: %s", exc)

    # ------------------------------------------------------------------
    def set_open_task_callback(self, callback: Optional[Callable[[str], None]]) -> None:
        """Update the callback invoked when the related-task button is clicked."""

        self._open_task_cb = callback
        if callback is None:
            self._task_button.setEnabled(False)
            self._task_label.setText("Task integration unavailable.")
```

Error Center card for the Virtual Desktop.

Provides filtered log tabs, severity highlighting, and task shortcuts
based on guidance from `concepts/dev_logic/Virtual_Desktop logic.md`.
**Classes:** _CategoryProfile, ErrorCenterCard


## Module `error_console.py`

```python
from __future__ import annotations

import io
import traceback
from datetime import datetime
from pathlib import Path
from typing import Optional

from PySide6.QtCore import Qt
from PySide6.QtWidgets import QDockWidget, QTextEdit, QWidget


class ErrorConsole(QDockWidget):
    """Dockable console to display and persist error messages."""

    def __init__(self, errors_dir: Path | str = "errors", parent: Optional[QWidget] = None):
        super().__init__("Errors", parent)
        self.setAllowedAreas(Qt.BottomDockWidgetArea | Qt.TopDockWidgetArea)
        self.setFeatures(QDockWidget.DockWidgetClosable | QDockWidget.DockWidgetMovable)
        self._text = QTextEdit(self)
        self._text.setReadOnly(True)
        self.setWidget(self._text)
        self.errors_dir = Path(errors_dir)
        self.errors_dir.mkdir(parents=True, exist_ok=True)

    # ------------------------------------------------------------------
    def log(self, message: str) -> None:
        """Append message to console and persist to timestamped file."""
        ts = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        self._text.append(f"[{ts}] {message}")
        fname = self.errors_dir / f"{datetime.now().strftime('%Y%m%d-%H%M%S')}.log"
        with fname.open("a", encoding="utf-8") as fh:
            if message.endswith("\n"):
                fh.write(message)
            else:
                fh.write(f"{message}\n")
        self.show()
        self.raise_()


class StderrRedirector(io.TextIOBase):
    """File-like object that sends writes to the ErrorConsole."""

    def __init__(self, console: ErrorConsole, original):
        self.console = console
        self.original = original
        self._buffer = ""

    def write(self, s: str) -> int:  # type: ignore[override]
        self.original.write(s)
        self._buffer += s
        while "\n" in self._buffer:
            line, self._buffer = self._buffer.split("\n", 1)
            if line.strip():
                self.console.log(line)
        return len(s)

    def flush(self) -> None:  # type: ignore[override]
        if self._buffer.strip():
            self.console.log(self._buffer)
            self._buffer = ""
        self.original.flush()


def log_exception(console: ErrorConsole, exc_type, exc, tb) -> None:
    """Format and log an exception using the provided console."""
    text = "".join(traceback.format_exception(exc_type, exc, tb))
    console.log(text)
```

**Classes:** ErrorConsole, StderrRedirector
**Functions:** log_exception(console, exc_type, exc, tb)


## Module `external_app_card.py`

```python
"""Windows-only helpers for embedding external GUI processes."""

from __future__ import annotations

import logging
import os
import shlex
import sys
import time
from dataclasses import dataclass
from typing import Callable, Iterable, List, Optional, Sequence, Set, Tuple

from PySide6.QtWidgets import QWidget  # common base for typing


def _load_embed_timeout(default: float = 30.0) -> float:
    """Return the configured embed timeout in seconds."""

    value = os.getenv("CODEX_EXTERNAL_APP_EMBED_TIMEOUT")
    if value is None:
        return default
    try:
        parsed = float(value)
    except (TypeError, ValueError):
        return default
    return parsed


EXTERNAL_APP_EMBED_TIMEOUT_SECONDS = _load_embed_timeout()


@dataclass
class LaunchSpec:
    """Normalized launch configuration for an external process."""

    argv: List[str]
    cwd: str
    target_path: str
    original_path: str


if sys.platform.startswith("win"):
    import ctypes
    from ctypes import wintypes

    from PySide6.QtCore import Qt, QEvent, QPoint, QProcess, QTimer, Signal
    from PySide6.QtGui import QWindow
    from PySide6.QtWidgets import QLabel, QVBoxLayout

    _user32 = ctypes.windll.user32  # type: ignore[attr-defined]
    _ole32 = ctypes.windll.ole32  # type: ignore[attr-defined]
    _shell32 = ctypes.windll.shell32  # type: ignore[attr-defined]
    _shlwapi = ctypes.windll.shlwapi  # type: ignore[attr-defined]
    _kernel32 = ctypes.WinDLL("kernel32", use_last_error=True)  # type: ignore[attr-defined]

    _EnumWindowsProc = ctypes.WINFUNCTYPE(wintypes.BOOL, wintypes.HWND, wintypes.LPARAM)
    _user32.EnumWindows.argtypes = [_EnumWindowsProc, wintypes.LPARAM]
    _user32.EnumWindows.restype = wintypes.BOOL
    _user32.GetWindowThreadProcessId.argtypes = [wintypes.HWND, ctypes.POINTER(wintypes.DWORD)]
    _user32.GetWindowThreadProcessId.restype = wintypes.DWORD
    _user32.IsWindowVisible.argtypes = [wintypes.HWND]
    _user32.IsWindowVisible.restype = wintypes.BOOL
    _user32.IsWindow.argtypes = [wintypes.HWND]
    _user32.IsWindow.restype = wintypes.BOOL
    _user32.GetWindow.argtypes = [wintypes.HWND, ctypes.c_uint]
    _user32.GetWindow.restype = wintypes.HWND
    _user32.GetParent.argtypes = [wintypes.HWND]
    _user32.GetParent.restype = wintypes.HWND
    _user32.SetParent.argtypes = [wintypes.HWND, wintypes.HWND]
    _user32.SetParent.restype = wintypes.HWND
    _user32.GetWindowLongW.argtypes = [wintypes.HWND, ctypes.c_int]
    _user32.GetWindowLongW.restype = ctypes.c_long
    _user32.SetWindowLongW.argtypes = [wintypes.HWND, ctypes.c_int, ctypes.c_long]
    _user32.SetWindowLongW.restype = ctypes.c_long
    _user32.SetWindowPos.argtypes = [wintypes.HWND, wintypes.HWND, ctypes.c_int, ctypes.c_int, ctypes.c_int, ctypes.c_int, ctypes.c_uint]
    _user32.SetWindowPos.restype = wintypes.BOOL
    _user32.ScreenToClient.argtypes = [wintypes.HWND, ctypes.POINTER(wintypes.POINT)]
    _user32.ScreenToClient.restype = wintypes.BOOL
    _user32.SetFocus.argtypes = [wintypes.HWND]
    _user32.SetFocus.restype = wintypes.HWND
    _user32.SetActiveWindow.argtypes = [wintypes.HWND]
    _user32.SetActiveWindow.restype = wintypes.HWND
    _user32.ShowWindow.argtypes = [wintypes.HWND, ctypes.c_int]
    _user32.ShowWindow.restype = wintypes.BOOL
    _user32.UpdateWindow.argtypes = [wintypes.HWND]
    _user32.UpdateWindow.restype = wintypes.BOOL

    _kernel32.OpenProcess.argtypes = [wintypes.DWORD, wintypes.BOOL, wintypes.DWORD]
    _kernel32.OpenProcess.restype = wintypes.HANDLE
    _kernel32.CloseHandle.argtypes = [wintypes.HANDLE]
    _kernel32.CloseHandle.restype = wintypes.BOOL
    _kernel32.QueryFullProcessImageNameW.argtypes = [
        wintypes.HANDLE,
        wintypes.DWORD,
        wintypes.LPWSTR,
        ctypes.POINTER(wintypes.DWORD),
    ]
    _kernel32.QueryFullProcessImageNameW.restype = wintypes.BOOL
    _kernel32.CreateToolhelp32Snapshot.argtypes = [wintypes.DWORD, wintypes.DWORD]
    _kernel32.CreateToolhelp32Snapshot.restype = wintypes.HANDLE
    _kernel32.TerminateProcess.argtypes = [wintypes.HANDLE, wintypes.UINT]
    _kernel32.TerminateProcess.restype = wintypes.BOOL
    _kernel32.WaitForSingleObject.argtypes = [wintypes.HANDLE, wintypes.DWORD]
    _kernel32.WaitForSingleObject.restype = wintypes.DWORD

    _GW_OWNER = 4
    _GWL_STYLE = -16
    _WS_CHILD = 0x40000000
    _WS_POPUP = 0x80000000
    _WS_CAPTION = 0x00C00000
    _WS_THICKFRAME = 0x00040000
    _WS_MINIMIZEBOX = 0x00020000
    _WS_MAXIMIZEBOX = 0x00010000
    _SWP_NOSIZE = 0x0001
    _SWP_NOZORDER = 0x0004
    _SWP_NOACTIVATE = 0x0010
    _SWP_FRAMECHANGED = 0x0020
    _SWP_SHOWWINDOW = 0x0040
    _SWP_ASYNCWINDOWPOS = 0x4000
    _SW_SHOW = 5
    _COINIT_APARTMENTTHREADED = 0x2
    _CLSCTX_INPROC_SERVER = 0x1
    _PROCESS_QUERY_LIMITED_INFORMATION = 0x1000
    _PROCESS_TERMINATE = 0x0001
    _SYNCHRONIZE = 0x00100000
    _ERROR_INSUFFICIENT_BUFFER = 122
    _TH32CS_SNAPPROCESS = 0x00000002
    _INVALID_HANDLE_VALUE = ctypes.c_void_p(-1).value
    _WAIT_TIMEOUT = 0x00000102

    HRESULT = ctypes.c_long
    ULONG = ctypes.c_ulong
    LPVOID = ctypes.c_void_p
    LPCOLESTR = wintypes.LPCWSTR
    LPWSTR = wintypes.LPWSTR

    class _GUID(ctypes.Structure):
        _fields_ = [
            ("Data1", wintypes.DWORD),
            ("Data2", wintypes.WORD),
            ("Data3", wintypes.WORD),
            ("Data4", ctypes.c_ubyte * 8),
        ]


    def _guid(value: str) -> _GUID:
        guid = _GUID()
        if _ole32.CLSIDFromString(ctypes.c_wchar_p(value), ctypes.byref(guid)) != 0:  # type: ignore[arg-type]
            raise OSError(f"CLSIDFromString failed for {value}")
        return guid


    class _IShellLinkW(ctypes.Structure):
        pass


    class _IShellLinkWVTbl(ctypes.Structure):
        _fields_ = [
            ("QueryInterface", ctypes.WINFUNCTYPE(HRESULT, ctypes.POINTER(_IShellLinkW), ctypes.POINTER(_GUID), ctypes.POINTER(LPVOID))),
            ("AddRef", ctypes.WINFUNCTYPE(ULONG, ctypes.POINTER(_IShellLinkW))),
            ("Release", ctypes.WINFUNCTYPE(ULONG, ctypes.POINTER(_IShellLinkW))),
            ("GetPath", ctypes.WINFUNCTYPE(HRESULT, ctypes.POINTER(_IShellLinkW), LPWSTR, ctypes.c_int, ctypes.POINTER(wintypes.WIN32_FIND_DATAW), wintypes.DWORD)),
            ("GetIDList", ctypes.WINFUNCTYPE(HRESULT, ctypes.POINTER(_IShellLinkW), ctypes.POINTER(LPVOID))),
            ("SetIDList", ctypes.WINFUNCTYPE(HRESULT, ctypes.POINTER(_IShellLinkW), LPVOID)),
            ("GetDescription", ctypes.WINFUNCTYPE(HRESULT, ctypes.POINTER(_IShellLinkW), LPWSTR, ctypes.c_int)),
            ("SetDescription", ctypes.WINFUNCTYPE(HRESULT, ctypes.POINTER(_IShellLinkW), wintypes.LPCWSTR)),
            ("GetWorkingDirectory", ctypes.WINFUNCTYPE(HRESULT, ctypes.POINTER(_IShellLinkW), LPWSTR, ctypes.c_int)),
            ("SetWorkingDirectory", ctypes.WINFUNCTYPE(HRESULT, ctypes.POINTER(_IShellLinkW), wintypes.LPCWSTR)),
            ("GetArguments", ctypes.WINFUNCTYPE(HRESULT, ctypes.POINTER(_IShellLinkW), LPWSTR, ctypes.c_int)),
            ("SetArguments", ctypes.WINFUNCTYPE(HRESULT, ctypes.POINTER(_IShellLinkW), wintypes.LPCWSTR)),
            ("GetHotkey", ctypes.WINFUNCTYPE(HRESULT, ctypes.POINTER(_IShellLinkW), ctypes.POINTER(wintypes.WORD))),
            ("SetHotkey", ctypes.WINFUNCTYPE(HRESULT, ctypes.POINTER(_IShellLinkW), wintypes.WORD)),
            ("GetShowCmd", ctypes.WINFUNCTYPE(HRESULT, ctypes.POINTER(_IShellLinkW), ctypes.POINTER(ctypes.c_int))),
            ("SetShowCmd", ctypes.WINFUNCTYPE(HRESULT, ctypes.POINTER(_IShellLinkW), ctypes.c_int)),
            ("GetIconLocation", ctypes.WINFUNCTYPE(HRESULT, ctypes.POINTER(_IShellLinkW), LPWSTR, ctypes.c_int, ctypes.POINTER(ctypes.c_int))),
            ("SetIconLocation", ctypes.WINFUNCTYPE(HRESULT, ctypes.POINTER(_IShellLinkW), wintypes.LPCWSTR, ctypes.c_int)),
            ("SetRelativePath", ctypes.WINFUNCTYPE(HRESULT, ctypes.POINTER(_IShellLinkW), wintypes.LPCWSTR, wintypes.DWORD)),
            ("Resolve", ctypes.WINFUNCTYPE(HRESULT, ctypes.POINTER(_IShellLinkW), wintypes.HWND, wintypes.DWORD)),
            ("SetPath", ctypes.WINFUNCTYPE(HRESULT, ctypes.POINTER(_IShellLinkW), wintypes.LPCWSTR)),
        ]


    _IShellLinkW._fields_ = [("lpVtbl", ctypes.POINTER(_IShellLinkWVTbl))]


    class _IPersistFile(ctypes.Structure):
        pass


    class _IPersistFileVTbl(ctypes.Structure):
        _fields_ = [
            ("QueryInterface", ctypes.WINFUNCTYPE(HRESULT, ctypes.POINTER(_IPersistFile), ctypes.POINTER(_GUID), ctypes.POINTER(LPVOID))),
            ("AddRef", ctypes.WINFUNCTYPE(ULONG, ctypes.POINTER(_IPersistFile))),
            ("Release", ctypes.WINFUNCTYPE(ULONG, ctypes.POINTER(_IPersistFile))),
            ("GetClassID", ctypes.WINFUNCTYPE(HRESULT, ctypes.POINTER(_IPersistFile), ctypes.POINTER(_GUID))),
            ("IsDirty", ctypes.WINFUNCTYPE(HRESULT, ctypes.POINTER(_IPersistFile))),
            ("Load", ctypes.WINFUNCTYPE(HRESULT, ctypes.POINTER(_IPersistFile), LPCOLESTR, wintypes.DWORD)),
            ("Save", ctypes.WINFUNCTYPE(HRESULT, ctypes.POINTER(_IPersistFile), LPCOLESTR, ctypes.c_int)),
            ("SaveCompleted", ctypes.WINFUNCTYPE(HRESULT, ctypes.POINTER(_IPersistFile), LPCOLESTR)),
            ("GetCurFile", ctypes.WINFUNCTYPE(HRESULT, ctypes.POINTER(_IPersistFile), ctypes.POINTER(LPCOLESTR))),
        ]


    _IPersistFile._fields_ = [("lpVtbl", ctypes.POINTER(_IPersistFileVTbl))]

    class _PROCESSENTRY32W(ctypes.Structure):
        _fields_ = [
            ("dwSize", wintypes.DWORD),
            ("cntUsage", wintypes.DWORD),
            ("th32ProcessID", wintypes.DWORD),
            ("th32DefaultHeapID", ctypes.c_void_p),
            ("th32ModuleID", wintypes.DWORD),
            ("cntThreads", wintypes.DWORD),
            ("th32ParentProcessID", wintypes.DWORD),
            ("pcPriClassBase", ctypes.c_long),
            ("dwFlags", wintypes.DWORD),
            ("szExeFile", wintypes.WCHAR * 260),
        ]

    _kernel32.Process32FirstW.argtypes = [wintypes.HANDLE, ctypes.POINTER(_PROCESSENTRY32W)]
    _kernel32.Process32FirstW.restype = wintypes.BOOL
    _kernel32.Process32NextW.argtypes = [wintypes.HANDLE, ctypes.POINTER(_PROCESSENTRY32W)]
    _kernel32.Process32NextW.restype = wintypes.BOOL

    _shell32.FindExecutableW.argtypes = [wintypes.LPCWSTR, wintypes.LPCWSTR, wintypes.LPWSTR]
    _shell32.FindExecutableW.restype = wintypes.HINSTANCE

    _shlwapi.AssocQueryStringW.argtypes = [
        wintypes.DWORD,
        wintypes.DWORD,
        wintypes.LPCWSTR,
        wintypes.LPCWSTR,
        wintypes.LPWSTR,
        ctypes.POINTER(wintypes.DWORD),
    ]
    _shlwapi.AssocQueryStringW.restype = HRESULT

    _ASSOCF_NONE = 0x00000000
    _ASSOCSTR_EXECUTABLE = 2

    _CLSID_SHELL_LINK = _guid("{00021401-0000-0000-C000-000000000046}")
    _IID_ISHELL_LINK = _guid("{000214F9-0000-0000-C000-000000000046}")
    _IID_IPERSIST_FILE = _guid("{0000010b-0000-0000-C000-000000000046}")


    def _resolve_associated_executable(path: str) -> Optional[str]:
        if not path:
            return None

        normalized = os.path.abspath(path)

        try:
            buffer = ctypes.create_unicode_buffer(wintypes.MAX_PATH)
            result = _shell32.FindExecutableW(normalized, None, buffer)
        except OSError:
            result = 0

        if result > 32:
            candidate = buffer.value.strip().strip('"')
            if candidate and os.path.isfile(candidate):
                return os.path.abspath(candidate)

        _, ext = os.path.splitext(normalized)
        if not ext:
            return None

        length = wintypes.DWORD(0)
        hr = _shlwapi.AssocQueryStringW(
            _ASSOCF_NONE,
            _ASSOCSTR_EXECUTABLE,
            ext,
            None,
            None,
            ctypes.byref(length),
        )

        if hr not in (0, 1) or length.value == 0:
            return None

        buffer = ctypes.create_unicode_buffer(length.value)
        hr = _shlwapi.AssocQueryStringW(
            _ASSOCF_NONE,
            _ASSOCSTR_EXECUTABLE,
            ext,
            None,
            buffer,
            ctypes.byref(length),
        )
        if hr != 0:
            return None

        candidate = buffer.value.strip().strip('"')
        if candidate and os.path.isfile(candidate):
            return os.path.abspath(candidate)

        return None


    def _enum_top_level_windows() -> List[int]:
        handles: List[int] = []

        @_EnumWindowsProc
        def _callback(hwnd: wintypes.HWND, _lparam: wintypes.LPARAM) -> wintypes.BOOL:
            if not _user32.IsWindowVisible(hwnd):
                return True
            if _user32.GetWindow(hwnd, _GW_OWNER):
                return True
            if _user32.GetParent(hwnd):
                return True
            handles.append(int(hwnd))
            return True

        _user32.EnumWindows(_callback, 0)
        return handles


    def _enum_windows_for_pid(pid: int) -> List[int]:
        handles: List[int] = []

        @_EnumWindowsProc
        def _callback(hwnd: wintypes.HWND, _lparam: wintypes.LPARAM) -> wintypes.BOOL:
            proc_id = wintypes.DWORD()
            _user32.GetWindowThreadProcessId(hwnd, ctypes.byref(proc_id))
            if proc_id.value != pid:
                return True
            if not _user32.IsWindowVisible(hwnd):
                return True
            if _user32.GetWindow(hwnd, _GW_OWNER):
                return True
            if _user32.GetParent(hwnd):
                return True
            handles.append(int(hwnd))
            return False

        _user32.EnumWindows(_callback, 0)
        return handles


    def _enum_descendant_processes(root_pid: int) -> Set[int]:
        descendants: Set[int] = set()
        if root_pid <= 0:
            return descendants

        snapshot = _kernel32.CreateToolhelp32Snapshot(_TH32CS_SNAPPROCESS, 0)
        handle_value = getattr(snapshot, "value", snapshot)
        if not snapshot or int(handle_value) == int(_INVALID_HANDLE_VALUE):
            return descendants

        parent_map: Dict[int, List[int]] = {}
        try:
            entry = _PROCESSENTRY32W()
            entry.dwSize = ctypes.sizeof(_PROCESSENTRY32W)
            if not _kernel32.Process32FirstW(snapshot, ctypes.byref(entry)):
                return descendants
            while True:
                pid = int(entry.th32ProcessID)
                parent = int(entry.th32ParentProcessID)
                if pid > 0 and pid != root_pid:
                    parent_map.setdefault(parent, []).append(pid)
                if not _kernel32.Process32NextW(snapshot, ctypes.byref(entry)):
                    break
        finally:
            _kernel32.CloseHandle(snapshot)

        queue: List[int] = [root_pid]
        while queue:
            current = queue.pop()
            for child in parent_map.get(current, []):
                if child not in descendants:
                    descendants.add(child)
                    queue.append(child)
        return descendants


    def _query_process_image_path(pid: int) -> Optional[str]:
        if pid <= 0:
            return None
        process = _kernel32.OpenProcess(_PROCESS_QUERY_LIMITED_INFORMATION, False, pid)
        if not process:
            return None
        try:
            size = wintypes.DWORD(260)
            while size.value <= 32768:
                buffer = ctypes.create_unicode_buffer(size.value)
                required = wintypes.DWORD(size.value)
                ctypes.set_last_error(0)
                success = _kernel32.QueryFullProcessImageNameW(process, 0, buffer, ctypes.byref(required))
                if success:
                    return buffer.value.strip()
                error = ctypes.get_last_error()
                if error != _ERROR_INSUFFICIENT_BUFFER:
                    return None
                if required.value > size.value:
                    size = wintypes.DWORD(required.value + 1)
                else:
                    size = wintypes.DWORD(size.value * 2)
            return None
        finally:
            _kernel32.CloseHandle(process)


    def _find_window_for_executables(paths: Iterable[str], ignored: Set[int]) -> Optional[Tuple[int, int]]:
        normalized: Set[str] = set()
        for path in paths:
            if not path:
                continue
            try:
                normalized.add(os.path.normcase(os.path.abspath(path)))
            except Exception:
                continue
        if not normalized:
            return None

        for hwnd in _enum_top_level_windows():
            if hwnd in ignored:
                continue
            proc_id = wintypes.DWORD()
            _user32.GetWindowThreadProcessId(wintypes.HWND(hwnd), ctypes.byref(proc_id))
            pid = int(proc_id.value)
            if pid <= 0:
                continue
            image = _query_process_image_path(pid)
            if not image:
                continue
            try:
                image_norm = os.path.normcase(os.path.abspath(image))
            except Exception:
                continue
            if image_norm in normalized:
                return hwnd, pid

        return None


    def _find_main_hwnd(pid: int) -> Optional[int]:
        handles = _enum_windows_for_pid(pid)
        return handles[0] if handles else None


    def _pe_is_gui_subsystem(path: str) -> Optional[bool]:
        try:
            with open(path, "rb") as fh:
                header = fh.read(64)
                if len(header) < 64 or header[:2] != b"MZ":
                    return None
                pe_offset = int.from_bytes(header[60:64], "little")
                fh.seek(pe_offset)
                if fh.read(4) != b"PE\0\0":
                    return None
                fh.seek(pe_offset + 24)
                optional = fh.read(0x60)
                if len(optional) < 0x46:
                    return None
                subsystem = int.from_bytes(optional[0x44:0x46], "little")
                if subsystem == 2:
                    return True
                if subsystem == 3:
                    return False
                return None
        except Exception:
            return None


    def _resolve_windows_shortcut(path: str) -> Optional[tuple[str, List[str], Optional[str]]]:
        if not path.lower().endswith(".lnk"):
            return None
        if not os.path.exists(path):
            return None
        hr = _ole32.CoInitializeEx(None, _COINIT_APARTMENTTHREADED)
        uninit = hr in (0, 1)
        try:
            shell_link_ptr = ctypes.c_void_p()
            result = _ole32.CoCreateInstance(
                ctypes.byref(_CLSID_SHELL_LINK),
                None,
                _CLSCTX_INPROC_SERVER,
                ctypes.byref(_IID_ISHELL_LINK),
                ctypes.byref(shell_link_ptr),
            )
            if result != 0 or not shell_link_ptr:
                return None
            shell_link = ctypes.cast(shell_link_ptr, ctypes.POINTER(_IShellLinkW))
            persist_ptr = ctypes.c_void_p()
            if shell_link.contents.lpVtbl.contents.QueryInterface(shell_link, ctypes.byref(_IID_IPERSIST_FILE), ctypes.byref(persist_ptr)) != 0:
                shell_link.contents.lpVtbl.contents.Release(shell_link)
                return None
            persist = ctypes.cast(persist_ptr, ctypes.POINTER(_IPersistFile))
            if persist.contents.lpVtbl.contents.Load(persist, ctypes.c_wchar_p(path), 0) != 0:
                persist.contents.lpVtbl.contents.Release(persist)
                shell_link.contents.lpVtbl.contents.Release(shell_link)
                return None
            buffer = ctypes.create_unicode_buffer(wintypes.MAX_PATH)
            find_data = wintypes.WIN32_FIND_DATAW()
            if shell_link.contents.lpVtbl.contents.GetPath(shell_link, buffer, len(buffer), ctypes.byref(find_data), 0) != 0:
                persist.contents.lpVtbl.contents.Release(persist)
                shell_link.contents.lpVtbl.contents.Release(shell_link)
                return None
            target = buffer.value
            args_buf = ctypes.create_unicode_buffer(1024)
            shell_link.contents.lpVtbl.contents.GetArguments(shell_link, args_buf, len(args_buf))
            cwd_buf = ctypes.create_unicode_buffer(wintypes.MAX_PATH)
            shell_link.contents.lpVtbl.contents.GetWorkingDirectory(shell_link, cwd_buf, len(cwd_buf))
            persist.contents.lpVtbl.contents.Release(persist)
            shell_link.contents.lpVtbl.contents.Release(shell_link)
            args = args_buf.value.strip()
            working_dir = cwd_buf.value.strip() or None
            arg_list = shlex.split(args, posix=False) if args else []
            return target, arg_list, working_dir
        except Exception:
            return None
        finally:
            if uninit:
                try:
                    _ole32.CoUninitialize()
                except Exception:
                    pass


    class ExternalAppCard(QWidget):  # pragma: no cover - Windows-specific widget
        request_close = Signal()
        process_finished = Signal(int, str)
        fallback_requested = Signal(str)

        def __init__(
            self,
            theme,
            spec: LaunchSpec,
            *,
            toast_cb: Optional[Callable[[str, str], None]] = None,
            log_cb: Optional[Callable[[str, int], None]] = None,
            embed_timeout: Optional[float] = None,
        ) -> None:
            super().__init__()
            self._theme = theme
            self._spec = spec
            self._toast_cb = toast_cb
            self._log_cb = log_cb
            self._process = QProcess(self)
            if spec.argv:
                self._process.setProgram(spec.argv[0])
                self._process.setArguments(spec.argv[1:])
            self._process.setWorkingDirectory(spec.cwd)
            self._process.finished.connect(self._on_finished)
            self._process.errorOccurred.connect(self._on_error)
            self._poll_timer = QTimer(self)
            self._poll_timer.setInterval(200)
            self._poll_timer.timeout.connect(self._poll_for_window)
            self._watchdog = QTimer(self)
            self._watchdog.setInterval(1000)
            self._watchdog.timeout.connect(self._check_window_alive)
            if embed_timeout is None:
                embed_timeout = EXTERNAL_APP_EMBED_TIMEOUT_SECONDS
            try:
                self._embed_timeout = float(embed_timeout)
            except (TypeError, ValueError):
                self._embed_timeout = float(EXTERNAL_APP_EMBED_TIMEOUT_SECONDS)
            self._embed_deadline = 0.0
            self._embedded_hwnd: int = 0
            self._original_parent: int = 0
            self._original_style: int = 0
            self._container: Optional[QWidget] = None
            self._embedded_window: Optional[QWindow] = None
            self._fallback_emitted = False
            self._suppress_finished = False
            self._card = None
            self._preexisting_windows: Set[int] = set(_enum_top_level_windows())
            self._discovered_executables: Set[str] = set()
            self._launcher_directories: Set[str] = self._compute_launcher_directories()
            self._candidate_executables: Set[str] = self._normalize_executable_candidates()
            self._tracked_pid: Optional[int] = None
            self._pending_exit_detail: Optional[Tuple[int, str]] = None
            self._window_released = True
            self._last_embedded_size: Optional[Tuple[int, int]] = None
            self._last_embedded_origin: Optional[Tuple[int, int]] = None
            self._last_position_sync_ts = 0.0
            self._position_sync_interval = 0.05

            layout = QVBoxLayout(self)
            layout.setContentsMargins(0, 0, 0, 0)
            layout.setSpacing(0)
            self._placeholder = QLabel("Launching…", self)
            self._placeholder.setAlignment(Qt.AlignCenter)
            self._placeholder.setStyleSheet(
                f"color:{getattr(theme, 'header_fg', '#eaf2ff')};font:600 10pt 'Cascadia Code';padding:24px;"
            )
            layout.addWidget(self._placeholder, 1)
            self.setFocusPolicy(Qt.StrongFocus)

        # ------------------------------------------------------------------
        def attach_card(self, card: QWidget) -> None:
            self._card = card
            connections = {
                "resized": self._sync_geometry,
                "moved": self._sync_geometry,
                "restored": self._sync_geometry,
                "moving": self._sync_embedded_position,
            }
            for signal_name, handler in connections.items():
                if not hasattr(card, signal_name):
                    continue
                try:
                    getattr(card, signal_name).connect(handler)
                except Exception:
                    continue

        # ------------------------------------------------------------------
        def start(self) -> bool:
            if not self._spec.argv:
                self._emit_fallback("No command specified.")
                return False
            try:
                program = self._spec.argv[0]
                args = self._spec.argv[1:]
                self._log(f"[external-app] Launching: {program} {' '.join(args)}")
                self._process.start(program, args)
            except Exception as exc:  # pragma: no cover - Qt start errors
                self._emit_fallback(f"Launch failed: {exc}")
                return False
            if not self._process.waitForStarted(5000):
                reason = self._process.errorString() or "Launch failed."
                self._emit_fallback(reason)
                return False
            if self._embed_timeout and self._embed_timeout > 0:
                self._embed_deadline = time.monotonic() + float(self._embed_timeout)
            else:
                self._embed_deadline = 0.0
            self._poll_timer.start()
            return True

        # ------------------------------------------------------------------
        def shutdown(self) -> None:
            self._poll_timer.stop()
            self._watchdog.stop()
            if self._process.state() == QProcess.NotRunning:
                self._force_terminate_tracked_process()
                self._release_window()
                return
            self._process.terminate()
            if self._process.waitForFinished(1500):
                self._release_window()
                return
            self._process.kill()
            if self._process.waitForFinished(1500) or self._process.state() == QProcess.NotRunning:
                self._release_window()

        # ------------------------------------------------------------------
        def _force_terminate_tracked_process(self) -> None:
            pid = self._tracked_pid
            if not pid or pid <= 0:
                self._tracked_pid = None
                return

            try:
                descendants = _enum_descendant_processes(pid)
            except Exception:
                descendants = set()

            targets = [child for child in descendants if child > 0]
            targets.sort(reverse=True)
            successes: List[int] = []
            failures: List[int] = []

            for target in targets:
                if self._terminate_process(target):
                    successes.append(target)
                else:
                    failures.append(target)

            if self._terminate_process(pid):
                successes.append(pid)
            else:
                failures.append(pid)

            self._tracked_pid = None

            if not successes and not failures:
                return

            detail_parts = [
                f"Forced termination for orphaned external app PID {pid}.",
            ]
            if successes:
                detail_parts.append(
                    "Terminated: " + ", ".join(str(value) for value in successes)
                )
            if failures:
                detail_parts.append(
                    "Failed: " + ", ".join(str(value) for value in failures)
                )
            level = logging.WARNING if not failures else logging.ERROR
            self._log("[external-app] " + " ".join(detail_parts), level)

            if callable(self._toast_cb):
                toast_message = "Force closed external app after launcher exit."
                toast_kind = "warning"
                if failures:
                    toast_message = (
                        "Unable to fully close external app after launcher exit."
                    )
                    toast_kind = "error"
                try:
                    self._toast_cb(toast_message, kind=toast_kind)
                except TypeError:
                    self._toast_cb(toast_message)  # type: ignore[misc]

        # ------------------------------------------------------------------
        def _terminate_process(self, pid: int) -> bool:
            if pid <= 0:
                return False

            desired_access = _PROCESS_TERMINATE | _SYNCHRONIZE
            try:
                handle = _kernel32.OpenProcess(desired_access, False, pid)
            except Exception:
                handle = None
            if not handle:
                return False

            try:
                try:
                    if not _kernel32.TerminateProcess(handle, 1):
                        return False
                except Exception:
                    return False
                try:
                    result = _kernel32.WaitForSingleObject(handle, 2000)
                except Exception:
                    result = None
                if result == _WAIT_TIMEOUT:
                    return False
                return True
            finally:
                try:
                    _kernel32.CloseHandle(handle)
                except Exception:
                    pass

        # ------------------------------------------------------------------
        def _emit_fallback(self, message: str) -> None:
            if self._fallback_emitted:
                return
            self._fallback_emitted = True
            self._suppress_finished = True
            self._pending_exit_detail = None
            self.shutdown()
            if callable(self._toast_cb):
                try:
                    self._toast_cb(message, kind="error")
                except TypeError:
                    self._toast_cb(message)  # type: ignore[misc]
            self.fallback_requested.emit(message)

        # ------------------------------------------------------------------
        def _compute_launcher_directories(self) -> Set[str]:
            directories: Set[str] = set()
            entries: List[str] = []
            if self._spec.argv:
                entries.append(self._spec.argv[0])
            if self._spec.target_path:
                entries.append(self._spec.target_path)
            base = self._spec.cwd or os.getcwd()
            for entry in entries:
                if not entry:
                    continue
                try:
                    path = entry
                    if not os.path.isabs(path):
                        path = os.path.join(base, path)
                    normalized = os.path.normcase(os.path.abspath(path))
                except Exception:
                    continue
                directory = os.path.dirname(normalized)
                if directory:
                    directories.add(directory)
            return directories

        # ------------------------------------------------------------------
        def _merge_discovered_executables(self, paths: Iterable[str]) -> None:
            added = False
            for path in paths:
                if not path:
                    continue
                try:
                    normalized = os.path.normcase(os.path.abspath(path))
                except Exception:
                    continue
                if normalized not in self._discovered_executables:
                    self._discovered_executables.add(normalized)
                    added = True
            if added:
                self._candidate_executables = self._normalize_executable_candidates()

        # ------------------------------------------------------------------
        def _normalize_executable_candidates(self) -> Set[str]:
            candidates: Set[str] = set()
            entries: List[str] = []
            if self._spec.argv:
                entries.append(self._spec.argv[0])
            if self._spec.target_path:
                entries.append(self._spec.target_path)
            entries.extend(self._discovered_executables)
            base = self._spec.cwd or os.getcwd()
            for entry in entries:
                if not entry:
                    continue
                try:
                    path = entry
                    if not os.path.isabs(path):
                        path = os.path.join(base, path)
                    candidates.add(os.path.normcase(os.path.abspath(path)))
                except Exception:
                    continue
            return candidates

        # ------------------------------------------------------------------
        def _poll_for_window(self) -> None:
            if self._embedded_hwnd or self._fallback_emitted:
                self._poll_timer.stop()
                return

            pid = int(self._process.processId())
            hwnd = 0
            if pid > 0:
                hwnd = _find_main_hwnd(pid)
            if hwnd:
                self._log(f"[external-app] Found HWND=0x{hwnd:x} for PID {pid}")
                self._embed_window(hwnd, owner_pid=pid)
                self._poll_timer.stop()
                self._watchdog.start()
                return
            fallback = self._locate_adoptable_window()
            if fallback:
                adopt_hwnd, adopt_pid = fallback
                self._log(
                    f"[external-app] Adopted HWND=0x{adopt_hwnd:x} from PID {adopt_pid} via executable scan"
                )
                self._embed_window(adopt_hwnd, owner_pid=adopt_pid)
                self._poll_timer.stop()
                self._watchdog.start()
                return
            if self._embed_deadline and time.monotonic() > self._embed_deadline:
                self._log(
                    f"[external-app] No window detected for PID {pid}; falling back.",
                    logging.WARNING,
                )
                self._emit_fallback("No window detected; falling back to console view.")

        # ------------------------------------------------------------------
        def _locate_adoptable_window(self) -> Optional[Tuple[int, int]]:
            if not self._candidate_executables:
                return None

            match = _find_window_for_executables(self._candidate_executables, self._preexisting_windows)
            if match:
                return match

            pid = int(self._process.processId()) if self._process else 0
            descendant_pids: Set[int] = set()
            descendant_paths: Set[str] = set()
            if pid > 0:
                try:
                    descendant_pids = _enum_descendant_processes(pid)
                except Exception:
                    descendant_pids = set()
                if descendant_pids:
                    for child_pid in descendant_pids:
                        image = _query_process_image_path(child_pid)
                        if image:
                            descendant_paths.add(image)
            if descendant_paths:
                self._merge_discovered_executables(descendant_paths)

            launcher_dirs = self._launcher_directories
            candidate: Optional[Tuple[int, int]] = None
            candidate_reason = ""
            new_executables: Set[str] = set()

            for hwnd in _enum_top_level_windows():
                if hwnd in self._preexisting_windows or hwnd == self._embedded_hwnd:
                    continue
                proc_id = self._window_pid(hwnd)
                if not proc_id or proc_id <= 0 or proc_id == pid:
                    continue
                image = _query_process_image_path(proc_id)
                if not image:
                    continue
                try:
                    image_norm = os.path.normcase(os.path.abspath(image))
                    image_dir = os.path.dirname(image_norm)
                except Exception:
                    continue

                reason = ""
                if proc_id in descendant_pids:
                    reason = "descendant"
                elif launcher_dirs and image_dir in launcher_dirs:
                    reason = "directory"
                if not reason:
                    continue

                new_executables.add(image_norm)
                current = (hwnd, proc_id)
                if reason == "descendant":
                    candidate = current
                    candidate_reason = reason
                    break
                if candidate is None:
                    candidate = current
                    candidate_reason = reason

            if new_executables:
                self._merge_discovered_executables(new_executables)

            if candidate:
                if candidate_reason == "descendant":
                    return candidate
                if candidate_reason == "directory":
                    return candidate
            return None

        # ------------------------------------------------------------------
        def _embed_window(self, hwnd: int, *, owner_pid: Optional[int] = None) -> None:
            if self._embedded_hwnd:
                return
            self._window_released = False
            self._embedded_hwnd = hwnd
            if owner_pid is None:
                owner_pid = self._window_pid(hwnd)
            self._tracked_pid = int(owner_pid) if owner_pid else None
            self._preexisting_windows.add(hwnd)
            try:
                self._original_parent = int(_user32.GetParent(hwnd) or 0)
            except Exception:
                self._original_parent = 0
            try:
                self._original_style = int(_user32.GetWindowLongW(hwnd, _GWL_STYLE))
            except Exception:
                self._original_style = 0
            window = QWindow.fromWinId(int(hwnd))
            window.setFlag(Qt.FramelessWindowHint, True)
            container = QWidget.createWindowContainer(window, self)
            self._last_embedded_size = None
            self._last_embedded_origin = None
            self._last_position_sync_ts = 0.0
            container.setFocusPolicy(Qt.StrongFocus)
            container.setMinimumSize(240, 180)
            container.installEventFilter(self)
            layout = self.layout()
            if isinstance(layout, QVBoxLayout):
                if self._placeholder:
                    layout.removeWidget(self._placeholder)
                    self._placeholder.deleteLater()
                    self._placeholder = None
                layout.addWidget(container, 1)
            self._container = container
            self._embedded_window = window
            new_style = (self._original_style | _WS_CHILD) & ~_WS_POPUP & ~_WS_THICKFRAME & ~_WS_CAPTION
            new_style &= ~_WS_MINIMIZEBOX & ~_WS_MAXIMIZEBOX
            try:
                _user32.SetWindowLongW(hwnd, _GWL_STYLE, new_style)
            except Exception:
                pass
            try:
                _user32.SetParent(hwnd, wintypes.HWND(int(container.winId())))
            except Exception:
                pass
            self._sync_geometry()
            try:
                _user32.ShowWindow(hwnd, _SW_SHOW)
            except Exception:
                pass

        # ------------------------------------------------------------------
        def _window_pid(self, hwnd: int) -> Optional[int]:
            proc_id = wintypes.DWORD()
            thread_id = _user32.GetWindowThreadProcessId(wintypes.HWND(hwnd), ctypes.byref(proc_id))
            if thread_id == 0:
                return None
            value = int(proc_id.value)
            return value if value > 0 else None

        # ------------------------------------------------------------------
        def _release_window(self) -> None:
            if self._window_released:
                return
            self._window_released = True
            hwnd = self._embedded_hwnd
            self._embedded_hwnd = 0
            self._tracked_pid = None
            try:
                if hwnd and self._original_style:
                    _user32.SetWindowLongW(hwnd, _GWL_STYLE, self._original_style)
                if hwnd and self._original_parent:
                    _user32.SetParent(hwnd, wintypes.HWND(self._original_parent))
                if hwnd:
                    _user32.SetWindowPos(
                        hwnd,
                        None,
                        0,
                        0,
                        0,
                        0,
                        _SWP_NOZORDER | _SWP_NOACTIVATE | _SWP_FRAMECHANGED,
                    )
            except Exception:
                pass
            self._original_parent = 0
            self._original_style = 0
            if self._embedded_window:
                try:
                    self._embedded_window.setParent(None)
                except Exception:
                    pass
                self._embedded_window = None
            if self._container:
                self._container.deleteLater()
                self._last_embedded_size = None
                self._last_embedded_origin = None
                self._last_position_sync_ts = 0.0
                self._container = None

        # ------------------------------------------------------------------
        def _sync_geometry(self) -> None:
            if not self._embedded_hwnd or not self._container:
                return
            rect = self._container.rect()
            requested_size = (
                max(1, rect.width()),
                max(1, rect.height()),
            )
            last_size = self._last_embedded_size
            if last_size is not None and requested_size == last_size:
                return
            hwnd = wintypes.HWND(self._embedded_hwnd)
            flags = _SWP_NOZORDER | _SWP_NOACTIVATE | _SWP_FRAMECHANGED
            width, height = requested_size
            try:
                succeeded = bool(
                    _user32.SetWindowPos(
                        hwnd,
                        None,
                        0,
                        0,
                        width,
                        height,
                        flags,
                    )
                )
            except Exception:
                succeeded = False
            if not succeeded:
                self._last_embedded_size = None
                return
            if not (flags & _SWP_ASYNCWINDOWPOS):
                try:
                    _user32.UpdateWindow(hwnd)
                except Exception:
                    pass
                self._last_embedded_size = requested_size
                self._last_embedded_origin = None
                self._last_position_sync_ts = 0.0

        # ------------------------------------------------------------------
        def _sync_embedded_position(self, _pos: QPoint) -> None:
            if not self._embedded_hwnd or not self._container:
                return
            hwnd = wintypes.HWND(self._embedded_hwnd)
            try:
                parent_handle = _user32.GetParent(hwnd)
            except Exception:
                parent_handle = wintypes.HWND(0)
            parent_value = int(parent_handle or 0)
            if not parent_value:
                return
            parent_hwnd = wintypes.HWND(parent_value)
            global_origin = self._container.mapToGlobal(self._container.rect().topLeft())
            point = wintypes.POINT(int(global_origin.x()), int(global_origin.y()))
            try:
                mapped = bool(_user32.ScreenToClient(parent_hwnd, ctypes.byref(point)))
            except Exception:
                return
            if not mapped:
                return
            origin = (int(point.x), int(point.y))
            last_origin = self._last_embedded_origin
            if last_origin is not None and origin == last_origin:
                return
            now = time.monotonic()
            if self._last_position_sync_ts and now - self._last_position_sync_ts < self._position_sync_interval:
                return
            flags = _SWP_NOSIZE | _SWP_NOZORDER | _SWP_NOACTIVATE
            try:
                succeeded = bool(
                    _user32.SetWindowPos(
                        hwnd,
                        None,
                        origin[0],
                        origin[1],
                        0,
                        0,
                        flags,
                    )
                )
            except Exception:
                return
            if not succeeded:
                return
            self._last_embedded_origin = origin
            self._last_position_sync_ts = now
            try:
                _user32.UpdateWindow(hwnd)
            except Exception:
                pass

        # ------------------------------------------------------------------
        def _check_window_alive(self) -> None:
            if not self._embedded_hwnd:
                return
            hwnd_obj = wintypes.HWND(self._embedded_hwnd)
            if not _user32.IsWindow(hwnd_obj):
                self._watchdog.stop()
                self._log("[external-app] Embedded window destroyed.", logging.WARNING)
                self._poll_timer.stop()
                exit_code, detail = (-1, "Window closed unexpectedly.")
                if self._pending_exit_detail:
                    exit_code, detail = self._pending_exit_detail
                    self._log(f"[external-app] {detail}")
                self._pending_exit_detail = None
                self._release_window()
                self.process_finished.emit(exit_code, detail)
                self.request_close.emit()
                return
            if self._tracked_pid:
                current_pid = self._window_pid(self._embedded_hwnd)
                if current_pid is not None and current_pid != self._tracked_pid:
                    self._watchdog.stop()
                    self._log("[external-app] Embedded window ownership changed.", logging.WARNING)
                    self._poll_timer.stop()
                    exit_code, detail = (-1, "Window closed unexpectedly.")
                    if self._pending_exit_detail:
                        exit_code, detail = self._pending_exit_detail
                        self._log(f"[external-app] {detail}")
                    self._pending_exit_detail = None
                    self._release_window()
                    self.process_finished.emit(exit_code, detail)
                    self.request_close.emit()

        # ------------------------------------------------------------------
        def focusInEvent(self, event) -> None:  # type: ignore[override]
            super().focusInEvent(event)
            self._activate_focus()

        # ------------------------------------------------------------------
        def eventFilter(self, obj, event):  # type: ignore[override]
            if obj is self._container:
                etype = event.type()
                if etype == QEvent.FocusIn:
                    self._activate_focus()
                elif etype == QEvent.Resize:
                    self._sync_geometry()
            return super().eventFilter(obj, event)

        # ------------------------------------------------------------------
        def _activate_focus(self) -> None:
            if not self._embedded_hwnd:
                return
            try:
                _user32.SetActiveWindow(wintypes.HWND(self._embedded_hwnd))
                _user32.SetFocus(wintypes.HWND(self._embedded_hwnd))
            except Exception:
                pass

        # ------------------------------------------------------------------
        def _on_finished(self, exit_code: int, status) -> None:
            waiting_for_embed = (
                not self._embedded_hwnd
                and not self._fallback_emitted
                and (not self._embed_deadline or time.monotonic() <= self._embed_deadline)
            )
            detail = "Process exited." if exit_code == 0 else f"Process exited with code {exit_code}."
            if waiting_for_embed:
                self._pending_exit_detail = (exit_code, detail)
                self._log(
                    "[external-app] Process exited before embedding; continuing to poll for adoptable window."
                )
                if not self._poll_timer.isActive():
                    self._poll_timer.start()
                return

            self._poll_timer.stop()
            self._watchdog.stop()
            self._release_window()
            self._pending_exit_detail = None
            if self._suppress_finished:
                self._suppress_finished = False
                return
            self._log(f"[external-app] {detail}")
            self.process_finished.emit(exit_code, detail)
            self.request_close.emit()

        # ------------------------------------------------------------------
        def _on_error(self, _error) -> None:
            if self._fallback_emitted:
                return
            reason = self._process.errorString() or "Process error."
            self._log(f"[external-app] Error: {reason}", logging.ERROR)
            if self._process.state() == QProcess.NotRunning and not self._embedded_hwnd:
                self._emit_fallback(reason)

        # ------------------------------------------------------------------
        def _log(self, message: str, level: int = logging.INFO) -> None:
            if callable(self._log_cb):
                try:
                    self._log_cb(message, level)
                except TypeError:
                    self._log_cb(message)  # type: ignore[misc]

else:  # Non-Windows -----------------------------------------------------------------

    def _pe_is_gui_subsystem(path: str) -> Optional[bool]:  # pragma: no cover - non-Windows stub
        return None

    def _resolve_windows_shortcut(path: str) -> Optional[tuple[str, List[str], Optional[str]]]:  # pragma: no cover
        return None

    def _resolve_associated_executable(path: str) -> Optional[str]:  # pragma: no cover - non-Windows stub
        return None

    class ExternalAppCard(QWidget):  # type: ignore[dead-code]
        def __init__(self, *args, **kwargs):  # pragma: no cover - non-Windows stub
            raise RuntimeError("ExternalAppCard is only available on Windows.")

        def attach_card(self, card: QWidget) -> None:  # pragma: no cover - stub
            raise RuntimeError("ExternalAppCard is only available on Windows.")

        def start(self) -> bool:  # pragma: no cover - stub
            return False

        def shutdown(self) -> None:  # pragma: no cover - stub
            return None


# ----------------------------------------------------------------------
# Shared helpers
# ----------------------------------------------------------------------

def build_launch_spec(path: str, script_dir: str) -> LaunchSpec:
    cwd = os.path.dirname(path) or script_dir
    target = path
    argv: List[str] = [path]

    if sys.platform.startswith("win") and path.lower().endswith(".lnk"):
        resolved = _resolve_windows_shortcut(path)
        if resolved:
            resolved_path, resolved_args, resolved_cwd = resolved
            if resolved_path:
                target = resolved_path
                argv = [resolved_path] + resolved_args
                if resolved_cwd:
                    cwd = resolved_cwd
                else:
                    cwd = os.path.dirname(resolved_path) or cwd

    lower_target = target.lower()
    if lower_target.endswith(".py"):
        argv = [sys.executable, target]
        cwd = os.path.dirname(target) or cwd
    elif sys.platform.startswith("win"):
        executable_exts = {".exe", ".scr", ".bat", ".cmd", ".com", ".py"}
        ext = os.path.splitext(lower_target)[1]
        if ext and ext not in executable_exts:
            associated = _resolve_associated_executable(target)
            if associated and os.path.normcase(associated) != os.path.normcase(target):
                target = associated
                argv = [associated, path]
                cwd = os.path.dirname(associated) or cwd

    return LaunchSpec(argv=argv, cwd=cwd, target_path=target, original_path=path)


def should_embed_external_app(spec: LaunchSpec, allowlist: Sequence[str]) -> bool:
    if not sys.platform.startswith("win"):
        return False
    if not spec.target_path:
        return False
    normalized_allowlist = {os.path.abspath(entry).lower() for entry in allowlist if entry}
    normalized = os.path.abspath(spec.target_path).lower()
    if normalized in normalized_allowlist:
        return False
    if spec.argv:
        primary = os.path.abspath(spec.argv[0]).lower()
        if primary in normalized_allowlist:
            return False
    ext = os.path.splitext(normalized)[1]
    if ext in {".bat", ".cmd", ".com", ".py"}:
        return False
    if ext not in {".exe", ".scr"}:
        return False
    subsystem = _pe_is_gui_subsystem(spec.target_path)
    if subsystem is False:
        return False
    if subsystem is True:
        return True
    return ext in {".exe", ".scr"}


__all__ = [
    "EXTERNAL_APP_EMBED_TIMEOUT_SECONDS",
    "ExternalAppCard",
    "LaunchSpec",
    "build_launch_spec",
    "should_embed_external_app",
]
```

Windows-only helpers for embedding external GUI processes.
**Classes:** LaunchSpec
**Functions:** _load_embed_timeout(default), build_launch_spec(path, script_dir), should_embed_external_app(spec, allowlist)


## Module `image_pipeline.py`

```python
"""Image processing helpers for Codex-Local.

This module keeps the OCR + vision summarisation logic reusable so that
both the terminal chat and future editor chat panes can import the same
helpers.  The functions are intentionally defensive because local OCR
and VLM pipelines may be unavailable on some machines.
"""

from __future__ import annotations

import base64
import io
from dataclasses import dataclass
import re
from pathlib import Path
from typing import Any, Dict, List, Optional, Protocol

try:  # Optional dependency – we can still provide structured errors.
    from PIL import Image  # type: ignore
except Exception:  # pragma: no cover - exercised via error path tests
    Image = None  # type: ignore

try:  # Optional dependency – pytesseract may not be installed yet.
    import pytesseract  # type: ignore
except Exception:  # pragma: no cover - exercised via error path tests
    pytesseract = None  # type: ignore


class VisionClient(Protocol):
    """Minimal protocol for Ollama-like chat clients."""

    def chat(
        self,
        model: str,
        messages: List[Dict[str, Any]],
        images: Optional[List[str]] = None,
    ) -> tuple[bool, str, str]:
        ...


@dataclass
class OCRResult:
    """Structured result returned by :func:`perform_ocr`."""

    text: str
    markdown: str
    error: Optional[str] = None

    @property
    def ok(self) -> bool:
        return self.error is None


@dataclass
class VisionResult:
    """Structured result returned by :func:`analyze_image`."""

    summary: str
    error: Optional[str] = None

    @property
    def ok(self) -> bool:
        return self.error is None


@dataclass
class ThumbnailUpdate:
    """Record describing a thumbnail replacement inside a Markdown log."""

    original_path: Path
    thumbnail_path: Path
    markdown_original: str
    markdown_thumbnail: str


_MARKDOWN_IMAGE_RE = re.compile(r"!\[(?P<alt>[^\]]*)\]\((?P<path>[^)]+)\)")


def _normalise_markdown(text: str) -> str:
    """Collapse whitespace and return Markdown-friendly text."""

    lines = [ln.rstrip() for ln in text.splitlines()]
    cleaned: list[str] = []
    blank = False
    for ln in lines:
        stripped = ln.strip()
        if not stripped:
            if not blank and cleaned:
                cleaned.append("")
            blank = True
            continue
        blank = False
        cleaned.append(stripped)
    return "\n".join(cleaned).strip()


def _ensure_image(path: Path) -> Optional[Path]:
    if path.exists():
        return path
    return None


def _thumbnail_path(path: Path) -> Path:
    return path.with_name(f"{path.stem}_thumb.png")


def _resolve_markdown_path(base: Path, ref: str) -> Path:
    ref_path = Path(ref.strip())
    if ref_path.is_absolute():
        return ref_path
    return (base.parent / ref_path).resolve(strict=False)


def _markdown_path(base: Path, path: Path) -> str:
    resolved = path.resolve(strict=False)
    try:
        rel = resolved.relative_to(base.parent)
        return rel.as_posix()
    except ValueError:
        return resolved.as_posix()


def generate_thumbnail(
    image_path: Path | str,
    *,
    max_size: tuple[int, int] = (160, 160),
) -> Optional[Path]:
    """Create or reuse a ``*_thumb.png`` for ``image_path``."""

    path = _ensure_image(Path(image_path))
    if path is None:
        return None

    thumb_path = _thumbnail_path(path)

    if Image is None:
        if thumb_path.exists():
            return thumb_path
        return None

    try:
        thumb_path.parent.mkdir(parents=True, exist_ok=True)
    except Exception:  # pragma: no cover - filesystem permissions
        return None

    try:
        src_mtime = path.stat().st_mtime
        if thumb_path.exists() and thumb_path.stat().st_mtime >= src_mtime:
            return thumb_path
    except Exception:  # pragma: no cover - unable to stat reliably
        pass

    try:
        with Image.open(path) as im:
            img = im.convert("RGBA")
            if hasattr(Image, "Resampling"):
                resample = Image.Resampling.LANCZOS
            else:  # pragma: no cover - Pillow < 9
                resample = Image.LANCZOS  # type: ignore[attr-defined]
            img.thumbnail(max_size, resample=resample)
            img.save(thumb_path, format="PNG", optimize=True)
    except Exception:  # pragma: no cover - corrupted image path
        return None

    return thumb_path


def _replace_markdown_paths(text: str, old: str, new: str) -> tuple[str, bool]:
    replaced = False

    def _sub(match: re.Match[str]) -> str:
        nonlocal replaced
        current = match.group("path").strip()
        if current == old:
            replaced = True
            alt = match.group("alt")
            return f"![{alt}]({new})"
        return match.group(0)

    return _MARKDOWN_IMAGE_RE.sub(_sub, text), replaced


def thumbnailize_conversation_markdown(
    conversation_path: Path | str,
    *,
    keep_recent: int = 10,
    max_size: tuple[int, int] = (160, 160),
) -> List[ThumbnailUpdate]:
    """Replace older Markdown image links with thumbnail variants."""

    conv_path = Path(conversation_path)
    if not conv_path.exists():
        return []

    try:
        text = conv_path.read_text(encoding="utf-8")
    except Exception:  # pragma: no cover - encoding error paths
        return []

    matches = list(_MARKDOWN_IMAGE_RE.finditer(text))
    if keep_recent < 0:
        keep_recent = 0
    cutoff = max(0, len(matches) - keep_recent)

    updates: List[ThumbnailUpdate] = []
    new_text_parts: List[str] = []
    last_end = 0

    for idx, match in enumerate(matches):
        new_text_parts.append(text[last_end : match.start()])
        alt = match.group("alt")
        original_ref = match.group("path").strip()
        replacement_ref = original_ref

        if idx < cutoff and not original_ref.endswith("_thumb.png"):
            resolved = _resolve_markdown_path(conv_path, original_ref)
            thumb_path = generate_thumbnail(resolved, max_size=max_size)
            if thumb_path is not None and thumb_path.exists():
                thumb_ref = _markdown_path(conv_path, thumb_path)
                orig_ref_norm = _markdown_path(conv_path, resolved)
                if thumb_ref != original_ref:
                    replacement_ref = thumb_ref
                    updates.append(
                        ThumbnailUpdate(
                            original_path=resolved,
                            thumbnail_path=thumb_path,
                            markdown_original=orig_ref_norm,
                            markdown_thumbnail=thumb_ref,
                        )
                    )

        new_text_parts.append(f"![{alt}]({replacement_ref})")
        last_end = match.end()

    new_text_parts.append(text[last_end:])
    new_text = "".join(new_text_parts)

    if new_text != text:
        conv_path.write_text(new_text, encoding="utf-8")

    return updates


def restore_conversation_image(
    conversation_path: Path | str,
    image_path: Path | str,
) -> bool:
    """Restore the original Markdown link for ``image_path`` if thumbnailed."""

    conv_path = Path(conversation_path)
    if not conv_path.exists():
        return False

    resolved = _resolve_markdown_path(conv_path, str(image_path))
    original_ref = _markdown_path(conv_path, resolved)
    thumb_ref = _markdown_path(conv_path, _thumbnail_path(resolved))

    try:
        text = conv_path.read_text(encoding="utf-8")
    except Exception:  # pragma: no cover - encoding error
        return False

    updated_text, changed = _replace_markdown_paths(text, thumb_ref, original_ref)
    if changed:
        conv_path.write_text(updated_text, encoding="utf-8")
    return changed


def perform_ocr(
    image_path: Path | str,
    *,
    engine: Optional[Any] = None,
    language: str = "eng",
) -> OCRResult:
    """Run OCR over ``image_path`` returning Markdown text or an error.

    Parameters
    ----------
    image_path:
        Location of the image to process.
    engine:
        Optional pytesseract-like module.  When omitted the function will
        use the globally imported :mod:`pytesseract` instance.
    language:
        Language hint forwarded to the OCR engine.
    """

    path = _ensure_image(Path(image_path))
    if path is None:
        return OCRResult("", "", error="Image not found")

    if Image is None:
        return OCRResult("", "", error="Pillow not installed")

    ocr_engine = engine or pytesseract
    if ocr_engine is None:
        return OCRResult("", "", error="pytesseract not installed")

    try:
        with Image.open(path) as im:
            img = im.convert("L")  # greyscale improves OCR quality
            text = ocr_engine.image_to_string(img, lang=language)
    except Exception as exc:  # pragma: no cover - hard to force reliably
        return OCRResult("", "", error=str(exc))

    text = text.strip()
    if not text:
        return OCRResult("", "", error="No text detected")

    markdown = _normalise_markdown(text)
    return OCRResult(text=text, markdown=markdown)


def _encode_png_base64(path: Path) -> Optional[str]:
    if Image is None:
        try:
            data = path.read_bytes()
        except Exception:  # pragma: no cover - filesystem error path
            return None
        return base64.b64encode(data).decode("ascii")

    try:
        with Image.open(path) as im:
            buf = io.BytesIO()
            im.convert("RGBA").save(buf, format="PNG", optimize=True)
            return base64.b64encode(buf.getvalue()).decode("ascii")
    except Exception:  # pragma: no cover - corrupted image path
        try:
            data = path.read_bytes()
        except Exception:
            return None
        return base64.b64encode(data).decode("ascii")


def analyze_image(
    image_path: Path | str,
    ocr_text: str,
    *,
    client: Optional[VisionClient],
    model: str,
    user_text: str = "",
) -> VisionResult:
    """Ask a vision-language model to describe ``image_path``.

    The ``ocr_text`` extracted via :func:`perform_ocr` is supplied to the
    model as grounding context.
    """

    path = _ensure_image(Path(image_path))
    if path is None:
        return VisionResult("", error="Image not found")

    if client is None:
        return VisionResult("", error="No vision client configured")

    b64 = _encode_png_base64(path)
    if not b64:
        return VisionResult("", error="Unable to encode image")

    messages = [
        {
            "role": "system",
            "content": (
                "You are a meticulous vision assistant. Use the provided OCR "
                "Markdown as factual ground truth and summarise UI elements, "
                "notable numbers, and potential actions succinctly."
            ),
        },
        {
            "role": "user",
            "content": (
                f"User request: {user_text or '(none)'}\n\nOCR Markdown:\n{ocr_text or '(empty)'}"
            ),
        },
    ]

    ok, summary, err = client.chat(model=model, messages=messages, images=[b64])
    if not ok:
        return VisionResult("", error=err or "Vision model error")

    summary = summary.strip()
    if not summary:
        return VisionResult("", error="Vision model returned no text")

    return VisionResult(summary=summary)


__all__ = [
    "OCRResult",
    "VisionResult",
    "perform_ocr",
    "analyze_image",
    "ThumbnailUpdate",
    "generate_thumbnail",
    "thumbnailize_conversation_markdown",
    "restore_conversation_image",
]
```

Image processing helpers for Codex-Local.

This module keeps the OCR + vision summarisation logic reusable so that
both the terminal chat and future editor chat panes can import the same
helpers.  The functions are intentionally defensive because local OCR
and VLM pipelines may be unavailable on some machines.
**Classes:** VisionClient, OCRResult, VisionResult, ThumbnailUpdate
**Functions:** _normalise_markdown(text), _ensure_image(path), _thumbnail_path(path), _resolve_markdown_path(base, ref), _markdown_path(base, path), generate_thumbnail(image_path), _replace_markdown_paths(text, old, new), thumbnailize_conversation_markdown(conversation_path), restore_conversation_image(conversation_path, image_path), perform_ocr(image_path), _encode_png_base64(path), analyze_image(image_path, ocr_text)


## Module `memory_manager.py`

```python
from __future__ import annotations

import ast
import hashlib
import json
import math
import os
import re
import tempfile
import time
import uuid
from dataclasses import dataclass
from pathlib import Path
from threading import RLock
from typing import Any, Callable, Dict, Iterable, Iterator, List, Mapping, Optional, Sequence, Set, Tuple

Vector = List[float]
TextEmbedder = Callable[[str], Sequence[float]]
ImageEmbedder = Callable[[Path], Sequence[float]]

__all__ = ["MemoryManager", "RepositoryIndex", "TextEmbedder", "ImageEmbedder"]


_FALLBACK_EMBED_DIM = 16
_REPO_DEFAULT_EXCLUDE = {
    ".git",
    "__pycache__",
    "datasets",
    "errors",
    "memory",
    "Archived Conversations",
}
_MAX_INDEX_FILE_SIZE = 256_000
_WINDOW_SIZE = 60
_WINDOW_OVERLAP = 10


def _hash_embedding(data: bytes, dims: int = _FALLBACK_EMBED_DIM) -> Vector:
    """Return a deterministic unit vector for ``data`` using BLAKE2b."""

    if not data:
        return [0.0] * dims

    digest = hashlib.blake2b(data, digest_size=dims * 4).digest()
    ints = [int.from_bytes(digest[i : i + 4], "big", signed=False) for i in range(0, len(digest), 4)]
    vec = [value / 4294967295.0 for value in ints]
    norm = math.sqrt(sum(component * component for component in vec))
    if norm == 0:
        return vec
    return [component / norm for component in vec]


def _fallback_text_embedding(text: str) -> Vector:
    return _hash_embedding(text.encode("utf-8"))


def _fallback_image_embedding(path: Path) -> Vector:
    try:
        data = path.read_bytes()
    except OSError:
        data = b""
    return _hash_embedding(data)


def _fallback_repo_embedding(text: str) -> Vector:
    tokens = [token for token in re.findall(r"[A-Za-z0-9_]+", text.lower()) if token]
    if not tokens:
        return _hash_embedding(text.encode("utf-8"))
    dims = _FALLBACK_EMBED_DIM
    vec = [0.0] * dims
    for token in tokens:
        digest = hashlib.blake2b(token.encode("utf-8"), digest_size=8).digest()
        index = int.from_bytes(digest[:4], "big") % dims
        vec[index] += 1.0
    norm = math.sqrt(sum(component * component for component in vec))
    if norm == 0:
        return vec
    return [component / norm for component in vec]


def _ensure_vector(value: Any) -> Vector:
    if isinstance(value, list):
        result: Vector = []
        for item in value:
            try:
                result.append(float(item))
            except (TypeError, ValueError):
                return []
        return result
    return []


def _cosine(a: Vector, b: Vector) -> float:
    if not a or not b or len(a) != len(b):
        return 0.0
    dot = sum(x * y for x, y in zip(a, b))
    da = math.sqrt(sum(x * x for x in a))
    db = math.sqrt(sum(y * y for y in b))
    if da == 0 or db == 0:
        return 0.0
    return dot / (da * db)


@dataclass(slots=True)
class _ImageRecord:
    session: str
    entry_id: str
    image_path: str
    image_embedding: Vector
    ocr_embedding: Vector
    text_embedding: Vector
    text: str
    ocr_text: str
    metadata: Dict[str, Any]
    tags: List[str]
    timestamp: float

    def score(self, query_vec: Vector) -> float:
        scores = []
        if self.image_embedding:
            scores.append(_cosine(query_vec, self.image_embedding))
        if self.ocr_embedding:
            scores.append(_cosine(query_vec, self.ocr_embedding))
        if self.text_embedding:
            scores.append(_cosine(query_vec, self.text_embedding))
        return max(scores) if scores else 0.0


@dataclass(slots=True)
class _RepoSegment:
    path: Path
    start_line: int
    end_line: int
    text: str
    metadata: Dict[str, Any]


@dataclass(slots=True)
class _RepoIndexRecord:
    identifier: str
    path: str
    start_line: int
    end_line: int
    text: str
    embedding: Vector
    metadata: Dict[str, Any]
    timestamp: float

    def score(self, query_vec: Vector) -> float:
        if not self.embedding or not query_vec:
            return 0.0
        return _cosine(query_vec, self.embedding)


def _segment_identifier(path: str, start_line: int, end_line: int) -> str:
    payload = f"{path}:{start_line}:{end_line}".encode("utf-8", "ignore")
    return hashlib.blake2b(payload, digest_size=16).hexdigest()


class MemoryManager:
    """Append-only conversation memory with text and image embeddings."""

    def __init__(
        self,
        data_root: Optional[Path | str] = None,
        *,
        text_embedder: Optional[TextEmbedder] = None,
        image_embedder: Optional[ImageEmbedder] = None,
        enable_embeddings: bool = True,
    ) -> None:
        base = Path(data_root) if data_root is not None else Path(__file__).resolve().parent / "datasets"
        self.data_root = base
        self.conversations_dir = self.data_root / "conversations"
        self.conversations_dir.mkdir(parents=True, exist_ok=True)
        self.enable_embeddings = enable_embeddings
        self._text_embedder = text_embedder or _fallback_text_embedding
        self._image_embedder = image_embedder or _fallback_image_embedding
        self._lock = RLock()
        self._image_cache: List[_ImageRecord] = []
        self._cache_loaded = False

    def log_interaction(
        self,
        session_id: str,
        role: str,
        content: str,
        *,
        images: Optional[Sequence[Path | str]] = None,
        ocr_map: Optional[Mapping[str, str]] = None,
        tags: Optional[Sequence[str]] = None,
        metadata: Optional[Mapping[str, Any]] = None,
    ) -> Dict[str, Any]:
        """Append a conversation record for ``session_id``.

        Parameters
        ----------
        session_id:
            Name of the logical conversation folder.
        role:
            Speaker associated with ``content`` (e.g. ``"user"``).
        content:
            Plain-text message body.
        images:
            Optional collection of image paths associated with the turn.
        ocr_map:
            Mapping of image path (stem, name, or resolved path) to OCR text.
        tags:
            Optional labels describing the interaction.
        metadata:
            Extra metadata persisted alongside the entry.
        """

        if not session_id:
            raise ValueError("session_id is required")

        session_dir = self.conversations_dir / session_id
        session_dir.mkdir(parents=True, exist_ok=True)
        dataset_path = session_dir / "conversation.jsonl"

        timestamp = time.time()
        entry_id = uuid.uuid4().hex
        tag_list = [str(tag) for tag in (tags or [])]
        meta: Dict[str, Any] = dict(metadata or {})

        image_payloads: List[Dict[str, Any]] = []
        record_source: List[tuple[str, Vector, Vector, str]] = []
        ocr_texts: List[str] = []

        for raw in images or []:
            img_path = Path(raw)
            path_str = img_path.as_posix()
            ocr_text = _resolve_ocr_text(img_path, ocr_map)
            ocr_texts.append(ocr_text)
            ocr_vec = self._embed_text(ocr_text) if (self.enable_embeddings and ocr_text) else []
            img_vec = self._embed_image(img_path) if self.enable_embeddings else []
            payload = {
                "path": path_str,
                "name": img_path.name,
                "ocr_text": ocr_text,
                "ocr_embedding": ocr_vec,
                "image_embedding": img_vec,
            }
            image_payloads.append(payload)
            record_source.append((path_str, img_vec, ocr_vec, ocr_text))

        combined_sources = [content.strip()]
        combined_sources.extend(text.strip() for text in ocr_texts if text.strip())
        combined_text = "\n".join([text for text in combined_sources if text])
        text_embedding = self._embed_text(combined_text) if (self.enable_embeddings and combined_text) else []

        entry = {
            "id": entry_id,
            "session": session_id,
            "ts": timestamp,
            "role": role,
            "text": content,
            "text_embedding": text_embedding,
            "images": image_payloads,
            "tags": tag_list,
            "metadata": meta,
        }

        serialised = json.dumps(entry, ensure_ascii=False)

        with self._lock:
            with dataset_path.open("a", encoding="utf-8") as fh:
                fh.write(serialised + "\n")
            if self._cache_loaded:
                for path_str, img_vec, ocr_vec, ocr_text in record_source:
                    if not (img_vec or ocr_vec or text_embedding):
                        continue
                    self._image_cache.append(
                        _ImageRecord(
                            session=session_id,
                            entry_id=entry_id,
                            image_path=path_str,
                            image_embedding=list(img_vec),
                            ocr_embedding=list(ocr_vec),
                            text_embedding=list(text_embedding),
                            text=content,
                            ocr_text=ocr_text,
                            metadata=dict(meta),
                            tags=list(tag_list),
                            timestamp=timestamp,
                        )
                    )

        return entry

    def search_images(
        self,
        query: str,
        k: int = 5,
        *,
        session_filter: Optional[str] = None,
    ) -> List[Dict[str, Any]]:
        """Return the ``k`` most similar image entries for ``query``."""

        if not self.enable_embeddings or k <= 0:
            return []

        query_text = query.strip()
        if not query_text:
            return []

        query_vec = self._embed_text(query_text)
        if not query_vec:
            return []

        with self._lock:
            self._ensure_cache_locked()
            records = list(self._image_cache)

        hits: List[tuple[float, _ImageRecord]] = []
        for record in records:
            if session_filter and record.session != session_filter:
                continue
            score = record.score(query_vec)
            if score <= 0:
                continue
            hits.append((score, record))

        hits.sort(key=lambda item: item[0], reverse=True)

        results: List[Dict[str, Any]] = []
        for score, record in hits[:k]:
            results.append(
                {
                    "score": score,
                    "session": record.session,
                    "entry_id": record.entry_id,
                    "image_path": record.image_path,
                    "text": record.text,
                    "ocr_text": record.ocr_text,
                    "metadata": dict(record.metadata),
                    "tags": list(record.tags),
                    "timestamp": record.timestamp,
                }
            )
        return results

    def _ensure_cache_locked(self) -> None:
        if self._cache_loaded:
            return

        cache: List[_ImageRecord] = []
        for session_dir in sorted(self.conversations_dir.iterdir()):
            if not session_dir.is_dir():
                continue
            dataset_path = session_dir / "conversation.jsonl"
            if not dataset_path.exists():
                continue
            with dataset_path.open("r", encoding="utf-8") as fh:
                for line in fh:
                    line = line.strip()
                    if not line:
                        continue
                    try:
                        entry = json.loads(line)
                    except json.JSONDecodeError:
                        continue
                    images = entry.get("images") or []
                    text_embedding = _ensure_vector(entry.get("text_embedding"))
                    metadata = dict(entry.get("metadata") or {})
                    tags = [str(tag) for tag in entry.get("tags") or []]
                    session_name = str(entry.get("session") or session_dir.name)
                    entry_id = str(entry.get("id") or "")
                    text = str(entry.get("text") or "")
                    timestamp = float(entry.get("ts") or 0.0)
                    for img in images:
                        if not isinstance(img, Mapping):
                            continue
                        path_str = str(img.get("path") or "")
                        if not path_str:
                            continue
                        image_embedding = _ensure_vector(img.get("image_embedding"))
                        ocr_embedding = _ensure_vector(img.get("ocr_embedding"))
                        ocr_text = str(img.get("ocr_text") or "")
                        if not (image_embedding or ocr_embedding or text_embedding):
                            continue
                        cache.append(
                            _ImageRecord(
                                session=session_name,
                                entry_id=entry_id,
                                image_path=path_str,
                                image_embedding=image_embedding,
                                ocr_embedding=ocr_embedding,
                                text_embedding=text_embedding,
                                text=text,
                                ocr_text=ocr_text,
                                metadata=dict(metadata),
                                tags=list(tags),
                                timestamp=timestamp,
                            )
                        )
        self._image_cache = cache
        self._cache_loaded = True

    def _embed_text(self, text: str) -> Vector:
        if not text:
            return []
        vec = self._text_embedder(text)
        return [float(v) for v in vec]

    def _embed_image(self, path: Path) -> Vector:
        vec = self._image_embedder(path)
        return [float(v) for v in vec]


class RepositoryIndex:
    """Build and query a lightweight repository text index."""

    def __init__(
        self,
        repo_root: Optional[Path | str] = None,
        data_root: Optional[Path | str] = None,
        *,
        text_embedder: Optional[TextEmbedder] = None,
        enable_embeddings: bool = True,
        include_extensions: Optional[Sequence[str]] = None,
        exclude_dirs: Optional[Sequence[str]] = None,
        extra_roots: Optional[Sequence[Path | str]] = None,
    ) -> None:
        base_repo = Path(repo_root) if repo_root is not None else Path(__file__).resolve().parent
        self.repo_root = base_repo.resolve()
        base_data = Path(data_root) if data_root is not None else Path(__file__).resolve().parent / "datasets"
        self.data_root = base_data.resolve()
        self.index_dir = self.data_root / "repo_index"
        self.index_path = self.index_dir / "index.jsonl"
        self.manifest_path = self.index_dir / "manifest.json"
        self.enable_embeddings = enable_embeddings
        self._text_embedder = text_embedder or _fallback_repo_embedding
        self._include_extensions = tuple(include_extensions) if include_extensions else None
        self._exclude_dirs = set(exclude_dirs) if exclude_dirs else set(_REPO_DEFAULT_EXCLUDE)
        extras: List[Path] = []
        seen: Set[Path] = {self.repo_root}
        if extra_roots:
            for entry in extra_roots:
                try:
                    candidate = Path(entry).expanduser().resolve()
                except Exception:
                    continue
                if candidate in seen:
                    continue
                seen.add(candidate)
                extras.append(candidate)
        self._extra_roots: Tuple[Path, ...] = tuple(extras)
        self._roots: Tuple[Path, ...] = (self.repo_root, *self._extra_roots)
        self._records: List[_RepoIndexRecord] = []
        self._loaded = False
        self._lock = RLock()

    # ------------------------------------------------------------------
    # Public API
    # ------------------------------------------------------------------
    def rebuild(self) -> Dict[str, Any]:
        """Rebuild the repository index and return a summary."""

        segments: List[Tuple[Path, _RepoSegment]] = []
        files_indexed = 0
        timestamp = time.time()

        for base_root, path in self._iter_repo_files():
            text = self._read_file_text(path)
            if text is None:
                continue
            files_indexed += 1
            for segment in self._segment_file(path, text):
                segments.append((base_root, segment))

        entries = []
        for base_root, segment in segments:
            rel_path = self._relative_path(segment.path, base_root)
            embedding: Vector = []
            if self.enable_embeddings and segment.text.strip():
                embedding = self._embed_text(segment.text)
            record_id = _segment_identifier(rel_path, segment.start_line, segment.end_line)
            metadata = dict(segment.metadata)
            metadata.setdefault("scan_root", str(base_root))
            entry = {
                "id": record_id,
                "path": rel_path,
                "start_line": segment.start_line,
                "end_line": segment.end_line,
                "text": segment.text,
                "embedding": embedding,
                "metadata": metadata,
                "ts": timestamp,
            }
            entries.append(entry)

        self.index_dir.mkdir(parents=True, exist_ok=True)
        tmp_path = self._write_index(entries)
        tmp_path.replace(self.index_path)

        embed_dim = 0
        if entries and entries[0]["embedding"]:
            embed_dim = len(entries[0]["embedding"])

        manifest = {
            "timestamp": timestamp,
            "segments": len(entries),
            "files_indexed": files_indexed,
            "embedding_dim": embed_dim,
        }
        with self.manifest_path.open("w", encoding="utf-8") as fh:
            json.dump(manifest, fh, ensure_ascii=False, indent=2)

        records = [
            _RepoIndexRecord(
                identifier=entry["id"],
                path=str(entry["path"]),
                start_line=int(entry["start_line"]),
                end_line=int(entry["end_line"]),
                text=str(entry["text"]),
                embedding=_ensure_vector(entry.get("embedding")),
                metadata=dict(entry.get("metadata") or {}),
                timestamp=float(entry.get("ts") or timestamp),
            )
            for entry in entries
        ]

        with self._lock:
            self._records = records
            self._loaded = True

        return {
            "files_indexed": files_indexed,
            "segments": len(entries),
            "timestamp": timestamp,
            "index_path": self.index_path,
        }

    def load(self) -> None:
        """Ensure the in-memory cache reflects the current on-disk index."""

        with self._lock:
            if self._loaded:
                return
            self._load_locked()

    def iter_segments(self) -> Iterator[Dict[str, Any]]:
        """Yield cached segment dictionaries without computing scores."""

        self.load()
        with self._lock:
            for record in self._records:
                yield {
                    "id": record.identifier,
                    "path": record.path,
                    "start_line": record.start_line,
                    "end_line": record.end_line,
                    "text": record.text,
                    "metadata": dict(record.metadata),
                    "timestamp": record.timestamp,
                }

    def search(self, query: str, k: int = 5) -> List[Dict[str, Any]]:
        """Return the top ``k`` matching segments for ``query``."""

        query_text = query.strip()
        if not query_text or k <= 0 or not self.enable_embeddings:
            return []

        query_vec = self._embed_text(query_text)
        if not query_vec:
            return []

        self.load()

        with self._lock:
            records = list(self._records)

        scored: List[Tuple[float, _RepoIndexRecord]] = []
        for record in records:
            score = record.score(query_vec)
            if score <= 0:
                continue
            scored.append((score, record))

        scored.sort(key=lambda item: item[0], reverse=True)

        results: List[Dict[str, Any]] = []
        for score, record in scored[:k]:
            results.append(
                {
                    "id": record.identifier,
                    "path": record.path,
                    "start_line": record.start_line,
                    "end_line": record.end_line,
                    "text": record.text,
                    "metadata": dict(record.metadata),
                    "score": score,
                    "timestamp": record.timestamp,
                }
            )
        return results

    # ------------------------------------------------------------------
    # Internal helpers
    # ------------------------------------------------------------------
    def _embed_text(self, text: str) -> Vector:
        vec = self._text_embedder(text) if text else []
        return [float(value) for value in vec]

    def _iter_repo_files(self) -> Iterator[Tuple[Path, Path]]:
        for base_root in self._roots:
            if not base_root.exists():
                continue
            try:
                base_resolved = base_root.resolve()
            except Exception:
                base_resolved = base_root
            for root, dirs, files in os.walk(base_root):
                path_root = Path(root)
                try:
                    relative_parts = set(path_root.relative_to(base_resolved).parts)
                except ValueError:
                    relative_parts = set()
                if relative_parts & self._exclude_dirs:
                    dirs[:] = []
                    continue
                dirs[:] = [
                    d
                    for d in dirs
                    if d not in self._exclude_dirs and not d.endswith(".egg-info")
                ]
                for name in files:
                    candidate = path_root / name
                    if candidate.is_symlink():
                        continue
                    if self._include_extensions and candidate.suffix not in self._include_extensions:
                        continue
                    yield base_resolved, candidate

    def _read_file_text(self, path: Path) -> Optional[str]:
        try:
            if path.stat().st_size > _MAX_INDEX_FILE_SIZE:
                return None
        except OSError:
            return None
        try:
            return path.read_text(encoding="utf-8")
        except UnicodeDecodeError:
            return None
        except OSError:
            return None

    def _segment_file(self, path: Path, text: str) -> List[_RepoSegment]:
        suffix = path.suffix.lower()
        lines = text.splitlines()
        if suffix == ".py":
            segments = self._segment_python(path, lines)
            if segments:
                return segments
        if suffix in {".md", ".rst"}:
            segments = self._segment_markdown(path, lines)
            if segments:
                return segments
        return self._segment_generic(path, lines)

    def _segment_python(self, path: Path, lines: List[str]) -> List[_RepoSegment]:
        source = "\n".join(lines)
        try:
            module = ast.parse(source)
        except SyntaxError:
            return []

        segments: List[_RepoSegment] = []

        if module.body:
            first = module.body[0]
            if isinstance(first, ast.Expr) and isinstance(getattr(first, "value", None), ast.Constant):
                constant = first.value
                if isinstance(constant.value, str):
                    start = getattr(first, "lineno", 1)
                    end = getattr(first, "end_lineno", start)
                    text_block = self._slice_lines(lines, start, end)
                    segment = self._make_segment(
                        path,
                        start,
                        end,
                        text_block,
                        {"language": "python", "kind": "docstring"},
                    )
                    if segment:
                        segments.append(segment)

        for node in module.body:
            if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)):
                start = getattr(node, "lineno", 1)
                end = getattr(node, "end_lineno", start)
                text_block = self._slice_lines(lines, start, end)
                segment = self._make_segment(
                    path,
                    start,
                    end,
                    text_block,
                    {
                        "language": "python",
                        "kind": "function",
                        "name": getattr(node, "name", ""),
                    },
                )
                if segment:
                    segments.append(segment)
            elif isinstance(node, ast.ClassDef):
                start = getattr(node, "lineno", 1)
                end = getattr(node, "end_lineno", start)
                text_block = self._slice_lines(lines, start, end)
                segment = self._make_segment(
                    path,
                    start,
                    end,
                    text_block,
                    {
                        "language": "python",
                        "kind": "class",
                        "name": getattr(node, "name", ""),
                    },
                )
                if segment:
                    segments.append(segment)

        if not segments:
            return []
        return segments

    def _segment_markdown(self, path: Path, lines: List[str]) -> List[_RepoSegment]:
        segments: List[_RepoSegment] = []
        total = len(lines)
        if total == 0:
            return segments
        current_start = 0
        for idx, line in enumerate(lines):
            if line.lstrip().startswith("#") and idx != current_start:
                text_block = self._slice_lines(lines, current_start + 1, idx)
                segment = self._make_segment(
                    path,
                    current_start + 1,
                    idx,
                    text_block,
                    {"language": "markdown", "kind": "section"},
                )
                if segment:
                    segments.append(segment)
                current_start = idx
        text_block = self._slice_lines(lines, current_start + 1, total)
        segment = self._make_segment(
            path,
            current_start + 1,
            total,
            text_block,
            {"language": "markdown", "kind": "section"},
        )
        if segment:
            segments.append(segment)
        return segments

    def _segment_generic(self, path: Path, lines: List[str]) -> List[_RepoSegment]:
        segments: List[_RepoSegment] = []
        window = max(_WINDOW_SIZE, 1)
        overlap = min(_WINDOW_OVERLAP, window - 1) if window > 1 else 0
        total = len(lines)
        if total == 0:
            return segments
        step = window - overlap if window > overlap else window
        start = 0
        while start < total:
            end = min(total, start + window)
            text_block = self._slice_lines(lines, start + 1, end)
            segment = self._make_segment(
                path,
                start + 1,
                end,
                text_block,
                {"language": self._guess_language(path), "kind": "block"},
            )
            if segment:
                segments.append(segment)
            if end == total:
                break
            start += step
        return segments

    def _make_segment(
        self,
        path: Path,
        start_line: int,
        end_line: int,
        text: str,
        metadata: Dict[str, Any],
    ) -> Optional[_RepoSegment]:
        cleaned = text.strip("\n")
        if not cleaned.strip():
            return None
        return _RepoSegment(
            path=path,
            start_line=start_line,
            end_line=end_line,
            text=cleaned,
            metadata=dict(metadata),
        )

    def _slice_lines(self, lines: List[str], start: int, end: int) -> str:
        start_index = max(start - 1, 0)
        end_index = max(start_index, min(end, len(lines)))
        return "\n".join(lines[start_index:end_index])

    def _guess_language(self, path: Path) -> str:
        suffix = path.suffix.lower().lstrip(".")
        if not suffix:
            return "text"
        return suffix

    def _relative_path(self, path: Path, base_root: Optional[Path] = None) -> str:
        try:
            resolved = path.resolve()
        except Exception:
            resolved = path
        roots: List[Path] = []
        if base_root is not None:
            roots.append(base_root)
        roots.append(self.repo_root)
        for root in roots:
            try:
                return resolved.relative_to(root).as_posix()
            except ValueError:
                continue
        return resolved.as_posix()

    def _write_index(self, entries: List[Dict[str, Any]]) -> Path:
        tmp_file = tempfile.NamedTemporaryFile("w", encoding="utf-8", delete=False, dir=self.index_dir)
        try:
            for entry in entries:
                json.dump(entry, tmp_file, ensure_ascii=False)
                tmp_file.write("\n")
        finally:
            tmp_file.close()
        return Path(tmp_file.name)

    def _load_locked(self) -> None:
        records: List[_RepoIndexRecord] = []
        if not self.index_path.exists():
            self._records = []
            self._loaded = True
            return
        with self.index_path.open("r", encoding="utf-8") as fh:
            for line in fh:
                payload = line.strip()
                if not payload:
                    continue
                try:
                    entry = json.loads(payload)
                except json.JSONDecodeError:
                    continue
                record = _RepoIndexRecord(
                    identifier=str(entry.get("id") or ""),
                    path=str(entry.get("path") or ""),
                    start_line=int(entry.get("start_line") or 1),
                    end_line=int(entry.get("end_line") or 1),
                    text=str(entry.get("text") or ""),
                    embedding=_ensure_vector(entry.get("embedding")),
                    metadata=dict(entry.get("metadata") or {}),
                    timestamp=float(entry.get("ts") or 0.0),
                )
                records.append(record)
        self._records = records
        self._loaded = True

def _resolve_ocr_text(path: Path, ocr_map: Optional[Mapping[str, str]]) -> str:
    if not ocr_map:
        return ""
    candidates: Iterable[str] = (
        path.as_posix(),
        str(path),
        path.name,
        path.stem,
    )
    for key in candidates:
        if key in ocr_map:
            return ocr_map[key]
    return ""
```

**Classes:** _ImageRecord, _RepoSegment, _RepoIndexRecord, MemoryManager, RepositoryIndex
**Functions:** _hash_embedding(data, dims), _fallback_text_embedding(text), _fallback_image_embedding(path), _fallback_repo_embedding(text), _ensure_vector(value), _cosine(a, b), _segment_identifier(path, start_line, end_line), _resolve_ocr_text(path, ocr_map)


## Module `metrics_manager.py`

```python
"""Helpers for persisting and querying script metrics."""

from __future__ import annotations

import json
import sqlite3
import time
from pathlib import Path
from typing import Any, Dict, Iterable, List, Mapping, Optional, Sequence

REPO_ROOT = Path(__file__).resolve().parent
DATASETS_ROOT = REPO_ROOT / "datasets"
DEFAULT_DB_PATHS: Mapping[str, Path] = {
    "local": DATASETS_ROOT / "local.db",
    "global": DATASETS_ROOT / "global.db",
}
_TABLE_NAME = "metrics"


def _ensure_parent(path: Path) -> None:
    path.parent.mkdir(parents=True, exist_ok=True)


def _ensure_schema(conn: sqlite3.Connection) -> None:
    conn.execute(
        f"""
        CREATE TABLE IF NOT EXISTS {_TABLE_NAME} (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            timestamp REAL NOT NULL,
            script_path TEXT NOT NULL,
            score REAL,
            runtime_ms REAL,
            component TEXT,
            metadata TEXT
        )
        """
    )
    conn.execute(
        f"""
        CREATE INDEX IF NOT EXISTS idx_{_TABLE_NAME}_script_ts
        ON {_TABLE_NAME} (script_path, timestamp)
        """
    )


def _normalise_entry(entry: Mapping[str, Any]) -> Optional[Dict[str, Any]]:
    script_path = entry.get("script_path")
    if not script_path:
        return None
    timestamp = entry.get("timestamp")
    ts = float(timestamp) if timestamp is not None else time.time()
    metadata = entry.get("metadata")
    if metadata is not None and not isinstance(metadata, str):
        try:
            metadata_json = json.dumps(metadata, ensure_ascii=False)
        except (TypeError, ValueError):
            metadata_json = None
    else:
        metadata_json = metadata if isinstance(metadata, str) else None
    return {
        "timestamp": ts,
        "script_path": str(script_path),
        "score": float(entry.get("score")) if entry.get("score") is not None else None,
        "runtime_ms": float(entry.get("runtime_ms")) if entry.get("runtime_ms") is not None else None,
        "component": entry.get("component"),
        "metadata": metadata_json,
    }


def _resolve_scopes(
    scopes: Sequence[str] | str | None,
    db_paths: Optional[Mapping[str, Path | str]] = None,
) -> Dict[str, Path]:
    scope_list: Sequence[str]
    if scopes is None:
        scope_list = ("local",)
    elif isinstance(scopes, str):
        scope_list = (scopes,)
    else:
        scope_list = scopes

    resolved: Dict[str, Path] = {}
    overrides: Dict[str, Path] = {}
    if db_paths:
        overrides = {key: Path(value) for key, value in db_paths.items()}
    for scope in scope_list:
        if scope in overrides:
            resolved[scope] = overrides[scope]
        else:
            default_path = DEFAULT_DB_PATHS.get(scope)
            if default_path is None:
                raise KeyError(f"Unknown metrics scope: {scope}")
            resolved[scope] = default_path
    return resolved


def _write_entries(db_path: Path, entries: Sequence[Dict[str, Any]]) -> int:
    if not entries:
        return 0
    _ensure_parent(db_path)
    with sqlite3.connect(db_path) as conn:
        _ensure_schema(conn)
        conn.executemany(
            f"""
            INSERT INTO {_TABLE_NAME} (timestamp, script_path, score, runtime_ms, component, metadata)
            VALUES (:timestamp, :script_path, :score, :runtime_ms, :component, :metadata)
            """,
            entries,
        )
        conn.commit()
        return conn.total_changes


def record_metrics(
    entries: Iterable[Mapping[str, Any]],
    *,
    scopes: Sequence[str] | str | None = ("local",),
    db_paths: Optional[Mapping[str, Path | str]] = None,
) -> Dict[str, int]:
    """Persist metrics ``entries`` into the configured database scopes."""

    materialised: List[Dict[str, Any]] = []
    for entry in entries:
        normalised = _normalise_entry(entry)
        if normalised is not None:
            materialised.append(normalised)
    if not materialised:
        return {}

    resolved_paths = _resolve_scopes(scopes, db_paths=db_paths)
    results: Dict[str, int] = {}
    for scope, path in resolved_paths.items():
        results[scope] = _write_entries(path, materialised)
    return results


def fetch_metrics(
    *,
    scope: str = "local",
    script_path: Optional[str] = None,
    since: Optional[float] = None,
    limit: Optional[int] = None,
    db_paths: Optional[Mapping[str, Path | str]] = None,
) -> List[Dict[str, Any]]:
    """Fetch metrics rows from the requested scope."""

    resolved_paths = _resolve_scopes(scope, db_paths=db_paths)
    db_path = next(iter(resolved_paths.values()))
    if not db_path.exists():
        return []

    query = [
        f"SELECT id, timestamp, script_path, score, runtime_ms, component, metadata FROM {_TABLE_NAME}",
    ]
    clauses: List[str] = []
    params: List[Any] = []
    if script_path:
        clauses.append("script_path = ?")
        params.append(script_path)
    if since is not None:
        clauses.append("timestamp >= ?")
        params.append(float(since))
    if clauses:
        query.append(" WHERE " + " AND ".join(clauses))
    query.append(" ORDER BY timestamp DESC, id DESC")
    if limit is not None:
        query.append(" LIMIT ?")
        params.append(int(limit))

    with sqlite3.connect(db_path) as conn:
        _ensure_schema(conn)
        rows = list(conn.execute("".join(query), params))

    results: List[Dict[str, Any]] = []
    for row in rows:
        ident, ts, path, score, runtime, component, metadata_json = row
        metadata_obj: Any
        if metadata_json is None:
            metadata_obj = None
        else:
            try:
                metadata_obj = json.loads(metadata_json)
            except json.JSONDecodeError:
                metadata_obj = metadata_json
        results.append(
            {
                "id": int(ident),
                "timestamp": float(ts),
                "script_path": str(path),
                "score": float(score) if score is not None else None,
                "runtime_ms": float(runtime) if runtime is not None else None,
                "component": component,
                "metadata": metadata_obj,
            }
        )
    return results


__all__ = ["record_metrics", "fetch_metrics"]
```

Helpers for persisting and querying script metrics.
**Functions:** _ensure_parent(path), _ensure_schema(conn), _normalise_entry(entry), _resolve_scopes(scopes, db_paths), _write_entries(db_path, entries), record_metrics(entries), fetch_metrics()


## Module `operator_manager.py`

```python
"""Operator Manager registry and Qt panel for Codex-Local agents."""
from __future__ import annotations

import os
import threading
from dataclasses import dataclass
from pathlib import Path
from typing import Callable, Dict, Iterable, Optional

from PySide6.QtCore import QObject, Qt, Signal
from PySide6.QtGui import QFont
from PySide6.QtWidgets import (
    QDialog,
    QDialogButtonBox,
    QFrame,
    QHBoxLayout,
    QLabel,
    QMessageBox,
    QPushButton,
    QScrollArea,
    QVBoxLayout,
    QWidget,
    QPlainTextEdit,
)

from prompt_loader import get_prompt_watcher


@dataclass
class OperatorRecord:
    """Metadata tracked for a single operator."""

    name: str
    role: str
    prompt_path: Optional[str] = None
    restart_callback: Optional[Callable[[], None]] = None
    status: str = "offline"
    status_detail: str = ""

    def clone(self) -> "OperatorRecord":
        return OperatorRecord(
            name=self.name,
            role=self.role,
            prompt_path=self.prompt_path,
            restart_callback=self.restart_callback,
            status=self.status,
            status_detail=self.status_detail,
        )


class OperatorManager(QObject):
    """Central registry that maintains agent metadata and emits status signals."""

    status_changed = Signal(str, str, str)  # name, status, detail
    operator_registered = Signal(str)
    operator_removed = Signal(str)

    def __init__(self) -> None:
        super().__init__()
        self._operators: Dict[str, OperatorRecord] = {}
        self._lock = threading.RLock()

    # -------- registry helpers --------
    def register(
        self,
        name: str,
        role: str,
        prompt_path: Optional[str] = None,
        restart_callback: Optional[Callable[[], None]] = None,
        status: str = "offline",
        status_detail: str = "",
    ) -> None:
        """Register or update an operator."""
        with self._lock:
            record = self._operators.get(name)
            is_new = record is None
            if is_new:
                record = OperatorRecord(
                    name=name,
                    role=role,
                    prompt_path=prompt_path,
                    restart_callback=restart_callback,
                    status=status,
                    status_detail=status_detail,
                )
                self._operators[name] = record
            else:
                record.role = role
                record.prompt_path = prompt_path
                record.restart_callback = restart_callback
                record.status = status
                record.status_detail = status_detail
        if is_new:
            self.operator_registered.emit(name)
        self.status_changed.emit(name, status, status_detail)

    def remove(self, name: str) -> None:
        with self._lock:
            if name not in self._operators:
                return
            del self._operators[name]
        self.operator_removed.emit(name)

    def list_records(self) -> Iterable[OperatorRecord]:
        with self._lock:
            return [rec.clone() for rec in self._operators.values()]

    def get(self, name: str) -> Optional[OperatorRecord]:
        with self._lock:
            record = self._operators.get(name)
            return record.clone() if record else None

    # -------- status helpers --------
    def update_status(self, name: str, status: str, detail: str = "") -> None:
        with self._lock:
            record = self._operators.get(name)
            if not record:
                return
            record.status = status
            record.status_detail = detail
        self.status_changed.emit(name, status, detail)

    def restart(self, name: str) -> bool:
        callback: Optional[Callable[[], None]]
        with self._lock:
            record = self._operators.get(name)
            if not record or not record.restart_callback:
                return False
            callback = record.restart_callback
        try:
            callback()  # type: ignore[operator]
            return True
        except Exception:
            raise


_manager_singleton: Optional[OperatorManager] = None


def get_operator_manager() -> OperatorManager:
    global _manager_singleton
    if _manager_singleton is None:
        _manager_singleton = OperatorManager()
    return _manager_singleton


_STATUS_COLORS: Dict[str, str] = {
    "idle": "#4caf50",
    "busy": "#ffb300",
    "listening": "#42a5f5",
    "error": "#ef5350",
    "offline": "#78909c",
}


class _StatusDot(QFrame):
    def __init__(self, color: str, parent: Optional[QWidget] = None) -> None:
        super().__init__(parent)
        self.setFixedSize(14, 14)
        self.set_color(color)

    def set_color(self, color: str) -> None:
        self.setStyleSheet(
            f"background:{color}; border-radius:7px; border:1px solid rgba(0,0,0,0.4);"
        )


class _PromptDialog(QDialog):
    def __init__(self, title: str, path: Optional[str], parent: Optional[QWidget] = None) -> None:
        super().__init__(parent)
        self.setWindowTitle(title)
        self.resize(640, 480)
        layout = QVBoxLayout(self)
        text = QPlainTextEdit(self)
        text.setReadOnly(True)
        font = QFont("Cascadia Code", 10)
        text.setFont(font)
        if path and os.path.isfile(path):
            try:
                with open(path, "r", encoding="utf-8", errors="replace") as fh:
                    text.setPlainText(fh.read())
            except Exception as exc:  # pragma: no cover - UI feedback only
                text.setPlainText(f"[Failed to load prompt]\n{exc}")
        else:
            pretty = Path(path).name if path else "prompt"
            text.setPlainText(f"No prompt file found for {pretty}.")
        layout.addWidget(text, 1)
        buttons = QDialogButtonBox(QDialogButtonBox.Close, Qt.Horizontal, self)
        buttons.rejected.connect(self.reject)
        layout.addWidget(buttons)


class _OperatorRow(QFrame):
    def __init__(
        self,
        record: OperatorRecord,
        manager: OperatorManager,
        theme: Optional[object] = None,
        parent: Optional[QWidget] = None,
    ) -> None:
        super().__init__(parent)
        self._record = record
        self._manager = manager
        self._theme = theme
        self.setObjectName("OperatorRow")
        bg = getattr(theme, "card_bg", "#0c1320")
        border = getattr(theme, "card_border", "#1f2a3a")
        text_fg = getattr(theme, "text_body", "#e8f1ff")
        muted = getattr(theme, "text_muted", "#b9c5db")
        accent = getattr(theme, "accent", "#1E5AFF")
        self.setStyleSheet(
            f"QFrame#OperatorRow{{background:{bg};border:1px solid {border};border-radius:10px;}}"
            f"QFrame#OperatorRow QLabel{{color:{text_fg};}}"
            f"QFrame#OperatorRow QLabel.status-detail{{color:{muted};font-size:10pt;}}"
            f"QFrame#OperatorRow QPushButton{{background:{accent};color:#fff;border:1px solid {border};border-radius:6px;padding:6px 12px;}}"
            f"QFrame#OperatorRow QPushButton:hover{{background:{getattr(theme, 'accent_hov', '#2f72ff')};}}"
        )
        layout = QVBoxLayout(self)
        layout.setContentsMargins(12, 12, 12, 12)
        layout.setSpacing(8)

        header = QHBoxLayout(); header.setSpacing(8)
        name_label = QLabel(record.name, self)
        font = QFont(); font.setPointSize(12); font.setBold(True)
        name_label.setFont(font)
        header.addWidget(name_label)
        header.addStretch(1)
        self._dot = _StatusDot(_STATUS_COLORS.get(record.status, "#607d8b"), self)
        header.addWidget(self._dot, 0)
        self._status_label = QLabel(record.status.title(), self)
        header.addWidget(self._status_label, 0)
        layout.addLayout(header)

        role_label = QLabel(record.role, self)
        role_label.setWordWrap(True)
        layout.addWidget(role_label)

        self._detail = QLabel(record.status_detail or "", self)
        self._detail.setObjectName("status-detail")
        self._detail.setWordWrap(True)
        if not record.status_detail:
            self._detail.hide()
        layout.addWidget(self._detail)

        buttons = QHBoxLayout(); buttons.setSpacing(8)
        self._restart_btn = QPushButton("Restart", self)
        self._restart_btn.clicked.connect(self._on_restart)
        self._prompt_btn = QPushButton("View Prompt", self)
        self._prompt_btn.clicked.connect(self._on_prompt)
        for btn in (self._restart_btn, self._prompt_btn):
            buttons.addWidget(btn)
        buttons.addStretch(1)
        layout.addLayout(buttons)

        if record.restart_callback is None:
            self._restart_btn.setEnabled(False)

    def update_status(self, status: str, detail: str) -> None:
        self._status_label.setText(status.title())
        color = _STATUS_COLORS.get(status, "#607d8b")
        self._dot.set_color(color)
        if detail:
            self._detail.setText(detail)
            self._detail.show()
        else:
            self._detail.hide()

    def _on_restart(self) -> None:
        try:
            ok = self._manager.restart(self._record.name)
        except Exception as exc:  # pragma: no cover - user feedback only
            QMessageBox.critical(self, "Restart failed", str(exc))
            return
        if not ok:
            QMessageBox.information(self, "Restart", "No restart hook registered.")

    def _on_prompt(self) -> None:
        dlg = _PromptDialog(f"{self._record.name} Prompt", self._record.prompt_path, self)
        dlg.exec()


class OperatorManagerWidget(QWidget):
    """Scrollable list of operator rows bound to the OperatorManager singleton."""

    def __init__(self, theme: Optional[object] = None, parent: Optional[QWidget] = None) -> None:
        super().__init__(parent)
        self._theme = theme
        self._manager = get_operator_manager()
        self._rows: Dict[str, _OperatorRow] = {}
        self.setObjectName("OperatorManagerWidget")
        bg = getattr(theme, "card_bg", "#0c1320")
        border = getattr(theme, "card_border", "#1f2a3a")
        fg = getattr(theme, "text_body", "#e8f1ff")
        self.setStyleSheet(
            f"QWidget#OperatorManagerWidget{{background:{bg};border:1px solid {border};border-radius:12px;}}"
            f"QWidget#OperatorManagerWidget QLabel{{color:{fg};}}"
        )

        layout = QVBoxLayout(self)
        layout.setContentsMargins(12, 12, 12, 12)
        layout.setSpacing(12)

        title = QLabel("Operator Manager", self)
        title_font = QFont(); title_font.setPointSize(14); title_font.setBold(True)
        title.setFont(title_font)
        layout.addWidget(title, 0)

        subtitle = QLabel("Monitor and control Codex-Local agents.", self)
        subtitle.setWordWrap(True)
        layout.addWidget(subtitle, 0)

        scroll = QScrollArea(self)
        scroll.setWidgetResizable(True)
        scroll.setFrameShape(QFrame.NoFrame)
        layout.addWidget(scroll, 1)

        container = QWidget(scroll)
        self._rows_layout = QVBoxLayout(container)
        self._rows_layout.setContentsMargins(0, 0, 0, 0)
        self._rows_layout.setSpacing(10)
        scroll.setWidget(container)

        hint = QLabel("Status updates stream live from registered agents.", self)
        hint.setWordWrap(True)
        layout.addWidget(hint, 0)

        self._manager.operator_registered.connect(self._on_registered)
        self._manager.operator_removed.connect(self._on_removed)
        self._manager.status_changed.connect(self._on_status)

        for record in self._manager.list_records():
            self._add_row(record)

    def _add_row(self, record: OperatorRecord) -> None:
        if record.name in self._rows:
            row = self._rows[record.name]
            row.update_status(record.status, record.status_detail)
            return
        row = _OperatorRow(record, self._manager, self._theme, self)
        self._rows[record.name] = row
        self._rows_layout.addWidget(row)

    def _on_registered(self, name: str) -> None:
        record = self._manager.get(name)
        if record:
            self._add_row(record)

    def _on_removed(self, name: str) -> None:
        row = self._rows.pop(name, None)
        if row:
            row.setParent(None)
            row.deleteLater()

    def _on_status(self, name: str, status: str, detail: str) -> None:
        row = self._rows.get(name)
        if row:
            row.update_status(status, detail)


def _prompt_path_for(slug: str) -> Optional[str]:
    try:
        watcher = get_prompt_watcher(slug)
    except KeyError:
        return None
    return str(watcher.base_path)


def ensure_default_operators() -> None:
    manager = get_operator_manager()
    manager.register(
        name="Codex",
        role="Code agent that executes commands and edits files.",
        prompt_path=_prompt_path_for("codex_system"),
        status="idle",
    )
    manager.register(
        name="Chat",
        role="Conversational assistant for analysis, explanations, and planning.",
        prompt_path=_prompt_path_for("chat_system"),
        status="idle",
    )
    manager.register(
        name="Voice",
        role="Speech interface handling microphone input and spoken output.",
        prompt_path=_prompt_path_for("voice_system"),
        status="offline",
    )


# Initialize defaults on import so other modules can update immediately.
ensure_default_operators()
```

Operator Manager registry and Qt panel for Codex-Local agents.
**Classes:** OperatorRecord, OperatorManager, _StatusDot, _PromptDialog, _OperatorRow, OperatorManagerWidget
**Functions:** get_operator_manager(), _prompt_path_for(slug), ensure_default_operators()


## Module `prompt_loader.py`

```python
"""Utilities for loading disk-backed prompt files with overlay support."""

from __future__ import annotations

from dataclasses import dataclass
from pathlib import Path
from threading import RLock
from typing import Dict, Iterable, Optional

PROMPTS_DIR = Path(__file__).resolve().parent / "prompts"


@dataclass(frozen=True)
class PromptDefinition:
    """Static metadata describing a prompt bundle."""

    slug: str
    title: str
    description: str
    default: str = ""

    @property
    def base_path(self) -> Path:
        return PROMPTS_DIR / f"{self.slug}.txt"

    @property
    def overlay_path(self) -> Path:
        return PROMPTS_DIR / f"{self.slug}.overlay.txt"


class PromptWatcher:
    """Caches prompt text and refreshes when the underlying files change."""

    def __init__(self, definition: PromptDefinition):
        self._definition = definition
        self._lock = RLock()
        self._cached_text: str = ""
        self._mtimes: tuple[Optional[float], Optional[float]] = (None, None)
        PROMPTS_DIR.mkdir(parents=True, exist_ok=True)
        self._load(initial=True)

    @property
    def definition(self) -> PromptDefinition:
        return self._definition

    @property
    def base_path(self) -> Path:
        return self._definition.base_path

    @property
    def overlay_path(self) -> Path:
        return self._definition.overlay_path

    def text(self) -> str:
        """Return the prompt text, reloading if files changed."""

        with self._lock:
            current = (self._stat(self.base_path), self._stat(self.overlay_path))
            if current != self._mtimes:
                self._load()
            return self._cached_text

    def reload(self) -> None:
        """Force a reload regardless of modification times."""

        with self._lock:
            self._load()

    # ----- internal helpers -----
    def _load(self, initial: bool = False) -> None:
        base_text = self._read_file(self.base_path)
        if not base_text.strip():
            base_text = self._definition.default
            if initial and self._definition.default and not self.base_path.exists():
                self.base_path.parent.mkdir(parents=True, exist_ok=True)
                self.base_path.write_text(self._definition.default + "\n", encoding="utf-8")
                base_text = self._definition.default
        overlay_text = self._read_file(self.overlay_path)
        combined = base_text.strip()
        overlay_clean = overlay_text.strip()
        if overlay_clean:
            combined = f"{combined}\n\n{overlay_clean}" if combined else overlay_clean
        if not combined.strip():
            combined = self._definition.default
        self._cached_text = combined
        self._mtimes = (self._stat(self.base_path), self._stat(self.overlay_path))

    def _read_file(self, path: Path) -> str:
        try:
            return path.read_text(encoding="utf-8")
        except FileNotFoundError:
            return ""

    def _stat(self, path: Path) -> Optional[float]:
        try:
            return path.stat().st_mtime
        except FileNotFoundError:
            return None


_PROMPT_DEFINITIONS: Dict[str, PromptDefinition] = {
    "codex_system": PromptDefinition(
        slug="codex_system",
        title="Codex System Prompt",
        description="Core persona for the coding operator.",
        default=(
            "You are Codex-Local's coding operator. Work entirely within this local "
            "workspace without network access. Translate user goals into exact shell "
            "commands and code edits, think through each plan before running it, and "
            "narrate critical decisions. The Codex interpreter may automatically prompt "
            "you to continue executing work; resume only when the requested path is "
            "safe and justified. When the requested work is complete, announce "
            "completion and emit `STOP` on its own line so downstream tooling halts "
            "cleanly. Respect safety guardrails, request confirmation for destructive "
            "steps, and prefer deterministic, minimal changes that keep tests green."
        ),
    ),
    "chat_system": PromptDefinition(
        slug="chat_system",
        title="Chat System Prompt",
        description="Conversational analysis and planning persona.",
        default=(
            "You are Codex-Local's planning and explanation companion. Provide "
            "thorough analysis, cite relevant repository context, and propose "
            "actionable next steps. Keep guidance grounded in files that exist locally, "
            "flag assumptions or risks, and delegate execution details to the coding "
            "operator when commands must be run. Anticipate interpreter auto-continue "
            "loops by outlining the next safe action and reminding the operator to "
            "declare completion. When work is finished, ensure the response includes an "
            "explicit completion note plus a standalone `STOP` line."
        ),
    ),
    "codex_shell": PromptDefinition(
        slug="codex_shell",
        title="Codex Shell Prompt",
        description="Translator from natural language intent to shell commands.",
        default=(
            "You convert natural language intent into concrete shell commands for "
            "Codex-Local. Use POSIX-friendly syntax unless the session explicitly "
            "targets another shell. Compose small, deterministic command sequences, "
            "include safety flags, and never guess at paths that do not exist. Expect "
            "interpreter auto-continue prompts; prepare follow-up commands only when "
            "prior output requires them. When no further safe commands remain, state "
            "that execution is complete and output `STOP` on its own line so automation "
            "knows to halt. If a request is ambiguous, return a brief question instead "
            "of a risky command."
        ),
    ),
    "voice_system": PromptDefinition(
        slug="voice_system",
        title="Voice System Prompt",
        description="Speech transcription and routing persona.",
        default=(
            "You run Codex-Local's voice interface. Listen for wake phrases, "
            "transcribe speech accurately, and summarize intent in concise text. "
            "Never execute commands yourself; hand the cleaned request to the "
            "appropriate agent. Preserve privacy by keeping audio-derived data local "
            "and discarding snippets once they are processed.\n\n"
            "Interpreter awareness:\n"
            "- Flag when a spoken request will trigger the coding interpreter so the "
            "user knows auto-continue may occur.\n"
            "- Remind the operator that completion replies must include a clear stop "
            "sentence plus a standalone `STOP` line."
        ),
    ),
}

_PROMPT_CACHE: Dict[str, PromptWatcher] = {}
_CACHE_LOCK = RLock()


def get_prompt_watcher(slug: str) -> PromptWatcher:
    """Return (and cache) the watcher for *slug*."""

    with _CACHE_LOCK:
        watcher = _PROMPT_CACHE.get(slug)
        if watcher is None:
            definition = _PROMPT_DEFINITIONS.get(slug)
            if definition is None:
                raise KeyError(f"Unknown prompt slug: {slug}")
            watcher = PromptWatcher(definition)
            _PROMPT_CACHE[slug] = watcher
        return watcher


def prompt_text(slug: str) -> str:
    """Convenience wrapper that returns the combined text for *slug*."""

    return get_prompt_watcher(slug).text()


def iter_prompt_definitions() -> Iterable[PromptDefinition]:
    """Iterate over known prompt definitions in a stable order."""

    for slug in sorted(_PROMPT_DEFINITIONS.keys()):
        yield _PROMPT_DEFINITIONS[slug]
```

Utilities for loading disk-backed prompt files with overlay support.
**Classes:** PromptDefinition, PromptWatcher
**Functions:** get_prompt_watcher(slug), prompt_text(slug), iter_prompt_definitions()


## Module `repo_reference_helper.py`

```python
"""Repository reference helper for chat input suggestions."""

from __future__ import annotations

import logging
from dataclasses import dataclass
from pathlib import Path
from typing import Dict, Iterable, List, Optional, Sequence, Set

# Optional Qt imports (guarded for pure-Python usage/tests)
try:  # pragma: no cover - import guard
    from PySide6.QtCore import QObject, QTimer, Signal, QFileSystemWatcher
    _HAS_QT = True
except Exception:  # pragma: no cover - fallback when PySide6 absent
    QObject = object  # type: ignore[assignment]
    QTimer = None  # type: ignore[assignment]
    Signal = None  # type: ignore[assignment]
    QFileSystemWatcher = None  # type: ignore[assignment]
    _HAS_QT = False

from memory_manager import RepositoryIndex

logger = logging.getLogger(__name__)


def _normalize_extra_roots(repo_root: Path, roots: Optional[Sequence[Path | str]]) -> List[Path]:
    extras: List[Path] = []
    if not roots:
        return extras
    try:
        base = repo_root.resolve()
    except Exception:
        base = repo_root
    seen: Set[Path] = {base}
    for entry in roots:
        if not entry:
            continue
        try:
            candidate = Path(entry).expanduser().resolve()
        except Exception:
            continue
        if candidate in seen:
            continue
        seen.add(candidate)
        extras.append(candidate)
    return extras


@dataclass(frozen=True)
class RepoReference:
    """Lightweight reference describing a repository file or directory."""

    absolute_path: Path
    relative_path: str
    kind: str  # "file" or "directory"

    def display_label(self) -> str:
        suffix = "/" if self.kind == "directory" else ""
        return f"{self.relative_path}{suffix}"


class RepoReferenceIndex:
    """Maintain an in-memory list of repository file and directory references."""

    def __init__(
        self,
        repo_root: Path,
        *,
        repository_index: Optional[RepositoryIndex] = None,
        extra_roots: Optional[Sequence[Path | str]] = None,
    ) -> None:
        self.repo_root = Path(repo_root).resolve()
        self._extra_roots = _normalize_extra_roots(self.repo_root, extra_roots)
        self._allowed_roots: List[Path] = [self.repo_root] + self._extra_roots
        self.repository_index = repository_index or RepositoryIndex(
            repo_root=self.repo_root,
            extra_roots=self._extra_roots,
        )
        self._references: List[RepoReference] = []

    # ------------------------------------------------------------------
    # Refresh + query
    # ------------------------------------------------------------------
    def refresh(self) -> None:
        """Refresh the cached references from the repository index."""

        references: List[RepoReference] = []
        file_paths = self._gather_file_paths()
        seen_dirs: Dict[Path, None] = {}

        for file_path in sorted(file_paths):
            rel = self._to_relative(file_path)
            references.append(
                RepoReference(absolute_path=file_path, relative_path=rel, kind="file")
            )
            for parent in file_path.parents:
                if parent == self.repo_root:
                    break
                if parent in seen_dirs:
                    continue
                seen_dirs[parent] = None
                references.append(
                    RepoReference(
                        absolute_path=parent,
                        relative_path=self._to_relative(parent),
                        kind="directory",
                    )
                )

        references.sort(key=lambda ref: (0 if ref.kind == "file" else 1, ref.relative_path.lower()))
        self._references = references

    def suggestions(self, query: str, limit: int = 5) -> List[RepoReference]:
        """Return matching references for ``query`` ordered by relevance."""

        text = (query or "").strip().lower()
        if not text:
            return []

        matches: List[tuple[int, int, RepoReference]] = []
        for ref in self._references:
            rel_lower = ref.relative_path.lower()
            name_lower = ref.absolute_path.name.lower()
            if text in rel_lower or text in name_lower:
                prefix_match = 0 if rel_lower.startswith(text) or name_lower.startswith(text) else 1
                matches.append((prefix_match, len(rel_lower), ref))

        matches.sort()
        return [ref for _, _, ref in matches[:limit]]

    # ------------------------------------------------------------------
    # Helpers
    # ------------------------------------------------------------------
    def entries(self) -> List[RepoReference]:
        return list(self._references)

    def _to_relative(self, path: Path) -> str:
        try:
            resolved = path.resolve()
        except Exception:
            resolved = path
        for root in self._allowed_roots:
            try:
                rel = resolved.relative_to(root)
            except ValueError:
                continue
            rel_text = rel.as_posix()
            if root == self.repo_root:
                return rel_text
            prefix = root.name or root.as_posix()
            return f"{prefix}/{rel_text}" if rel_text else prefix
        return resolved.as_posix()

    def _match_allowed_root(self, value: object) -> Optional[Path]:
        if not value:
            return None
        try:
            candidate = Path(str(value)).expanduser().resolve()
        except Exception:
            return None
        for root in self._allowed_roots:
            if candidate == root:
                return root
        return None

    def _resolve_segment_path(self, base_root: Path, relative_path: str) -> Optional[Path]:
        try:
            candidate = Path(relative_path)
        except Exception:
            return None
        try:
            if candidate.is_absolute():
                resolved = candidate.resolve()
            else:
                resolved = (base_root / candidate).resolve()
        except Exception:
            return None
        try:
            resolved.relative_to(base_root)
        except ValueError:
            return None
        return resolved

    def _gather_file_paths(self) -> List[Path]:
        paths = set()
        segments: Iterable[Dict[str, object]] = []

        try:
            self.repository_index.load()
            segments = list(self.repository_index.iter_segments())
        except Exception:
            segments = []

        if not segments:
            try:
                self.repository_index.rebuild()
                self.repository_index.load()
                segments = list(self.repository_index.iter_segments())
            except Exception as exc:  # pragma: no cover - logged for visibility
                logger.debug("RepoReferenceIndex rebuild failed: %s", exc)
                segments = []

        allowed_set = {root for root in self._allowed_roots}
        for segment in segments:
            if not isinstance(segment, dict):
                continue
            path_str = str(segment.get("path") or "")
            if not path_str:
                continue
            metadata = segment.get("metadata")
            base_root = None
            if isinstance(metadata, dict):
                base_root = self._match_allowed_root(metadata.get("scan_root"))
            if base_root is None:
                base_root = self.repo_root
            if base_root not in allowed_set:
                continue
            resolved = self._resolve_segment_path(base_root, path_str)
            if resolved is None:
                continue
            if resolved.is_file():
                paths.add(resolved)

        if not paths:
            for root in self._allowed_roots:
                if not root.exists():
                    continue
                for file_path in root.rglob("*"):
                    if file_path.is_file():
                        try:
                            resolved = file_path.resolve()
                        except Exception:
                            continue
                        paths.add(resolved)

        return list(paths)


if _HAS_QT:

    class RepoReferenceHelper(QObject):
        """Qt-aware helper that refreshes repository references as the workspace changes."""

        refreshed = Signal()  # type: ignore[assignment]

        def __init__(
            self,
            repo_root: Path,
            *,
            parent: Optional[QObject] = None,
            repository_index: Optional[RepositoryIndex] = None,
            embed_contents: bool = True,
            case_sensitive: bool = False,
            token_guard: bool = True,
            extra_roots: Optional[Sequence[Path | str]] = None,
        ) -> None:
            super().__init__(parent)
            self.repo_root = Path(repo_root).resolve()
            self._extra_roots = _normalize_extra_roots(self.repo_root, extra_roots)
            self.index = RepoReferenceIndex(
                self.repo_root,
                repository_index=repository_index,
                extra_roots=self._extra_roots,
            )
            self.index.refresh()

            self.embed_contents = bool(embed_contents)
            self.case_sensitive = bool(case_sensitive)
            self.token_guard = bool(token_guard)

            self._watcher = QFileSystemWatcher(self)  # type: ignore[assignment]
            self._watcher.directoryChanged.connect(self._schedule_refresh)
            self._watcher.fileChanged.connect(self._schedule_refresh)

            self._debounce = QTimer(self)  # type: ignore[assignment]
            self._debounce.setSingleShot(True)
            self._debounce.setInterval(300)
            self._debounce.timeout.connect(self.refresh)

            self._register_watch_paths()

        # ------------------------------------------------------------------
        # Public API
        # ------------------------------------------------------------------
        def refresh(self) -> None:
            self.index.refresh()
            self.refreshed.emit()

        def suggestions(self, query: str, limit: int = 5) -> List[RepoReference]:
            return self.index.suggestions(query, limit)

        # ------------------------------------------------------------------
        # Internals
        # ------------------------------------------------------------------
        def _register_watch_paths(self) -> None:
            for root in [self.repo_root] + self._extra_roots:
                if not root.exists():
                    continue
                try:
                    self._watcher.addPath(str(root))
                except Exception as exc:  # pragma: no cover - watcher limitations
                    logger.debug("Failed to watch repo root %s: %s", root, exc)

            index_path = getattr(self.index.repository_index, "index_path", None)
            if index_path:
                path_obj = Path(index_path)
                if path_obj.exists():
                    try:
                        self._watcher.addPath(str(path_obj))
                    except Exception as exc:  # pragma: no cover - watcher limitations
                        logger.debug("Failed to watch index %s: %s", path_obj, exc)

        def _schedule_refresh(self, _path: str) -> None:
            self._debounce.start()

else:

    class RepoReferenceHelper:  # pragma: no cover - runtime guard
        def __init__(self, *args, **kwargs) -> None:
            raise RuntimeError("PySide6 is required to use RepoReferenceHelper")

        def refresh(self) -> None:
            raise RuntimeError("PySide6 is required to use RepoReferenceHelper")

        def suggestions(self, query: str, limit: int = 5) -> List[RepoReference]:
            raise RuntimeError("PySide6 is required to use RepoReferenceHelper")
```

Repository reference helper for chat input suggestions.
**Classes:** RepoReference, RepoReferenceIndex
**Functions:** _normalize_extra_roots(repo_root, roots)


## Module `safety.py`

```python
"""Runtime safety guardrails for the Codex Terminal."""

from __future__ import annotations

import builtins
import os
import re
import shlex
import threading
import uuid
from pathlib import Path
from typing import Callable, Dict, Optional, Sequence

__all__ = ["SafetyViolation", "SafetyManager", "manager"]


class SafetyViolation(RuntimeError):
    """Raised when a safety rule blocks an operation."""


class SafetyManager:
    """Coordinates safety guardrails for file writes and shell commands."""

    def __init__(self) -> None:
        self._lock = threading.RLock()
        self._protected_files: set[Path] = set()
        self._protected_dirs: set[Path] = set()
        self._notifiers: Dict[str, Callable[[str], None]] = {}
        self._confirmer: Optional[Callable[[str, Sequence[str]], bool]] = None
        self._original_open = builtins.open
        self._installed = False
        self._risk_patterns = (
            re.compile(r"\brm\b.*\b--no-preserve-root\b"),
            re.compile(r"\brm\b.*\b-\w*[rf]\w*\b.*\s/"),
            re.compile(r"\bsudo\s+rm\b"),
            re.compile(r"\bmkfs(\.\w+)?\b"),
            re.compile(r"\bformat\s+[A-Za-z]:"),
            re.compile(r":\(\)\s*\{\s*:\s*\|\s*:\s*;\s*\}\s*;\s*:"),
        )

    # ------------------------------------------------------------------
    def install_file_guard(self) -> None:
        """Monkey patch ``open`` so we can intercept destructive writes."""

        with self._lock:
            if self._installed:
                return

            def _guarded_open(file, mode="r", *args, **kwargs):  # type: ignore[override]
                path = self._coerce_path(file)
                if path is not None and self._is_write_mode(mode):
                    self._enforce_protected(path, mode)
                return self._original_open(file, mode, *args, **kwargs)

            builtins.open = _guarded_open  # type: ignore[assignment]
            self._installed = True

    # ------------------------------------------------------------------
    def add_protected_path(self, path: os.PathLike[str] | str) -> None:
        resolved = self._normalise(path)
        with self._lock:
            self._protected_files.add(resolved)

    def add_protected_directory(self, path: os.PathLike[str] | str) -> None:
        resolved = self._normalise(path)
        with self._lock:
            self._protected_dirs.add(resolved)

    def remove_protected_path(self, path: os.PathLike[str] | str) -> None:
        resolved = self._normalise(path)
        with self._lock:
            self._protected_files.discard(resolved)

    def remove_protected_directory(self, path: os.PathLike[str] | str) -> None:
        resolved = self._normalise(path)
        with self._lock:
            self._protected_dirs.discard(resolved)

    def clear_protected(self) -> None:
        with self._lock:
            self._protected_files.clear()
            self._protected_dirs.clear()

    # ------------------------------------------------------------------
    def add_notifier(self, callback: Callable[[str], None]) -> str:
        token = uuid.uuid4().hex
        with self._lock:
            self._notifiers[token] = callback
        return token

    def remove_notifier(self, token: str) -> None:
        with self._lock:
            self._notifiers.pop(token, None)

    def clear_notifiers(self) -> None:
        with self._lock:
            self._notifiers.clear()

    # ------------------------------------------------------------------
    def set_confirmer(self, callback: Optional[Callable[[str, Sequence[str]], bool]]) -> None:
        with self._lock:
            self._confirmer = callback

    # ------------------------------------------------------------------
    def ensure_command_allowed(self, cmd: Sequence[str]) -> None:
        if not cmd:
            return

        canonical = [str(part) for part in cmd]
        joined = shlex.join(canonical)
        lowered = joined.lower()

        reason = self._match_risky(lowered, canonical)
        if not reason:
            return

        prompt = f"[SAFETY] Confirmation required: {joined}" if reason == "confirm" else f"[SAFETY] {reason}: {joined}"
        self._dispatch(prompt)

        allow = False
        callback = self._confirmer
        if callback is not None:
            try:
                allow = bool(callback(prompt, tuple(canonical)))
            except Exception as exc:  # pragma: no cover - defensive
                self._dispatch(f"[SAFETY] Confirmation handler failed: {exc}")
                allow = False

        if allow:
            self._dispatch(f"[SAFETY] Approved: {joined}")
            return

        message = f"[SAFETY] Blocked command: {joined}"
        self._dispatch(message)
        raise SafetyViolation(message)

    # ------------------------------------------------------------------
    def _match_risky(self, lowered: str, tokens: Sequence[str]) -> Optional[str]:
        for pattern in self._risk_patterns:
            if pattern.search(lowered):
                return "confirm"

        # Additional heuristic for rm -rf style deletions.
        if not tokens:
            return None

        lowered_tokens = [t.lower() for t in tokens]
        if "rm" in lowered_tokens or any(tok.endswith("rm") for tok in lowered_tokens):
            if self._has_flag(lowered_tokens, "r") and self._has_flag(lowered_tokens, "f"):
                if any(tok == "/" or tok.startswith("/") for tok in lowered_tokens):
                    return "confirm"
        return None

    @staticmethod
    def _has_flag(tokens: Sequence[str], flag: str) -> bool:
        return any(token.startswith("-") and flag in token for token in tokens)

    # ------------------------------------------------------------------
    def _dispatch(self, message: str) -> None:
        with self._lock:
            callbacks = list(self._notifiers.values())
        for cb in callbacks:
            try:
                cb(message)
            except Exception:  # pragma: no cover - defensive
                continue

    # ------------------------------------------------------------------
    def _enforce_protected(self, path: Path, mode: str) -> None:
        if not self._is_protected(path):
            return

        if "a" in mode and "w" not in mode:
            return

        message = f"[SAFETY] Blocked write to protected path: {path}"
        self._dispatch(message)
        raise SafetyViolation(message)

    def _is_protected(self, path: Path) -> bool:
        with self._lock:
            files = set(self._protected_files)
            dirs = set(self._protected_dirs)
        if path in files:
            return True
        for root in dirs:
            try:
                if path == root or path.is_relative_to(root):  # type: ignore[attr-defined]
                    return True
            except AttributeError:
                try:
                    path.resolve()
                    root.resolve()
                except Exception:
                    continue
                if str(path).startswith(str(root)):
                    return True
        return False

    # ------------------------------------------------------------------
    @staticmethod
    def _is_write_mode(mode: str) -> bool:
        return any(token in mode for token in ("w", "a", "+", "x"))

    @staticmethod
    def _coerce_path(file: object) -> Optional[Path]:
        if isinstance(file, (str, bytes, os.PathLike)):
            return Path(file)
        return None

    @staticmethod
    def _normalise(path: os.PathLike[str] | str) -> Path:
        return Path(path).expanduser().resolve(strict=False)


manager = SafetyManager()
manager.install_file_guard()
manager.add_protected_path(Path("Agent.md"))
manager.add_protected_directory(Path("errors"))
```

Runtime safety guardrails for the Codex Terminal.
**Classes:** SafetyViolation, SafetyManager


## Module `simple_codex_terminal.py`

```python
import warnings
from Codex_Terminal import *  # noqa: F401,F403

warnings.warn(
    "simple_codex_terminal is deprecated; use Codex_Terminal instead",
    DeprecationWarning,
    stacklevel=2,
)

if __name__ == "__main__":
    main()
```



## Module `token_budget.py`

```python
from __future__ import annotations

import math
import re
from functools import lru_cache
from typing import Dict

try:
    import tiktoken  # type: ignore
except Exception:  # pragma: no cover - optional dependency
    tiktoken = None  # type: ignore

# Conservative defaults based on common context lengths.
_MODEL_TOKEN_LIMITS: Dict[str, int] = {
    "qwen3": 32768,
    "qwen2": 32768,
    "qwen": 32768,
    "llama3": 8192,
    "llama-3": 8192,
    "llama2": 4096,
    "llama-2": 4096,
    "mistral": 8192,
    "mixtral": 8192,
    "phi3": 4096,
    "phi-3": 4096,
    "phi2": 4096,
    "codellama": 16384,
    "deepseek": 16384,
    "gpt-4o": 128000,
    "gpt-4": 8192,
    "gpt-3.5": 4096,
}

_DEFAULT_MAX_TOKENS = 8192
_WORD_RE = re.compile(r"\S+")


@lru_cache(maxsize=32)
def _encoding_for_model(model: str | None):  # pragma: no cover - simple cache
    if not tiktoken:
        return None
    name = (model or "").strip() or "cl100k_base"
    try:
        return tiktoken.encoding_for_model(name)
    except Exception:
        try:
            return tiktoken.get_encoding("cl100k_base")
        except Exception:
            return None


def get_model_token_limit(model: str | None) -> int:
    """Return the maximum prompt tokens supported by ``model``.

    The lookup is intentionally fuzzy — if a known pattern appears within the
    model name we use the associated limit. Unknown models fall back to a
    conservative default so callers always receive a positive integer.
    """

    if not model:
        return _DEFAULT_MAX_TOKENS
    key = model.lower()
    for pattern, limit in _MODEL_TOKEN_LIMITS.items():
        if pattern in key:
            return limit
    return _DEFAULT_MAX_TOKENS


def prompt_token_budget(model: str | None, headroom_pct: int) -> int:
    """Compute the usable prompt budget given a headroom percentage."""

    limit = get_model_token_limit(model)
    pct = max(1, min(int(headroom_pct or 0), 100))
    return int(limit * (pct / 100.0))


def count_tokens(text: str, model: str | None = None) -> int:
    """Count tokens for ``text`` using an optional tokenizer fallback."""

    if not text:
        return 0
    encoding = _encoding_for_model(model)
    if encoding:
        try:
            return len(encoding.encode(text))
        except Exception:
            pass
    tokens = _WORD_RE.findall(text)
    if tokens:
        return len(tokens)
    # Fallback heuristic when whitespace tokenisation fails (e.g. CJK text).
    return max(1, math.ceil(len(text) / 4))
```

**Functions:** _encoding_for_model(model), get_model_token_limit(model), prompt_token_budget(model, headroom_pct), count_tokens(text, model)


## Module `User_Guided_Notes.py`

```python
#!/usr/bin/env python3
"""User Guided Notes card for Codex Virtual Desktop.

This module provides a high-level implementation of the User Guided Notes
card described in the specification that accompanies the Virtual Desktop.
It focuses on providing a structured, high-contrast interface for capturing
conversations, evidence, and exports while remaining self-contained so it
can run even when optional subsystems (Ollama, OCR, etc.) are unavailable.

The implementation intentionally leans on defensive fallbacks so the widget
can be instantiated both as an embedded Virtual Desktop card and as a
standalone window.
"""

from __future__ import annotations

import json
import os
import shutil
import subprocess
import sys
import threading
import time
import uuid
from dataclasses import dataclass, asdict
from datetime import datetime
from pathlib import Path
from typing import Any, Dict, Iterable, List, Optional, Sequence, Tuple

try:  # Optional dependency for HTTP interactions with Ollama/OpenAI
    import requests  # type: ignore
except Exception:  # pragma: no cover - optional
    requests = None  # type: ignore

from PySide6.QtCore import (
    QEvent,
    QObject,
    QPoint,
    QRect,
    QSize,
    Qt,
    QTimer,
    Signal,
    QSignalBlocker,
    QUrl,
)
from PySide6.QtGui import (
    QAction,
    QColor,
    QDesktopServices,
    QGuiApplication,
    QIcon,
    QImage,
    QKeySequence,
    QPainter,
    QPen,
)
from PySide6.QtWidgets import (
    QApplication,
    QComboBox,
    QDialog,
    QFileDialog,
    QGroupBox,
    QHBoxLayout,
    QInputDialog,
    QLabel,
    QLineEdit,
    QListWidget,
    QListWidgetItem,
    QMainWindow,
    QMenuBar,
    QMessageBox,
    QPushButton,
    QPlainTextEdit,
    QSplitter,
    QTabWidget,
    QTextBrowser,
    QTextEdit,
    QToolButton,
    QVBoxLayout,
    QWidget,
)

from image_pipeline import perform_ocr, analyze_image, generate_thumbnail, OCRResult

# --------------------------------------------------------------------------------------
# Storage helpers
# --------------------------------------------------------------------------------------

BASE_DIR = Path(__file__).resolve().parent / "User_Guided_Notes"
SETTINGS_PATH = BASE_DIR / "settings.json"
PROMPTS_PATH = BASE_DIR / "prompts" / "index.json"
NOTES_ROOT = BASE_DIR / "notes"
DEFAULT_PROVIDER = "Ollama"
DEFAULT_MODEL = "qwen:latest"
DEFAULT_EMBED_MODEL = "nomic-embed-text"
DATASET_TOP_K = 5

DEFAULT_PANE_VISIBILITY: Dict[str, bool] = {
    "evidence": True,
    "conversation": True,
    "summary": True,
    "dataset": True,
    "attachments": True,
}

DEFAULT_THEME = "dark"
DEFAULT_FONT_POINT_ADJUST = 0.0
COMPACT_FONT_POINT_ADJUST = -2.0


@dataclass(frozen=True)
class ThemePalette:
    name: str
    window_bg: str
    window_fg: str
    border: str
    panel_bg: str
    panel_fg: str
    secondary_bg: str
    secondary_fg: str
    input_bg: str
    input_fg: str
    accent: str
    accent_hover: str
    accent_fg: str
    muted_bg: str
    muted_fg: str
    status_fg: str
    traffic_red: str
    traffic_yellow: str
    traffic_green: str


THEME_PALETTES: Dict[str, ThemePalette] = {
    "dark": ThemePalette(
        name="dark",
        window_bg="#010409",
        window_fg="#f6f8fa",
        border="#1e2a44",
        panel_bg="#050b15",
        panel_fg="#e8f1ff",
        secondary_bg="#0c111f",
        secondary_fg="#f0f6ff",
        input_bg="#0c111f",
        input_fg="#f0f6ff",
        accent="#1f6feb",
        accent_hover="#388bfd",
        accent_fg="#ffffff",
        muted_bg="#030712",
        muted_fg="#9ba7bd",
        status_fg="#9ba7bd",
        traffic_red="#ff5f57",
        traffic_yellow="#febb2e",
        traffic_green="#2ac840",
    ),
    "light": ThemePalette(
        name="light",
        window_bg="#f5f5f7",
        window_fg="#1f1f24",
        border="#d0d4da",
        panel_bg="#ffffff",
        panel_fg="#1f2933",
        secondary_bg="#eef1f7",
        secondary_fg="#273449",
        input_bg="#ffffff",
        input_fg="#1f2933",
        accent="#3478f6",
        accent_hover="#1d6ce5",
        accent_fg="#ffffff",
        muted_bg="#e8ebf5",
        muted_fg="#4a5467",
        status_fg="#4a5467",
        traffic_red="#ff5f57",
        traffic_yellow="#fcbc2f",
        traffic_green="#28c840",
    ),
}


@dataclass
class FontTarget:
    widget: QWidget
    point_size: float
    pixel_size: int


def _capture_font_target(widget: QWidget) -> FontTarget:
    font = widget.font()
    return FontTarget(widget=widget, point_size=font.pointSizeF(), pixel_size=font.pixelSize())


def _apply_font_targets(
    targets: Sequence[FontTarget],
    offset: float,
    *,
    min_point: float = 6.0,
    min_pixel: int = 9,
) -> None:
    point_to_pixel = 96.0 / 72.0
    for target in targets:
        font = target.widget.font()
        if target.point_size > 0:
            font.setPointSizeF(max(target.point_size + offset, min_point))
        elif target.pixel_size > 0:
            computed = int(round(target.pixel_size + offset * point_to_pixel))
            font.setPixelSize(max(computed, min_pixel))
        target.widget.setFont(font)


class ThemeHelper:
    @classmethod
    def palette(cls, name: str) -> ThemePalette:
        return THEME_PALETTES.get(name, THEME_PALETTES[DEFAULT_THEME])

    @classmethod
    def available(cls) -> Sequence[str]:
        return list(THEME_PALETTES.keys())

BASE_DIR.mkdir(parents=True, exist_ok=True)
(NOTES_ROOT).mkdir(parents=True, exist_ok=True)
(PROMPTS_PATH.parent).mkdir(parents=True, exist_ok=True)


# --------------------------------------------------------------------------------------
# Utility functions
# --------------------------------------------------------------------------------------

def timestamp() -> str:
    return datetime.utcnow().replace(microsecond=0).isoformat() + "Z"


def slugify(text: str, *, max_length: int = 48) -> str:
    cleaned = "".join(ch if ch.isalnum() else "-" for ch in text.lower()).strip("-")
    cleaned = "-".join(filter(None, cleaned.split("-")))
    if not cleaned:
        cleaned = f"note-{int(time.time())}"
    if len(cleaned) <= max_length:
        return cleaned
    return cleaned[:max_length].rstrip("-")


def load_json(path: Path, default: Any) -> Any:
    try:
        if path.exists():
            return json.loads(path.read_text(encoding="utf-8"))
    except Exception:
        pass
    return default


def save_json(path: Path, data: Any) -> None:
    try:
        path.parent.mkdir(parents=True, exist_ok=True)
        tmp = path.with_suffix(".tmp")
        tmp.write_text(json.dumps(data, indent=2, sort_keys=True), encoding="utf-8")
        tmp.replace(path)
    except Exception:
        # Best-effort persistence; surfaced via UI logs later if required.
        pass


if not SETTINGS_PATH.exists():
    save_json(
        SETTINGS_PATH,
        {
            "provider": DEFAULT_PROVIDER,
            "model": DEFAULT_MODEL,
            "embed_model": DEFAULT_EMBED_MODEL,
            "autosave_interval": 20.0,
            "last_note_slug": None,
            "theme": DEFAULT_THEME,
            "font_point_adjust": DEFAULT_FONT_POINT_ADJUST,
        },
    )

if not PROMPTS_PATH.exists():
    save_json(
        PROMPTS_PATH,
        {
            "prompts": [
                {
                    "name": "Editorial Default",
                    "enabled": True,
                    "text": (
                        "You are a senior editor-engineer. Convert each user problem into precise "
                        "implementation corrections for this repository."
                    ),
                }
            ]
        },
    )


# --------------------------------------------------------------------------------------
# Data structures
# --------------------------------------------------------------------------------------

@dataclass
class NotePaths:
    root: Path
    note_md: Path
    dataset_jsonl: Path
    embeddings_json: Path
    attachments_full: Path
    attachments_thumbs: Path
    exports_dir: Path
    logs_dir: Path


@dataclass
class NoteMeta:
    id: str
    name: str
    slug: str
    created_ts: str
    updated_ts: str
    paths: NotePaths
    settings: Dict[str, Any]

    def as_dict(self) -> Dict[str, Any]:
        payload = asdict(self)
        payload["paths"] = {k: str(v) for k, v in payload["paths"].items()}
        return payload


@dataclass
class Message:
    role: str
    text: str
    images: List[str]
    ts: str

    def to_json(self) -> Dict[str, Any]:
        return {
            "role": self.role,
            "text": self.text,
            "images": self.images,
            "ts": self.ts,
        }


# --------------------------------------------------------------------------------------
# Embedding helpers (placeholder deterministic embedding)
# --------------------------------------------------------------------------------------

EMBED_DIM = 96


def _hash_bytes(text: str) -> bytes:
    import hashlib

    return hashlib.sha256(text.encode("utf-8", "ignore")).digest()


def compute_embedding(text: str, *, dim: int = EMBED_DIM) -> List[float]:
    if not text:
        return [0.0] * dim
    raw = _hash_bytes(text)
    values: List[float] = []
    for idx in range(dim):
        byte = raw[idx % len(raw)]
        values.append((byte - 127.5) / 127.5)
    return values


def cosine_similarity(a: Sequence[float], b: Sequence[float]) -> float:
    if len(a) != len(b):
        return 0.0
    dot = sum(x * y for x, y in zip(a, b))
    mag_a = sum(x * x for x in a) ** 0.5
    mag_b = sum(y * y for y in b) ** 0.5
    if mag_a <= 1e-9 or mag_b <= 1e-9:
        return 0.0
    return dot / (mag_a * mag_b)


# --------------------------------------------------------------------------------------
# Ollama helpers
# --------------------------------------------------------------------------------------

OLLAMA_HOST = os.environ.get("OLLAMA_HOST", "http://127.0.0.1:11434")


def discover_ollama_models() -> List[str]:
    models: List[str] = []
    # Try HTTP API first.
    if requests is not None:
        try:
            resp = requests.get(f"{OLLAMA_HOST.rstrip('/')}/api/tags", timeout=2)
            if resp.ok:
                payload = resp.json()
                for model in payload.get("models", []):
                    name = model.get("name")
                    if isinstance(name, str):
                        models.append(name)
        except Exception:
            models = []
    if models:
        return models
    # Fallback to CLI list --json
    exe = shutil.which("ollama")
    if exe:
        try:
            output = subprocess.check_output([exe, "list", "--json"], text=True, timeout=5)
            for line in output.splitlines():
                try:
                    row = json.loads(line)
                except json.JSONDecodeError:
                    continue
                name = row.get("name")
                if isinstance(name, str):
                    models.append(name)
        except Exception:
            models = []
    if models:
        return models
    return [DEFAULT_MODEL]


# --------------------------------------------------------------------------------------
# Persistence manager
# --------------------------------------------------------------------------------------


class NoteManager:
    """Manage creation and persistence of notes on disk."""

    def __init__(self) -> None:
        self.base = NOTES_ROOT
        self.base.mkdir(parents=True, exist_ok=True)

    # ------------------------------------------------------------------
    def list_notes(self) -> List[NoteMeta]:
        notes: List[NoteMeta] = []
        if not self.base.exists():
            return notes
        for meta_path in sorted(self.base.glob("*/note.meta.json")):
            meta = self._load_meta_from_path(meta_path)
            if meta is not None:
                notes.append(meta)
        notes.sort(key=self._timestamp_key, reverse=True)
        return notes

    # ------------------------------------------------------------------
    def load_note(self, slug: str) -> Optional[NoteMeta]:
        return self._load_meta_from_path(self.base / slug / "note.meta.json")

    # ------------------------------------------------------------------
    def _load_meta_from_path(self, meta_path: Path) -> Optional[NoteMeta]:
        if not meta_path.exists():
            return None
        try:
            raw = meta_path.read_text(encoding="utf-8")
        except Exception:
            return None
        try:
            payload = json.loads(raw)
        except Exception:
            return None
        if not isinstance(payload, dict):
            return None
        return self._deserialize_meta(meta_path, payload)

    # ------------------------------------------------------------------
    def _deserialize_meta(self, meta_path: Path, payload: Dict[str, Any]) -> Optional[NoteMeta]:
        root = meta_path.parent
        slug = str(payload.get("slug") or root.name)
        name = str(payload.get("name") or slug)
        created_ts = str(payload.get("created_ts") or timestamp())
        updated_ts = str(payload.get("updated_ts") or created_ts)
        note_id = str(payload.get("id") or uuid.uuid4())

        default_paths = self._default_paths(root)
        stored_paths = payload.get("paths")
        if isinstance(stored_paths, dict):
            default_paths = NotePaths(
                root=root,
                note_md=self._coerce_path(stored_paths.get("note_md"), default_paths.note_md, root),
                dataset_jsonl=self._coerce_path(
                    stored_paths.get("dataset_jsonl"), default_paths.dataset_jsonl, root
                ),
                embeddings_json=self._coerce_path(
                    stored_paths.get("embeddings_json"), default_paths.embeddings_json, root
                ),
                attachments_full=self._coerce_path(
                    stored_paths.get("attachments_full"), default_paths.attachments_full, root
                ),
                attachments_thumbs=self._coerce_path(
                    stored_paths.get("attachments_thumbs"), default_paths.attachments_thumbs, root
                ),
                exports_dir=self._coerce_path(
                    stored_paths.get("exports_dir"), default_paths.exports_dir, root
                ),
                logs_dir=self._coerce_path(stored_paths.get("logs_dir"), default_paths.logs_dir, root),
            )

        settings_raw = payload.get("settings")
        settings: Dict[str, Any]
        if isinstance(settings_raw, dict):
            settings = dict(settings_raw)
        else:
            settings = {}
        settings.setdefault("font_point_adjust", DEFAULT_FONT_POINT_ADJUST)

        return NoteMeta(
            id=note_id,
            name=name,
            slug=slug,
            created_ts=created_ts,
            updated_ts=updated_ts,
            paths=default_paths,
            settings=settings,
        )

    # ------------------------------------------------------------------
    def _coerce_path(self, value: Any, default: Path, root: Path) -> Path:
        if isinstance(value, str) and value:
            candidate = Path(value)
            if not candidate.is_absolute():
                candidate = root / candidate
            return candidate
        return default

    # ------------------------------------------------------------------
    def _default_paths(self, root: Path) -> NotePaths:
        return NotePaths(
            root=root,
            note_md=root / "note.md",
            dataset_jsonl=root / "note.dataset.jsonl",
            embeddings_json=root / "embeddings.json",
            attachments_full=root / "attachments" / "full",
            attachments_thumbs=root / "attachments" / "thumbs",
            exports_dir=root / "exports",
            logs_dir=root / "logs",
        )

    # ------------------------------------------------------------------
    def _timestamp_key(self, note: NoteMeta) -> float:
        for value in (note.updated_ts, note.created_ts):
            if isinstance(value, str) and value:
                try:
                    cleaned = value.replace("Z", "+00:00") if value.endswith("Z") else value
                    return datetime.fromisoformat(cleaned).timestamp()
                except Exception:
                    continue
        return 0.0

    def create_note(self, name: str) -> NoteMeta:
        slug = slugify(name)
        root = self.base / slug
        suffix = 1
        while root.exists():
            root = self.base / f"{slug}-{suffix}"
            suffix += 1
        root.mkdir(parents=True, exist_ok=True)
        paths = NotePaths(
            root=root,
            note_md=root / "note.md",
            dataset_jsonl=root / "note.dataset.jsonl",
            embeddings_json=root / "embeddings.json",
            attachments_full=root / "attachments" / "full",
            attachments_thumbs=root / "attachments" / "thumbs",
            exports_dir=root / "exports",
            logs_dir=root / "logs",
        )
        paths.attachments_full.mkdir(parents=True, exist_ok=True)
        paths.attachments_thumbs.mkdir(parents=True, exist_ok=True)
        paths.exports_dir.mkdir(parents=True, exist_ok=True)
        paths.logs_dir.mkdir(parents=True, exist_ok=True)

        meta = NoteMeta(
            id=str(uuid.uuid4()),
            name=name,
            slug=root.name,
            created_ts=timestamp(),
            updated_ts=timestamp(),
            paths=paths,
            settings={
                "provider": DEFAULT_PROVIDER,
                "model": DEFAULT_MODEL,
                "embed_model": DEFAULT_EMBED_MODEL,
                "pane_visibility": dict(DEFAULT_PANE_VISIBILITY),
                "font_point_adjust": DEFAULT_FONT_POINT_ADJUST,
            },
        )
        # Seed files
        if not paths.note_md.exists():
            paths.note_md.write_text(f"# {name}\n\n", encoding="utf-8")
        if not paths.dataset_jsonl.exists():
            paths.dataset_jsonl.write_text("", encoding="utf-8")
        if not paths.embeddings_json.exists():
            paths.embeddings_json.write_text("[]\n", encoding="utf-8")
        self._write_meta(meta)
        return meta

    def _meta_path(self, note: NoteMeta) -> Path:
        return note.paths.root / "note.meta.json"

    def _write_meta(self, note: NoteMeta) -> None:
        save_json(self._meta_path(note), note.as_dict())

    def update_meta(self, note: NoteMeta) -> None:
        note.updated_ts = timestamp()
        self._write_meta(note)

    def append_message(self, note: NoteMeta, message: Message) -> None:
        path = note.paths.dataset_jsonl
        path.parent.mkdir(parents=True, exist_ok=True)
        with path.open("a", encoding="utf-8") as handle:
            handle.write(json.dumps(message.to_json(), ensure_ascii=False) + "\n")
        # Update embeddings file
        entry = {
            "doc_id": message.ts,
            "vec": compute_embedding(message.text),
            "meta": {
                "role": message.role,
            },
        }
        embeddings = load_json(note.paths.embeddings_json, [])
        embeddings.append(entry)
        save_json(note.paths.embeddings_json, embeddings)
        note.updated_ts = timestamp()
        self._write_meta(note)

    def iter_messages(self, note: NoteMeta) -> Iterable[Dict[str, Any]]:
        path = note.paths.dataset_jsonl
        if not path.exists():
            return
        try:
            with path.open("r", encoding="utf-8") as handle:
                for line in handle:
                    line = line.strip()
                    if not line:
                        continue
                    try:
                        yield json.loads(line)
                    except json.JSONDecodeError:
                        continue
        except Exception:
            return


# --------------------------------------------------------------------------------------
# Worker threads for LLM interactions
# --------------------------------------------------------------------------------------


class ChatWorker(QObject):
    chunk_received = Signal(str)
    finished = Signal(str)
    failed = Signal(str)

    def __init__(self, provider: str, model: str, messages: List[Dict[str, str]]):
        super().__init__()
        self.provider = provider
        self.model = model
        self.messages = messages
        self._thread: Optional[threading.Thread] = None

    def start(self) -> None:
        if self._thread and self._thread.is_alive():
            return
        self._thread = threading.Thread(target=self._run, daemon=True)
        self._thread.start()

    # ------------------------------------------------------------------
    def _run(self) -> None:
        try:
            if self.provider.lower() == "openai":
                text = self._run_openai()
            else:
                text = self._run_ollama()
            self.finished.emit(text)
        except Exception as exc:
            self.failed.emit(str(exc))

    # ------------------------------------------------------------------
    def _run_ollama(self) -> str:
        if requests is None:
            raise RuntimeError("requests module unavailable")
        url = f"{OLLAMA_HOST.rstrip('/')}/api/chat"
        payload = {
            "model": self.model,
            "messages": self.messages,
            "stream": False,
        }
        resp = requests.post(url, json=payload, timeout=120)
        resp.raise_for_status()
        data = resp.json()
        msg = data.get("message") or {}
        content = msg.get("content") or data.get("response")
        if not isinstance(content, str):
            raise RuntimeError("invalid Ollama response")
        return content.strip()

    # ------------------------------------------------------------------
    def _run_openai(self) -> str:
        api_key = os.environ.get("OPENAI_API_KEY")
        if not api_key:
            raise RuntimeError("OPENAI_API_KEY not set")
        if requests is None:
            raise RuntimeError("requests module unavailable")
        url = "https://api.openai.com/v1/chat/completions"
        payload = {
            "model": self.model,
            "messages": self.messages,
            "stream": False,
        }
        headers = {
            "Authorization": f"Bearer {api_key}",
            "Content-Type": "application/json",
        }
        resp = requests.post(url, json=payload, headers=headers, timeout=120)
        resp.raise_for_status()
        data = resp.json()
        choices = data.get("choices") or []
        if not choices:
            raise RuntimeError("no choices returned")
        message = choices[0].get("message", {})
        content = message.get("content")
        if not isinstance(content, str):
            raise RuntimeError("no content returned")
        return content.strip()


# --------------------------------------------------------------------------------------
# UI components
# --------------------------------------------------------------------------------------


class DatasetInspector(QWidget):
    """Simple list showing retrieved dataset entries."""

    def __init__(self, parent: Optional[QWidget] = None) -> None:
        super().__init__(parent)
        layout = QVBoxLayout(self)
        layout.setContentsMargins(6, 6, 6, 6)
        layout.setSpacing(4)
        self.title = QLabel("Dataset Inspector", self)
        self.title.setStyleSheet("font-weight:600;")
        layout.addWidget(self.title)
        self.listing = QListWidget(self)
        layout.addWidget(self.listing, 1)
        self._font_targets = [
            _capture_font_target(self.title),
            _capture_font_target(self.listing),
        ]
        self._palette = ThemeHelper.palette(DEFAULT_THEME)

    def update_entries(self, entries: Sequence[Tuple[float, Dict[str, Any]]]) -> None:
        self.listing.clear()
        for score, row in entries:
            text = row.get("text") or row.get("markdown") or "(no text)"
            preview = text.strip().splitlines()[0] if text else "(empty)"
            item = QListWidgetItem(f"{score:.2f} — {preview[:80]}")
            item.setToolTip(text)
            self.listing.addItem(item)

    def apply_theme(self, palette: ThemePalette) -> None:
        self._palette = palette
        self.title.setStyleSheet(f"font-weight:600; color:{palette.window_fg};")
        self.listing.setStyleSheet(
            f"QListWidget {{ background:{palette.muted_bg}; color:{palette.window_fg}; border:1px solid {palette.border}; border-radius:6px; }}"
        )

    def apply_font_scale(self, offset: float) -> None:
        _apply_font_targets(self._font_targets, offset)


class AttachmentsPanel(QWidget):
    def __init__(self, parent: Optional[QWidget] = None) -> None:
        super().__init__(parent)
        layout = QVBoxLayout(self)
        layout.setContentsMargins(6, 6, 6, 6)
        layout.setSpacing(4)
        self.title = QLabel("Attachments", self)
        self.title.setStyleSheet("font-weight:600;")
        layout.addWidget(self.title)
        self.listing = QListWidget(self)
        layout.addWidget(self.listing, 1)
        self.open_btn = QPushButton("Open Folder", self)
        self.open_btn.clicked.connect(self._open_folder)
        layout.addWidget(self.open_btn)
        self._current_root: Optional[Path] = None
        self._font_targets = [
            _capture_font_target(self.title),
            _capture_font_target(self.listing),
            _capture_font_target(self.open_btn),
        ]
        self._palette = ThemeHelper.palette(DEFAULT_THEME)

    def set_root(self, root: Path) -> None:
        self._current_root = root

    def refresh(self, files: Sequence[Path]) -> None:
        self.listing.clear()
        for path in files:
            item = QListWidgetItem(path.name)
            item.setToolTip(str(path))
            self.listing.addItem(item)

    def _open_folder(self) -> None:
        if not self._current_root:
            return
        QDesktopServices.openUrl(QUrl.fromLocalFile(str(self._current_root)))

    def apply_theme(self, palette: ThemePalette) -> None:
        self._palette = palette
        self.title.setStyleSheet(f"font-weight:600; color:{palette.window_fg};")
        self.listing.setStyleSheet(
            f"QListWidget {{ background:{palette.muted_bg}; color:{palette.window_fg}; border:1px solid {palette.border}; border-radius:6px; }}"
        )
        self.open_btn.setStyleSheet(
            (
                "QPushButton {"
                f" background:{palette.accent};"
                f" color:{palette.accent_fg};"
                f" border:1px solid {palette.accent};"
                " border-radius:6px; padding:6px 12px; }"
                "QPushButton:hover {"
                f" background:{palette.accent_hover};"
                " }"
            )
        )

    def apply_font_scale(self, offset: float) -> None:
        _apply_font_targets(self._font_targets, offset)


class DragHandle(QPushButton):
    drag_started = Signal(QPoint)
    drag_moved = Signal(QPoint)
    drag_finished = Signal()

    def __init__(self, color: str, tooltip: str, cursor: Qt.CursorShape, parent: Optional[QWidget] = None) -> None:
        super().__init__("", parent)
        self._dragging = False
        self._press_pos = QPoint()
        self.setToolTip(tooltip)
        self.setCursor(cursor)
        self.setFixedSize(28, 28)
        self.setFocusPolicy(Qt.NoFocus)
        self.setStyleSheet(
            (
                "QPushButton {"
                " border-radius:14px;"
                f" background:{color};"
                " border:1px solid rgba(0,0,0,0.3);"
                " }"
            )
        )

    def mousePressEvent(self, event) -> None:  # type: ignore[override]
        if event.button() == Qt.LeftButton:
            self._dragging = True
            self._press_pos = event.globalPosition().toPoint()
            self.drag_started.emit(self._press_pos)
            event.accept()
            return
        super().mousePressEvent(event)

    def mouseMoveEvent(self, event) -> None:  # type: ignore[override]
        if self._dragging:
            self.drag_moved.emit(event.globalPosition().toPoint())
            event.accept()
            return
        super().mouseMoveEvent(event)

    def mouseReleaseEvent(self, event) -> None:  # type: ignore[override]
        if self._dragging and event.button() == Qt.LeftButton:
            self._dragging = False
            self.drag_finished.emit()
            event.accept()
            return
        super().mouseReleaseEvent(event)


class SnippingOverlay(QWidget):
    captured = Signal(Path)
    canceled = Signal()

    MIN_WIDTH = 120
    MIN_HEIGHT = 90

    def __init__(self, attachments_dir: Path, parent: Optional[QWidget] = None) -> None:
        super().__init__(None)
        self.attachments_dir = attachments_dir
        self._screen = self._resolve_screen(parent)
        screen = self._screen or QGuiApplication.primaryScreen()
        if screen is None:
            raise RuntimeError("No available screen for snipping overlay")
        self._screen_geometry = screen.geometry()

        self.setWindowFlag(Qt.FramelessWindowHint, True)
        self.setWindowFlag(Qt.WindowStaysOnTopHint, True)
        self.setWindowFlag(Qt.Tool, True)
        self.setAttribute(Qt.WA_TranslucentBackground, True)
        self.setWindowModality(Qt.ApplicationModal)
        self.setGeometry(self._screen_geometry)
        self._selection_rect = QRect(0, 0, 480, 320)
        self._selection_rect.moveCenter(self.rect().center())
        self._press_anchor = QPoint()
        self._initial_rect = QRect()

        self.move_handle = DragHandle("#ffffff", "Move selection", Qt.SizeAllCursor, self)
        self.move_handle.drag_started.connect(self._begin_move)
        self.move_handle.drag_moved.connect(self._update_move)
        self.move_handle.drag_finished.connect(self._end_drag)

        self.resize_handle = DragHandle("#388bfd", "Resize selection", Qt.SizeFDiagCursor, self)
        self.resize_handle.drag_started.connect(self._begin_resize)
        self.resize_handle.drag_moved.connect(self._update_resize)
        self.resize_handle.drag_finished.connect(self._end_drag)

        self.capture_btn = QPushButton("", self)
        self.capture_btn.setFixedSize(28, 28)
        self.capture_btn.setCursor(Qt.PointingHandCursor)
        self.capture_btn.setToolTip("Capture selection")
        self.capture_btn.setStyleSheet(
            "QPushButton { border-radius:14px; background:#2ac840; border:1px solid rgba(0,0,0,0.3); }"
        )
        self.capture_btn.clicked.connect(self._capture_selection)

        self.close_btn = QPushButton("", self)
        self.close_btn.setFixedSize(28, 28)
        self.close_btn.setCursor(Qt.PointingHandCursor)
        self.close_btn.setToolTip("Cancel capture")
        self.close_btn.setStyleSheet(
            "QPushButton { border-radius:14px; background:#ff5f57; border:1px solid rgba(0,0,0,0.3); }"
        )
        self.close_btn.clicked.connect(self._cancel)

        self._update_controls()

    def _resolve_screen(self, widget: Optional[QWidget]):
        if widget is None:
            return QGuiApplication.primaryScreen()
        window = widget.window()
        if window is None:
            return QGuiApplication.primaryScreen()
        handle = window.windowHandle()
        if handle is None:
            return QGuiApplication.primaryScreen()
        return handle.screen()

    def showEvent(self, event) -> None:  # type: ignore[override]
        super().showEvent(event)
        QTimer.singleShot(0, self.activateWindow)

    def paintEvent(self, event) -> None:  # type: ignore[override]
        painter = QPainter(self)
        painter.setRenderHint(QPainter.Antialiasing)
        painter.fillRect(self.rect(), QColor(1, 4, 9, 160))
        painter.setCompositionMode(QPainter.CompositionMode_Clear)
        painter.fillRect(self._selection_rect, Qt.transparent)
        painter.setCompositionMode(QPainter.CompositionMode_SourceOver)
        pen = QPen(QColor("#1f6feb"), 2)
        painter.setPen(pen)
        painter.drawRect(self._selection_rect)

    def keyPressEvent(self, event) -> None:  # type: ignore[override]
        if event.key() == Qt.Key_Escape:
            self._cancel()
            event.accept()
            return
        super().keyPressEvent(event)

    def _begin_move(self, global_pos: QPoint) -> None:
        self._press_anchor = global_pos
        self._initial_rect = QRect(self._selection_rect)

    def _begin_resize(self, global_pos: QPoint) -> None:
        self._press_anchor = global_pos
        self._initial_rect = QRect(self._selection_rect)

    def _update_move(self, global_pos: QPoint) -> None:
        delta = global_pos - self._press_anchor
        rect = QRect(self._initial_rect)
        rect.moveTo(rect.topLeft() + delta)
        self._set_selection_rect(rect)

    def _update_resize(self, global_pos: QPoint) -> None:
        delta = global_pos - self._press_anchor
        rect = QRect(self._initial_rect)
        rect.setWidth(max(self.MIN_WIDTH, rect.width() + delta.x()))
        rect.setHeight(max(self.MIN_HEIGHT, rect.height() + delta.y()))
        self._set_selection_rect(rect)

    def _end_drag(self) -> None:
        self._initial_rect = QRect(self._selection_rect)

    def _set_selection_rect(self, rect: QRect) -> None:
        bounded = QRect(rect)
        bounded.setWidth(min(bounded.width(), self.width()))
        bounded.setHeight(min(bounded.height(), self.height()))
        if bounded.left() < 0:
            bounded.moveLeft(0)
        if bounded.top() < 0:
            bounded.moveTop(0)
        if bounded.right() > self.width():
            bounded.moveRight(self.width())
        if bounded.bottom() > self.height():
            bounded.moveBottom(self.height())
        if bounded.width() < self.MIN_WIDTH:
            bounded.setWidth(self.MIN_WIDTH)
        if bounded.height() < self.MIN_HEIGHT:
            bounded.setHeight(self.MIN_HEIGHT)
        self._selection_rect = bounded
        self._update_controls()
        self.update()

    def _update_controls(self) -> None:
        top_left = self._selection_rect.topLeft()
        spacing = 10
        base = QPoint(top_left.x() + spacing, top_left.y() + spacing)
        offset = self.move_handle.width() + 6
        self.move_handle.move(base)
        self.resize_handle.move(base + QPoint(offset, 0))
        self.capture_btn.move(base + QPoint(offset * 2, 0))
        self.close_btn.move(base + QPoint(offset * 3, 0))

    def _capture_selection(self) -> None:
        screen = self._screen or QGuiApplication.primaryScreen()
        if screen is None:
            self._cancel()
            return
        capture_rect = QRect(self._selection_rect)
        global_top_left = self._screen_geometry.topLeft() + capture_rect.topLeft()
        self.hide()
        QApplication.processEvents()
        pixmap = screen.grabWindow(
            0,
            global_top_left.x(),
            global_top_left.y(),
            capture_rect.width(),
            capture_rect.height(),
        )
        if pixmap.isNull():
            self.show()
            QMessageBox.critical(self, "Capture failed", "Unable to capture the selected region.")
            return
        self.attachments_dir.mkdir(parents=True, exist_ok=True)
        dest = self.attachments_dir / f"{timestamp()}_snip.png"
        pixmap.save(str(dest), "PNG")
        self.captured.emit(dest)
        self.close()

    def _cancel(self) -> None:
        self.canceled.emit()
        self.close()

    def closeEvent(self, event) -> None:  # type: ignore[override]
        super().closeEvent(event)
        QTimer.singleShot(0, self.deleteLater)

class EvidencePanel(QGroupBox):
    ocr_ready = Signal(str)
    vision_ready = Signal(str)

    def __init__(self, note: NoteMeta, parent: Optional[QWidget] = None) -> None:
        super().__init__("Evidence", parent)
        self.note = note
        self.setLayout(QVBoxLayout())
        layout: QVBoxLayout = self.layout()  # type: ignore[assignment]
        layout.setContentsMargins(8, 8, 8, 8)
        layout.setSpacing(6)
        self._palette = ThemeHelper.palette(DEFAULT_THEME)
        self._font_targets: List[FontTarget] = []
        self._active_overlay: Optional[SnippingOverlay] = None

        btn_row = QHBoxLayout()
        self.add_snapshot_btn = QPushButton("Add Snapshot", self)
        self.add_snapshot_btn.clicked.connect(self._capture_snapshot)
        btn_row.addWidget(self.add_snapshot_btn)
        btn_row.addStretch(1)
        layout.addLayout(btn_row)

        self.thumb_strip = QListWidget(self)
        self.thumb_strip.setViewMode(QListWidget.IconMode)
        self.thumb_strip.setIconSize(QSize(96, 96))
        self.thumb_strip.setResizeMode(QListWidget.Adjust)
        self.thumb_strip.setMovement(QListWidget.Static)
        self.thumb_strip.setSpacing(6)
        layout.addWidget(self.thumb_strip, 1)

        self.ocr_box = QTextBrowser(self)
        self.ocr_box.setPlaceholderText("OCR Markdown will appear here")
        layout.addWidget(self.ocr_box, 1)

        self.vision_box = QTextBrowser(self)
        self.vision_box.setPlaceholderText("Vision summary will appear here")
        layout.addWidget(self.vision_box, 1)

        self._thumbnails: List[Path] = []
        self._font_targets.extend(
            [
                _capture_font_target(self),
                _capture_font_target(self.add_snapshot_btn),
                _capture_font_target(self.thumb_strip),
                _capture_font_target(self.ocr_box),
                _capture_font_target(self.vision_box),
            ]
        )

    # ------------------------------------------------------------------
    def _capture_snapshot(self) -> None:
        box = QMessageBox(self)
        box.setWindowTitle("Add Snapshot")
        box.setIcon(QMessageBox.Question)
        box.setText("How would you like to add evidence?")
        browse_btn = box.addButton("Browse…", QMessageBox.AcceptRole)
        paste_btn = box.addButton("Paste from Clipboard", QMessageBox.ActionRole)
        capture_btn = box.addButton("Capture with Wireframe", QMessageBox.ActionRole)
        box.addButton(QMessageBox.Cancel)
        box.exec()
        clicked = box.clickedButton()
        if clicked is browse_btn:
            self._import_from_dialog()
        elif clicked is paste_btn:
            self._import_from_clipboard()
        elif clicked is capture_btn:
            self._launch_snipping_overlay()

    def _ensure_attachment_dirs(self) -> None:
        self.note.paths.attachments_full.mkdir(parents=True, exist_ok=True)
        self.note.paths.attachments_thumbs.mkdir(parents=True, exist_ok=True)

    def _ingest_snapshot(self, dest: Path) -> None:
        if not dest.exists():
            QMessageBox.warning(self, "Missing file", f"Captured file was not found: {dest}")
            return
        self._ensure_attachment_dirs()
        thumb_path = generate_thumbnail(dest)
        thumb_display: Path
        if thumb_path:
            thumb_dest = self.note.paths.attachments_thumbs / Path(thumb_path).name
            try:
                thumb_dest.parent.mkdir(parents=True, exist_ok=True)
                shutil.copy2(thumb_path, thumb_dest)
                thumb_display = thumb_dest
            except Exception:
                thumb_display = dest
        else:
            thumb_display = dest
        item = QListWidgetItem(QIcon(str(thumb_display)), dest.name)
        item.setToolTip(str(dest))
        self.thumb_strip.addItem(item)
        self._thumbnails.append(dest)
        self._run_ocr(dest)

    def _import_from_dialog(self) -> None:
        start_dir = str(self.note.paths.attachments_full)
        file_path, _ = QFileDialog.getOpenFileName(
            self,
            "Select Image",
            start_dir,
            "Images (*.png *.jpg *.jpeg *.bmp *.gif)"
        )
        if not file_path:
            return
        src = Path(file_path)
        dest = self.note.paths.attachments_full / f"{timestamp()}_{src.name}"
        try:
            self._ensure_attachment_dirs()
            shutil.copy2(src, dest)
        except Exception as exc:
            QMessageBox.critical(self, "Copy failed", f"Failed to copy image: {exc}")
            return
        self._ingest_snapshot(dest)

    def _import_from_clipboard(self) -> None:
        clipboard = QGuiApplication.clipboard()
        if clipboard is None:
            QMessageBox.warning(self, "Clipboard unavailable", "Cannot access the system clipboard.")
            return
        image: QImage = clipboard.image()
        if image.isNull():
            pixmap = clipboard.pixmap()
            if not pixmap.isNull():
                image = pixmap.toImage()
        if image.isNull():
            QMessageBox.information(self, "No image found", "Clipboard does not contain image data.")
            return
        self._ensure_attachment_dirs()
        dest = self.note.paths.attachments_full / f"{timestamp()}_clipboard.png"
        if not image.save(str(dest), "PNG"):
            QMessageBox.critical(self, "Save failed", "Unable to write clipboard image to disk.")
            return
        self._ingest_snapshot(dest)

    def _launch_snipping_overlay(self) -> None:
        if self._active_overlay is not None:
            return
        try:
            overlay = SnippingOverlay(self.note.paths.attachments_full, self)
        except RuntimeError as exc:
            QMessageBox.critical(self, "Capture unavailable", str(exc))
            return
        self._active_overlay = overlay
        overlay.captured.connect(self._handle_snip_captured)
        overlay.canceled.connect(self._overlay_closed)
        overlay.destroyed.connect(lambda *_: self._overlay_closed())
        overlay.show()

    def _handle_snip_captured(self, dest: Path) -> None:
        self._active_overlay = None
        self._ingest_snapshot(dest)

    def _overlay_closed(self) -> None:
        self._active_overlay = None

    # ------------------------------------------------------------------
    def _run_ocr(self, path: Path) -> None:
        result: OCRResult = perform_ocr(path)
        if result.ok:
            self.ocr_box.append(f"### {path.name}\n\n{result.markdown}\n")
            self.ocr_ready.emit(result.markdown)
        else:
            self.ocr_box.append(f"### {path.name}\n\n*(OCR failed: {result.error})*\n")
        vision = analyze_image(path, result.markdown, client=None, model="", user_text="")
        if vision.ok:
            self.vision_box.append(f"### {path.name}\n\n{vision.summary}\n")
            self.vision_ready.emit(vision.summary)
        elif vision.error:
            self.vision_box.append(f"### {path.name}\n\n*(Vision unavailable: {vision.error})*\n")

    def apply_theme(self, palette: ThemePalette) -> None:
        self._palette = palette
        self.setStyleSheet(
            (
                "QGroupBox {"
                f" background:{palette.panel_bg};"
                f" color:{palette.panel_fg};"
                f" border:1px solid {palette.border};"
                " border-radius:8px; margin-top:12px; }"
                "QGroupBox::title { subcontrol-origin: margin; subcontrol-position: top left; padding:0 6px; }"
            )
        )
        button_style = (
            "QPushButton {"
            f" background:{palette.accent};"
            f" color:{palette.accent_fg};"
            f" border:1px solid {palette.accent};"
            " border-radius:6px; padding:6px 12px; }"
            "QPushButton:hover {"
            f" background:{palette.accent_hover};"
            " }"
        )
        self.add_snapshot_btn.setStyleSheet(button_style)
        self.thumb_strip.setStyleSheet(
            f"QListWidget {{ background:{palette.muted_bg}; color:{palette.panel_fg}; border:1px solid {palette.border}; border-radius:6px; }}"
        )
        browser_style = (
            "QTextBrowser {"
            f" background:{palette.secondary_bg};"
            f" color:{palette.secondary_fg};"
            f" border:1px solid {palette.border};"
            " border-radius:6px; }"
        )
        self.ocr_box.setStyleSheet(browser_style)
        self.vision_box.setStyleSheet(browser_style)

    def apply_font_scale(self, offset: float) -> None:
        _apply_font_targets(self._font_targets, offset)


class ConversationWidget(QWidget):
    message_submitted = Signal(str)

    def __init__(self, parent: Optional[QWidget] = None) -> None:
        super().__init__(parent)
        self._palette = ThemeHelper.palette(DEFAULT_THEME)
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(4)
        self.view = QTextBrowser(self)
        layout.addWidget(self.view, 1)
        input_row = QHBoxLayout()
        self.input = QPlainTextEdit(self)
        self.input.setPlaceholderText("Describe the problem or next step…")
        self.input.installEventFilter(self)
        input_row.addWidget(self.input, 1)
        self.send_btn = QPushButton("Send", self)
        self.send_btn.setCursor(Qt.PointingHandCursor)
        self.send_btn.clicked.connect(self._emit_message)
        input_row.addWidget(self.send_btn)
        layout.addLayout(input_row)
        self._font_targets = [
            _capture_font_target(self.view),
            _capture_font_target(self.input),
            _capture_font_target(self.send_btn),
        ]

    def append_message(self, role: str, text: str) -> None:
        palette = self._palette
        if role == "assistant":
            colour = palette.accent
        elif role == "system":
            colour = palette.traffic_yellow
        else:
            colour = palette.traffic_green
        safe_text = text.replace("<", "&lt;").replace(">", "&gt;")
        self.view.append(f"<p style='color:{colour};'><b>{role.title()}:</b> {safe_text}</p>")

    def eventFilter(self, obj: QObject, event: QEvent) -> bool:
        if obj is self.input and event.type() == QEvent.KeyPress:
            if event.key() in (Qt.Key_Return, Qt.Key_Enter) and event.modifiers() & Qt.ControlModifier:
                self._emit_message()
                return True
        return super().eventFilter(obj, event)

    def _emit_message(self) -> None:
        text = self.input.toPlainText().strip()
        if not text:
            return
        self.message_submitted.emit(text)
        self.input.clear()

    def apply_theme(self, palette: ThemePalette) -> None:
        self._palette = palette
        self.view.setStyleSheet(
            (
                "QTextBrowser {"
                f" background:{palette.panel_bg};"
                f" color:{palette.panel_fg};"
                f" border:1px solid {palette.border};"
                " border-radius:6px; }"
            )
        )
        self.input.setStyleSheet(
            (
                "QPlainTextEdit {"
                f" background:{palette.secondary_bg};"
                f" color:{palette.secondary_fg};"
                f" border:1px solid {palette.border};"
                " border-radius:6px; }"
            )
        )
        self.send_btn.setStyleSheet(
            (
                "QPushButton {"
                f" background:{palette.accent};"
                f" color:{palette.accent_fg};"
                f" border:1px solid {palette.accent};"
                " border-radius:6px; padding:6px 12px; }"
                "QPushButton:hover {"
                f" background:{palette.accent_hover};"
                " }"
            )
        )

    def apply_font_scale(self, offset: float) -> None:
        _apply_font_targets(self._font_targets, offset)


class NoteTab(QWidget):
    request_chat = Signal(str)
    export_requested = Signal()

    def __init__(
        self,
        manager: NoteManager,
        meta: NoteMeta,
        theme: str,
        font_offset: float,
        parent: Optional[QWidget] = None,
    ) -> None:
        super().__init__(parent)
        self.manager = manager
        self.meta = meta
        self.meta.settings.setdefault("font_point_adjust", font_offset)
        self._theme_name = theme
        self._font_offset = font_offset
        self._palette = ThemeHelper.palette(theme)
        self.retrieval_cache: List[Tuple[float, Dict[str, Any]]] = []
        self._font_targets: List[FontTarget] = []

        root = QVBoxLayout(self)
        root.setContentsMargins(8, 8, 8, 8)
        root.setSpacing(8)

        header_row = QHBoxLayout()
        self.header_label = QLabel("Problem title", self)
        header_row.addWidget(self.header_label)
        self.title_edit = QLineEdit(meta.name, self)
        self.title_edit.editingFinished.connect(self._save_title)
        header_row.addWidget(self.title_edit, 1)
        root.addLayout(header_row)

        self.splitter = QSplitter(Qt.Horizontal, self)
        self.splitter.setChildrenCollapsible(False)
        self.splitter.setHandleWidth(6)
        self.splitter.setStretchFactor(0, 5)
        self.splitter.setStretchFactor(1, 3)
        root.addWidget(self.splitter, 1)

        left = QWidget(self.splitter)
        self.left_container = left
        self.left_container.setMinimumWidth(320)
        left_layout = QVBoxLayout(left)
        left_layout.setContentsMargins(0, 0, 0, 0)
        left_layout.setSpacing(8)

        self.evidence = EvidencePanel(meta, left)
        self.evidence.setMinimumHeight(220)
        self.evidence.ocr_ready.connect(self._handle_ocr)
        self.evidence.vision_ready.connect(self._handle_vision)
        left_layout.addWidget(self.evidence, 2)

        self.conversation = ConversationWidget(left)
        self.conversation.setMinimumHeight(200)
        self.conversation.message_submitted.connect(self._handle_user_message)
        left_layout.addWidget(self.conversation, 4)

        summary_box = QGroupBox("Note summary", left)
        summary_box.setMinimumHeight(140)
        self.summary_box = summary_box
        summary_layout = QVBoxLayout(summary_box)
        self.summary_edit = QTextEdit(summary_box)
        self.summary_edit.setPlaceholderText("Running summary will appear here")
        self.summary_edit.textChanged.connect(self._save_summary)
        self.summary_edit.setMinimumHeight(120)
        summary_layout.addWidget(self.summary_edit)
        left_layout.addWidget(summary_box, 1)

        right = QWidget(self.splitter)
        self.right_container = right
        self.right_container.setMinimumWidth(240)
        right_layout = QVBoxLayout(right)
        right_layout.setContentsMargins(0, 0, 0, 0)
        right_layout.setSpacing(6)
        self.dataset_inspector = DatasetInspector(right)
        self.dataset_inspector.setMinimumHeight(160)
        right_layout.addWidget(self.dataset_inspector, 3)
        self.attachments_panel = AttachmentsPanel(right)
        self.attachments_panel.setMinimumHeight(140)
        self.attachments_panel.set_root(meta.paths.attachments_full)
        right_layout.addWidget(self.attachments_panel, 2)
        self._default_split_sizes = [560, 280]
        self.splitter.setSizes(self._default_split_sizes)
        self._pane_widgets: Dict[str, QWidget] = {
            "evidence": self.evidence,
            "conversation": self.conversation,
            "summary": self.summary_box,
            "dataset": self.dataset_inspector,
            "attachments": self.attachments_panel,
        }

        self._font_targets.extend(
            [
                _capture_font_target(self),
                _capture_font_target(self.header_label),
                _capture_font_target(self.title_edit),
                _capture_font_target(self.summary_box),
                _capture_font_target(self.summary_edit),
            ]
        )

        self._initialize_pane_visibility()
        self.apply_theme(self._palette)
        self.apply_font_scale(self._font_offset)

        self._load_existing()

    # ------------------------------------------------------------------
    def _load_existing(self) -> None:
        attachments = sorted(self.meta.paths.attachments_full.glob("*"))
        self.attachments_panel.refresh(attachments)
        if self.meta.paths.note_md.exists():
            try:
                raw = self.meta.paths.note_md.read_text(encoding="utf-8")
            except Exception:
                raw = ""
            lines = raw.splitlines()
            if lines and lines[0].lstrip().startswith("#"):
                lines = lines[1:]
                if lines and not lines[0].strip():
                    lines = lines[1:]
            text = "\n".join(lines)
            self.summary_edit.blockSignals(True)
            self.summary_edit.setPlainText(text)
            self.summary_edit.blockSignals(False)
        for row in self.manager.iter_messages(self.meta):
            role = row.get("role", "user")
            text = row.get("text", "")
            self.conversation.append_message(role, text)
        self._update_retrieval("")

    def apply_theme(self, palette: ThemePalette) -> None:
        self._palette = palette
        self._theme_name = palette.name
        base_style = (
            "QWidget {"
            f" background:{palette.window_bg};"
            f" color:{palette.window_fg};"
            " }"
            "QLabel {"
            f" color:{palette.window_fg};"
            " }"
            "QLineEdit, QPlainTextEdit, QTextEdit {"
            f" background:{palette.input_bg};"
            f" color:{palette.input_fg};"
            f" border:1px solid {palette.border};"
            " border-radius:6px; padding:4px; }"
            "QSplitter::handle {"
            f" background:{palette.border};"
            " }"
            "QGroupBox {"
            f" background:{palette.panel_bg};"
            f" color:{palette.panel_fg};"
            f" border:1px solid {palette.border};"
            " border-radius:8px; margin-top:12px; }"
            "QGroupBox::title { subcontrol-origin: margin; subcontrol-position: top left; padding:0 6px; }"
        )
        self.setStyleSheet(base_style)
        self.evidence.apply_theme(palette)
        self.conversation.apply_theme(palette)
        self.dataset_inspector.apply_theme(palette)
        self.attachments_panel.apply_theme(palette)

    def apply_font_scale(self, offset: float, *, persist: bool = False) -> None:
        self._font_offset = offset
        _apply_font_targets(self._font_targets, offset)
        self.evidence.apply_font_scale(offset)
        self.conversation.apply_font_scale(offset)
        self.dataset_inspector.apply_font_scale(offset)
        self.attachments_panel.apply_font_scale(offset)
        if persist:
            if self.meta.settings.get("font_point_adjust") != offset:
                self.meta.settings["font_point_adjust"] = offset
                self.manager.update_meta(self.meta)

    def update_theme(self, theme: str) -> None:
        self.apply_theme(ThemeHelper.palette(theme))

    def font_offset(self) -> float:
        return self._font_offset

    # ------------------------------------------------------------------
    def pane_visibility(self) -> Dict[str, bool]:
        return {name: widget.isVisible() for name, widget in self._pane_widgets.items()}

    # ------------------------------------------------------------------
    def apply_pane_visibility(self, panes: Dict[str, bool], *, persist: bool = True) -> None:
        for name, widget in self._pane_widgets.items():
            widget.setVisible(bool(panes.get(name, True)))
        self._apply_splitter_policy()
        if persist:
            self._persist_pane_settings()

    # ------------------------------------------------------------------
    def set_pane_visible(self, pane: str, visible: bool) -> None:
        widget = self._pane_widgets.get(pane)
        if widget is None:
            return
        current = widget.isVisible()
        if current == bool(visible):
            return
        widget.setVisible(bool(visible))
        self._apply_splitter_policy()
        self._persist_pane_settings()

    # ------------------------------------------------------------------
    def _initialize_pane_visibility(self) -> None:
        stored = self.meta.settings.get("pane_visibility")
        defaults = self._default_pane_states()
        stored_dict = stored if isinstance(stored, dict) else {}
        normalized = {name: bool(stored_dict.get(name, defaults[name])) for name in defaults}
        missing_defaults = not isinstance(stored, dict) or any(name not in stored_dict for name in defaults)
        non_bool_values = any(not isinstance(stored_dict.get(name), bool) for name in defaults if name in stored_dict)
        self.meta.settings["pane_visibility"] = dict(normalized)
        self.apply_pane_visibility(normalized, persist=False)
        if missing_defaults or non_bool_values:
            self.manager.update_meta(self.meta)

    # ------------------------------------------------------------------
    def _default_pane_states(self) -> Dict[str, bool]:
        return dict(DEFAULT_PANE_VISIBILITY)

    # ------------------------------------------------------------------
    def _apply_splitter_policy(self) -> None:
        right_visible = any(
            self._pane_widgets[name].isVisible() for name in ("dataset", "attachments")
        )
        self.right_container.setVisible(right_visible)
        total = sum(self.splitter.sizes())
        if not total:
            total = sum(self._default_split_sizes)
        if not right_visible:
            self.splitter.setSizes([total, 0])
            return
        sizes = self.splitter.sizes()
        if sizes[1] == 0:
            left = int(total * 0.65)
            right = total - left
            if right <= 0:
                right = max(int(total * 0.35), 1)
                left = total - right
            self.splitter.setSizes([left, right])

    # ------------------------------------------------------------------
    def _persist_pane_settings(self) -> None:
        states = self.pane_visibility()
        stored = self.meta.settings.get("pane_visibility")
        if not isinstance(stored, dict) or stored != states:
            self.meta.settings["pane_visibility"] = dict(states)
            self.manager.update_meta(self.meta)

    # ------------------------------------------------------------------
    def _handle_user_message(self, text: str) -> None:
        self.conversation.append_message("user", text)
        msg = Message(role="user", text=text, images=[], ts=timestamp())
        self.manager.append_message(self.meta, msg)
        self._update_retrieval(text)
        self.request_chat.emit(text)

    # ------------------------------------------------------------------
    def append_assistant_message(self, text: str) -> None:
        self.conversation.append_message("assistant", text)
        msg = Message(role="assistant", text=text, images=[], ts=timestamp())
        self.manager.append_message(self.meta, msg)
        self.summary_edit.setPlainText(text if not self.summary_edit.toPlainText() else self.summary_edit.toPlainText() + "\n" + text)
        self._update_retrieval(text)

    # ------------------------------------------------------------------
    def _handle_ocr(self, markdown: str) -> None:
        msg = Message(role="system", text=f"OCR:\n{markdown}", images=[], ts=timestamp())
        self.manager.append_message(self.meta, msg)
        self._update_retrieval(markdown)
        attachments = sorted(self.meta.paths.attachments_full.glob("*"))
        self.attachments_panel.refresh(attachments)

    # ------------------------------------------------------------------
    def _handle_vision(self, summary: str) -> None:
        if not summary:
            return
        msg = Message(role="system", text=f"Vision:\n{summary}", images=[], ts=timestamp())
        self.manager.append_message(self.meta, msg)
        self._update_retrieval(summary)

    # ------------------------------------------------------------------
    def _update_retrieval(self, query: str) -> None:
        query_vec = compute_embedding(query)
        rows: List[Tuple[float, Dict[str, Any]]] = []
        for row in self.manager.iter_messages(self.meta):
            vec = compute_embedding(row.get("text", ""))
            score = cosine_similarity(query_vec, vec)
            rows.append((score, row))
        rows.sort(key=lambda pair: pair[0], reverse=True)
        self.retrieval_cache = rows[:DATASET_TOP_K]
        self.dataset_inspector.update_entries(self.retrieval_cache)

    # ------------------------------------------------------------------
    def export_documents(self) -> None:
        self.export_requested.emit()

    # ------------------------------------------------------------------
    def _save_summary(self) -> None:
        text = self.summary_edit.toPlainText().rstrip()
        title = self.title_edit.text().strip() or "Untitled note"
        content = f"# {title}\n\n{text}\n" if text else f"# {title}\n"
        try:
            self.meta.paths.note_md.write_text(content, encoding="utf-8")
        except Exception:
            pass
        else:
            self.manager.update_meta(self.meta)

    # ------------------------------------------------------------------
    def _save_title(self) -> None:
        title = self.title_edit.text().strip() or "Untitled note"
        if title != self.meta.name:
            self.meta.name = title
            self.manager.update_meta(self.meta)
            self._save_summary()


# --------------------------------------------------------------------------------------
# Main widget
# --------------------------------------------------------------------------------------


class TopStrip(QWidget):
    provider_changed = Signal(str)
    model_changed = Signal(str)
    mic_changed = Signal(str)
    mic_toggled = Signal(bool)
    new_tab_requested = Signal()
    export_requested = Signal()
    pane_visibility_changed = Signal(str, bool)
    detach_requested = Signal(bool)
    theme_changed = Signal(str)
    font_scale_changed = Signal(float)

    def __init__(self, parent: Optional[QWidget] = None) -> None:
        super().__init__(parent)
        self.setObjectName("TopStrip")
        layout = QHBoxLayout(self)
        layout.setContentsMargins(10, 4, 10, 4)
        layout.setSpacing(8)

        self._font_targets: List[FontTarget] = []
        self._pane_buttons: Dict[str, QToolButton] = {}
        self._traffic_lights: List[QLabel] = []
        self._font_scale_labels: Dict[float, str] = {
            DEFAULT_FONT_POINT_ADJUST: "Default",
            COMPACT_FONT_POINT_ADJUST: "Compact (-2pt)",
        }
        self._font_scale_lookup: Dict[str, float] = {
            label: value for value, label in self._font_scale_labels.items()
        }

        traffic_container = QWidget(self)
        traffic_layout = QHBoxLayout(traffic_container)
        traffic_layout.setContentsMargins(0, 0, 0, 0)
        traffic_layout.setSpacing(4)
        for colour_key in ("traffic_red", "traffic_yellow", "traffic_green"):
            dot = QLabel(traffic_container)
            dot.setFixedSize(12, 12)
            traffic_layout.addWidget(dot)
            self._traffic_lights.append(dot)
        layout.addWidget(traffic_container)
        layout.addSpacing(8)

        self.provider_label = QLabel("Provider", self)
        self.provider_combo = QComboBox(self)
        self.provider_combo.addItems(["Ollama", "OpenAI"])
        self.provider_combo.currentTextChanged.connect(self.provider_changed.emit)
        layout.addWidget(self.provider_label)
        layout.addWidget(self.provider_combo)

        self.model_label = QLabel("Model", self)
        self.model_combo = QComboBox(self)
        self.model_combo.setEditable(True)
        self.model_combo.currentTextChanged.connect(self.model_changed.emit)
        layout.addWidget(self.model_label)
        layout.addWidget(self.model_combo, 1)

        self.mic_label = QLabel("Microphone", self)
        self.mic_combo = QComboBox(self)
        self.mic_combo.currentTextChanged.connect(self.mic_changed.emit)
        layout.addWidget(self.mic_label)
        layout.addWidget(self.mic_combo)

        self.refresh_mics_btn = QToolButton(self)
        self.refresh_mics_btn.setText("↻")
        self.refresh_mics_btn.setToolTip("Refresh available microphones")
        self.refresh_mics_btn.clicked.connect(self._populate_mics)
        layout.addWidget(self.refresh_mics_btn)

        self.mic_toggle = QToolButton(self)
        self.mic_toggle.setText("🎙")
        self.mic_toggle.setCheckable(True)
        self.mic_toggle.setToolTip("Toggle microphone (F9)")
        self.mic_toggle.clicked.connect(self.mic_toggled.emit)
        layout.addWidget(self.mic_toggle)

        self.theme_label = QLabel("Theme", self)
        self.theme_combo = QComboBox(self)
        self.theme_combo.addItems(["Dark", "Light"])
        self.theme_combo.currentTextChanged.connect(self._emit_theme_changed)
        layout.addWidget(self.theme_label)
        layout.addWidget(self.theme_combo)

        self.font_label = QLabel("Font", self)
        self.font_scale_combo = QComboBox(self)
        for label in self._font_scale_labels.values():
            self.font_scale_combo.addItem(label)
        self.font_scale_combo.currentTextChanged.connect(self._emit_font_scale_changed)
        layout.addWidget(self.font_label)
        layout.addWidget(self.font_scale_combo)

        self.new_tab_btn = QPushButton("New Tab", self)
        self.new_tab_btn.clicked.connect(self.new_tab_requested.emit)
        layout.addWidget(self.new_tab_btn)

        self.export_btn = QPushButton("Export", self)
        self.export_btn.clicked.connect(self.export_requested.emit)
        layout.addWidget(self.export_btn)

        self.detach_btn = QToolButton(self)
        self.detach_btn.setCheckable(True)
        self.detach_btn.setCursor(Qt.PointingHandCursor)
        self.detach_btn.setToolTip("Pop the notes out into a standalone window")
        self.detach_btn.setAccessibleName("Pop out User Guided Notes")
        self.detach_btn.setText("Pop Out")
        self.detach_btn.toggled.connect(self._on_detach_toggled)
        layout.addWidget(self.detach_btn)

        pane_layout = QHBoxLayout()
        pane_layout.setContentsMargins(0, 0, 0, 0)
        pane_layout.setSpacing(4)
        pane_specs = [
            ("evidence", "Evidence", "Show or hide the evidence panel"),
            ("conversation", "Conversation", "Show or hide the conversation log"),
            ("summary", "Summary", "Show or hide the summary editor"),
            ("dataset", "Dataset", "Show or hide the dataset inspector"),
            ("attachments", "Attachments", "Show or hide the attachments list"),
        ]
        for key, label, tip in pane_specs:
            btn = QToolButton(self)
            btn.setText(label)
            btn.setCheckable(True)
            btn.setChecked(True)
            btn.setCursor(Qt.PointingHandCursor)
            btn.setToolTip(tip)
            btn.setAccessibleName(f"Toggle {label} visibility")
            btn.toggled.connect(lambda checked, name=key: self.pane_visibility_changed.emit(name, checked))
            pane_layout.addWidget(btn)
            self._pane_buttons[key] = btn
        layout.addLayout(pane_layout)
        layout.addStretch(1)

        self.status_label = QLabel("Ready", self)
        layout.addWidget(self.status_label)

        self._populate_mics()

        self._font_targets.extend(
            [
                _capture_font_target(self.provider_label),
                _capture_font_target(self.provider_combo),
                _capture_font_target(self.model_label),
                _capture_font_target(self.model_combo),
                _capture_font_target(self.mic_label),
                _capture_font_target(self.mic_combo),
                _capture_font_target(self.refresh_mics_btn),
                _capture_font_target(self.mic_toggle),
                _capture_font_target(self.theme_label),
                _capture_font_target(self.theme_combo),
                _capture_font_target(self.font_label),
                _capture_font_target(self.font_scale_combo),
                _capture_font_target(self.new_tab_btn),
                _capture_font_target(self.export_btn),
                _capture_font_target(self.detach_btn),
                _capture_font_target(self.status_label),
            ]
        )

    def set_models(self, models: Sequence[str]) -> None:
        current = self.model_combo.currentText()
        self.model_combo.clear()
        for model in models:
            self.model_combo.addItem(model)
        if current:
            idx = self.model_combo.findText(current)
            if idx >= 0:
                self.model_combo.setCurrentIndex(idx)
        else:
            self.model_combo.setCurrentIndex(0)

    def _populate_mics(self) -> None:
        try:
            from PySide6.QtMultimedia import QMediaDevices  # type: ignore
        except Exception:
            QTimer.singleShot(0, lambda: self.status_label.setText("Audio unavailable"))
            return
        devices = QMediaDevices.audioInputs()
        self.mic_combo.clear()
        for dev in devices:
            self.mic_combo.addItem(dev.description())
        if not devices:
            self.mic_combo.addItem("No devices")

    def set_theme_name(self, theme: str) -> None:
        display = "Light" if theme.lower() == "light" else "Dark"
        blocker = QSignalBlocker(self.theme_combo)
        self.theme_combo.setCurrentText(display)

    def set_font_offset(self, offset: float) -> None:
        label = None
        for value, name in self._font_scale_labels.items():
            if abs(value - offset) <= 0.1:
                label = name
                break
        if label is None:
            label = self._font_scale_labels[DEFAULT_FONT_POINT_ADJUST]
        blocker = QSignalBlocker(self.font_scale_combo)
        self.font_scale_combo.setCurrentText(label)

    def apply_theme(self, palette: ThemePalette) -> None:
        combo_style = (
            "QComboBox {"
            f" background:{palette.input_bg};"
            f" color:{palette.input_fg};"
            f" border:1px solid {palette.border};"
            " border-radius:6px; padding:2px 6px; }"
            "QComboBox::drop-down { border: none; }"
            "QComboBox QAbstractItemView {"
            f" background:{palette.input_bg};"
            f" color:{palette.input_fg};"
            f" border:1px solid {palette.border};"
            " }"
        )
        self.setStyleSheet(
            f"#TopStrip {{ background:{palette.secondary_bg}; border-bottom:1px solid {palette.border}; }}"
            f"#TopStrip QLabel {{ color:{palette.window_fg}; }}"
            + combo_style
        )
        button_style = (
            "QPushButton {"
            f" background:{palette.accent};"
            f" color:{palette.accent_fg};"
            f" border:1px solid {palette.accent};"
            " border-radius:6px; padding:6px 12px; }"
            "QPushButton:hover {"
            f" background:{palette.accent_hover};"
            " }"
        )
        for btn in (self.new_tab_btn, self.export_btn):
            btn.setStyleSheet(button_style)
        tool_style = (
            "QToolButton {"
            f" background:{palette.muted_bg};"
            f" color:{palette.window_fg};"
            f" border:1px solid {palette.border};"
            " border-radius:6px; padding:4px 8px; }"
            "QToolButton:hover {"
            f" background:{palette.accent};"
            f" color:{palette.accent_fg};"
            " }"
            "QToolButton:checked {"
            f" background:{palette.accent};"
            f" color:{palette.accent_fg};"
            " }"
        )
        for widget in (self.refresh_mics_btn, self.mic_toggle, self.detach_btn):
            widget.setStyleSheet(tool_style)
        for btn in self._pane_buttons.values():
            btn.setStyleSheet(tool_style)
        self.status_label.setStyleSheet(f"color:{palette.status_fg};")
        colours = [palette.traffic_red, palette.traffic_yellow, palette.traffic_green]
        for dot, colour in zip(self._traffic_lights, colours):
            dot.setStyleSheet(
                f"background:{colour}; border-radius:6px; border:1px solid {palette.border};"
            )

    def apply_font_scale(self, offset: float) -> None:
        _apply_font_targets(self._font_targets, offset)

    def _emit_theme_changed(self, text: str) -> None:
        self.theme_changed.emit(text.lower())

    def _emit_font_scale_changed(self, text: str) -> None:
        value = self._font_scale_lookup.get(text, DEFAULT_FONT_POINT_ADJUST)
        self.font_scale_changed.emit(value)

    def apply_pane_states(self, states: Dict[str, bool]) -> None:
        for name, button in self._pane_buttons.items():
            desired = bool(states.get(name, True))
            if button.isChecked() != desired:
                blocker = QSignalBlocker(button)
                button.setChecked(desired)

    def _on_detach_toggled(self, detached: bool) -> None:
        self._apply_detach_label(detached)
        self.detach_requested.emit(detached)

    def _apply_detach_label(self, detached: bool) -> None:
        if detached:
            self.detach_btn.setText("Dock")
            self.detach_btn.setToolTip("Return the notes to the desktop card")
            self.detach_btn.setAccessibleName("Dock User Guided Notes")
        else:
            self.detach_btn.setText("Pop Out")
            self.detach_btn.setToolTip("Pop the notes out into a standalone window")
            self.detach_btn.setAccessibleName("Pop out User Guided Notes")

    def set_detach_state(self, detached: bool) -> None:
        if self.detach_btn.isChecked() == detached:
            self._apply_detach_label(detached)
            return
        blocker = QSignalBlocker(self.detach_btn)
        self.detach_btn.setChecked(detached)
        self._apply_detach_label(detached)


class UserGuidedNotesWidget(QWidget):
    request_detach = Signal(object)
    request_redock = Signal(object)

    def __init__(self, embedded: bool = True, parent: Optional[QWidget] = None) -> None:
        super().__init__(parent)
        self.embedded = embedded
        self.manager = NoteManager()
        raw_settings = load_json(SETTINGS_PATH, {})
        self.settings = raw_settings if isinstance(raw_settings, dict) else {}
        self.settings.setdefault("last_note_slug", None)
        self.settings.setdefault("theme", DEFAULT_THEME)
        self.settings.setdefault("font_point_adjust", DEFAULT_FONT_POINT_ADJUST)
        self._workers: List[ChatWorker] = []
        self._theme_name = str(self.settings.get("theme") or DEFAULT_THEME)
        try:
            self._font_offset = float(self.settings.get("font_point_adjust", DEFAULT_FONT_POINT_ADJUST))
        except (TypeError, ValueError):
            self._font_offset = DEFAULT_FONT_POINT_ADJUST
        self.setWindowTitle("User Guided Notes")
        self.setMinimumSize(520, 360)
        self.tabs = QTabWidget(self)
        self.tabs.setTabsClosable(True)
        self.tabs.tabCloseRequested.connect(self._close_tab)
        self.tabs.setMovable(True)
        self.tabs.tabBarDoubleClicked.connect(self._rename_tab)

        root = QVBoxLayout(self)
        root.setContentsMargins(0, 0, 0, 0)
        root.setSpacing(0)

        self.menu_bar = QMenuBar(self)
        root.addWidget(self.menu_bar)
        self._build_menus()

        self.top_strip = TopStrip(self)
        root.addWidget(self.top_strip)

        root.addWidget(self.tabs, 1)

        self.top_strip.set_detach_state(not self.embedded)
        self.top_strip.provider_changed.connect(self._handle_provider_change)
        self.top_strip.new_tab_requested.connect(self._create_note_tab)
        self.top_strip.export_requested.connect(self._export_active_note)
        self.top_strip.pane_visibility_changed.connect(self._handle_pane_visibility_change)
        self.top_strip.detach_requested.connect(self._handle_detach_toggle)
        self.top_strip.theme_changed.connect(self._handle_theme_change)
        self.top_strip.font_scale_changed.connect(self._handle_font_scale_change)
        self.tabs.currentChanged.connect(self._handle_tab_changed)

        self.models = discover_ollama_models()
        self.top_strip.set_models(self.models)

        palette = ThemeHelper.palette(self._theme_name)
        self.top_strip.apply_theme(palette)
        self.top_strip.set_theme_name(self._theme_name)
        self.top_strip.set_font_offset(self._font_offset)
        self.top_strip.apply_font_scale(self._font_offset)

        self._initialize_tabs()

    # ------------------------------------------------------------------
    def apply_embedded_state(self, embedded: bool) -> None:
        if self.embedded == embedded:
            self.top_strip.set_detach_state(not embedded)
            return
        self.embedded = embedded
        self.top_strip.set_detach_state(not embedded)

    # ------------------------------------------------------------------
    def _handle_detach_toggle(self, detached: bool) -> None:
        if detached:
            if self.embedded:
                self.request_detach.emit(self)
            else:
                self.top_strip.set_detach_state(True)
        else:
            if not self.embedded:
                self.request_redock.emit(self)
            else:
                self.top_strip.set_detach_state(False)

    # ------------------------------------------------------------------
    def _handle_theme_change(self, theme: str) -> None:
        normalized = theme.lower()
        if normalized not in ThemeHelper.available():
            normalized = DEFAULT_THEME
        if normalized == self._theme_name:
            self.top_strip.set_theme_name(normalized)
            return
        self._theme_name = normalized
        self.settings["theme"] = normalized
        self._save_settings()
        palette = ThemeHelper.palette(normalized)
        self.top_strip.apply_theme(palette)
        self.top_strip.set_theme_name(normalized)
        self.top_strip.apply_font_scale(self._font_offset)
        for idx in range(self.tabs.count()):
            widget = self.tabs.widget(idx)
            if isinstance(widget, NoteTab):
                widget.update_theme(normalized)

    # ------------------------------------------------------------------
    def _handle_font_scale_change(self, offset: float) -> None:
        try:
            normalized = float(offset)
        except (TypeError, ValueError):
            normalized = DEFAULT_FONT_POINT_ADJUST
        if abs(self._font_offset - normalized) <= 1e-6:
            return
        self._font_offset = normalized
        self.settings["font_point_adjust"] = normalized
        self._save_settings()
        self.top_strip.set_font_offset(normalized)
        self.top_strip.apply_font_scale(normalized)
        for idx in range(self.tabs.count()):
            widget = self.tabs.widget(idx)
            if isinstance(widget, NoteTab):
                widget.apply_font_scale(normalized, persist=True)

    # ------------------------------------------------------------------
    def _build_menus(self) -> None:
        file_menu = self.menu_bar.addMenu("File")
        new_action = QAction("New Note", self)
        new_action.setShortcut(QKeySequence.New)
        new_action.triggered.connect(self._create_note_tab)
        file_menu.addAction(new_action)

        export_action = QAction("Export", self)
        export_action.triggered.connect(self._export_active_note)
        file_menu.addAction(export_action)

        open_root = QAction("Open Notes Folder", self)
        open_root.triggered.connect(
            lambda: QDesktopServices.openUrl(QUrl.fromLocalFile(str(NOTES_ROOT)))
        )
        file_menu.addAction(open_root)

        settings_menu = self.menu_bar.addMenu("Settings")
        refresh_models = QAction("Refresh Models", self)
        refresh_models.triggered.connect(self._refresh_models)
        settings_menu.addAction(refresh_models)

    # ------------------------------------------------------------------
    def _refresh_models(self) -> None:
        self.models = discover_ollama_models()
        self.top_strip.set_models(self.models)

    # ------------------------------------------------------------------
    def _handle_pane_visibility_change(self, pane: str, visible: bool) -> None:
        widget = self.tabs.currentWidget()
        if isinstance(widget, NoteTab):
            widget.set_pane_visible(pane, visible)
            self._sync_top_strip_with_tab(widget)

    # ------------------------------------------------------------------
    def _handle_tab_changed(self, index: int) -> None:
        widget = self.tabs.widget(index)
        if isinstance(widget, NoteTab):
            self._sync_top_strip_with_tab(widget)
            self._remember_last_note(widget.meta)
        else:
            self.top_strip.apply_pane_states(DEFAULT_PANE_VISIBILITY)
            self.top_strip.set_font_offset(self._font_offset)
            self.top_strip.set_theme_name(self._theme_name)
            self.top_strip.apply_font_scale(self._font_offset)

    # ------------------------------------------------------------------
    def _sync_top_strip_with_tab(self, tab: NoteTab) -> None:
        self._font_offset = tab.font_offset()
        self.top_strip.apply_pane_states(tab.pane_visibility())
        self.top_strip.set_font_offset(self._font_offset)
        self.top_strip.apply_font_scale(self._font_offset)
        self.top_strip.set_theme_name(self._theme_name)

    # ------------------------------------------------------------------
    def _initialize_tabs(self) -> None:
        notes = self.manager.list_notes()
        target: Optional[NoteMeta] = None
        last_slug = self.settings.get("last_note_slug")
        if isinstance(last_slug, str) and last_slug:
            for note in notes:
                if note.slug == last_slug:
                    target = note
                    break
        if target is None and notes:
            target = notes[0]
        if target is not None:
            self._open_note_tab(target)
        else:
            self._create_note_tab()

    # ------------------------------------------------------------------
    def _save_settings(self) -> None:
        save_json(SETTINGS_PATH, self.settings)

    # ------------------------------------------------------------------
    def _remember_last_note(self, meta: NoteMeta) -> None:
        slug = meta.slug
        if not slug:
            return
        if self.settings.get("last_note_slug") == slug:
            return
        self.settings["last_note_slug"] = slug
        self._save_settings()

    # ------------------------------------------------------------------
    def _open_note_tab(self, meta: NoteMeta, *, make_current: bool = True) -> NoteTab:
        offset_raw = meta.settings.get("font_point_adjust")
        try:
            note_offset = float(offset_raw)
        except (TypeError, ValueError):
            note_offset = self._font_offset
        tab = NoteTab(self.manager, meta, self._theme_name, note_offset, self)
        tab.request_chat.connect(lambda text, t=tab: self._invoke_chat(t, text))
        tab.export_requested.connect(lambda t=tab: self._export_note(t))
        idx = self.tabs.addTab(tab, meta.name)
        if make_current:
            self.tabs.setCurrentIndex(idx)
            self._sync_top_strip_with_tab(tab)
            self._remember_last_note(meta)
        return tab

    # ------------------------------------------------------------------
    def _select_existing_note(self, exclude_slug: Optional[str]) -> Optional[NoteMeta]:
        notes = self.manager.list_notes()
        if not notes:
            return None
        if exclude_slug:
            for note in notes:
                if note.slug != exclude_slug:
                    return note
        return notes[0]

    # ------------------------------------------------------------------
    def _update_last_note_setting(self) -> None:
        widget = self.tabs.currentWidget()
        if isinstance(widget, NoteTab):
            self._remember_last_note(widget.meta)

    # ------------------------------------------------------------------
    def _create_note_tab(self) -> None:
        name, ok = self._prompt("New note", "Enter note title:")
        if not ok and self.tabs.count() > 0:
            return
        meta = self.manager.create_note(name or "Untitled note")
        if meta.settings.get("font_point_adjust") != self._font_offset:
            meta.settings["font_point_adjust"] = self._font_offset
            self.manager.update_meta(meta)
        self._open_note_tab(meta)

    # ------------------------------------------------------------------
    def _prompt(self, title: str, text: str) -> Tuple[str, bool]:
        dialog = QInputDialog(self)
        dialog.setWindowTitle(title)
        dialog.setLabelText(text)
        dialog.setTextValue("Untitled note")
        dialog.resize(380, 120)
        ok = dialog.exec() == QDialog.Accepted
        return dialog.textValue(), ok

    # ------------------------------------------------------------------
    def _invoke_chat(self, tab: NoteTab, text: str) -> None:
        provider = self.top_strip.provider_combo.currentText()
        model = self.top_strip.model_combo.currentText() or DEFAULT_MODEL
        system_prompt = self._build_system_prompt(tab)
        messages = [{"role": "system", "content": system_prompt}]
        for row in tab.retrieval_cache:
            entry = row[1]
            if entry.get("role") == "assistant":
                messages.append({"role": "assistant", "content": entry.get("text", "")})
            else:
                messages.append({"role": "user", "content": entry.get("text", "")})
        messages.append({"role": "user", "content": text})

        worker = ChatWorker(provider, model, messages)

        def _cleanup(worker_ref: ChatWorker) -> None:
            try:
                self._workers.remove(worker_ref)
            except ValueError:
                pass

        def _finished(reply: str, *, worker_ref: ChatWorker = worker, target: NoteTab = tab) -> None:
            _cleanup(worker_ref)
            target.append_assistant_message(reply)

        def _failed(err: str, *, worker_ref: ChatWorker = worker, target: NoteTab = tab) -> None:
            _cleanup(worker_ref)
            target.append_assistant_message(f"(LLM error: {err})")

        worker.finished.connect(_finished)
        worker.failed.connect(_failed)
        self._workers.append(worker)
        worker.start()

    # ------------------------------------------------------------------
    def _build_system_prompt(self, tab: NoteTab) -> str:
        return (
            "You are a senior editor-engineer. Convert each user problem into precise implementation "
            "corrections. Provide actionable bullet points."
        )

    # ------------------------------------------------------------------
    def _export_active_note(self) -> None:
        widget = self.tabs.currentWidget()
        if isinstance(widget, NoteTab):
            self._export_note(widget)

    # ------------------------------------------------------------------
    def _export_note(self, tab: NoteTab) -> None:
        narrative = tab.summary_edit.toPlainText().strip()
        convo_lines = []
        for row in self.manager.iter_messages(tab.meta):
            role = row.get("role", "user")
            text = row.get("text", "")
            convo_lines.append(f"### {role}\n\n{text}\n")
        context_doc = "\n".join(convo_lines)
        impl_plan = [
            "# Implementation Tasklist",
            "",
            f"Generated: {timestamp()}",
            "",
            "## Summary",
            narrative or "(No summary)",
        ]
        task_path = tab.meta.paths.exports_dir / "Implementation_Tasklist.md"
        task_path.write_text("\n".join(impl_plan), encoding="utf-8")

        context_path = tab.meta.paths.exports_dir / "Note_Context.md"
        context_doc = "# Note Context\n\n" + context_doc
        context_path.write_text(context_doc, encoding="utf-8")
        QMessageBox.information(self, "Export complete", f"Exports saved to {tab.meta.paths.exports_dir}")

    # ------------------------------------------------------------------
    def _rename_tab(self, index: int) -> None:
        if index < 0:
            return
        widget = self.tabs.widget(index)
        if not isinstance(widget, NoteTab):
            return
        title, ok = self._prompt("Rename note", "New title:")
        if ok and title:
            widget.meta.name = title
            widget.manager.update_meta(widget.meta)
            self.tabs.setTabText(index, title)

    # ------------------------------------------------------------------
    def _close_tab(self, index: int) -> None:
        widget = self.tabs.widget(index)
        if widget is None:
            return
        closed_slug = widget.meta.slug if isinstance(widget, NoteTab) else None
        widget.deleteLater()
        self.tabs.removeTab(index)
        if self.tabs.count() == 0:
            fallback = self._select_existing_note(closed_slug)
            if fallback is not None:
                self._open_note_tab(fallback)
            else:
                self._create_note_tab()
        else:
            self._update_last_note_setting()

    # ------------------------------------------------------------------
    def _handle_provider_change(self, provider: str) -> None:
        if provider.lower() == "ollama":
            self._refresh_models()
        else:
            # Provide OpenAI defaults
            self.top_strip.set_models(["gpt-4o-mini", "gpt-4.1"])


class UserGuidedNotesWindow(QMainWindow):
    def __init__(self, widget: Optional[UserGuidedNotesWidget] = None) -> None:
        super().__init__()
        if widget is None:
            widget = UserGuidedNotesWidget(embedded=False)
        else:
            widget.apply_embedded_state(False)
        self.widget = widget
        self.setCentralWidget(self.widget)
        self.setWindowTitle("User Guided Notes")
        self.setFont(self.widget.font())
        self.resize(1100, 700)


# --------------------------------------------------------------------------------------
# Factory / entry points
# --------------------------------------------------------------------------------------


def create_card(parent: Optional[QWidget] = None, embedded: bool = True):
    widget = UserGuidedNotesWidget(embedded=embedded, parent=parent)
    meta = {
        "title": "User Guided Notes",
        "persist_tag": "user_guided_notes",
        "task_profile": "notes",
        "task_tooltip": "User Guided Notes",
    }
    return widget, meta


def build_widget(parent: Optional[QWidget] = None, embedded: bool = True):
    return create_card(parent=parent, embedded=embedded)


def main() -> None:
    app = QApplication.instance()
    owns_app = False
    if app is None:
        app = QApplication(sys.argv)
        owns_app = True
    window = UserGuidedNotesWindow()
    window.show()
    if owns_app:
        sys.exit(app.exec())


if __name__ == "__main__":
    main()
```

User Guided Notes card for Codex Virtual Desktop.

This module provides a high-level implementation of the User Guided Notes
card described in the specification that accompanies the Virtual Desktop.
It focuses on providing a structured, high-contrast interface for capturing
conversations, evidence, and exports while remaining self-contained so it
can run even when optional subsystems (Ollama, OCR, etc.) are unavailable.

The implementation intentionally leans on defensive fallbacks so the widget
can be instantiated both as an embedded Virtual Desktop card and as a
standalone window.
**Classes:** ThemePalette, FontTarget, ThemeHelper, NotePaths, NoteMeta, Message, NoteManager, ChatWorker, DatasetInspector, AttachmentsPanel, DragHandle, SnippingOverlay, EvidencePanel, ConversationWidget, NoteTab, TopStrip, UserGuidedNotesWidget, UserGuidedNotesWindow
**Functions:** _capture_font_target(widget), _apply_font_targets(targets, offset), timestamp(), slugify(text), load_json(path, default), save_json(path, data), _hash_bytes(text), compute_embedding(text), cosine_similarity(a, b), discover_ollama_models(), create_card(parent, embedded), build_widget(parent, embedded), main()


## Module `Virtual_Desktop.py`

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Virtual_Desktop.py — Windows-style virtual desktop (contained), with Start panel and card window controls.

Directives satisfied:
- All former top toolbar actions moved into Start panel and Settings; no floating top bar.
- Start menu is a docked panel that rises from the taskbar and stays attached to the bottom.
- Window has standard minimize, maximize, close in the top-right (Qt title bar). Starts maximized with border.
- Each Card has its own Minimize, Max/Restore, Close buttons. Minimize hides to taskbar, restore via task button.
- Desktop edge trim removed. Background is clean blue gradient. High contrast enforced for text vs background.
- No drag-out to OS. No file URL clipboard exports. All dialogs non-native and modal to keep containment.
- Explorer and desktop icons support rename with extensions. Type/extension changes reflect immediately.
- Visual refreshes are immediate after file ops. QFileSystemWatcher also keeps UI current.
- Codex_Terminal.py can be launched from Start ▸ Apps ▸ Codex Terminal as an embedded card (factory supports embedded=True).  # See note re: citation in chat.

Notes:
- Contrast rule: inline comments and palettes ensure readable foreground/background in all states.
- Start panel includes: Apps (Explorer, Codex Terminal, Template Terminal), Recent, Settings, Power menu, Search.
- Settings panel collects previous toolbar utilities and view toggles.
"""

from __future__ import annotations

import os, sys, json, time, math, threading, subprocess, importlib.util, argparse, logging, traceback, ctypes, shutil, inspect, socket, difflib, zipfile, base64, binascii, weakref
from dataclasses import dataclass
from datetime import datetime, timezone
from typing import Optional, List, Dict, Tuple, Callable, TYPE_CHECKING, Union, Sequence, Mapping, Iterable, Any, cast
from pathlib import Path

from PySide6.QtCore import (
    Qt, QPoint, QRect, QRectF, QSize, QEvent, QTimer, Signal, Slot, QUrl, QMimeData,
    QFileSystemWatcher, QDateTime, QDir, QFileInfo, QBuffer, QIODevice, QObject
)
try:  # Optional pointer helper (missing in some PySide6 builds)
    from PySide6.QtCore import QPointer as _QtQPointer  # type: ignore
except ImportError:  # pragma: no cover - fallback path when QPointer absent
    _QtQPointer = None  # type: ignore
from PySide6.QtGui import (
    QColor, QGuiApplication, QPainter, QPainterPath, QLinearGradient, QPalette,
    QAction, QKeySequence, QClipboard, QCursor, QIcon, QPixmap, QFont, QResizeEvent,
    QWindowStateChangeEvent, QDrag, QMouseEvent, QFontMetrics,
)
from PySide6.QtWidgets import (
    QApplication, QMainWindow, QWidget, QScrollArea, QFrame, QLabel, QVBoxLayout,
    QHBoxLayout, QBoxLayout, QSizeGrip, QPushButton, QGraphicsDropShadowEffect, QMenuBar,
    QFileDialog, QPlainTextEdit, QMenu, QListWidget, QListWidgetItem, QStyle, QToolButton,
    QMessageBox, QInputDialog, QLineEdit, QDialog, QSplitter, QTextBrowser, QComboBox, QCheckBox,
    QGridLayout, QSizePolicy, QLayout, QTableWidget, QTableWidgetItem, QHeaderView,
    QDoubleSpinBox, QSpinBox, QFileIconProvider
)

try:
    import shiboken6  # type: ignore
except Exception:  # pragma: no cover - shiboken may be unavailable in some environments
    shiboken6 = None  # type: ignore

try:  # Optional Windows helpers for native icon conversion
    from PySide6.QtWinExtras import QtWin  # type: ignore
except Exception:  # pragma: no cover - QtWinExtras may be unavailable on non-Windows builds
    QtWin = None  # type: ignore

try:  # Optional plotting dependency
    import pyqtgraph as pg  # type: ignore
    from pyqtgraph import BarGraphItem
    from pyqtgraph.graphicsItems.DateAxisItem import DateAxisItem
except Exception:  # pragma: no cover - optional dependency may be unavailable
    pg = None
    BarGraphItem = None
    DateAxisItem = None

from error_center import ErrorCenterCard
from errors import ProcessErrorCard
from background import (
    BackgroundConfig,
    BackgroundFit,
    BackgroundManager,
    BackgroundMode,
    GifBg,
    GLViewportBg,
    StaticImageBg,
    VideoBg,
)
from metrics_manager import fetch_metrics
from tools.system_metrics import collect_metrics
from external_app_card import (
    ExternalAppCard,
    LaunchSpec,
    build_launch_spec,
    should_embed_external_app,
)

try:  # Optional User-Guided Notes card factory
    import User_Guided_Notes as _user_guided_notes_module  # type: ignore
except Exception:  # pragma: no cover - optional dependency
    _user_guided_notes_module = None
    _USER_GUIDED_NOTES_FACTORY = None
    _USER_GUIDED_NOTES_WINDOW_CLASS = None
    _USER_GUIDED_NOTES_WIDGET_CLASS = None
else:
    _USER_GUIDED_NOTES_FACTORY = getattr(_user_guided_notes_module, "build_widget", None)
    if not callable(_USER_GUIDED_NOTES_FACTORY):
        _USER_GUIDED_NOTES_FACTORY = getattr(_user_guided_notes_module, "create_card", None)
    if not callable(_USER_GUIDED_NOTES_FACTORY):
        _USER_GUIDED_NOTES_FACTORY = None
    _USER_GUIDED_NOTES_WINDOW_CLASS = getattr(_user_guided_notes_module, "UserGuidedNotesWindow", None)
    _USER_GUIDED_NOTES_WIDGET_CLASS = getattr(_user_guided_notes_module, "UserGuidedNotesWidget", None)

try:  # Optional task bus (absent when tasks module unavailable)
    from tasks.bus import subscribe as bus_subscribe, Subscription as BusSubscription  # type: ignore
except Exception:  # pragma: no cover - optional dependency
    bus_subscribe = None
    BusSubscription = None  # type: ignore

# --------------------------------------------------------------------------------------
# Paths, logging & state
# --------------------------------------------------------------------------------------
SCRIPT_DIR = os.path.abspath(os.path.dirname(__file__))
STATE_PATH = os.path.join(SCRIPT_DIR, "vd_state.json")
LOG_PATH = os.path.join(SCRIPT_DIR, "vd_system.log")
WORKSPACE_ROOT = os.environ.get("CODEX_WORKSPACE")
VDSK_ROOT = WORKSPACE_ROOT or os.path.join(SCRIPT_DIR, "Virtual_Desktop")
os.makedirs(VDSK_ROOT, exist_ok=True)

def workspace_root() -> str:
    return VDSK_ROOT

def _is_contained(path: str) -> bool:
    root = Path(VDSK_ROOT).resolve()
    try:
        resolved = Path(path).resolve()
    except Exception:
        return False
    return resolved == root or root in resolved.parents

def _safe_resolve(path_str: Optional[str]) -> Optional[str]:
    if not path_str:
        return None
    cleaned = path_str.strip().strip('"')
    if not cleaned:
        return None
    try:
        path = Path(cleaned).expanduser()
        if not path.exists():
            return None
        return str(path.resolve())
    except Exception:
        return None

def _build_allowlist() -> set[str]:
    entries: set[str] = set()
    for candidate in (
        sys.executable,
        os.environ.get("COMSPEC"),
        os.environ.get("SHELL"),
        shutil.which("python"),
        shutil.which("python3"),
        shutil.which("cmd"),
        shutil.which("cmd.exe"),
        shutil.which("powershell"),
        shutil.which("powershell.exe"),
        shutil.which("pwsh"),
        shutil.which("bash"),
        shutil.which("sh"),
    ):
        resolved = _safe_resolve(candidate)
        if resolved:
            entries.add(resolved)
    return entries

ALLOWLIST: set[str] = _build_allowlist()

BASE_CARD_WIDTH = 1100
BASE_CARD_HEIGHT = 700
MIN_CARD_WIDTH = 520
MIN_CARD_HEIGHT = 360
CARD_SCALE_MIN = 0.6
CARD_SCALE_MAX = 1.6


def _make_card_pointer(card: "Card") -> Callable[[], Optional["Card"]]:
    """Return a callable that resolves the card while guarding against GC."""
    if _QtQPointer is not None:
        pointer = _QtQPointer(card)

        def _resolve() -> Optional["Card"]:
            try:
                return cast(Optional["Card"], pointer.data())
            except Exception:
                return None

        return _resolve

    ref = weakref.ref(card)

    def _resolve() -> Optional["Card"]:
        try:
            return cast(Optional["Card"], ref())
        except Exception:
            return None

    return _resolve


def _is_card_valid(card: Optional["Card"]) -> bool:
    if card is None:
        return False
    if shiboken6 is None:  # pragma: no cover - shiboken unavailable
        return True
    try:
        return bool(shiboken6.isValid(card))
    except Exception:  # pragma: no cover - defensive fallback
        return False


def _make_guarded_card_method(
    card: "Card",
    method: Union[str, Callable[["Card"], Any]],
    *args: object,
    **kwargs: object,
) -> Callable[[], bool]:
    """Create a callable that safely invokes ``method`` on ``card``.

    The returned function resolves the card via :func:`_make_card_pointer` to
    avoid holding a strong reference. It then checks the pointer with
    :func:`_is_card_valid` (which in turn uses ``shiboken6.isValid`` when
    available) before invoking the requested method. The callable returns
    ``True`` when the method was executed, ``False`` otherwise.
    """

    resolve_card = _make_card_pointer(card)
    method_name: Optional[str]
    method_ref: Optional[Callable[["Card"], Any]]
    if isinstance(method, str):
        method_name = method
        method_ref = None
    else:
        method_name = None
        method_ref = method

    def _invoke() -> bool:
        target = resolve_card()
        if target is None:
            return False
        card_obj = cast("Card", target)
        if not _is_card_valid(card_obj):
            return False
        try:
            if method_name is not None:
                bound = getattr(card_obj, method_name, None)
                if not callable(bound):
                    return False
                bound(*args, **kwargs)
            else:
                assert method_ref is not None
                method_ref(card_obj, *args, **kwargs)
        except (RuntimeError, ReferenceError):  # pragma: no cover - Qt GC race
            return False
        return True

    return _invoke

START_PANEL_AUTO_DELAY_MIN_MS = 500
START_PANEL_AUTO_DELAY_MAX_MS = 15000
DEFAULT_START_PANEL_AUTO_DELAY_MS = 2000
START_PANEL_CLOSE_DEFAULT = {
    "mode": "click",
    "auto_delay_ms": DEFAULT_START_PANEL_AUTO_DELAY_MS,
}

# Desktop icon grid offsets (align manual drags with auto arrange)
GRID_ORIGIN_X = 30
GRID_ORIGIN_Y = 40

_FILE_ICON_PROVIDER: Optional["QFileIconProvider"]
try:
    _FILE_ICON_PROVIDER = QFileIconProvider()
except Exception:  # pragma: no cover - provider may be unavailable in headless environments
    _FILE_ICON_PROVIDER = None

_ICON_DRAG_MIME = "application/x-codex-virtual-desktop-icon"
_ICON_OFFSET_MIME = "application/x-codex-virtual-desktop-icon-offset"

if sys.platform.startswith("win"):
    from ctypes import wintypes  # type: ignore

    class _SHFILEINFOW(ctypes.Structure):  # pragma: no cover - Windows specific helper
        _fields_ = [
            ("hIcon", wintypes.HICON),
            ("iIcon", ctypes.c_int),
            ("dwAttributes", wintypes.DWORD),
            ("szDisplayName", ctypes.c_wchar * 260),
            ("szTypeName", ctypes.c_wchar * 80),
        ]

    _SHGFI_ICON = 0x000000100
    _SHGFI_LARGEICON = 0x000000000
    _SHGFI_SMALLICON = 0x000000001

    def _try_shell_icon(path: Path, large: bool = True) -> Optional[QIcon]:
        if QtWin is None:
            return None
        info = _SHFILEINFOW()
        flags = _SHGFI_ICON | (_SHGFI_LARGEICON if large else _SHGFI_SMALLICON)
        try:
            result = ctypes.windll.shell32.SHGetFileInfoW(  # type: ignore[attr-defined]
                str(path),
                0,
                ctypes.byref(info),
                ctypes.sizeof(info),
                flags,
            )
        except Exception:
            return None
        if not result or not info.hIcon:
            return None
        try:
            pixmap = QtWin.fromHICON(info.hIcon)  # type: ignore[attr-defined]
            if pixmap and not pixmap.isNull():
                return QIcon(pixmap)
        finally:
            try:
                ctypes.windll.user32.DestroyIcon(info.hIcon)  # type: ignore[attr-defined]
            except Exception:
                pass
        return None
else:

    def _try_shell_icon(path: Path, large: bool = True) -> Optional[QIcon]:  # pragma: no cover - non-Windows stub
        return None


def _try_provider_icon(path: Path) -> Optional[QIcon]:
    provider = _FILE_ICON_PROVIDER
    if not provider:
        return None
    try:
        info = QFileInfo(str(path))
        icon = provider.icon(info)
    except Exception:
        return None
    if icon and not icon.isNull():
        return icon
    return None


def _fallback_icon_for_path(path: Path) -> QIcon:
    style = QApplication.style()
    if path.exists() and path.is_dir():
        return style.standardIcon(QStyle.SP_DirIcon)
    ext = path.suffix.lower()
    if ext in {".txt", ".md", ".log", ".ini", ".cfg", ".json"}:
        return QIcon.fromTheme("text-x-generic") or style.standardIcon(QStyle.SP_FileIcon)
    if ext in {".png", ".jpg", ".jpeg", ".gif", ".bmp"}:
        return QIcon.fromTheme("image-x-generic") or style.standardIcon(QStyle.SP_FileIcon)
    if ext == ".py":
        return QIcon.fromTheme("text-x-python") or style.standardIcon(QStyle.SP_FileIcon)
    return style.standardIcon(QStyle.SP_FileIcon)


def _icon_for_path(path_like: os.PathLike[str] | str) -> Tuple[QIcon, bool]:
    path = Path(path_like)
    native = False
    icon: Optional[QIcon] = None
    if path.exists():
        icon = _try_provider_icon(path)
        if icon and not icon.isNull():
            native = True
        else:
            shell_icon = _try_shell_icon(path)
            if shell_icon and not shell_icon.isNull():
                icon = shell_icon
                native = True
    if not icon or icon.isNull():
        icon = _fallback_icon_for_path(path)
        native = False
    return icon, native


_ICON_FOR_PATH_HELPER = _icon_for_path


def _clear_native_icon_caches() -> None:
    global _FILE_ICON_PROVIDER
    try:
        provider_type = QFileIconProvider
    except NameError:
        return
    if provider_type is None:
        return
    try:
        _FILE_ICON_PROVIDER = provider_type()
    except Exception:
        _FILE_ICON_PROVIDER = None

def _resolve_executable_path(cmd: List[str], cwd: Optional[str]) -> Optional[str]:
    if not cmd:
        return None
    first = cmd[0]
    resolved = _safe_resolve(first) if os.path.isabs(first) else None
    if resolved:
        return resolved
    search_path = None
    if cwd:
        try:
            candidate = Path(cwd).joinpath(first)
            candidate_resolved = candidate.resolve()
            if candidate_resolved.exists():
                return str(candidate_resolved)
        except Exception:
            pass
        try:
            resolved_cwd = Path(cwd).resolve()
            if resolved_cwd.exists():
                search_path = str(resolved_cwd)
        except Exception:
            search_path = None
    if search_path:
        located = shutil.which(first, path=search_path)
        if located:
            resolved = _safe_resolve(located)
            if resolved:
                return resolved
    located = shutil.which(first)
    if located:
        resolved = _safe_resolve(located)
        if resolved:
            return resolved
    return None

def _validate_process_request(
    cmd: List[str],
    cwd: Optional[str],
    allow_external: bool = False,
) -> Tuple[bool, str]:
    if not cmd:
        return False, "Blocked: no command specified."
    resolved_cwd = os.path.abspath(cwd or VDSK_ROOT)
    if not os.path.isdir(resolved_cwd):
        return False, f"Blocked: working directory does not exist ({resolved_cwd})."
    if not _is_contained(resolved_cwd):
        return False, "Blocked: working directory is outside the Virtual Desktop workspace."
    exec_path = _resolve_executable_path(cmd, resolved_cwd)
    if not exec_path:
        return False, "Blocked: executable could not be resolved inside the workspace."
    if _is_contained(exec_path) or exec_path in ALLOWLIST:
        return True, exec_path
    if allow_external:
        return True, exec_path
    name = os.path.basename(exec_path) or exec_path
    return False, f"Blocked: {name} is outside the Virtual Desktop workspace."
    return True, exec_path

LOGGER = logging.getLogger("VirtualDesktop")
LOGGER.setLevel(logging.INFO)
if LOGGER.handlers:
    LOGGER.handlers.clear()
_fh = logging.FileHandler(LOG_PATH, mode="w", encoding="utf-8")
_fh.setFormatter(logging.Formatter("%(asctime)s [%(levelname)s] %(message)s"))
LOGGER.addHandler(_fh)

def log(msg: str, level=logging.INFO):
    LOGGER.log(level, msg)


def _encode_icon(icon: Optional[QIcon], size: QSize = QSize(32, 32)) -> Optional[str]:
    if icon is None or icon.isNull():
        return None
    try:
        pixmap = icon.pixmap(size)
    except Exception:
        return None
    if pixmap.isNull():
        return None
    buffer = QBuffer()
    if not buffer.open(QIODevice.WriteOnly):
        return None
    try:
        if not pixmap.save(buffer, "PNG"):
            return None
        data = bytes(buffer.data())
    finally:
        buffer.close()
    if not data:
        return None
    return base64.b64encode(data).decode("ascii")


def _decode_icon(data: Optional[str]) -> Optional[QIcon]:
    if not data:
        return None
    try:
        raw = base64.b64decode(data)
    except (ValueError, binascii.Error):
        return None
    pixmap = QPixmap()
    if not pixmap.loadFromData(raw, "PNG"):
        return None
    return QIcon(pixmap)


def _icon_for_profile(profile: str) -> QIcon:
    style = QApplication.style()
    mapping = {
        "explorer": QStyle.SP_DirIcon,
        "tasks": QStyle.SP_FileDialogListView,
        "operator-manager": QStyle.SP_DesktopIcon,
        "codex-terminal": QStyle.SP_DesktopIcon,
        "template-terminal": QStyle.SP_ComputerIcon,
        "terminal": QStyle.SP_ComputerIcon,
        "text-viewer": QStyle.SP_FileIcon,
        "image-viewer": QStyle.SP_FileDialogContentsView,
        "error-center": QStyle.SP_MessageBoxCritical,
        "system-overview": QStyle.SP_DesktopIcon,
        "notes": QStyle.SP_FileDialogDetailedView,
        "settings": QStyle.SP_FileDialogDetailedView,
    }
    enum = mapping.get(profile, QStyle.SP_FileIcon)
    return style.standardIcon(enum)

def _load_state() -> Dict:
    if os.path.isfile(STATE_PATH):
        try:
            with open(STATE_PATH, "r", encoding="utf-8") as f:
                return json.load(f)
        except Exception as e:
            log(f"state load failed: {e}", logging.WARNING)
    # defaults
    return {
        "recent": [],
        "geom": {},
        "icon_pos": {},
        "background": BackgroundConfig().to_state(),
        "icon_size": "medium",
        "desktop_sort": "name",
        "ui_scale": 1.0,
        "taskbar_autohide": False,
        "taskbar_side": "bottom",
        "taskbar_pins": [],
        "allow_external_browse": False,
        "card_scale": 1.0,
        "start_panel_close": dict(START_PANEL_CLOSE_DEFAULT),
    }

def _save_state(state: Dict):
    try:
        with open(STATE_PATH, "w", encoding="utf-8") as f:
            json.dump(state, f, indent=2)
    except Exception as e:
        log(f"state save failed: {e}", logging.WARNING)

def _remember_card(kind: str, path: str, title: str):
    st = _load_state()
    st["recent"] = [r for r in st.get("recent", []) if r.get("path") != path or r.get("kind") != kind]
    st["recent"].insert(0, {"kind": kind, "path": path, "title": title, "ts": int(time.time())})
    st["recent"] = st["recent"][:24]
    _save_state(st)

def _geom_key_for(kind: str, persist_tag: str) -> str:
    return f"{kind}:{persist_tag}"


def _rect_to_dict(rect: QRect) -> Dict[str, int]:
    """Convert a QRect into a plain dict with integer coordinates."""
    return {
        "x": int(rect.x()),
        "y": int(rect.y()),
        "width": int(rect.width()),
        "height": int(rect.height()),
    }


def _widget_geometry_snapshot(widget: Optional[QWidget]) -> Dict[str, object]:
    """Return local/global geometry information for automation hooks."""
    if widget is None:
        return {}
    try:
        local = _rect_to_dict(widget.geometry())
    except Exception:
        local = {}
    try:
        top_left = widget.mapToGlobal(QPoint(0, 0))
        global_rect = QRect(top_left, widget.geometry().size())
        global_geom = _rect_to_dict(global_rect)
    except Exception:
        global_geom = dict(local)
    snapshot: Dict[str, object] = {
        "local": local,
        "global": global_geom,
        "visible": bool(widget.isVisible()),
        "objectName": widget.objectName() or "",
    }
    return snapshot


# --------------------------------------------------------------------------------------
# System metrics helpers (pure functions for card + tests)
# --------------------------------------------------------------------------------------
_RECENT_SECONDS = 24 * 3600
_SCORE_BUCKET_LABELS: Dict[str, str] = {
    "healthy": "Healthy (≥0.80)",
    "watch": "Watch (0.50–0.79)",
    "critical": "Critical (<0.50)",
    "unknown": "Unknown",
}
_LAST_RUN_LABELS: Dict[str, str] = {
    "recent": "Ran <24h ago",
    "stale": "Ran ≥24h ago",
    "never": "Never run",
}


def _script_type_label(path: str) -> str:
    if not path:
        return "Unknown"
    norm = str(path).replace("\\", "/")
    if norm.startswith("tests/"):
        return "Tests"
    if norm.startswith("tasks/"):
        return "Tasks"
    if norm.startswith("tools/"):
        return "Tools"
    if norm.endswith("Virtual_Desktop.py"):
        return "Desktop"
    if norm.endswith("Codex_Terminal.py"):
        return "Terminal"
    if norm.endswith(".py"):
        return "Python"
    return "Other"


def _score_from_error_count(error_count: Optional[Any]) -> float:
    try:
        errors = int(error_count or 0)
    except (TypeError, ValueError):
        errors = 0
    if errors <= 0:
        return 1.0
    return 1.0 / (1.0 + float(errors))


def _score_bucket_key(score: Optional[float]) -> str:
    if score is None:
        return "unknown"
    try:
        value = float(score)
    except (TypeError, ValueError):
        return "unknown"
    if value >= 0.8:
        return "healthy"
    if value >= 0.5:
        return "watch"
    return "critical"


def _last_run_bucket(last_run_ts: Optional[Any], *, now: Optional[float] = None) -> str:
    if last_run_ts in (None, ""):
        return "never"
    try:
        ts = float(last_run_ts)
    except (TypeError, ValueError):
        return "never"
    ref = float(now) if now is not None else time.time()
    delta = max(0.0, ref - ts)
    if delta <= _RECENT_SECONDS:
        return "recent"
    return "stale"


def _flatten_metrics_summary(
    summary: Mapping[str, Any] | None,
    *,
    now: Optional[float] = None,
) -> List[Dict[str, Any]]:
    if not summary:
        return []
    components = summary.get("components")
    if not isinstance(components, Mapping):
        return []
    rows: List[Dict[str, Any]] = []
    ref_now = float(now) if now is not None else float(summary.get("generated_at") or time.time())
    for component_name, component_data in components.items():
        if not isinstance(component_data, Mapping):
            continue
        scripts = component_data.get("scripts")
        if not isinstance(scripts, Mapping):
            continue
        for script_path, payload in scripts.items():
            if not isinstance(payload, Mapping):
                continue
            script_type = _script_type_label(str(script_path))
            line_count = payload.get("line_count")
            try:
                lines = int(line_count or 0)
            except (TypeError, ValueError):
                lines = 0
            errors = payload.get("error_count")
            try:
                err_count = int(errors or 0)
            except (TypeError, ValueError):
                err_count = 0
            last_modified = payload.get("last_modified")
            try:
                modified_ts = float(last_modified) if last_modified is not None else None
            except (TypeError, ValueError):
                modified_ts = None
            last_run_ts = payload.get("last_run_ts")
            try:
                last_run = float(last_run_ts) if last_run_ts is not None else None
            except (TypeError, ValueError):
                last_run = None
            score = _score_from_error_count(err_count)
            row = {
                "component": str(component_name),
                "script_path": str(script_path),
                "script_type": script_type,
                "line_count": lines,
                "error_count": err_count,
                "score": score,
                "score_bucket": _score_bucket_key(score),
                "last_modified": modified_ts,
                "last_run_ts": last_run,
                "last_run_bucket": _last_run_bucket(last_run, now=ref_now),
            }
            rows.append(row)
    rows.sort(key=lambda item: (item["component"], item["script_path"]))
    return rows


def _filter_metrics_rows(
    rows: Sequence[Mapping[str, Any]],
    *,
    script_type: str = "all",
    last_run: str = "any",
    score_bucket: str = "all",
) -> List[Dict[str, Any]]:
    filtered: List[Dict[str, Any]] = []
    type_key = (script_type or "all").strip()
    last_run_key = (last_run or "any").strip()
    score_key = (score_bucket or "all").strip()
    for row in rows:
        if not isinstance(row, Mapping):
            continue
        if type_key.lower() != "all" and row.get("script_type") != type_key:
            continue
        if last_run_key.lower() not in {"any", "all"} and row.get("last_run_bucket") != last_run_key:
            continue
        if score_key.lower() != "all" and row.get("score_bucket") != score_key:
            continue
        filtered.append(dict(row))
    return filtered


def _score_distribution(rows: Sequence[Mapping[str, Any]]) -> Dict[str, int]:
    counts = {key: 0 for key in _SCORE_BUCKET_LABELS.keys()}
    for row in rows:
        bucket = row.get("score_bucket", "unknown") if isinstance(row, Mapping) else "unknown"
        counts[bucket] = counts.get(bucket, 0) + 1
    return counts

# --------------------------------------------------------------------------------------
# Optional modules fallbacks
# --------------------------------------------------------------------------------------
def _fallback_build_editor_widget(parent=None, initial_path: Optional[str]=None, **_unused) -> QWidget:
    w = QWidget(parent)
    v = QVBoxLayout(w); v.setContentsMargins(10,10,10,10); v.setSpacing(8)
    lab = QLabel(f"Internal Code Viewer{f' — {os.path.basename(initial_path)}' if initial_path else ''}")
    lab.setStyleSheet("color:#eaf2ff; font:600 11pt 'Cascadia Code';")
    v.addWidget(lab)
    edit = QPlainTextEdit(w); edit.setReadOnly(True)
    # High-contrast palette: always set Base/Text with strong contrast
    p = edit.palette()
    bg = QColor("#0b1828"); fg = QColor("#d6e6ff")
    for g in (QPalette.Active, QPalette.Inactive, QPalette.Disabled):
        p.setColor(g, QPalette.Base, bg); p.setColor(g, QPalette.Text, fg)
        p.setColor(g, QPalette.Window, bg); p.setColor(g, QPalette.WindowText, fg)
        p.setColor(g, QPalette.Highlight, QColor("#264f78")); p.setColor(g, QPalette.HighlightedText, QColor("#ffffff"))
    edit.setPalette(p)
    edit.setStyleSheet("QPlainTextEdit{border:1px solid #213040; border-radius:10px; font-family:'Cascadia Code',Consolas,monospace;}")
    try:
        if initial_path and os.path.isfile(initial_path):
            with open(initial_path, "r", encoding="utf-8", errors="replace") as f:
                edit.setPlainText(f.read())
        else:
            edit.setPlainText("No file selected.")
    except Exception as ex:
        edit.setPlainText(f"[open failed] {ex}")
    v.addWidget(edit, 1)
    return w

try:
    from code_editor import build_widget as build_editor_widget  # type: ignore
except Exception:
    build_editor_widget = _fallback_build_editor_widget  # type: ignore

class _FallbackTaskManager:
    def __init__(self, dataset_path: str, workspace_root: Optional[str] = None):
        self.dataset_path = dataset_path
        self._workspace = workspace_root

    def set_workspace(self, workspace_root: Optional[str]) -> None:
        self._workspace = workspace_root

    def start_system_metrics_job(self, *_, **__) -> None:  # pragma: no cover - fallback no-op
        return

    def stop_system_metrics_job(self) -> None:  # pragma: no cover - fallback no-op
        return


def _fallback_open_card(*_args, **_kwargs):  # type: ignore[override]
    QMessageBox.information(None, "Tasks", "Tasks module not available.")
    return None


try:  # pragma: no cover - import guard for optional module
    from tasks.card import TaskManager, open_card  # type: ignore
except Exception:  # pragma: no cover - fallback to placeholder
    TaskManager = _FallbackTaskManager  # type: ignore
    open_card = _fallback_open_card  # type: ignore

from operator_manager import OperatorManagerWidget

if TYPE_CHECKING:  # pragma: no cover - typing helpers
    from tasks.card import TaskCard

# --------------------------------------------------------------------------------------
# Theme
# --------------------------------------------------------------------------------------
@dataclass
class Theme:
    desktop_top: str = "#0f3b8e"
    desktop_mid: str = "#1c54cc"
    edge_glow: str = "#1c54cc"  # kept same as mid but not drawn anymore
    card_bg: str = "#0c1320"
    card_border: str = "#213040"
    card_radius: int = 12
    header_bg: str = "#0a111e"
    header_fg: str = "#eaf2ff"
    text_muted: str = "#c7d5ee"
    text_body: str = "#e9f3ff"
    accent: str = "#1E5AFF"
    accent_hov: str = "#2f72ff"
    editor_bg: str = "#0b1828"
    editor_fg: str = "#d6e6ff"
    editor_sel: str = "#264f78"
    menu_bg: str = "#0a111e"
    menu_fg: str = "#eaf2ff"
    taskbar_bg: str = "#0f1722"
    taskbar_fg: str = "#eaf2ff"
    task_btn_bg: str = "#172532"
    task_btn_fg: str = "#eaf2ff"
    task_btn_hv: str = "#24374a"
    start_bg: str = "#0f2342"
    start_panel: str = "#0d1526"
    start_tile: str = "#13213a"
    start_hv: str = "#1b7fd3"

def apply_contrast_palette(w: QWidget, bg_hex: str, fg_hex: str):
    # High-contrast rule: set strong Base/Text for all states
    p = w.palette(); bg = QColor(bg_hex); fg = QColor(fg_hex)
    for group in (QPalette.Active, QPalette.Inactive, QPalette.Disabled):
        p.setColor(group, QPalette.Base, bg)
        p.setColor(group, QPalette.Text, fg)
        p.setColor(group, QPalette.Window, bg)
        p.setColor(group, QPalette.WindowText, fg)
        p.setColor(group, QPalette.Highlight, QColor("#2a5ea1"))
        p.setColor(group, QPalette.HighlightedText, QColor("#ffffff"))
    w.setPalette(p)

# --------------------------------------------------------------------------------------
# System Console (embedded log window)
# --------------------------------------------------------------------------------------
class SystemConsole(QWidget):
    def __init__(self, theme: Theme, log_path: str):
        super().__init__()
        self.setWindowFlag(Qt.Window, True)
        self.setWindowTitle("System Console")
        self.resize(900, 560)
        self.t = theme
        self.log_path = log_path
        self._pos = 0
        v = QVBoxLayout(self); v.setContentsMargins(10,10,10,10); v.setSpacing(8)
        self.text = QPlainTextEdit(self); self.text.setReadOnly(True)
        apply_contrast_palette(self.text, theme.editor_bg, theme.editor_fg)
        self.text.setStyleSheet(
            f"QPlainTextEdit{{ background:{theme.editor_bg}; color:{theme.editor_fg}; "
            f"selection-background-color:{theme.editor_sel}; border:1px solid {theme.card_border}; "
            f"font-family:'Cascadia Code',Consolas,monospace; }}"
        )
        v.addWidget(self.text, 1)
        row = QHBoxLayout(); row.setSpacing(8)
        def mk_btn(lbl, fn):
            b = QPushButton(lbl); b.clicked.connect(fn)
            b.setStyleSheet(f"QPushButton{{color:#fff;background:{self.t.accent};border:1px solid {self.t.card_border};border-radius:6px;padding:6px 10px;}}"
                            f"QPushButton:hover{{background:{self.t.accent_hov};}}")
            return b
        row.addWidget(mk_btn("Refresh", self.refresh))
        row.addWidget(mk_btn("Clear", self.clear_log))
        row.addStretch(1)
        v.addLayout(row)
        self.timer = QTimer(self); self.timer.setInterval(800); self.timer.timeout.connect(self.refresh)
        self.timer.start()
        self.refresh(initial=True)
    def refresh(self, initial: bool=False):
        try:
            with open(self.log_path, "r", encoding="utf-8", errors="replace") as f:
                f.seek(self._pos)
                chunk = f.read()
                self._pos = f.tell()
            if initial: self.text.setPlainText(chunk)
            else:
                if chunk:
                    self.text.moveCursor(self.text.textCursor().End)
                    self.text.insertPlainText(chunk)
            self.text.moveCursor(self.text.textCursor().End)
        except Exception:
            pass
    def clear_log(self):
        try:
            with open(self.log_path, "w", encoding="utf-8"): pass
            self._pos = 0; self.text.setPlainText("")
        except Exception as e:
            log(f"log clear failed: {e}", logging.WARNING)

# --------------------------------------------------------------------------------------
# Template Terminal (Card How-To)
# --------------------------------------------------------------------------------------
_TEMPLATE_INSTRUCTIONS = """\
Template Terminal — Card How-To
===============================
A Card is a QWidget hosted by the Virtual Desktop. It can be a terminal, editor,
dashboard—anything with a Qt widget.

Load cards in two ways:
1) Verified Card (embedded): define create_card(parent)->QWidget|(QWidget,title) or build_widget(parent)
2) Process Console (fallback): if no factory, we run it as a subprocess and stream output.

Contrast rule: always set Base/Text colors for Active/Inactive/Disabled *or* style with QSS so
read-only and disabled text stays readable.
"""
_TEMPLATE_CODE = r'''# minimal_card.py — simple verified card (high-contrast)
from PySide6.QtWidgets import QWidget, QVBoxLayout, QLabel, QPushButton
from PySide6.QtGui import QPalette, QColor
from PySide6.QtCore import Qt
def _apply_palette(w, bg="#0b1828", fg="#e9f3ff"):
    p=w.palette(); bgc,fgc=QColor(bg),QColor(fg)
    for g in (QPalette.Active,QPalette.Inactive,QPalette.Disabled):
        p.setColor(g,QPalette.Base,bgc); p.setColor(g,QPalette.Text,fgc)
        p.setColor(g,QPalette.Window,bgc); p.setColor(g,QPalette.WindowText,fgc)
    w.setPalette(p)
def create_card(parent=None):
    w=QWidget(parent); _apply_palette(w)
    w.setStyleSheet("QLabel{color:#c7d5ee; font:600 11pt 'Cascadia Code';}"
                    "QPushButton{color:#fff; background:#1E5AFF; border:1px solid #213040; border-radius:6px; padding:6px 10px;}"
                    "QPushButton:hover{background:#2f72ff;}")
    lay=QVBoxLayout(w); lay.setContentsMargins(14,14,14,14); lay.setSpacing(8)
    title=QLabel('🧩 My Card'); title.setAlignment(Qt.AlignCenter)
    btn=QPushButton('Click Me'); lay.addWidget(title); lay.addWidget(btn)
    return w,"My First Card"
'''
class TemplateTerminal(QWidget):
    def __init__(self, theme: Theme):
        super().__init__()
        self.t = theme
        v = QVBoxLayout(self); v.setContentsMargins(12, 12, 12, 12); v.setSpacing(10)
        hdr = QLabel("Template Terminal — Card How-To ✨")
        hdr.setStyleSheet("color:#eaf2ff; font:700 12pt 'Cascadia Code';")
        v.addWidget(hdr)
        self.txt = QPlainTextEdit(self); self.txt.setReadOnly(True)
        self.txt.setPlainText(_TEMPLATE_INSTRUCTIONS)
        apply_contrast_palette(self.txt, theme.editor_bg, theme.editor_fg)
        self.txt.setStyleSheet(
            f"QPlainTextEdit{{ background:{theme.editor_bg}; color:{theme.editor_fg}; "
            f"selection-background-color:{theme.editor_sel}; border:1px solid {theme.card_border}; "
            f"font-family:'Cascadia Code',Consolas,monospace; }}"
        )
        v.addWidget(self.txt, 1)
        row = QHBoxLayout(); row.setSpacing(8)
        btn_copy_info = QPushButton("📋 Copy Instructions")
        btn_copy_tpl = QPushButton("📋 Copy Minimal Card Template")
        for b in (btn_copy_info, btn_copy_tpl):
            b.setStyleSheet(f"QPushButton{{color:#fff;background:{self.t.accent};border:1px solid {self.t.card_border};border-radius:6px;padding:6px 10px;}}"
                            f"QPushButton:hover{{background:{self.t.accent_hov};}}")
        btn_copy_info.clicked.connect(lambda: QApplication.clipboard().setText(_TEMPLATE_INSTRUCTIONS, QClipboard.Clipboard))
        btn_copy_tpl.clicked.connect(lambda: QApplication.clipboard().setText(_TEMPLATE_CODE, QClipboard.Clipboard))
        row.addWidget(btn_copy_info); row.addWidget(btn_copy_tpl); row.addStretch(1)
        v.addLayout(row)
        code_hdr = QLabel("🧪 Minimal Card (verified) — save as minimal_card.py then use Start ▸ Apps ▸ Load Script as Card…")
        code_hdr.setStyleSheet("color:#c7d5ee;")
        v.addWidget(code_hdr)
        self.code = QPlainTextEdit(self); self.code.setReadOnly(True)
        self.code.setPlainText(_TEMPLATE_CODE)
        apply_contrast_palette(self.code, theme.editor_bg, theme.editor_fg)
        self.code.setStyleSheet(
            f"QPlainTextEdit{{ background:{theme.editor_bg}; color:{theme.editor_fg}; "
            f"selection-background-color:{self.t.editor_sel}; border:1px solid {self.t.card_border}; "
            f"font-family:'Cascadia Code',Consolas,monospace; }}"
        )
        v.addWidget(self.code, 1)

# --------------------------------------------------------------------------------------
# Explorer (renames change extension; non-native dialogs to keep containment)
# --------------------------------------------------------------------------------------
def _non_native_open_files(parent, caption, start_dir, filt) -> Tuple[List[str], str]:
    dlg = QFileDialog(parent, caption, start_dir, filt)
    dlg.setOption(QFileDialog.DontUseNativeDialog, True)  # containment: no OS-native surfaces
    dlg.setFileMode(QFileDialog.ExistingFiles)
    if dlg.exec(): return dlg.selectedFiles(), dlg.selectedNameFilter()
    return [], ""

def _non_native_open_file(parent, caption, start_dir, filt) -> Tuple[str, str]:
    files, nf = _non_native_open_files(parent, caption, start_dir, filt)
    return (files[0] if files else ""), nf

def _non_native_open_dir(parent, caption, start_dir) -> str:
    dlg = QFileDialog(parent, caption, start_dir)
    dlg.setOption(QFileDialog.DontUseNativeDialog, True)
    dlg.setFileMode(QFileDialog.Directory)
    dlg.setOption(QFileDialog.ShowDirsOnly, True)
    return dlg.selectedFiles()[0] if dlg.exec() else ""

class ExplorerCard(QWidget):
    def __init__(self, root_path: str, open_cb: Callable[[str], None], theme: Theme, refresh_hook: Optional[Callable[[], None]] = None):
        super().__init__()
        self.root = root_path
        self.open_cb = open_cb
        self.t = theme
        self.refresh_hook = refresh_hook
        v = QVBoxLayout(self); v.setContentsMargins(10,10,10,10); v.setSpacing(8)
        hdr = QFrame(self); hdr.setStyleSheet(f"background:{self.t.header_bg}; border:1px solid {self.t.card_border}; border-radius:8px;")
        h = QHBoxLayout(hdr); h.setContentsMargins(8,6,8,6); h.setSpacing(8)
        self.lbl_path = QLabel(self.root); self.lbl_path.setStyleSheet(f"color:{self.t.header_fg}; font:600 10pt 'Cascadia Code';")
        btn_up = QPushButton("Up"); btn_new = QPushButton("New Folder"); btn_refresh = QPushButton("Refresh"); self.btn_view = QPushButton("List View")
        for b in (btn_up, btn_new, btn_refresh, self.btn_view):
            b.setStyleSheet(
                f"QPushButton{{color:#fff; background:{self.t.accent}; border:1px solid {self.t.card_border}; border-radius:6px; padding:4px 10px;}}"
                f"QPushButton:hover{{background:{self.t.accent_hov};}}"
            )
        h.addWidget(self.lbl_path); h.addStretch(1); h.addWidget(self.btn_view); h.addWidget(btn_refresh); h.addWidget(btn_new); h.addWidget(btn_up)
        v.addWidget(hdr)
        self.list = QListWidget(self)
        self.list.setViewMode(QListWidget.IconMode)
        self.list.setIconSize(QSize(48,48))
        self.list.setResizeMode(QListWidget.Adjust)
        self.list.setMovement(QListWidget.Static)
        self.list.setSpacing(12)
        self.list.setStyleSheet(
            f"QListWidget{{ background:{self.t.editor_bg}; color:{self.t.editor_fg}; border:1px solid {self.t.card_border}; border-radius:10px; }}"
        )
        v.addWidget(self.list, 1)
        btn_up.clicked.connect(self._go_up)
        btn_new.clicked.connect(self._new_folder)
        btn_refresh.clicked.connect(self._refresh)
        self.btn_view.clicked.connect(self._toggle_view_mode)
        self.list.itemActivated.connect(self._open_item)
        self.list.setContextMenuPolicy(Qt.CustomContextMenu)
        self.list.customContextMenuRequested.connect(self._icon_context)
        self._cwd = self.root
        self._view_mode = "grid"
        self._thumb_cache: Dict[str, QIcon] = {}
        self._native_icon_cache: Dict[str, QIcon] = {}
        self._apply_view_mode()
        self._refresh()

    def _apply_view_mode(self):
        if self._view_mode == "list":
            self.list.setViewMode(QListWidget.ListMode)
            self.list.setIconSize(QSize(96, 72))
            self.list.setSpacing(6)
            self.list.setWordWrap(True)
            self.btn_view.setText("Grid View")
        else:
            self.list.setViewMode(QListWidget.IconMode)
            self.list.setIconSize(QSize(64, 64))
            self.list.setSpacing(12)
            self.list.setWordWrap(False)
            self.btn_view.setText("List View")

    def _toggle_view_mode(self):
        self._view_mode = "list" if self._view_mode == "grid" else "grid"
        self._thumb_cache.clear()
        self._native_icon_cache.clear()
        _clear_native_icon_caches()
        self._apply_view_mode()
        self._refresh()

    def _icon_for_path(self, path: str) -> QIcon:
        norm_path = os.path.abspath(path)
        path_obj = Path(norm_path)
        if self._view_mode == "list":
            ext = path_obj.suffix.lower()
            if ext in {".png", ".jpg", ".jpeg", ".gif", ".bmp"} and path_obj.exists():
                cached_thumb = self._thumb_cache.get(norm_path)
                if cached_thumb:
                    return cached_thumb
                pix = QPixmap(norm_path)
                if not pix.isNull():
                    icon = QIcon(
                        pix.scaled(self.list.iconSize(), Qt.KeepAspectRatio, Qt.SmoothTransformation)
                    )
                    self._thumb_cache[norm_path] = icon
                    return icon

        cached_icon = self._native_icon_cache.get(norm_path)
        if cached_icon:
            return cached_icon

        icon, _ = _ICON_FOR_PATH_HELPER(path_obj)
        if icon.isNull():
            icon = QApplication.style().standardIcon(QStyle.SP_FileIcon)
        self._native_icon_cache[norm_path] = icon
        return icon

    def _refresh(self):
        self.list.clear()
        self.lbl_path.setText(self._cwd)
        try:
            ents = sorted(os.listdir(self._cwd), key=lambda s: s.lower())
        except Exception as e:
            log(f"Explorer list failed: {e}", logging.WARNING)
            ents = []
        if os.path.abspath(self._cwd) != os.path.abspath(self.root):
            it = QListWidgetItem("..")
            it.setIcon(QApplication.style().standardIcon(QStyle.SP_ArrowUp))
            it.setData(Qt.UserRole, os.path.abspath(os.path.join(self._cwd, "..")))
            self.list.addItem(it)
        for name in ents:
            full = os.path.join(self._cwd, name)
            it = QListWidgetItem(name)
            it.setIcon(self._icon_for_path(full))
            it.setData(Qt.UserRole, full)
            self.list.addItem(it)

    def _open_item(self, item: QListWidgetItem):
        path = item.data(Qt.UserRole)
        if not path: return
        if os.path.isdir(path):
            self._cwd = path; self._refresh()
        else:
            self.open_cb(path)

    def _go_up(self):
        if os.path.abspath(self._cwd) == os.path.abspath(self.root):
            return
        self._cwd = os.path.abspath(os.path.join(self._cwd, ".."))
        self._refresh()

    def _new_folder(self):
        base = os.path.join(self._cwd, "New Folder")
        name = base; i = 1
        while os.path.exists(name):
            name = f"{base} {i}"; i += 1
        try:
            os.makedirs(name, exist_ok=False)
            self._refresh()
            if self.refresh_hook: self.refresh_hook(); QApplication.processEvents()
        except Exception as e:
            log(f"mkdir failed: {e}", logging.WARNING)

    def _icon_context(self, pos: QPoint):
        item = self.list.itemAt(pos)
        if not item: return
        path = item.data(Qt.UserRole)
        if not path: return
        m = QMenu(self)
        act_open = m.addAction("Open")
        act_rename = m.addAction("Rename")
        act_delete = m.addAction("Delete")
        act_props = m.addAction("Properties")
        act = m.exec(self.list.mapToGlobal(pos))
        if act == act_open:
            self._open_item(item)
        elif act == act_rename:
            new_name, ok = QInputDialog.getText(self, "Rename", "New name (extensions allowed):", text=os.path.basename(path))
            if ok and new_name:
                try:
                    os.rename(path, os.path.join(self._cwd, new_name))
                    self._refresh()
                    if self.refresh_hook: self.refresh_hook(); QApplication.processEvents()
                except Exception as e:
                    QMessageBox.warning(self, "Rename", f"Rename failed: {e}")
        elif act == act_delete:
            try:
                if os.path.isdir(path): shutil.rmtree(path)
                else: os.remove(path)
                self._refresh()
                if self.refresh_hook: self.refresh_hook(); QApplication.processEvents()
            except Exception as e:
                QMessageBox.warning(self, "Delete", f"Delete failed: {e}")
        elif act == act_props:
            size = os.path.getsize(path) if os.path.isfile(path) else "Folder"
            QMessageBox.information(self, "Properties", f"Path: {path}\nSize: {size}")

# --------------------------------------------------------------------------------------
# Card with Min/Max/Close and taskbar integration
# --------------------------------------------------------------------------------------
class CardSizeGrip(QSizeGrip):
    """Custom size grip that directly resizes the owning :class:`Card`."""

    def __init__(self, card: "Card", corner: Qt.Corner):
        super().__init__(card)
        self._card = card
        self._corner = corner
        self._dragging = False
        self._press_pos = QPoint()
        self._start_geom = QRect()

    def _handles_left(self) -> bool:
        return self._corner in (Qt.TopLeftCorner, Qt.BottomLeftCorner)

    def _handles_right(self) -> bool:
        return self._corner in (Qt.TopRightCorner, Qt.BottomRightCorner)

    def _handles_top(self) -> bool:
        return self._corner in (Qt.TopLeftCorner, Qt.TopRightCorner)

    def _handles_bottom(self) -> bool:
        return self._corner in (Qt.BottomLeftCorner, Qt.BottomRightCorner)

    def mousePressEvent(self, event):
        if event.button() == Qt.LeftButton:
            if getattr(self._card, "_maximized", False):
                event.ignore()
                return
            self._dragging = True
            self._press_pos = event.globalPosition().toPoint()
            self._start_geom = QRect(self._card.geometry())
            self._card.raise_()
            self._card.activateWindow()
            event.accept()
            return
        super().mousePressEvent(event)

    def mouseMoveEvent(self, event):
        if not self._dragging:
            super().mouseMoveEvent(event)
            return
        if getattr(self._card, "_maximized", False):
            self._dragging = False
            event.ignore()
            return
        delta = event.globalPosition().toPoint() - self._press_pos
        dx = delta.x()
        dy = delta.y()
        geom = self._start_geom
        x, y, w, h = geom.x(), geom.y(), geom.width(), geom.height()

        if self._handles_left():
            x += dx
            w -= dx
        elif self._handles_right():
            w += dx

        if self._handles_top():
            y += dy
            h -= dy
        elif self._handles_bottom():
            h += dy

        min_w = max(self._card.minimumWidth(), MIN_CARD_WIDTH)
        min_h = max(self._card.minimumHeight(), MIN_CARD_HEIGHT)

        if w < min_w:
            if self._handles_left():
                x -= (min_w - w)
            w = min_w

        if h < min_h:
            if self._handles_top():
                y -= (min_h - h)
            h = min_h

        parent = self._card.parentWidget()
        margin = 6
        if parent:
            avail_w = max(min_w, parent.width() - margin * 2)
            avail_h = max(min_h, parent.height() - margin * 2)
            if w > avail_w:
                w = avail_w
                if self._handles_left():
                    x = margin
                else:
                    x = parent.width() - margin - w
            if h > avail_h:
                h = avail_h
                if self._handles_top():
                    y = margin
                else:
                    y = parent.height() - margin - h

            max_x = parent.width() - margin - w
            max_y = parent.height() - margin - h
            x = max(margin, min(x, max_x))
            y = max(margin, min(y, max_y))

        new_geom = QRect(x, y, w, h)
        if new_geom != self._card.geometry():
            self._card.setGeometry(new_geom)
        event.accept()

    def mouseReleaseEvent(self, event):
        if self._dragging and event.button() == Qt.LeftButton:
            self._dragging = False
            event.accept()
            return
        super().mouseReleaseEvent(event)


class Card(QFrame):
    moved = Signal()
    moving = Signal(QPoint)
    resized = Signal()
    closed = Signal(object)     # self on close
    minimized = Signal(object)  # self on minimize
    restored = Signal(object)   # self on restore

    def __init__(self, theme: Theme, title: str = "Card", parent: Optional[QWidget] = None):
        super().__init__(parent)
        self.t = theme
        self._drag = False
        self._press = QPoint()
        self._persist_tag: Optional[str] = None
        self._maximized = False
        self._normal_geom = QRect(0,0,0,0)
        st = QApplication.style()
        self.task_profile = "card"
        self.task_icon = st.standardIcon(QStyle.SP_FileIcon)
        self.task_tooltip = title

        self.setObjectName("Card")
        self.setStyleSheet(
            f"#Card {{ background:{self.t.card_bg}; border:1px solid {self.t.card_border}; border-radius:{self.t.card_radius}px; }}"
        )
        sh = QGraphicsDropShadowEffect(self); sh.setColor(QColor(0, 30, 80, 150))
        sh.setBlurRadius(28); sh.setOffset(0, 12); self.setGraphicsEffect(sh)

        root = QVBoxLayout(self); root.setContentsMargins(0, 0, 0, 0); root.setSpacing(0)
        # Header
        self.header = QFrame(self); self.header.setObjectName("Hdr")
        self.header.setStyleSheet(
            f"#Hdr {{ background:{self.t.header_bg}; border-top-left-radius:{self.t.card_radius}px; "
            f"border-top-right-radius:{self.t.card_radius}px; }}"
            f"QLabel {{ color:{self.t.header_fg}; font:600 10.5pt 'Cascadia Code'; }}"
            f"QPushButton {{ color:#fff; background:{self.t.accent}; border:1px solid {self.t.card_border}; border-radius:6px; padding:3px 8px; }}"
            f"QPushButton:hover {{ background:{self.t.accent_hov}; }}"
        )
        H = QHBoxLayout(self.header); H.setContentsMargins(12, 8, 12, 6); H.setSpacing(8)
        self.title_label = QLabel(title, self.header)

        H.addWidget(self.title_label); H.addStretch(1)

        self.btn_min = QPushButton("—", self.header); self.btn_min.setFixedWidth(28)
        self.btn_max = QPushButton("▢", self.header); self.btn_max.setFixedWidth(28)
        self.close_btn = QPushButton("✕", self.header); self.close_btn.setFixedWidth(28)

        self.btn_min.clicked.connect(self._minimize_card)
        self.btn_max.clicked.connect(self._toggle_max_restore)
        self.close_btn.clicked.connect(self._close_card)

        for b in (self.btn_min, self.btn_max, self.close_btn):
            b.setCursor(Qt.PointingHandCursor)

        H.addWidget(self.btn_min); H.addWidget(self.btn_max); H.addWidget(self.close_btn)
        root.addWidget(self.header)

        # Body
        self.body = QFrame(self); self.body.setObjectName("Body")
        self.body.setStyleSheet(f"#Body {{ background:{self.t.card_bg}; }}")
        root.addWidget(self.body, 1)

        # Size grips
        corners = (
            Qt.BottomLeftCorner,
            Qt.BottomRightCorner,
            Qt.TopLeftCorner,
            Qt.TopRightCorner,
        )
        self._grips = [CardSizeGrip(self, corner) for corner in corners]
        for g in self._grips: g.setFixedSize(16, 16); g.raise_()

    def set_persist_tag(self, tag: str):
        self._persist_tag = tag

    def set_task_metadata(self, profile: Optional[str] = None, icon: Optional[QIcon] = None, tooltip: Optional[str] = None):
        if profile:
            self.task_profile = profile
        if icon is not None and not icon.isNull():
            self.task_icon = icon
        if tooltip:
            self.task_tooltip = tooltip

    def header_geom(self) -> QRect:
        return QRect(0, 0, self.width(), 44)

    def resizeEvent(self, e):
        w, h = self.width(), self.height(); m = 6; g = self._grips
        g[0].move(m, h - g[0].height() - m)
        g[1].move(w - g[1].width() - m, h - g[1].height() - m)
        g[2].move(m, m)
        g[3].move(w - g[3].width() - m, m)
        self.resized.emit()
        super().resizeEvent(e)

    def mousePressEvent(self, ev):
        if ev.button() == Qt.LeftButton and self.header_geom().contains(ev.position().toPoint()):
            self._drag = True; self._press = ev.position().toPoint()
            self.raise_(); self.activateWindow(); self.setFocus(Qt.ActiveWindowFocusReason)
            ev.accept()
        else:
            super().mousePressEvent(ev)

    def mouseMoveEvent(self, ev):
        if not self._drag:
            super().mouseMoveEvent(ev); return
        delta = ev.position().toPoint() - self._press
        current_pos = self.pos()
        canvas = self.parentWidget()
        effect = self.graphicsEffect()
        cached_rect: Optional[QRect] = None
        if canvas is not None:
            if effect is not None:
                cached_rect = effect.boundingRectFor(QRectF(self.rect())).translated(current_pos.x(), current_pos.y()).toAlignedRect()
            else:
                cached_rect = self.geometry()
        if delta.isNull():
            ev.accept()
            return
        new_pos = current_pos + delta
        if canvas:
            r = canvas.rect()
            new_pos.setX(max(6, min(new_pos.x(), r.width() - self.width() - 6)))
            new_pos.setY(max(6, min(new_pos.y(), r.height() - self.height() - 6)))
        if new_pos == current_pos:
            ev.accept()
            return
        self.move(new_pos)
        if canvas is not None and cached_rect is not None:
            canvas.update(cached_rect)
            if effect is not None:
                new_rect = effect.boundingRectFor(QRectF(self.rect())).translated(new_pos.x(), new_pos.y()).toAlignedRect()
            else:
                new_rect = self.geometry()
            canvas.update(new_rect)
        self.moving.emit(new_pos)
        ev.accept()

    def mouseReleaseEvent(self, ev):
        if self._drag:
            self._drag = False; self.moved.emit()
        super().mouseReleaseEvent(ev)

    def mouseDoubleClickEvent(self, ev):
        if ev.button() == Qt.LeftButton and self.header_geom().contains(ev.position().toPoint()):
            self._toggle_max_restore()
            ev.accept()
            return
        super().mouseDoubleClickEvent(ev)

    def contextMenuEvent(self, e):
        if not self.header_geom().contains(e.pos()): return
        menu = QMenu(self)
        act_min = menu.addAction("Minimize")
        act_max = menu.addAction("Maximize" if not self._maximized else "Restore")
        act_close = menu.addAction("Close")
        act = menu.exec(e.globalPos())
        if act == act_min: self._minimize_card()
        elif act == act_max: self._toggle_max_restore()
        elif act == act_close: self._close_card()

    def _minimize_card(self):
        self.hide()
        self.minimized.emit(self)

    def _toggle_max_restore(self):
        canvas = self.parentWidget()
        if not canvas: return
        if not self._maximized:
            self._normal_geom = QRect(self.x(), self.y(), self.width(), self.height())
            margin = 8
            insets = {"left": 0, "top": 0, "right": 0, "bottom": 0}
            parent_core = getattr(canvas, "parent", lambda: None)()
            if parent_core and hasattr(parent_core, "taskbar_insets"):
                try:
                    fetched = parent_core.taskbar_insets()
                    if isinstance(fetched, dict):
                        insets.update({k: int(max(0, v)) for k, v in fetched.items()})
                except Exception:
                    insets = {"left": 0, "top": 0, "right": 0, "bottom": 0}
            width = max(200, canvas.width() - insets["left"] - insets["right"] - 2 * margin)
            height = max(160, canvas.height() - insets["top"] - insets["bottom"] - 2 * margin)
            x = margin + insets["left"]
            y = margin + insets["top"]
            self.setGeometry(x, y, width, height)
            self._maximized = True
            self.btn_max.setText("❐")  # restore glyph
        else:
            if self._normal_geom.width() > 0:
                self.setGeometry(self._normal_geom)
            self._maximized = False
            self.btn_max.setText("▢")
        self.raise_(); self.activateWindow()
        self.restored.emit(self)

    def _close_card(self):
        try:
            self.closed.emit(self)
        finally:
            self.deleteLater()


# --------------------------------------------------------------------------------------
# System Overview card
# --------------------------------------------------------------------------------------
class SystemOverviewCard(Card):
    """Interactive dashboard presenting collected system metrics."""

    _DEFAULT_DB_NAME = "system_metrics.db"

    def __init__(
        self,
        theme: Theme,
        datasets_root: os.PathLike[str] | str,
        *,
        parent: Optional[QWidget] = None,
    ) -> None:
        super().__init__(theme, "System Overview", parent)
        self._datasets_root = Path(datasets_root)
        self._datasets_root.mkdir(parents=True, exist_ok=True)
        self._db_path = self._datasets_root / self._DEFAULT_DB_NAME
        self._rows: List[Dict[str, Any]] = []
        self._filtered_rows: List[Dict[str, Any]] = []
        self._history_by_script: Dict[str, List[Dict[str, Any]]] = {}
        self._summary_time: float = time.time()
        self._subscription: Optional[BusSubscription] = None
        self._building_filters = False

        self._build_body()
        self._subscribe_bus()
        QTimer.singleShot(0, self.refresh)

    # ------------------------------------------------------------------
    def _build_body(self) -> None:
        body_layout = QVBoxLayout(self.body)
        body_layout.setContentsMargins(16, 16, 16, 16)
        body_layout.setSpacing(12)

        stats_frame = QFrame(self.body)
        stats_frame.setObjectName("SystemStats")
        stats_frame.setStyleSheet(
            (
                "#SystemStats{background:#0a111e;border:1px solid #1d2b3c;border-radius:12px;}"
                "QLabel{color:#eaf2ff;font:600 10pt 'Segoe UI';}"
            )
        )
        stats_layout = QHBoxLayout(stats_frame)
        stats_layout.setContentsMargins(12, 10, 12, 10)
        stats_layout.setSpacing(18)

        self._components_label = QLabel("Components: 0", stats_frame)
        self._scripts_label = QLabel("Scripts: 0", stats_frame)
        self._score_label = QLabel("Average Score: 0.00", stats_frame)
        self._generated_label = QLabel("Generated: --", stats_frame)
        for label in (
            self._components_label,
            self._scripts_label,
            self._score_label,
            self._generated_label,
        ):
            stats_layout.addWidget(label)
        stats_layout.addStretch(1)
        body_layout.addWidget(stats_frame)

        filter_frame = QFrame(self.body)
        filter_frame.setObjectName("SystemFilters")
        filter_frame.setStyleSheet(
            (
                "#SystemFilters{background:#0a111e;border:1px solid #1d2b3c;border-radius:12px;}"
                "QComboBox{color:#eaf2ff;background:#122035;border:1px solid #1f2b3c;border-radius:8px;padding:4px 8px;}"
                "QPushButton{color:#ffffff;background:#1E5AFF;border:none;border-radius:8px;padding:6px 12px;}"
                "QPushButton:hover{background:#2f72ff;}"
            )
        )
        filter_layout = QHBoxLayout(filter_frame)
        filter_layout.setContentsMargins(12, 10, 12, 10)
        filter_layout.setSpacing(12)

        self.filter_type = QComboBox(filter_frame)
        self.filter_type.setMinimumWidth(180)
        self.filter_last_run = QComboBox(filter_frame)
        self.filter_last_run.setMinimumWidth(160)
        self.filter_score = QComboBox(filter_frame)
        self.filter_score.setMinimumWidth(180)
        self.refresh_button = QPushButton("Refresh", filter_frame)

        self._building_filters = True
        self.filter_type.addItem("All Script Types", "all")
        self.filter_last_run.addItem("Any Last Run", "any")
        for key, label in _LAST_RUN_LABELS.items():
            self.filter_last_run.addItem(label, key)
        self.filter_score.addItem("All Scores", "all")
        for key, label in _SCORE_BUCKET_LABELS.items():
            self.filter_score.addItem(label, key)
        self._building_filters = False

        filter_layout.addWidget(self.filter_type)
        filter_layout.addWidget(self.filter_last_run)
        filter_layout.addWidget(self.filter_score)
        filter_layout.addStretch(1)
        filter_layout.addWidget(self.refresh_button)
        body_layout.addWidget(filter_frame)

        splitter = QSplitter(Qt.Horizontal, self.body)
        splitter.setChildrenCollapsible(False)

        self.table = QTableWidget(0, 6, splitter)
        self.table.setObjectName("SystemTable")
        self.table.setHorizontalHeaderLabels(
            [
                "Script",
                "Component",
                "Type",
                "Last Run",
                "Errors",
                "Score",
            ]
        )
        header = self.table.horizontalHeader()
        header.setSectionResizeMode(0, QHeaderView.Stretch)
        header.setSectionResizeMode(1, QHeaderView.Stretch)
        for idx in range(2, 6):
            header.setSectionResizeMode(idx, QHeaderView.ResizeToContents)
        self.table.verticalHeader().setVisible(False)
        self.table.setAlternatingRowColors(True)
        self.table.setStyleSheet(
            (
                "QTableWidget{background:#0b1828;color:#eaf2ff;border:1px solid #1f2b3c;border-radius:10px;}"
                "QHeaderView::section{background:#122035;color:#d6e6ff;padding:6px;border:none;}"
                "QTableWidget::item:selected{background:#264f78;}"
            )
        )
        self.table.setSelectionBehavior(QTableWidget.SelectionBehavior.SelectRows)
        self.table.setSelectionMode(QTableWidget.SelectionMode.SingleSelection)
        splitter.addWidget(self.table)

        self._charts_container = QWidget(splitter)
        charts_layout = QVBoxLayout(self._charts_container)
        charts_layout.setContentsMargins(0, 0, 0, 0)
        charts_layout.setSpacing(12)

        distribution_label = QLabel("Score Distribution", self._charts_container)
        distribution_label.setStyleSheet("color:#eaf2ff;font:600 10pt 'Segoe UI';")
        charts_layout.addWidget(distribution_label)

        if pg and BarGraphItem is not None:
            self._distribution_plot = pg.PlotWidget(background=self.t.card_bg)
            self._distribution_plot.showGrid(y=True, alpha=0.2)
            charts_layout.addWidget(self._distribution_plot, 1)
        else:
            self._distribution_plot = None
            placeholder = QLabel(
                "PyQtGraph not available — install it to see charts.",
                self._charts_container,
            )
            placeholder.setAlignment(Qt.AlignCenter)
            placeholder.setStyleSheet("color:#9ab0d6;font:600 10pt 'Segoe UI';")
            charts_layout.addWidget(placeholder)

        history_label = QLabel("Score History", self._charts_container)
        history_label.setStyleSheet("color:#eaf2ff;font:600 10pt 'Segoe UI';")
        charts_layout.addWidget(history_label)

        if pg:
            axis_items = {"bottom": DateAxisItem(orientation="bottom")} if DateAxisItem else None
            self._history_plot = pg.PlotWidget(
                axisItems=axis_items,
                background=self.t.card_bg,
            )
            self._history_plot.setYRange(0, 1.05)
            self._history_plot.showGrid(y=True, alpha=0.2)
            charts_layout.addWidget(self._history_plot, 1)
        else:
            self._history_plot = None
            history_placeholder = QLabel(
                "Score history charts require pyqtgraph.",
                self._charts_container,
            )
            history_placeholder.setAlignment(Qt.AlignCenter)
            history_placeholder.setStyleSheet("color:#9ab0d6;font:600 10pt 'Segoe UI';")
            charts_layout.addWidget(history_placeholder)

        self._history_hint = QLabel("Select a script to view trend details.", self._charts_container)
        self._history_hint.setStyleSheet("color:#9ab0d6;font:500 9pt 'Segoe UI';")
        charts_layout.addWidget(self._history_hint)

        splitter.addWidget(self._charts_container)
        splitter.setStretchFactor(0, 3)
        splitter.setStretchFactor(1, 2)
        body_layout.addWidget(splitter, 1)

        self._status_label = QLabel("Collecting metrics…", self.body)
        self._status_label.setStyleSheet("color:#9ab0d6;font:500 9pt 'Segoe UI';")
        body_layout.addWidget(self._status_label)

        self.refresh_button.clicked.connect(lambda: self.refresh(store=True))
        self.filter_type.currentIndexChanged.connect(self._apply_filters)
        self.filter_last_run.currentIndexChanged.connect(self._apply_filters)
        self.filter_score.currentIndexChanged.connect(self._apply_filters)
        self.table.itemSelectionChanged.connect(self._handle_selection_changed)
        self.destroyed.connect(lambda *_: self._cleanup())

    # ------------------------------------------------------------------
    def _subscribe_bus(self) -> None:
        if bus_subscribe is None:
            return
        try:
            self._subscription = bus_subscribe("system.metrics", self._on_metrics_event)
        except Exception:
            log("SystemOverviewCard bus subscription failed", logging.DEBUG)

    # ------------------------------------------------------------------
    def _cleanup(self) -> None:
        if self._subscription is not None:
            try:
                self._subscription.unsubscribe()
            except Exception:
                pass
            finally:
                self._subscription = None

    # ------------------------------------------------------------------
    def _on_metrics_event(self, _payload: dict) -> None:  # pragma: no cover - callback bridge
        QTimer.singleShot(0, self.refresh)

    # ------------------------------------------------------------------
    def refresh(self, store: bool = False) -> None:
        self._status_label.setText("Refreshing metrics…")
        QApplication.processEvents()
        try:
            summary = collect_metrics(store=store, datasets_root=self._datasets_root)
        except Exception as exc:
            self._status_label.setText(f"Metrics refresh failed: {exc}")
            log(f"SystemOverviewCard refresh failed: {exc}", logging.DEBUG)
            return
        try:
            history = fetch_metrics(scope="local", db_paths={"local": str(self._db_path)})
        except Exception as exc:
            history = []
            log(f"Metrics history fetch failed: {exc}", logging.DEBUG)

        generated_at = float(summary.get("generated_at") or time.time()) if summary else time.time()
        self._summary_time = generated_at
        self._rows = _flatten_metrics_summary(summary, now=generated_at)
        self._group_history(history)
        self._update_filters()
        self._apply_filters()
        self._update_stats()
        self._status_label.setText(f"Last updated {self._format_timestamp(generated_at)}")

    # ------------------------------------------------------------------
    def _group_history(self, history: Iterable[Mapping[str, Any]]) -> None:
        grouped: Dict[str, List[Dict[str, Any]]] = {}
        for entry in history or []:
            if not isinstance(entry, Mapping):
                continue
            script = entry.get("script_path")
            if not script:
                continue
            grouped.setdefault(str(script), []).append(dict(entry))
        for values in grouped.values():
            values.sort(key=lambda item: float(item.get("timestamp") or 0.0))
        self._history_by_script = grouped

    # ------------------------------------------------------------------
    def _update_filters(self) -> None:
        self._building_filters = True
        current_type = self.filter_type.currentData()
        self.filter_type.clear()
        self.filter_type.addItem("All Script Types", "all")
        types = sorted({row.get("script_type", "Unknown") for row in self._rows})
        for label in types:
            self.filter_type.addItem(label, label)
        if current_type in {"all", *types}:
            index = self.filter_type.findData(current_type)
            if index >= 0:
                self.filter_type.setCurrentIndex(index)
        else:
            self.filter_type.setCurrentIndex(0)
        self._building_filters = False

    # ------------------------------------------------------------------
    def _apply_filters(self) -> None:
        if self._building_filters:
            return
        script_type = self.filter_type.currentData() or "all"
        last_run = self.filter_last_run.currentData() or "any"
        score_bucket = self.filter_score.currentData() or "all"
        filtered = _filter_metrics_rows(
            self._rows,
            script_type=script_type,
            last_run=last_run,
            score_bucket=score_bucket,
        )
        self._filtered_rows = filtered
        self._populate_table(filtered)
        self._update_distribution_chart(filtered if filtered else self._rows)
        if filtered:
            QTimer.singleShot(0, lambda: self._select_first_row())
        else:
            self._update_history_plot(None)

    # ------------------------------------------------------------------
    def _select_first_row(self) -> None:
        if self.table.rowCount() and not self.table.selectedItems():
            self.table.selectRow(0)

    # ------------------------------------------------------------------
    def _populate_table(self, rows: Sequence[Mapping[str, Any]]) -> None:
        self.table.setRowCount(len(rows))
        for idx, row in enumerate(rows):
            script_path = str(row.get("script_path", ""))
            component = str(row.get("component", ""))
            script_type = str(row.get("script_type", "Unknown"))
            last_run_text = self._format_last_run(row)
            errors = int(row.get("error_count") or 0)
            score = float(row.get("score") or 0.0)
            bucket = row.get("score_bucket", "unknown")
            score_label = _SCORE_BUCKET_LABELS.get(bucket, bucket.title())

            items = [
                QTableWidgetItem(script_path),
                QTableWidgetItem(component),
                QTableWidgetItem(script_type),
                QTableWidgetItem(last_run_text),
                QTableWidgetItem(str(errors)),
                QTableWidgetItem(f"{score:.2f} — {score_label}"),
            ]
            for col, item in enumerate(items):
                if col == 0:
                    item.setData(Qt.UserRole, script_path)
                item.setFlags(item.flags() & ~Qt.ItemIsEditable)
                self.table.setItem(idx, col, item)

    # ------------------------------------------------------------------
    def _format_last_run(self, row: Mapping[str, Any]) -> str:
        bucket = row.get("last_run_bucket")
        if bucket == "never":
            return _LAST_RUN_LABELS["never"]
        ts = row.get("last_run_ts")
        if ts in (None, ""):
            return _LAST_RUN_LABELS.get(str(bucket), "Unknown")
        try:
            timestamp = float(ts)
        except (TypeError, ValueError):
            return _LAST_RUN_LABELS.get(str(bucket), "Unknown")
        relative = self._relative_time(timestamp)
        dt = datetime.fromtimestamp(timestamp, tz=timezone.utc).astimezone()
        return f"{relative} ({dt.strftime('%Y-%m-%d %H:%M')})"

    # ------------------------------------------------------------------
    def _relative_time(self, timestamp: float) -> str:
        delta = max(0.0, self._summary_time - float(timestamp))
        if delta < 60:
            return "Just now"
        if delta < 3600:
            minutes = int(delta // 60)
            return f"{minutes}m ago"
        if delta < 86400:
            hours = int(delta // 3600)
            return f"{hours}h ago"
        days = int(delta // 86400)
        return f"{days}d ago"

    # ------------------------------------------------------------------
    def _update_stats(self) -> None:
        components = {row["component"] for row in self._rows}
        total_scripts = len(self._rows)
        avg_score = sum(row.get("score", 0.0) for row in self._rows)
        avg_value = (avg_score / total_scripts) if total_scripts else 0.0
        self._components_label.setText(f"Components: {len(components)}")
        self._scripts_label.setText(f"Scripts: {total_scripts}")
        self._score_label.setText(f"Average Score: {avg_value:.2f}")
        self._generated_label.setText(f"Generated: {self._format_timestamp(self._summary_time)}")

    # ------------------------------------------------------------------
    def _format_timestamp(self, ts: float) -> str:
        dt = datetime.fromtimestamp(ts, tz=timezone.utc).astimezone()
        return dt.strftime("%Y-%m-%d %H:%M")

    # ------------------------------------------------------------------
    def _handle_selection_changed(self) -> None:
        selected = self.table.selectedItems()
        if not selected:
            self._update_history_plot(None)
            return
        script_path = selected[0].data(Qt.UserRole)
        self._update_history_plot(script_path)

    # ------------------------------------------------------------------
    def _update_distribution_chart(self, rows: Sequence[Mapping[str, Any]]) -> None:
        if not pg or self._distribution_plot is None:
            return
        counts = _score_distribution(rows)
        self._distribution_plot.clear()
        keys = ["healthy", "watch", "critical", "unknown"]
        colors = {
            "healthy": "#1E5AFF",
            "watch": "#f2c744",
            "critical": "#ef5b68",
            "unknown": "#6b7a90",
        }
        ticks = []
        max_height = 1
        for idx, key in enumerate(keys):
            height = counts.get(key, 0)
            max_height = max(max_height, height)
            ticks.append((idx, _SCORE_BUCKET_LABELS.get(key, key.title())))
            if BarGraphItem is None:
                continue
            bar = BarGraphItem(
                x=[idx],
                height=[height],
                width=0.6,
                brush=pg.mkBrush(colors[key]),
                pen=pg.mkPen(colors[key]),
            )
            self._distribution_plot.addItem(bar)
        axis = self._distribution_plot.getAxis("bottom")
        if axis:
            axis.setTicks([ticks])
        self._distribution_plot.setYRange(0, max_height + 1)

    # ------------------------------------------------------------------
    def _update_history_plot(self, script_path: Optional[str]) -> None:
        if not pg or self._history_plot is None:
            return
        self._history_plot.clear()
        if not script_path:
            self._history_hint.setText("Select a script to view trend details.")
            return
        history = self._history_by_script.get(str(script_path), [])
        if not history:
            self._history_hint.setText("No historical scores recorded for this script yet.")
            return
        points = []
        for entry in history:
            try:
                ts = float(entry.get("timestamp"))
            except (TypeError, ValueError):
                continue
            score = entry.get("score")
            if score is None:
                continue
            try:
                val = float(score)
            except (TypeError, ValueError):
                continue
            points.append((ts, val))
        if not points:
            self._history_hint.setText("History available but contains no numeric scores.")
            return
        xs, ys = zip(*points)
        self._history_plot.plot(
            x=list(xs),
            y=list(ys),
            pen=pg.mkPen(self.t.accent, width=2),
            symbol="o",
            symbolBrush=pg.mkBrush(self.t.accent_hov),
        )
        self._history_hint.setText(str(script_path))

# --------------------------------------------------------------------------------------
# Desktop icons (no OS drag-out; internal only)
# --------------------------------------------------------------------------------------
class DesktopIcon(QToolButton):
    request_open = Signal(str)
    request_move_to_folder = Signal(str, str)  # src, dst_folder
    def __init__(self, theme: Theme, path: str, parent: QWidget, grid_size: Tuple[int, int]):
        super().__init__(parent)
        self.t = theme
        self.path = path
        self.grid_size = grid_size
        self.setSizePolicy(QSizePolicy.Fixed, QSizePolicy.Fixed)
        self.setFixedSize(QSize(*grid_size))
        self.setAcceptDrops(False)  # containment: icons themselves do not accept external drops
        self.setAutoRaise(True)
        self.setToolButtonStyle(Qt.ToolButtonTextUnderIcon)
        base = os.path.basename(path)
        self._caption_base = os.path.splitext(base)[0] if os.path.isfile(path) else base
        self._set_icon_size_from_state()
        self.setCursor(Qt.OpenHandCursor)
        self._resolved_icon: Optional[QIcon] = None
        self._resolved_icon_native: bool = False
        self._pick_icon()
        self._drag_active = False
        self._press_pos = QPoint()
        self._moved = False
        self._hovered = False
        self._selected = False
        self._drag_hotspot = QPoint()
        self.setStyleSheet("QToolButton{color:#eaf2ff;}")  # high-contrast text
        self.setFocusPolicy(Qt.ClickFocus)
        self._update_caption_text()
        self._update_tooltip()

    def _set_icon_size_from_state(self):
        st = _load_state()
        sz = st.get("icon_size", "medium")
        if sz == "small": self.setIconSize(QSize(32, 32))
        elif sz == "large": self.setIconSize(QSize(64, 64))
        else: self.setIconSize(QSize(48, 48))
        self._update_caption_text()

    def _pick_icon(self):
        path = Path(self.path)
        icon, native = _icon_for_path(path)
        self._resolved_icon = icon
        self._resolved_icon_native = native
        self.setIcon(icon)
        self._update_tooltip()

    def changeEvent(self, event: QEvent) -> None:  # pragma: no cover - GUI update
        if event.type() == QEvent.FontChange:
            self._update_caption_text()
        super().changeEvent(event)

    def _update_caption_text(self) -> None:
        caption_source = getattr(self, "_caption_base", None)
        if caption_source is None:
            base_name = os.path.basename(self.path)
            caption_source = os.path.splitext(base_name)[0] if os.path.isfile(self.path) else base_name
        formatted = self._format_caption(caption_source)
        self.setText(formatted)

    def _format_caption(self, text: str) -> str:
        cleaned = text.strip()
        if not cleaned:
            return ""
        metrics = QFontMetrics(self.font())
        max_width = max(24, self.grid_size[0] - 12)
        lines: List[str] = []
        remainder = cleaned
        for _ in range(2):
            if not remainder:
                break
            segment, remainder = self._consume_caption_segment(remainder, metrics, max_width)
            if not segment:
                # ensure forward progress even when measuring fails
                segment, remainder = remainder[0], remainder[1:]
            lines.append(metrics.elidedText(segment, Qt.ElideRight, max_width))
        if not lines:
            return ""
        if remainder:
            lines[-1] = metrics.elidedText(lines[-1], Qt.ElideRight, max_width)
        return "\n".join(lines)

    def _consume_caption_segment(self, text: str, metrics: QFontMetrics, max_width: int) -> Tuple[str, str]:
        snippet = text.lstrip()
        if not snippet:
            return "", ""
        consumed = ""
        last_space = -1
        for idx, ch in enumerate(snippet):
            candidate = consumed + ch
            if metrics.horizontalAdvance(candidate) <= max_width or not consumed:
                consumed = candidate
                if ch.isspace():
                    last_space = len(consumed.rstrip())
            else:
                break
        if len(consumed) == len(snippet):
            return consumed.rstrip(), ""
        break_at = last_space if last_space > 0 else len(consumed)
        segment = consumed[:break_at].rstrip()
        remainder = snippet[break_at:].lstrip()
        return segment, remainder

    def _update_tooltip(self) -> None:
        info = QFileInfo(self.path)
        if not info.exists():
            self.setToolTip("")
            return
        display_name = info.fileName() or os.path.basename(self.path)
        if _FILE_ICON_PROVIDER is not None:
            try:
                type_desc = _FILE_ICON_PROVIDER.type(info)
            except Exception:
                type_desc = "File"
        else:
            type_desc = "File folder" if info.isDir() else (info.suffix() or "File")
        created_dt: QDateTime = info.birthTime() if info.birthTime().isValid() else info.created()
        if not created_dt.isValid():
            created_str = "Unknown"
        else:
            created_dt = created_dt.toTimeZone(QDateTime.currentDateTime().timeZone())
            created_str = created_dt.toString("dddd, MMMM d, yyyy h:mm AP")
        tooltip = f"{display_name}\nType: {type_desc}\nDate created: {created_str}"
        self.setToolTip(tooltip)

    def mousePressEvent(self, ev):
        if ev.button() == Qt.LeftButton:
            parent = self.parentWidget()
            if parent and hasattr(parent, "set_active_icon"):
                parent.set_active_icon(self)
            self.setCursor(Qt.ClosedHandCursor)
            self._drag_active = True
            self._press_pos = ev.position().toPoint()
            self._drag_hotspot = QPoint(self._press_pos)
            self._moved = False
        elif ev.button() == Qt.RightButton:
            parent = self.parentWidget()
            if parent and hasattr(parent, "set_active_icon"):
                parent.set_active_icon(self)
        super().mousePressEvent(ev)

    def mouseMoveEvent(self, ev):
        if self._drag_active:
            delta = ev.position().toPoint() - self._press_pos
            if delta.manhattanLength() > QApplication.startDragDistance():
                self._moved = True
                drag = QDrag(self)
                mime = QMimeData()
                mime.setData(_ICON_DRAG_MIME, self.path.encode("utf-8"))
                mime.setData(_ICON_OFFSET_MIME, f"{self._drag_hotspot.x()},{self._drag_hotspot.y()}".encode("utf-8"))
                mime.setUrls([QUrl.fromLocalFile(self.path)])
                drag.setMimeData(mime)
                pixmap = self._build_drag_pixmap()
                drag.setPixmap(pixmap)
                drag.setHotSpot(self._drag_hotspot)
                parent = self.parentWidget()
                if isinstance(parent, DesktopCanvas):
                    parent.begin_icon_drag(self.path)
                drop_actions = Qt.DropActions(Qt.MoveAction | Qt.CopyAction)
                result = drag.exec(drop_actions, Qt.MoveAction)
                if isinstance(parent, DesktopCanvas):
                    parent.end_icon_drag(result, self.path)
                self._drag_active = False
                self.setCursor(Qt.OpenHandCursor)
                return
        super().mouseMoveEvent(ev)

    def mouseReleaseEvent(self, ev):
        if self._drag_active:
            self.setCursor(Qt.OpenHandCursor)
            self._drag_active = False
            self._moved = False
            # Simple clicks fall through so QToolButton handles selection; activation stays in mouseDoubleClickEvent.
        super().mouseReleaseEvent(ev)

    def mouseDoubleClickEvent(self, ev):
        if ev.button() == Qt.LeftButton: self.request_open.emit(self.path)

    def enterEvent(self, event: QEvent) -> None:
        self._hovered = True
        self.update()
        super().enterEvent(event)

    def leaveEvent(self, event: QEvent) -> None:
        self._hovered = False
        self.update()
        super().leaveEvent(event)

    def setSelected(self, selected: bool) -> None:
        if self._selected == selected:
            return
        self._selected = selected
        self.update()

    def isSelected(self) -> bool:
        return self._selected

    def paintEvent(self, event):
        if self._hovered or self._selected:
            painter = QPainter(self)
            painter.setRenderHint(QPainter.Antialiasing)
            rect = self.rect().adjusted(2, 2, -2, -2)
            border_color = QColor(112, 169, 255, 200 if self._selected else 140)
            fill_color = QColor(112, 169, 255, 60 if self._selected else 30)
            painter.setPen(border_color)
            painter.setBrush(fill_color)
            painter.drawRoundedRect(rect, 6, 6)
            painter.end()
        super().paintEvent(event)

    def _build_drag_pixmap(self) -> QPixmap:
        pixmap = self.grab()
        painter = QPainter(pixmap)
        painter.setCompositionMode(QPainter.CompositionMode_SourceAtop)
        painter.fillRect(pixmap.rect(), QColor(64, 128, 255, 120))
        painter.end()
        return pixmap

    # CONTAINMENT: removed any external clipboard or drag-out behavior

    def contextMenuEvent(self, e):
        parent = self.parentWidget()
        if parent and hasattr(parent, "set_active_icon"):
            parent.set_active_icon(self)
        m = QMenu(self)
        act_open = m.addAction("Open")
        act_rename = m.addAction("Rename")
        act_delete = m.addAction("Delete")
        act_props = m.addAction("Properties")
        act = m.exec(e.globalPos())
        if act == act_open:
            handled = False
            parent_obj = self.parent()
            open_cb = getattr(parent_obj, "_open_path_from_icon", None)
            if callable(open_cb):
                try:
                    open_cb(self.path)
                    handled = True
                except Exception as exc:
                    log(f"Context open failed for {self.path}: {exc}", logging.DEBUG)
                    handled = False
            if not handled:
                self.request_open.emit(self.path)
        elif act == act_rename:
            new_name, ok = QInputDialog.getText(self, "Rename", "New name (extensions allowed):", text=os.path.basename(self.path))
            if ok and new_name:
                try:
                    os.rename(self.path, os.path.join(os.path.dirname(self.path), new_name))
                    parent_canvas = self.parentWidget()
                    if isinstance(parent_canvas, DesktopCanvas):
                        parent_canvas.refresh_icons_once()
                    QApplication.processEvents()
                except Exception as exc:
                    QMessageBox.warning(self, "Rename", f"Rename failed: {exc}")
        elif act == act_delete:
            try:
                os.remove(self.path) if os.path.isfile(self.path) else shutil.rmtree(self.path)
                parent_canvas = self.parentWidget()
                if isinstance(parent_canvas, DesktopCanvas):
                    parent_canvas.refresh_icons_once()
                QApplication.processEvents()
            except Exception as exc:
                QMessageBox.warning(self, "Delete", f"Delete failed: {exc}")
        elif act == act_props:
            size = os.path.getsize(self.path) if os.path.isfile(self.path) else sum(f.stat().st_size for f in Path(self.path).rglob('*') if f.is_file())
            QMessageBox.information(self, "Properties", f"Path: {self.path}\nSize: {size} bytes")

# --------------------------------------------------------------------------------------
# Desktop canvas
# --------------------------------------------------------------------------------------
class DesktopCanvas(QWidget):
    def __init__(
        self,
        theme: Theme,
        size: QSize,
        parent: Optional[QWidget] = None,
        core: Optional["VirtualDesktopCore"] = None,
    ):
        super().__init__(parent)
        self.t = theme
        self.resize(size)
        self._core_ref: Optional[Callable[[], Optional["VirtualDesktopCore"]]] = None
        if core is not None:
            self._core_ref = weakref.ref(core)
        else:
            resolved = self._resolve_core()
            if resolved is not None:
                self._core_ref = weakref.ref(resolved)
        self.setAcceptDrops(True)  # Allow internal icon drags; external drops remain disabled via MIME checks
        self._icons: Dict[str, DesktopIcon] = {}
        self._drag_origin_path: Optional[str] = None
        self._internal_drop_paths: set[str] = set()
        self._fswatcher = QFileSystemWatcher(self)
        self._fswatcher.addPath(VDSK_ROOT)
        self._fswatcher.directoryChanged.connect(self._refresh_icons)
        self._fswatcher.fileChanged.connect(lambda _: self._refresh_icons())
        self._grid_size = (96, 96)  # square spacing keeps icons aligned
        self._selected_icon: Optional[DesktopIcon] = None
        self._selected_path: Optional[str] = None
        self._drag_active = False
        self._pending_refresh = False
        self._bg_manager = BackgroundManager(self)
        self._bg_manager.register(BackgroundMode.STATIC, lambda canvas: StaticImageBg(canvas))
        self._bg_manager.register(BackgroundMode.GIF, lambda canvas: GifBg(canvas))
        self._bg_manager.register(BackgroundMode.VIDEO, lambda canvas: VideoBg(canvas))
        self._bg_manager.register(BackgroundMode.GL, lambda canvas: GLViewportBg(canvas))
        self._bg_config = BackgroundConfig.from_state(_load_state().get("background"))
        self._sort_mode = _load_state().get("desktop_sort", "name")
        self._last_sorted_paths: List[str] = []
        self._apply_background_config(self._bg_config, persist=False)
        QTimer.singleShot(0, self._refresh_icons)
        self.setContextMenuPolicy(Qt.CustomContextMenu)
        self.customContextMenuRequested.connect(self._desktop_context)

    def _resolve_core(self) -> Optional["VirtualDesktopCore"]:
        candidate: Optional[QObject] = self.parent()
        while candidate is not None:
            if hasattr(candidate, "open_any_path") and callable(getattr(candidate, "open_any_path", None)):
                return cast("VirtualDesktopCore", candidate)
            candidate = candidate.parent() if isinstance(candidate, QObject) else None
        return None

    def _core(self) -> Optional["VirtualDesktopCore"]:
        if self._core_ref is not None:
            core = self._core_ref()
            if core is not None:
                return core
        resolved = self._resolve_core()
        if resolved is not None:
            self._core_ref = weakref.ref(resolved)
        return resolved

    def _open_path_from_icon(self, path: str) -> None:
        core = self._core()
        if not core:
            log(f"Dropped icon open for {path}: no VirtualDesktopCore", logging.DEBUG)
            return
        try:
            core.open_any_path(path)
        except Exception as exc:
            log(f"Icon open failed for {path}: {exc}", logging.DEBUG)

    def paintEvent(self, _):
        p = QPainter(self); p.setRenderHint(QPainter.Antialiasing)
        r = self.rect()
        # Clean blue desktop. No trim, no inner vignette. High contrast icons ensure readability.
        painted = self._bg_manager.paint(p, r)
        if not painted:
            g = QLinearGradient(r.topLeft(), r.bottomLeft())
            g.setColorAt(0.00, QColor(self.t.desktop_top))
            g.setColorAt(1.00, QColor(self.t.desktop_mid))
            p.fillRect(r, g)

    def resizeEvent(self, ev: QResizeEvent):  # pragma: no cover - trivial wrapper
        super().resizeEvent(ev)
        self._bg_manager.resize(ev.size())

    def _refresh_icons(self):
        if self._drag_active:
            self._pending_refresh = True
            return
        self._do_refresh_icons()

    def refresh_icons_once(self) -> None:
        if self._drag_active:
            self._pending_refresh = True
            return
        self._do_refresh_icons()

    def begin_icon_drag(self, path: str) -> None:
        if self._drag_active:
            return
        self._drag_active = True
        self._drag_origin_path = self._normalize_drop_path(path)
        self._internal_drop_paths.clear()

    def _register_internal_drop(self, path: str) -> None:
        normalized = self._normalize_drop_path(path)
        if normalized:
            self._internal_drop_paths.add(normalized)

    def _normalize_drop_path(self, path: str) -> Optional[str]:
        try:
            return str(Path(path).resolve())
        except Exception:
            try:
                return os.path.abspath(path)
            except Exception:
                return None

    def end_icon_drag(self, action: Qt.DropAction, path: Optional[str]) -> None:
        if not self._drag_active:
            return
        self._drag_active = False
        normalized = self._normalize_drop_path(path) if path else None
        if normalized is None:
            normalized = self._drag_origin_path
        delete_source = False
        workspace_root_str: Optional[str]
        try:
            workspace_root_str = str(Path(VDSK_ROOT).resolve())
        except Exception:
            workspace_root_str = None
        if action == Qt.MoveAction and normalized and _is_contained(normalized):
            if workspace_root_str and normalized == workspace_root_str:
                delete_source = False
            elif normalized not in self._internal_drop_paths:
                delete_source = True
        if delete_source and normalized:
            try:
                resolved = Path(normalized)
                if resolved.is_dir():
                    shutil.rmtree(resolved)
                elif resolved.exists():
                    resolved.unlink()
            except Exception as exc:
                log(f"External move cleanup failed for {normalized}: {exc}", logging.WARNING)
                delete_source = False
        need_refresh = delete_source or self._pending_refresh
        self._pending_refresh = False
        self._internal_drop_paths.clear()
        self._drag_origin_path = None
        if need_refresh:
            self._do_refresh_icons()

    def _do_refresh_icons(self) -> None:
        self._pending_refresh = False
        self._core()  # ensure we attempt to cache a core reference before wiring callbacks
        current = set(self._icons.keys())
        want_paths = [str(p) for p in self._sorted_workspace_entries()]
        self._last_sorted_paths = want_paths
        want_set = set(want_paths)
        changed = False
        for path in list(current - want_set):
            btn = self._icons.pop(path, None)
            if not btn:
                continue
            btn.setParent(None)
            btn.deleteLater()
            if self._selected_path == path:
                self._selected_icon = None
                self._selected_path = None
            changed = True
        for path in want_paths:
            if path in self._icons:
                continue
            btn = DesktopIcon(self.t, path, self, self._grid_size)
            btn.request_open.connect(self._open_path_from_icon)
            btn.request_move_to_folder.connect(self._move_file_to_folder)
            btn.show()
            btn.lower()
            self._icons[path] = btn
            pos = self.restore_icon_position(path)
            if pos is None:
                idx = len(self._icons) - 1
                cols = max(1, int((self.width() - GRID_ORIGIN_X * 2) / self._grid_size[0]))
                row, col = divmod(idx, cols)
                btn.move(
                    GRID_ORIGIN_X + col * self._grid_size[0],
                    GRID_ORIGIN_Y + row * self._grid_size[1],
                )
            else:
                btn.move(pos)
            changed = True
        for path, btn in self._icons.items():
            btn._set_icon_size_from_state()
            btn.setSelected(path == self._selected_path)
            try:
                btn.lower()
            except Exception:
                pass
            if path == self._selected_path:
                self._selected_icon = btn
        if changed:
            if self._sort_mode in {"type", "date"}:
                self._arrange_icons()
            self._notify_workspace_changed()
        parent = self.parent()
        if parent and hasattr(parent, "_iter_cards"):
            try:
                cards = list(parent._iter_cards())  # type: ignore[attr-defined]
            except Exception:
                cards = []
            for card in cards:
                try:
                    card.raise_()
                except Exception:
                    pass
        QApplication.processEvents()

    def _sorted_workspace_entries(self) -> List[Path]:
        try:
            entries = list(Path(VDSK_ROOT).iterdir())
        except Exception as exc:
            log(f"list workspace failed: {exc}", logging.DEBUG)
            return []
        mode = self._sort_mode if self._sort_mode in {"name", "type", "date"} else "name"
        def base_key(p: Path) -> int:
            return 0 if p.is_dir() else 1

        if mode == "type":
            entries.sort(key=lambda p: (base_key(p), p.suffix.lower(), p.name.lower()))
        elif mode == "date":
            def mtime(path: Path) -> float:
                try:
                    return float(path.stat().st_mtime)
                except Exception:
                    return 0.0
            entries.sort(key=lambda p: (base_key(p), -mtime(p), p.name.lower()))
        else:
            entries.sort(key=lambda p: (base_key(p), p.name.lower()))
        return entries

    def _notify_workspace_changed(self) -> None:
        core = self.parent()
        if core and hasattr(core, "mark_start_index_stale"):
            try:
                core.mark_start_index_stale()
            except Exception:
                pass

    def _current_icon_size(self) -> str:
        return str(_load_state().get("icon_size", "medium"))

    def _set_sort_mode(self, mode: str) -> None:
        target = mode if mode in {"name", "type", "date"} else "name"
        if target == self._sort_mode:
            return
        self._sort_mode = target
        st = _load_state()
        st["desktop_sort"] = target
        _save_state(st)
        self._refresh_icons()
        self._arrange_icons()

    def _arrange_icons(self) -> None:
        if not self._icons:
            return
        paths = self._last_sorted_paths or [str(p) for p in self._sorted_workspace_entries()]
        cols = max(1, int((self.width() - GRID_ORIGIN_X * 2) / self._grid_size[0]))
        for idx, path in enumerate(paths):
            btn = self._icons.get(path)
            if not btn:
                continue
            row, col = divmod(idx, cols)
            pos = QPoint(
                GRID_ORIGIN_X + col * self._grid_size[0],
                GRID_ORIGIN_Y + row * self._grid_size[1],
            )
            btn.move(pos)
            self.save_icon_position(path, pos)

    def _unique_path(self, base_name: str, extension: str = "") -> Path:
        candidate = Path(VDSK_ROOT) / f"{base_name}{extension}"
        if not candidate.exists():
            return candidate
        idx = 1
        while True:
            alt = Path(VDSK_ROOT) / f"{base_name} ({idx}){extension}"
            if not alt.exists():
                return alt
            idx += 1

    def _create_text_file(self, base_name: str, extension: str, contents: str = "") -> None:
        try:
            path = self._unique_path(base_name, extension)
            path.write_text(contents, encoding="utf-8")
            self.refresh_icons_once()
        except Exception as exc:
            log(f"new file failed: {exc}", logging.WARNING)

    def _move_file_to_folder(self, src: str, dst: str):
        try:
            shutil.move(src, dst)
            self.refresh_icons_once()
        except Exception as e:
            log(f"move failed: {e}", logging.WARNING)

    def save_icon_position(self, path: str, pos: QPoint):
        st = _load_state()
        st.setdefault("icon_pos", {})[path] = [pos.x(), pos.y()]
        _save_state(st)

    def restore_icon_position(self, path: str) -> Optional[QPoint]:
        st = _load_state()
        xy = st.get("icon_pos", {}).get(path)
        if not xy: return None
        try:
            return QPoint(int(xy[0]), int(xy[1]))
        except Exception:
            return None

    def set_active_icon(self, icon: Optional[DesktopIcon]) -> None:
        if icon is self._selected_icon:
            if icon is not None and not icon.isSelected():
                icon.setSelected(True)
                self._selected_path = icon.path
            return
        if self._selected_icon:
            self._selected_icon.setSelected(False)
        self._selected_icon = icon
        if icon is None:
            self._selected_path = None
            return
        self._selected_path = icon.path
        icon.setSelected(True)

    def clear_selection(self) -> None:
        self.set_active_icon(None)

    def mousePressEvent(self, ev):  # pragma: no cover - GUI interaction
        if ev.button() == Qt.LeftButton:
            child = self.childAt(ev.position().toPoint()) if hasattr(ev, "position") else self.childAt(ev.pos())
            if not isinstance(child, DesktopIcon):
                self.clear_selection()
        super().mousePressEvent(ev)

    def dragEnterEvent(self, event):  # pragma: no cover - GUI interaction
        mime = event.mimeData()
        if mime.hasFormat(_ICON_DRAG_MIME):
            event.setDropAction(Qt.MoveAction)
            event.accept()
            return
        if self._drop_paths_from_mime(mime):
            event.setDropAction(Qt.CopyAction)
            event.accept()
            return
        event.ignore()

    def dragMoveEvent(self, event):  # pragma: no cover - GUI interaction
        mime = event.mimeData()
        if mime.hasFormat(_ICON_DRAG_MIME):
            event.setDropAction(Qt.MoveAction)
            event.accept()
            return
        if self._drop_paths_from_mime(mime):
            event.setDropAction(Qt.CopyAction)
            event.accept()
            return
        event.ignore()

    def dropEvent(self, event):  # pragma: no cover - GUI interaction
        mime = event.mimeData()
        if mime.hasFormat(_ICON_DRAG_MIME):
            try:
                path = bytes(mime.data(_ICON_DRAG_MIME)).decode("utf-8")
            except Exception:
                event.ignore()
                return
            icon = self._icons.get(path)
            if not icon:
                event.ignore()
                return
            offset = QPoint(icon.width() // 2, icon.height() // 2)
            if mime.hasFormat(_ICON_OFFSET_MIME):
                raw = bytes(mime.data(_ICON_OFFSET_MIME)).decode("utf-8")
                try:
                    ox, oy = (int(part) for part in raw.split(",", 1))
                    offset = QPoint(ox, oy)
                except Exception:
                    pass
            drop_point = (event.position().toPoint() if hasattr(event, "position") else event.pos()) - offset
            drop_point = self._clamp_to_bounds(drop_point, icon)
            snapped_point = self._snap_to_grid(drop_point)
            drop_center = event.position().toPoint() if hasattr(event, "position") else event.pos()
            target_folder: Optional[DesktopIcon] = None
            for sib in self._icons.values():
                if sib is icon:
                    continue
                if sib.geometry().contains(drop_center) and os.path.isdir(sib.path):
                    target_folder = sib
                    break
            if target_folder:
                self._register_internal_drop(icon.path)
                icon.request_move_to_folder.emit(icon.path, target_folder.path)
                self.set_active_icon(target_folder)
                event.acceptProposedAction()
                return
            icon.move(snapped_point)
            self.save_icon_position(icon.path, snapped_point)
            self.set_active_icon(icon)
            self._register_internal_drop(icon.path)
            event.acceptProposedAction()
            return

        drop_paths = self._drop_paths_from_mime(mime)
        if not drop_paths:
            event.ignore()
            return
        drop_center = event.position().toPoint() if hasattr(event, "position") else event.pos()
        target_folder: Optional[DesktopIcon] = None
        for candidate in self._icons.values():
            if not os.path.isdir(candidate.path):
                continue
            if candidate.geometry().contains(drop_center):
                target_folder = candidate
                break
        destination_dir: Optional[Path]
        if target_folder is not None:
            try:
                destination_dir = Path(target_folder.path)
            except Exception:
                destination_dir = Path(VDSK_ROOT)
        else:
            destination_dir = Path(VDSK_ROOT)
        drop_point = event.position().toPoint() if hasattr(event, "position") else event.pos()
        imported = self._import_dropped_paths(drop_paths, destination_dir, drop_point=drop_point)
        if not imported:
            event.ignore()
            return
        if target_folder is not None:
            self.set_active_icon(target_folder)
        try:
            dest_resolved = Path(destination_dir).resolve()
        except Exception:
            dest_resolved = Path(VDSK_ROOT).resolve()
        if _is_contained(str(dest_resolved)):
            for created in imported.keys():
                self._register_internal_drop(str(created))
        self.refresh_icons_once()
        if dest_resolved == Path(VDSK_ROOT).resolve():
            for created_path, preferred in imported.items():
                if preferred is None:
                    continue
                try:
                    self.save_icon_position(str(created_path), preferred)
                except Exception as exc:
                    log(f"Import position save failed for {created_path}: {exc}", logging.DEBUG)
                    continue
                icon = self._icons.get(str(created_path))
                if icon is not None:
                    try:
                        icon.move(preferred)
                    except Exception:
                        pass
        event.setDropAction(Qt.CopyAction)
        event.acceptProposedAction()

    def _drop_paths_from_mime(self, mime: QMimeData) -> List[Path]:
        paths: List[Path] = []
        if not mime.hasUrls():
            return paths
        for url in mime.urls():
            if not url.isValid() or not url.isLocalFile():
                continue
            local_path = url.toLocalFile()
            if not local_path:
                continue
            try:
                resolved = Path(local_path).expanduser().resolve()
            except Exception:
                continue
            if not resolved.exists():
                continue
            paths.append(resolved)
        return paths

    def _unique_destination_path(self, dest: Path) -> Path:
        if not dest.exists():
            return dest
        suffix = "".join(dest.suffixes)
        base_name = dest.name[:-len(suffix)] if suffix else dest.name
        parent = dest.parent
        idx = 1
        while True:
            candidate = parent / f"{base_name} ({idx}){suffix}"
            if not candidate.exists():
                return candidate
            idx += 1

    def _import_dropped_paths(
        self,
        paths: Sequence[Path],
        destination_dir: Optional[Union[str, Path]] = None,
        drop_point: Optional[QPoint] = None,
    ) -> Dict[str, Optional[QPoint]]:
        imported: Dict[str, Optional[QPoint]] = {}
        created_paths: List[Path] = []
        target_dir = destination_dir if destination_dir is not None else VDSK_ROOT
        try:
            dest_root = Path(target_dir).expanduser().resolve()
        except Exception as exc:
            log(f"Drop destination resolution failed for {target_dir}: {exc}", logging.DEBUG)
            return imported
        try:
            dest_root.mkdir(parents=True, exist_ok=True)
        except Exception as exc:
            log(f"Drop destination mkdir failed for {dest_root}: {exc}", logging.WARNING)
            return imported
        for source in paths:
            try:
                resolved = source.resolve()
            except Exception:
                continue
            if resolved == dest_root:
                continue
            if resolved.is_dir():
                try:
                    dest_root.relative_to(resolved)
                except Exception:
                    pass
                else:
                    # Prevent copying a directory that already contains the workspace root
                    continue
            destination = self._unique_destination_path(dest_root / resolved.name)
            try:
                if resolved.is_dir():
                    shutil.copytree(resolved, destination)
                else:
                    shutil.copy2(resolved, destination)
            except Exception as exc:
                log(f"Drop copy failed for {resolved}: {exc}", logging.WARNING)
                continue
            created_paths.append(destination)
        if not created_paths:
            return imported
        dest_is_desktop = False
        try:
            dest_is_desktop = dest_root == Path(VDSK_ROOT).resolve()
        except Exception:
            dest_is_desktop = False
        if not drop_point or not dest_is_desktop:
            for path in created_paths:
                imported[str(path)] = None
            return imported
        grid_w, grid_h = self._grid_size
        origin_x, origin_y = GRID_ORIGIN_X, GRID_ORIGIN_Y
        cols = max(1, int((self.width() - origin_x * 2) / grid_w))
        half_cell = QPoint(grid_w // 2, grid_h // 2)
        aligned_point = self._snap_to_grid(drop_point - half_cell)
        base_col = int(round((aligned_point.x() - origin_x) / grid_w)) if grid_w else 0
        base_row = int(round((aligned_point.y() - origin_y) / grid_h)) if grid_h else 0
        base_col = max(0, min(base_col, cols - 1))
        if grid_h:
            base_row = max(0, base_row)
        rect = self.rect()
        max_x = max(origin_x, rect.width() - grid_w)
        max_y = max(origin_y, rect.height() - grid_h)
        start_index = max(0, base_row * cols + base_col)
        for idx, path in enumerate(created_paths):
            target_index = start_index + idx
            target_row = target_index // cols if cols else 0
            target_col = target_index % cols if cols else 0
            x = origin_x + target_col * grid_w
            y = origin_y + target_row * grid_h
            x = max(origin_x, min(x, max_x))
            y = max(origin_y, min(y, max_y))
            imported[str(path)] = QPoint(x, y)
        return imported

    def _clamp_to_bounds(self, point: QPoint, icon: DesktopIcon) -> QPoint:
        rect = self.rect()
        x = max(6, min(point.x(), rect.width() - icon.width() - 6))
        y = max(30, min(point.y(), rect.height() - icon.height() - 30))
        return QPoint(x, y)

    def _snap_to_grid(self, point: QPoint) -> QPoint:
        gx, gy = self._grid_size
        origin_x, origin_y = GRID_ORIGIN_X, GRID_ORIGIN_Y
        snapped_x = int(round((point.x() - origin_x) / gx)) * gx + origin_x
        snapped_y = int(round((point.y() - origin_y) / gy)) * gy + origin_y
        return QPoint(snapped_x, snapped_y)

    def _desktop_context(self, pos: QPoint):
        m = QMenu(self)
        current_size = self._current_icon_size()
        view_m = m.addMenu("View")
        view_actions = {
            "large": view_m.addAction("Large icons"),
            "medium": view_m.addAction("Medium icons"),
            "small": view_m.addAction("Small icons"),
        }
        for key, action in view_actions.items():
            action.setCheckable(True)
            action.setChecked(current_size == key)
            action.triggered.connect(lambda _checked, size=key: self._set_icon_size(size))
        sort_m = m.addMenu("Sort by")
        for key, label in (("name", "Name"), ("type", "Type"), ("date", "Date modified")):
            act = sort_m.addAction(label)
            act.setCheckable(True)
            act.setChecked(self._sort_mode == key)
            act.triggered.connect(lambda _checked, mode=key: self._set_sort_mode(mode))
        m.addAction("Refresh", self._refresh_icons)
        m.addSeparator()
        new_m = m.addMenu("New")
        new_m.addAction("Folder", self._new_folder_desktop)
        new_m.addAction("Text Document", self._new_text_desktop)
        new_m.addAction("Markdown Document", self._new_markdown_desktop)
        new_m.addAction("JSON Document", self._new_json_desktop)
        new_m.addAction("Python File", self._new_python_desktop)
        new_m.addAction("PowerShell Script", self._new_powershell_desktop)
        new_m.addAction("ZIP Archive", self._new_zip_desktop)
        new_m.addAction("Shortcut", self._new_shortcut_desktop)
        m.addSeparator()
        pers_m = m.addMenu("Personalize")
        pers_m.addAction("Solid color", lambda: self._select_background(BackgroundMode.SOLID))
        pers_m.addAction("Image…", lambda: self._select_background(BackgroundMode.STATIC))
        pers_m.addAction("Animated GIF…", lambda: self._select_background(BackgroundMode.GIF))
        pers_m.addAction("Video…", lambda: self._select_background(BackgroundMode.VIDEO))
        pers_m.addAction("Live GL viewport…", lambda: self._select_background(BackgroundMode.GL))
        m.addSeparator()
        m.addAction("Display settings", self._open_display_settings)
        m.addAction("Desktop settings", self._open_desktop_settings)
        m.exec(self.mapToGlobal(pos))

    def _set_icon_size(self, sz: str):
        st = _load_state(); st["icon_size"] = sz; _save_state(st); self._refresh_icons()

    def _new_folder_desktop(self):
        try:
            path = self._unique_path("New Folder")
            path.mkdir()
            self._refresh_icons()
        except Exception as e:
            log(f"new folder failed: {e}", logging.WARNING)

    def _new_text_desktop(self):
        self._create_text_file("New Text Document", ".txt")

    def _new_markdown_desktop(self):
        self._create_text_file("New Markdown Document", ".md", "# New Markdown Document\n\n")

    def _new_json_desktop(self):
        self._create_text_file("New JSON Document", ".json", "{\n\n}\n")

    def _new_python_desktop(self):
        self._create_text_file(
            "New Python File",
            ".py",
            "#!/usr/bin/env python3\n\n\"\"\"New script.\"\"\"\n\n",
        )

    def _new_powershell_desktop(self):
        self._create_text_file("New PowerShell Script", ".ps1", "Write-Host 'Hello from Virtual Desktop'\n")

    def _new_zip_desktop(self):
        try:
            path = self._unique_path("New Archive", ".zip")
            with zipfile.ZipFile(path, "w") as zf:
                pass
            self._refresh_icons()
        except Exception as e:
            log(f"new zip failed: {e}", logging.WARNING)

    def _new_shortcut_desktop(self):
        try:
            path = self._unique_path("New Shortcut", ".shortcut.json")
            payload = {"target": "", "args": [], "working_dir": ""}
            path.write_text(json.dumps(payload, indent=2) + "\n", encoding="utf-8")
            self._refresh_icons()
        except Exception as e:
            log(f"new shortcut failed: {e}", logging.WARNING)

    def _open_display_settings(self):
        core = self.parent()
        if core and hasattr(core, "_open_settings_panel"):
            core._open_settings_panel(section="display")

    def _open_desktop_settings(self):
        core = self.parent()
        if core and hasattr(core, "_open_settings_panel"):
            core._open_settings_panel(section="desktop")

    def background_config(self) -> BackgroundConfig:
        return self._bg_config

    def set_background_config(self, config: BackgroundConfig) -> None:
        self._apply_background_config(config)

    def _apply_background_config(self, config: BackgroundConfig, *, persist: bool = True) -> None:
        self._bg_config = config
        if persist:
            st = _load_state()
            st["background"] = config.to_state()
            _save_state(st)
        if config.mode == BackgroundMode.SOLID or not config.source:
            self._bg_manager.clear()
        else:
            self._bg_manager.apply(config)
        self.update()
        QApplication.processEvents()

    def _select_background(self, mode: BackgroundMode):
        config = BackgroundConfig.from_state(self._bg_config.to_state()) if self._bg_config else BackgroundConfig()
        config.mode = mode
        if mode == BackgroundMode.SOLID:
            config.source = ""
            self._apply_background_config(config)
            return
        path = self.prompt_background_path(mode)
        if not path:
            return
        config.source = path
        if mode in (BackgroundMode.STATIC, BackgroundMode.GIF) and not isinstance(config.fit, BackgroundFit):
            config.fit = BackgroundFit.FILL
        if mode == BackgroundMode.VIDEO:
            config.loop = True
            config.mute = True
        self._apply_background_config(config)

    def _validate_background_path(self, path: str) -> bool:
        core = self.parent()
        allow_external = bool(getattr(core, "allow_external_browse", lambda: False)()) if core else False
        if not _is_contained(path) and not allow_external:
            if core and hasattr(core, "_toast"):
                core._toast("Background must stay inside the workspace.")
            log(f"Blocked background outside workspace: {path}", logging.WARNING)
            return False
        return True

    def validate_background_source(self, path: str) -> bool:
        return self._validate_background_path(path)

    def _background_prompt_details(self, mode: BackgroundMode) -> Tuple[str, str]:
        filters = {
            BackgroundMode.STATIC: "Images (*.png *.jpg *.jpeg *.bmp *.gif)",
            BackgroundMode.GIF: "GIF images (*.gif)",
            BackgroundMode.VIDEO: "Videos (*.mp4 *.mov *.mkv *.avi *.webm)",
            BackgroundMode.GL: "Python Scripts (*.py)",
        }
        captions = {
            BackgroundMode.STATIC: "Choose Background Image",
            BackgroundMode.GIF: "Choose Animated GIF",
            BackgroundMode.VIDEO: "Choose Background Video",
            BackgroundMode.GL: "Choose GL Background Script",
        }
        return filters.get(mode, "*"), captions.get(mode, "Choose Background")

    def prompt_background_path(self, mode: BackgroundMode) -> Optional[str]:
        path_filter, caption = self._background_prompt_details(mode)
        path, _ = _non_native_open_file(self, caption, VDSK_ROOT, path_filter)
        if not path:
            return None
        if not self._validate_background_path(path):
            return None
        return path

# --------------------------------------------------------------------------------------
# Camera viewport
# --------------------------------------------------------------------------------------
class Camera(QScrollArea):
    def __init__(self, content: DesktopCanvas, parent: Optional[QWidget] = None):
        super().__init__(parent)
        self.setWidget(content)
        self.setAcceptDrops(True)
        if self.viewport():
            self.viewport().setAcceptDrops(True)
        # Allow the scroll area to resize the canvas with the viewport so edge drags
        # on the main window immediately reflect in the desktop geometry.
        self.setWidgetResizable(True)
        self.setFrameShape(QFrame.NoFrame)
        self.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        self.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        # Drag-to-pan
        self._dragging = False; self._last = QPoint()
        self.viewport().installEventFilter(self)

    def center_on_widget(self, w: QWidget | None):
        if not w: return
        c = w.geometry().center()
        self.center_on_point(c)

    def center_on_point(self, pt: QPoint):
        cont = self.widget(); vw = self.viewport().size()
        x = max(0, min(pt.x() - vw.width() // 2, max(0, cont.width() - vw.width())))
        y = max(0, min(pt.y() - vw.height() // 2, max(0, cont.height() - vw.height())))
        self.horizontalScrollBar().setValue(x)
        self.verticalScrollBar().setValue(y)

    def pan(self, dx: int, dy: int):
        hs = self.horizontalScrollBar(); vs = self.verticalScrollBar()
        hs.setValue(max(hs.minimum(), min(hs.maximum(), hs.value() + dx)))
        vs.setValue(max(vs.minimum(), min(vs.maximum(), vs.value() + dy)))

    def eventFilter(self, obj, ev):
        if obj is self.viewport():
            if ev.type() == QEvent.Type.Wheel:
                delta = ev.angleDelta()
                steps = delta.y() // 120 if delta.y() else delta.x() // 120
                if ev.modifiers() & Qt.ShiftModifier:
                    self.pan(-int(steps) * 120, 0)
                else:
                    self.pan(0, -int(steps) * 120)
                return True
            if ev.type() == QEvent.MouseButtonPress and ev.button() == Qt.MiddleButton:
                self._dragging = True; self._last = ev.position().toPoint(); return True
            elif ev.type() == QEvent.MouseMove and self._dragging:
                cur = ev.position().toPoint()
                delta = cur - self._last; self._last = cur
                self.pan(-delta.x(), -delta.y()); return True
            elif ev.type() in (QEvent.MouseButtonRelease, QEvent.Leave):
                self._dragging = False
            elif ev.type() in (
                QEvent.Type.DragEnter,
                QEvent.Type.DragMove,
                QEvent.Type.Drop,
            ):
                method_map = {
                    QEvent.Type.DragEnter: "dragEnterEvent",
                    QEvent.Type.DragMove: "dragMoveEvent",
                    QEvent.Type.Drop: "dropEvent",
                }
                method = method_map.get(ev.type())
                if method and self._forward_drag_event(method, ev):
                    return True
        return super().eventFilter(obj, ev)

    # --- Drag and drop bridging -------------------------------------------------
    def _forward_drag_event(self, method: str, event) -> bool:
        canvas = self.widget()
        handler = getattr(canvas, method, None) if canvas else None
        if not callable(handler):
            return False
        try:
            handler(event)
        except Exception:
            return False
        return event.isAccepted()

    def dragEnterEvent(self, event):  # pragma: no cover - GUI interaction
        if self._forward_drag_event("dragEnterEvent", event):
            return
        super().dragEnterEvent(event)

    def dragMoveEvent(self, event):  # pragma: no cover - GUI interaction
        if self._forward_drag_event("dragMoveEvent", event):
            return
        super().dragMoveEvent(event)

    def dropEvent(self, event):  # pragma: no cover - GUI interaction
        if self._forward_drag_event("dropEvent", event):
            return
        super().dropEvent(event)

# --------------------------------------------------------------------------------------
# Taskbar + Start panel
# --------------------------------------------------------------------------------------
class StartPanel(QFrame):
    request_close = Signal()
    cursor_exited = Signal()
    FACETS = [
        ("all", "All"),
        ("apps", "Apps"),
        ("docs", "Docs"),
        ("images", "Images"),
        ("scripts", "Scripts"),
    ]
    _RECENT_KIND_MAP = {
        "text": "docs",
        "image": "images",
        "py_card": "scripts",
        "process": "apps",
        "template": "apps",
        "builtin": "apps",
    }

    def __init__(self, core: "VirtualDesktopCore"):
        super().__init__(core)
        self.core = core
        self.t = core.t
        self.setObjectName("StartPanel")
        self.setAutoFillBackground(False)
        self.setStyleSheet(
            f"""
            QFrame#StartPanel {{
                background:{self.t.start_panel};
                border-top:1px solid {self.t.card_border};
                border-left:1px solid {self.t.card_border};
                border-right:1px solid {self.t.card_border};
                border-top-left-radius:10px;
                border-top-right-radius:10px;
            }}
            QLabel {{ color:{self.t.menu_fg}; }}
            QLineEdit {{
                background:#0b1828; color:#eaf2ff; border:1px solid {self.t.card_border}; border-radius:6px; padding:6px 8px;
            }}
            QToolButton#FacetButton {{
                background:transparent; color:{self.t.menu_fg}; border:1px solid transparent; border-radius:6px; padding:4px 10px;
            }}
            QToolButton#FacetButton:checked {{ background:{self.t.accent}; color:#fff; border:1px solid {self.t.accent}; }}
            QListWidget#RecommendedList {{
                background:#0f1c2d; color:{self.t.menu_fg}; border:1px solid {self.t.card_border}; border-radius:8px; padding:4px;
            }}
            QListWidget#RecommendedList::item {{
                padding:6px 8px; margin:2px 2px; border-radius:6px;
            }}
            QListWidget#RecommendedList::item:hover {{ background:rgba(45, 91, 160, 0.35); }}
            QListWidget#RecommendedList::item:selected {{ background:{self.t.accent}; color:#fff; }}
            QToolButton#PinnedAppButton {{
                background:{self.t.start_tile}; color:{self.t.menu_fg}; border:1px solid {self.t.card_border}; border-radius:8px; padding:8px 6px 6px;
            }}
            QToolButton#PinnedAppButton:hover,
            QToolButton#PinnedAppButton:checked {{
                background:{self.t.accent}; color:#fff; border:1px solid {self.t.accent};
            }}
            QLabel#PinnedTypeLabel {{ color:{self.t.menu_fg}; font:600 11pt 'Cascadia Code'; padding-left:2px; }}
            QPushButton[class="RecentItem"] {{
                background:#1b4fbf; color:#fff; border:1px solid #0d214b; border-radius:6px; padding:8px 10px; text-align:left;
            }}
            QPushButton[class="RecentItem"]:hover {{ background:#2a64ff; }}
            QPushButton[class="ResultItem"] {{
                background:#162438; color:#eaf2ff; border:1px solid {self.t.card_border}; border-radius:8px; padding:6px 9px; text-align:left;
            }}
            QPushButton[class="ResultItem"]:hover {{ background:{self.t.accent}; color:#fff; }}
            QPushButton[class="Power"] {{
                background:{self.t.start_tile}; color:#dfe9ff; border:1px solid {self.t.card_border}; border-radius:8px; padding:10px 16px;
            }}
            QPushButton[class="Power"]:hover {{ background:{self.t.accent}; color:#fff; }}
            QPushButton#Shutdown {{
                background:#E04B4B; color:#fff; border:1px solid #3b0f0f; border-radius:8px; padding:10px 16px;
            }}
            QPushButton#Shutdown:hover {{ background:#ff5c5c; }}
            """
        )
        self.setMinimumHeight(580)
        self._facet = "all"
        self._workspace_items: List[Dict[str, str]] = []
        self._index_stale = True
        self._app_entries = self._build_app_entries()
        self._selected_app_id: Optional[str] = None
        self._icon_buttons: Dict[str, QToolButton] = {}
        self._cursor_inside = False
        self._focus_refresh_pending = True
        self._warm_thread: Optional[threading.Thread] = None
        self._path_icon_cache: Dict[str, QIcon] = {}

        self._search_timer = QTimer(self)
        self._search_timer.setSingleShot(True)
        self._search_timer.setInterval(180)
        self._cursor_exit_timer = QTimer(self)
        self._cursor_exit_timer.setSingleShot(True)
        self._cursor_exit_timer.timeout.connect(self._on_cursor_exit_timeout)
        self.refresh_close_behavior()
        main = QVBoxLayout(self)
        main.setContentsMargins(12, 10, 12, 12)
        main.setSpacing(10)

        search_row = QHBoxLayout(); search_row.setSpacing(8)
        self.search = QLineEdit(self); self.search.setPlaceholderText("Search apps, files, and recents")
        self.search.installEventFilter(self)
        self.search.textChanged.connect(self._on_search_changed)
        self.search.returnPressed.connect(self._run_search)
        self.btn_close = QPushButton("✕"); self.btn_close.setFixedWidth(32)
        self.btn_close.clicked.connect(self.hide)
        search_row.addWidget(self.search, 1)
        search_row.addWidget(self.btn_close, 0)
        main.addLayout(search_row)

        facet_row = QHBoxLayout(); facet_row.setSpacing(6)
        self._facet_buttons: Dict[str, QToolButton] = {}
        for key, label in self.FACETS:
            btn = QToolButton(self)
            btn.setObjectName("FacetButton")
            btn.setText(label)
            btn.setCheckable(True)
            btn.clicked.connect(lambda _checked, f=key: self._set_facet(f))
            if key == self._facet:
                btn.setChecked(True)
            self._facet_buttons[key] = btn
            facet_row.addWidget(btn)
        facet_row.addStretch(1)
        main.addLayout(facet_row)

        self.results_scroll = QScrollArea(self)
        self.results_scroll.setWidgetResizable(True)
        self.results_scroll.setFrameShape(QFrame.NoFrame)
        self.results_scroll.setMinimumHeight(220)
        self.results_scroll.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        self._results_widget = QWidget(self.results_scroll)
        self._results_layout = QVBoxLayout(self._results_widget)
        self._results_layout.setContentsMargins(0, 0, 0, 0)
        self._results_layout.setSpacing(6)
        self.results_scroll.setWidget(self._results_widget)
        self._show_results_placeholder()
        self.results_scroll.setVisible(False)
        main.addWidget(self.results_scroll)

        apps_header = QHBoxLayout(); apps_header.setSpacing(6)
        apps_label = QLabel("Recommended")
        apps_header.addWidget(apps_label)
        apps_header.addStretch(1)
        main.addLayout(apps_header)

        pinned_row = QHBoxLayout(); pinned_row.setSpacing(12)
        self.recommended_list = QListWidget(self)
        self.recommended_list.setObjectName("RecommendedList")
        self.recommended_list.setSelectionMode(QListWidget.SingleSelection)
        self.recommended_list.setVerticalScrollMode(QListWidget.ScrollPerPixel)
        self.recommended_list.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        self.recommended_list.setMinimumWidth(160)
        self.recommended_list.setIconSize(QSize(24, 24))
        self.recommended_list.setSizePolicy(QSizePolicy.Preferred, QSizePolicy.Expanding)
        self.recommended_list.itemActivated.connect(self._on_recent_item_activated)
        pinned_row.addWidget(self.recommended_list, 2)

        right_column = QVBoxLayout(); right_column.setSpacing(6)
        self.apps_type_label = QLabel("Pinned", self)
        self.apps_type_label.setObjectName("PinnedTypeLabel")
        right_column.addWidget(self.apps_type_label, 0)
        self.apps_grid_widget = QWidget(self)
        self.apps_grid_widget.setMinimumWidth(260)
        self.apps_grid_widget.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Preferred)
        self.apps_grid_layout = QGridLayout(self.apps_grid_widget)
        self.apps_grid_layout.setContentsMargins(0, 0, 0, 0)
        self.apps_grid_layout.setSpacing(8)
        self.apps_grid_layout.setAlignment(Qt.AlignLeft | Qt.AlignTop)
        right_column.addWidget(self.apps_grid_widget, 1)
        pinned_row.addLayout(right_column, 3)
        pinned_row.setStretch(0, 2)
        pinned_row.setStretch(1, 3)
        main.addLayout(pinned_row)
        self._rebuild_apps_views()

        self.recent_frame = QFrame(self)
        self.recent_frame.setObjectName("RecentFrame")
        self.recent_layout = QVBoxLayout(self.recent_frame)
        self.recent_layout.setContentsMargins(0, 0, 0, 0)
        self.recent_layout.setSpacing(6)
        self.recent_title = QLabel("Recent")
        self.recent_layout.addWidget(self.recent_title)
        main.addWidget(self.recent_frame)

        self._populate_recent()

        bottom = QHBoxLayout(); bottom.addStretch(1)
        btn_settings = QPushButton("Settings…"); btn_settings.setProperty("class", "Power")
        btn_settings.clicked.connect(self._make_click_handler(core._open_settings_panel))
        btn_console = QPushButton("System Console"); btn_console.setProperty("class", "Power")
        btn_console.clicked.connect(self._make_click_handler(core._open_system_console))
        btn_errors = QPushButton("Error Center"); btn_errors.setProperty("class", "Power")
        btn_errors.clicked.connect(self._make_click_handler(core._open_error_center))
        btn_quit = QPushButton("Shut down"); btn_quit.setObjectName("Shutdown")
        btn_quit.clicked.connect(self._make_click_handler(lambda: core.window().close() if core.window() else None))
        for b in (btn_settings, btn_console, btn_errors, btn_quit):
            b.setMinimumHeight(38)
        bottom.addWidget(btn_settings)
        bottom.addWidget(btn_console)
        bottom.addWidget(btn_errors)
        bottom.addWidget(btn_quit)
        main.addLayout(bottom)

    def enterEvent(self, event):
        self._cursor_inside = True
        self._cancel_cursor_exit_timer()
        super().enterEvent(event)

    def leaveEvent(self, event):
        was_inside = self._cursor_inside
        self._cursor_inside = False
        super().leaveEvent(event)
        if was_inside:
            self._handle_cursor_exit()

    def hideEvent(self, event):
        self._cursor_inside = False
        self._cancel_cursor_exit_timer()
        super().hideEvent(event)

    def _handle_cursor_exit(self) -> None:
        if not self.isVisible():
            return
        if not self._auto_close_enabled():
            self._cancel_cursor_exit_timer()
            return
        if self.search.hasFocus():
            self._cancel_cursor_exit_timer()
            return
        if self.underMouse():
            return
        try:
            global_pos = QCursor.pos()
        except Exception:
            self._cursor_exit_timer.stop()
            self._cursor_exit_timer.start()
            return
        local_pos = self.mapFromGlobal(global_pos)
        if not self.rect().contains(local_pos):
            self._cursor_exit_timer.stop()
            self._cursor_exit_timer.start()

    def eventFilter(self, obj, event):
        if obj is self.search and event and event.type() == QEvent.FocusIn:
            self._refresh_index_if_pending()
            self._cancel_cursor_exit_timer()
        return super().eventFilter(obj, event)

    def _auto_close_enabled(self) -> bool:
        getter = getattr(self.core, "start_panel_auto_close_enabled", None)
        if callable(getter):
            try:
                return bool(getter())
            except Exception:
                return False
        return False

    def _auto_close_delay(self) -> int:
        getter = getattr(self.core, "start_panel_auto_close_delay", None)
        if callable(getter):
            try:
                delay = int(getter())
            except Exception:
                delay = DEFAULT_START_PANEL_AUTO_DELAY_MS
            else:
                if delay <= 0:
                    delay = DEFAULT_START_PANEL_AUTO_DELAY_MS
            return delay
        return DEFAULT_START_PANEL_AUTO_DELAY_MS

    def refresh_close_behavior(self) -> None:
        delay = max(0, int(self._auto_close_delay()))
        if delay <= 0:
            delay = DEFAULT_START_PANEL_AUTO_DELAY_MS
        self._cursor_exit_timer.setInterval(delay)
        if not self._auto_close_enabled():
            self._cursor_exit_timer.stop()

    def _cancel_cursor_exit_timer(self) -> None:
        if self._cursor_exit_timer.isActive():
            self._cursor_exit_timer.stop()

    def _on_cursor_exit_timeout(self) -> None:
        if not self.isVisible():
            return
        if not self._auto_close_enabled():
            self._cancel_cursor_exit_timer()
            return
        if self.underMouse():
            return
        if self.search.hasFocus():
            self._cancel_cursor_exit_timer()
            return
        try:
            global_pos = QCursor.pos()
        except Exception:
            self.cursor_exited.emit()
            return
        local_pos = self.mapFromGlobal(global_pos)
        if not self.rect().contains(local_pos):
            self.cursor_exited.emit()

    def showEvent(self, event):
        self.refresh_close_behavior()
        self._rebuild_apps_views()
        self._populate_recent()
        self._ensure_index()
        self._run_search()
        super().showEvent(event)

    def warm_index_async(self) -> None:
        if self._warm_thread and self._warm_thread.is_alive():
            return

        def _runner():
            try:
                self._ensure_index()
            finally:
                self._warm_thread = None

        thread = threading.Thread(target=_runner, name="StartIndexWarm", daemon=True)
        self._warm_thread = thread
        thread.start()

    def mark_index_stale(self) -> None:
        self._index_stale = True
        self._focus_refresh_pending = True

    def _refresh_index_if_pending(self) -> None:
        if not self._focus_refresh_pending:
            return
        self._focus_refresh_pending = False
        self._ensure_index(force=True)

    def _build_app_entries(self) -> List[Dict[str, object]]:
        style = QApplication.style()
        entries: List[Dict[str, object]] = [
            {
                "id": "explorer",
                "title": "Desktop Explorer",
                "icon": style.standardIcon(QStyle.SP_DirIcon),
                "callback": self.core._open_explorer,
                "kind": "app",
            },
            {
                "id": "tasks",
                "title": "Tasks",
                "icon": style.standardIcon(QStyle.SP_FileDialogListView),
                "callback": self.core._open_tasks,
                "kind": "app",
            },
            {
                "id": "operators",
                "title": "Operator Manager",
                "icon": style.standardIcon(QStyle.SP_DesktopIcon),
                "callback": self.core._open_operator_manager,
                "kind": "app",
            },
            {
                "id": "codex-terminal",
                "title": "Codex Terminal",
                "icon": style.standardIcon(QStyle.SP_DesktopIcon),
                "callback": self.core.open_codex_terminal,
                "kind": "app",
            },
            {
                "id": "codex-terminal-new",
                "title": "New Codex Agent…",
                "icon": style.standardIcon(QStyle.SP_FileDialogNewFolder),
                "callback": self._launch_codex_agent_for_directory,
                "kind": "app",
            },
            {
                "id": "template-terminal",
                "title": "Template Terminal",
                "icon": style.standardIcon(QStyle.SP_ComputerIcon),
                "callback": lambda: self.core.toggle_template_terminal(True),
                "kind": "app",
            },
            {
                "id": "load-script",
                "title": "Load Script as Card…",
                "icon": style.standardIcon(QStyle.SP_FileDialogDetailedView),
                "callback": self.core._load_script_dialog,
                "kind": "app",
            },
        ]

        if self.core.has_user_guided_notes():
            notes_entry = {
                "id": "user-guided-notes",
                "title": "User-Guided Notes",
                "icon": style.standardIcon(QStyle.SP_FileDialogDetailedView),
                "callback": self.core._open_user_guided_notes,
                "kind": "app",
            }
            insert_pos = max(0, len(entries) - 1)
            entries.insert(insert_pos, notes_entry)

        system_entry = {
            "id": "system-overview",
            "title": "System Overview",
            "icon": style.standardIcon(QStyle.SP_DesktopIcon),
            "callback": self.core._open_system_overview,
            "kind": "app",
        }
        entries = [e for e in entries if e.get("id") != system_entry["id"]]
        entries.insert(2, system_entry)
        return entries

    def _launch_codex_agent_for_directory(self) -> None:
        start_dir = workspace_root()
        chosen = _non_native_open_dir(
            self,
            "Select Codex workspace",
            start_dir or SCRIPT_DIR,
        )
        if not chosen:
            return
        script_path = self.core._resolve_codex_terminal_path()
        if not script_path:
            QMessageBox.information(self, "Codex", "Codex_Terminal.py not found.")
            return
        workspace = os.path.abspath(chosen)
        previous_env = os.environ.get("CODEX_WORKSPACE")
        os.environ["CODEX_WORKSPACE"] = workspace
        icon = QApplication.style().standardIcon(QStyle.SP_DesktopIcon)
        try:
            card = self.core._load_python_as_card(
                script_path,
                persist_key=f"{script_path}:{workspace}",
                nice_title="Codex Terminal",
                task_profile="codex-terminal",
                task_icon=icon,
                task_tooltip=f"Workspace: {workspace}",
            )
        except Exception:
            if previous_env is None:
                os.environ.pop("CODEX_WORKSPACE", None)
            else:
                os.environ["CODEX_WORKSPACE"] = previous_env
            raise
        if card is None:
            if previous_env is None:
                os.environ.pop("CODEX_WORKSPACE", None)
            else:
                os.environ["CODEX_WORKSPACE"] = previous_env
            return

        def _restore_env(_=None) -> None:
            if os.environ.get("CODEX_WORKSPACE") != workspace:
                return
            if previous_env is None:
                os.environ.pop("CODEX_WORKSPACE", None)
            else:
                os.environ["CODEX_WORKSPACE"] = previous_env

        card.closed.connect(_restore_env)

    def _make_click_handler(self, callback: Callable[[], None]):
        def handler(_=False):
            self.hide()
            try:
                callback()
            except Exception as exc:
                log(f"Start launch failed: {exc}", logging.DEBUG)
        return handler

    def _rebuild_apps_views(self) -> None:
        recents = self._recent_entries()
        self.recommended_list.blockSignals(True)
        self.recommended_list.clear()
        for rec in recents:
            title = rec.get("title") or Path(rec.get("path", "")).name or "Recent Item"
            item = QListWidgetItem(title)
            icon = self._icon_for_item("Recent", rec)
            if icon:
                item.setIcon(icon)
            tooltip = rec.get("path") or rec.get("tooltip") or ""
            if tooltip:
                item.setToolTip(tooltip)
            item.setData(Qt.UserRole, rec)
            self.recommended_list.addItem(item)
        if not recents:
            placeholder = QListWidgetItem("No recommendations yet.")
            placeholder.setFlags(Qt.NoItemFlags)
            self.recommended_list.addItem(placeholder)
        self.recommended_list.blockSignals(False)
        self.apps_type_label.setText("Pinned")
        self._populate_icon_grid(None, self._selected_app_id)

    def _make_app_button(self, entry: Dict[str, object]) -> QToolButton:
        btn = QToolButton(self)
        btn.setObjectName("PinnedAppButton")
        btn.setIcon(entry.get("icon") if isinstance(entry.get("icon"), QIcon) else QIcon())
        btn.setIconSize(QSize(44, 44))
        btn.setCheckable(True)
        btn.setAutoRaise(False)
        btn.setToolButtonStyle(Qt.ToolButtonTextUnderIcon)
        title = str(entry.get("title") or "")
        btn.setText(title)
        btn.setCursor(Qt.PointingHandCursor)
        btn.setFixedSize(96, 88)
        btn.setFocusPolicy(Qt.TabFocus)
        btn.setToolTip(title)
        btn.clicked.connect(lambda _=False, entry_id=entry.get("id"): self._handle_icon_activated(entry_id))
        return btn

    def _select_entry_by_id(self, entry_id: Optional[str]) -> None:
        if not self._app_entries:
            self._selected_app_id = None
            return
        normalized = entry_id if entry_id and self._entry_by_id(entry_id) else self._app_entries[0]["id"]
        self._selected_app_id = normalized if isinstance(normalized, str) else None
        for entry_key, button in self._icon_buttons.items():
            button.setChecked(entry_key == self._selected_app_id)

    def _populate_icon_grid(self, kind: Optional[str], selected_id: Optional[str]) -> None:
        self._clear_layout(self.apps_grid_layout)
        self._icon_buttons.clear()
        if not self._app_entries:
            self._selected_app_id = None
            return
        if kind:
            normalized = self._normalize_kind(kind)
            matching = [e for e in self._app_entries if self._normalize_kind(e.get("kind")) == normalized]
        else:
            matching = list(self._app_entries)
        if not matching:
            self._selected_app_id = None
            return
        current_id = None
        if selected_id and any(e.get("id") == selected_id for e in matching):
            current_id = selected_id
        else:
            first = matching[0].get("id")
            current_id = first if isinstance(first, str) else None
        cols = max(1, min(4, int(len(matching) ** 0.5) + 1))
        for idx, entry in enumerate(matching):
            btn = self._make_app_button(entry)
            btn.setChecked(entry.get("id") == current_id)
            row, col = divmod(idx, cols)
            self.apps_grid_layout.addWidget(btn, row, col)
            entry_id = entry.get("id")
            if isinstance(entry_id, str):
                self._icon_buttons[entry_id] = btn
        self._selected_app_id = current_id if isinstance(current_id, str) else None

    def _handle_icon_activated(self, entry_id: Optional[str]) -> None:
        if not entry_id:
            return
        entry = self._entry_by_id(entry_id)
        if not entry:
            return
        self._select_entry_by_id(entry_id)
        cb = entry.get("callback")
        if callable(cb):
            self._make_click_handler(cb)()

    def _on_recent_item_activated(self, item: QListWidgetItem) -> None:
        if not item:
            return
        payload = item.data(Qt.UserRole)
        if not isinstance(payload, dict):
            return
        callback = payload.get("callback")
        if callable(callback):
            self._make_click_handler(callback)()
            return
        path = payload.get("path") or payload.get("value")
        if path:
            self._make_click_handler(lambda p=path: self.core.open_any_path(p))()

    def _entry_by_id(self, entry_id: Optional[str]) -> Optional[Dict[str, object]]:
        if not entry_id:
            return None
        for entry in self._app_entries:
            if entry.get("id") == entry_id:
                return entry
        return None

    def _normalize_kind(self, kind: Optional[object]) -> str:
        if not kind:
            return ""
        value = str(kind).strip().lower()
        if value.endswith("s"):
            value = value[:-1]
        return value

    def _kind_label(self, kind: Optional[object]) -> str:
        normalized = self._normalize_kind(kind)
        mapping = {
            "app": "Apps",
            "doc": "Docs",
            "image": "Images",
            "script": "Scripts",
        }
        if not normalized:
            return "Pinned"
        return mapping.get(normalized, normalized.capitalize())

    def _set_facet(self, facet: str) -> None:
        if facet == self._facet:
            return
        if facet not in {f for f, _ in self.FACETS}:
            facet = "all"
        self._facet = facet
        for key, btn in self._facet_buttons.items():
            btn.setChecked(key == facet)
        self._run_search()

    def _on_search_changed(self, _text: str) -> None:
        self._search_timer.start()

    def _run_search(self) -> None:
        self._search_timer.stop()
        query = self.search.text().strip()
        if not query:
            self._clear_layout(self._results_layout)
            self._show_results_placeholder()
            self.results_scroll.setVisible(False)
            return
        self._ensure_index()
        results = self._perform_search(query)
        self._render_results(results)

    def _ensure_index(self, force: bool = False) -> bool:
        if not force and not self._index_stale and self._workspace_items:
            return False
        root = Path(self.core._workspace or VDSK_ROOT)
        self._workspace_items = self._index_workspace(root)
        self._index_stale = False
        return True

    def _index_workspace(self, root: Path) -> List[Dict[str, str]]:
        items: List[Dict[str, str]] = []
        image_exts = {".png", ".jpg", ".jpeg", ".gif", ".bmp"}
        doc_exts = {".txt", ".md", ".json", ".log", ".cfg", ".ini"}
        try:
            for p in root.rglob("*"):
                if p.is_dir():
                    continue
                ext = p.suffix.lower()
                if ext in image_exts:
                    kind = "image"
                elif ext == ".py":
                    kind = "script"
                elif ext in doc_exts:
                    kind = "doc"
                else:
                    kind = "file"
                items.append({"path": str(p), "title": p.name, "kind": kind})
        except Exception as exc:
            log(f"Start index failed: {exc}", logging.DEBUG)
        return items

    def _perform_search(self, query: str) -> Dict[str, List[Dict[str, object]]]:
        out: Dict[str, List[Dict[str, object]]] = {"Apps": [], "Recent": [], "Files": []}
        # Apps
        if self._facet in {"all", "apps"}:
            names = [entry["title"] for entry in self._app_entries]
            for title in self._fuzzy_names(query, names):
                entry = next((e for e in self._app_entries if e["title"] == title), None)
                if entry:
                    out["Apps"].append(entry)
        # Recent
        recents = self._recent_entries()
        filtered_recents = []
        for rec in recents:
            mapped = self._RECENT_KIND_MAP.get(rec.get("kind"), "apps")
            if self._facet in {"all", mapped}:
                filtered_recents.append(rec)
        recent_pairs = [(rec, rec.get("title") or Path(rec.get("path", "")).name) for rec in filtered_recents]
        rec_titles = [name for _, name in recent_pairs]
        for title in self._fuzzy_names(query, rec_titles):
            for rec, rec_name in recent_pairs:
                if rec_name == title:
                    out["Recent"].append(rec)
                    break
        # Files
        if self._facet in {"all", "docs", "images", "scripts"}:
            kinds = {
                "docs": {"doc"},
                "images": {"image"},
                "scripts": {"script"},
                "all": {"doc", "image", "script", "file"},
            }
            allowed = kinds.get(self._facet, kinds["all"])
            pool = [item for item in self._workspace_items if item.get("kind") in allowed]
            names = [item["title"] for item in pool]
            for title in self._fuzzy_names(query, names):
                item = next((it for it in pool if it["title"] == title), None)
                if item:
                    out["Files"].append(item)
        return out

    def _render_results(self, results: Dict[str, List[Dict[str, object]]]) -> None:
        self._clear_layout(self._results_layout)
        has_results = False
        for section in ("Apps", "Recent", "Files"):
            items = results.get(section, [])
            if not items:
                continue
            has_results = True
            header = QLabel(section)
            header.setStyleSheet("font:600 11pt 'Cascadia Code'; color:#eaf2ff;")
            self._results_layout.addWidget(header)
            for item in items[:12]:
                btn = self._make_result_button(section, item)
                self._results_layout.addWidget(btn)
        if not has_results:
            self._show_results_placeholder()
        self.results_scroll.setVisible(has_results)

    def _make_result_button(self, section: str, item: Dict[str, object]) -> QPushButton:
        btn = QPushButton(str(item.get("title", "")), self)
        btn.setProperty("class", "ResultItem")
        icon = self._icon_for_item(section, item)
        if icon:
            btn.setIcon(icon)
            btn.setIconSize(QSize(20, 20))
        subtitle = str(item.get("path") or item.get("tooltip") or "")
        if subtitle:
            btn.setToolTip(subtitle)
        if section == "Apps":
            cb = item.get("callback") if callable(item.get("callback")) else None
        else:
            path = item.get("path") or item.get("value")
            cb = (lambda p=path: self.core.open_any_path(p)) if path else None
        if callable(cb):
            btn.clicked.connect(self._make_click_handler(cb))
        return btn

    def _normalized_item_path(self, item: Mapping[str, object]) -> Optional[str]:
        raw_path = item.get("path") or item.get("value")
        if not isinstance(raw_path, str):
            return None
        candidate = raw_path.strip()
        if not candidate:
            return None
        if candidate.startswith("(builtin") and candidate.endswith(")"):
            return None
        if "://" in candidate:
            return None
        try:
            path_obj = Path(candidate).expanduser()
        except Exception:
            return None
        if not path_obj.is_absolute():
            base = getattr(self.core, "_workspace", None) or VDSK_ROOT
            try:
                path_obj = Path(base).joinpath(path_obj)
            except Exception:
                return None
        try:
            resolved = path_obj.resolve()
        except Exception:
            try:
                resolved = Path(os.path.abspath(str(path_obj)))
            except Exception:
                return None
        return str(resolved)

    def _icon_from_item_path(self, item: Mapping[str, object]) -> Optional[QIcon]:
        kind = str(item.get("kind", ""))
        if kind.lower() == "builtin":
            return None
        normalized = self._normalized_item_path(item)
        if not normalized:
            return None
        cached = self._path_icon_cache.get(normalized)
        if cached is None:
            try:
                icon, _ = _ICON_FOR_PATH_HELPER(Path(normalized))
            except Exception:
                icon = QIcon()
            if not isinstance(icon, QIcon):
                icon = QIcon()
            cached = QIcon(icon)
            self._path_icon_cache[normalized] = cached
        return cached

    def _icon_for_item(self, section: str, item: Dict[str, object]) -> Optional[QIcon]:
        style = QApplication.style()
        path_icon = self._icon_from_item_path(item)
        if path_icon is not None and not path_icon.isNull():
            return path_icon
        if section == "Apps":
            icon = item.get("icon")
            return icon if isinstance(icon, QIcon) else style.standardIcon(QStyle.SP_FileIcon)
        kind = item.get("kind", "")
        if kind == "image":
            return style.standardIcon(QStyle.SP_FileDialogContentsView)
        if kind in {"doc", "text"}:
            return style.standardIcon(QStyle.SP_FileDialogDetailedView)
        if kind == "script":
            return style.standardIcon(QStyle.SP_FileDialogInfoView)
        if path_icon is not None and path_icon.isNull():
            return style.standardIcon(QStyle.SP_FileIcon)
        return style.standardIcon(QStyle.SP_FileIcon)

    def _recent_entries(self) -> List[Dict[str, object]]:
        st = _load_state()
        return st.get("recent", [])[:8]

    def _populate_recent(self):
        while True:
            item = self.recent_layout.takeAt(1)  # preserve title at index 0
            if not item:
                break
            if item.widget():
                item.widget().deleteLater()
        for rec in self._recent_entries():
            title = rec.get("title", "")
            path = rec.get("path", "")
            btn = QPushButton(title or path or "Recent Item", self)
            btn.setProperty("class", "RecentItem")
            btn.setToolTip(path)
            btn.clicked.connect(self._make_click_handler(lambda p=path: self.core.open_any_path(p)))
            self.recent_layout.addWidget(btn)
        if self.recent_layout.count() == 1:
            placeholder = QLabel("No recent items yet.")
            placeholder.setStyleSheet("color:#7c8cab;")
            self.recent_layout.addWidget(placeholder)

    def _fuzzy_names(self, query: str, names: List[str], limit: int = 12) -> List[str]:
        if not query:
            return names[:limit]
        picks = difflib.get_close_matches(query, names, n=limit, cutoff=0.3)
        q = query.lower()
        picks += [name for name in names if q in name.lower()]
        seen: set[str] = set()
        out: List[str] = []
        for name in picks:
            if name in seen:
                continue
            seen.add(name)
            out.append(name)
            if len(out) >= limit:
                break
        return out

    def _clear_layout(self, layout: QLayout) -> None:
        while layout.count():
            item = layout.takeAt(0)
            widget = item.widget()
            if widget:
                widget.deleteLater()
            elif item.layout():
                self._clear_layout(item.layout())

    def _show_results_placeholder(self) -> None:
        placeholder = QLabel("Type to search for apps or files.", self._results_widget)
        placeholder.setStyleSheet("color:#7c8cab; font:italic 10pt 'Cascadia Code';")
        self._results_layout.addWidget(placeholder)

@dataclass
class TaskGroup:
    profile: str
    button: QToolButton
    cards: List[Card]
    index: int = 0
    pinned: bool = False
    removable: bool = True
    display_name: str = ""
    launcher_id: Optional[str] = None
    icon_payload: Optional[str] = None


class Taskbar(QWidget):
    SIDES = {"bottom", "top", "left", "right"}

    request_start_menu = Signal()

    def __init__(self, theme: Theme, parent: Optional[QWidget] = None):
        super().__init__(parent)
        self.t = theme
        self._core = parent
        self._side = "bottom"
        self.setAutoFillBackground(False)
        self.setStyleSheet(f"QWidget{{background:{self.t.taskbar_bg};}}")

        self.row = QBoxLayout(QBoxLayout.LeftToRight)
        self.row.setContentsMargins(8, 4, 8, 4)
        self.row.setSpacing(6)
        self.setLayout(self.row)

        self.start_btn = QPushButton(" ⊞ Start")
        self.start_btn.setCursor(Qt.PointingHandCursor)
        self.start_btn.setStyleSheet(
            f"QPushButton{{background:{self.t.accent}; color:#fff; border:none; border-radius:6px; padding:0 12px;}}"
            f"QPushButton:hover{{background:{self.t.accent_hov};}}"
        )
        self.start_btn.clicked.connect(lambda: self.request_start_menu.emit())

        self._pin_layout = QBoxLayout(QBoxLayout.LeftToRight)
        self._pin_layout.setSpacing(6)
        self._pin_layout.setContentsMargins(0, 0, 0, 0)
        self._pin_layout.setAlignment(Qt.AlignLeft | Qt.AlignVCenter)
        self._pinned_holder = QWidget(self)
        self._pinned_holder.setLayout(self._pin_layout)
        self._pinned_holder.setSizePolicy(QSizePolicy.Maximum, QSizePolicy.Fixed)

        self.tasks = QBoxLayout(QBoxLayout.LeftToRight)
        self.tasks.setSpacing(6)
        self.tasks.setContentsMargins(0, 0, 0, 0)
        self.tasks.setAlignment(Qt.AlignLeft | Qt.AlignVCenter)
        self._tasks_holder = QWidget(self)
        self._tasks_holder.setLayout(self.tasks)
        self._tasks_holder.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Fixed)

        self.clock = QLabel("")
        self.clock.setStyleSheet(f"color:{self.t.taskbar_fg}; font:600 10pt 'Cascadia Code';")
        self.clock.setAlignment(Qt.AlignVCenter | Qt.AlignRight)

        self.row.addWidget(self.start_btn, 0)
        self.row.addWidget(self._pinned_holder, 0)
        self.row.addWidget(self._tasks_holder, 1)
        self.row.addWidget(self.clock, 0)
        self.row.setStretch(self.row.indexOf(self._tasks_holder), 1)

        self.setContextMenuPolicy(Qt.CustomContextMenu)
        self.customContextMenuRequested.connect(self._show_bar_menu)

        self._timer = QTimer(self)
        self._timer.timeout.connect(self._tick)
        self._timer.start(1000)
        self._tick()

        self._groups: Dict[str, TaskGroup] = {}
        self._card_group: Dict[Card, str] = {}
        self._pin_records: Dict[str, Dict[str, Any]] = {}
        self._pin_order: List[str] = []
        self._prune_guard = False

        self.set_side(self._side)

    def configure_pins(self, entries: Sequence[Mapping[str, Any]]) -> None:
        self._pin_records.clear()
        self._pin_order.clear()
        for entry in entries:
            if not isinstance(entry, Mapping):
                continue
            profile = str(entry.get("profile", "")).strip()
            if not profile:
                continue
            title = str(entry.get("title", "")).strip() or profile.title()
            removable = bool(entry.get("removable", True))
            launcher_raw = entry.get("launcher")
            launcher = str(launcher_raw).strip() if isinstance(launcher_raw, str) and launcher_raw.strip() else profile
            icon_payload = entry.get("icon") if isinstance(entry.get("icon"), str) else None
            icon = _decode_icon(icon_payload) if icon_payload else None
            if icon is None:
                icon = _icon_for_profile(profile)
                if icon_payload is None:
                    icon_payload = _encode_icon(icon)
            group = self._ensure_group(
                profile,
                pinned=True,
                display_name=title,
                icon=icon,
                launcher=launcher,
                removable=removable,
                icon_payload=icon_payload,
            )
            self._pin_records[profile] = {
                "profile": profile,
                "title": group.display_name or title,
                "icon": group.icon_payload,
                "removable": removable,
                "launcher": group.launcher_id or launcher,
            }
            if profile not in self._pin_order:
                self._pin_order.append(profile)
            self._refresh_group_tooltip(profile)
        self._refresh_group_metrics()

    def _invoke_core(self, method: str, *args) -> None:
        core = self._core
        if core is None:
            return
        func = getattr(core, method, None)
        if callable(func):
            try:
                func(*args)
            except Exception as exc:
                log(f"Taskbar core call {method} failed: {exc}", logging.DEBUG)

    def _show_bar_menu(self, pos: QPoint) -> None:
        menu = QMenu(self)
        if hasattr(self._core, "_open_settings_panel"):
            menu.addAction("Taskbar settings…", lambda: self._invoke_core("_open_settings_panel"))
        if hasattr(self._core, "_open_explorer"):
            menu.addAction("Open Desktop Explorer", lambda: self._invoke_core("_open_explorer"))
        if hasattr(self._core, "_open_tasks"):
            menu.addAction("Open Tasks", lambda: self._invoke_core("_open_tasks", None))
        if not menu.actions():
            return
        global_pos = self.mapToGlobal(pos)
        menu.exec(global_pos)

    def _ensure_group(
        self,
        profile: str,
        *,
        pinned: bool = False,
        display_name: Optional[str] = None,
        icon: Optional[QIcon] = None,
        launcher: Optional[str] = None,
        removable: Optional[bool] = None,
        icon_payload: Optional[str] = None,
    ) -> TaskGroup:
        group = self._groups.get(profile)
        created = False
        if group is None:
            btn = QToolButton(self)
            btn.setAutoRaise(True)
            btn.setCheckable(True)
            btn.setCursor(Qt.PointingHandCursor)
            btn.setToolButtonStyle(Qt.ToolButtonIconOnly)
            btn.setFocusPolicy(Qt.NoFocus)
            btn.setStyleSheet(
                f"QToolButton{{background:{self.t.task_btn_bg}; border:1px solid {self.t.card_border}; border-radius:8px; padding:4px;}}"
                f"QToolButton:hover{{background:{self.t.task_btn_hv};}}"
                f"QToolButton:checked{{background:{self.t.accent}; border:1px solid {self.t.accent}; color:#fff;}}"
            )
            btn.clicked.connect(lambda _=False, key=profile: self._activate_group(key))
            btn.setContextMenuPolicy(Qt.CustomContextMenu)
            btn.customContextMenuRequested.connect(
                lambda point, key=profile, button=btn: self._show_button_menu(key, button.mapToGlobal(point))
            )
            group = TaskGroup(profile=profile, button=btn, cards=[])
            group.launcher_id = profile
            self._groups[profile] = group
            created = True
        if pinned:
            group.pinned = True
        if removable is not None:
            group.removable = bool(removable)
        if display_name:
            group.display_name = display_name
        if launcher:
            group.launcher_id = launcher
        if icon_payload is not None:
            group.icon_payload = icon_payload
        if icon is not None and not icon.isNull():
            group.button.setIcon(icon)
            if group.pinned and not group.icon_payload:
                payload = _encode_icon(icon)
                if payload:
                    group.icon_payload = payload
        elif group.pinned and group.icon_payload:
            fallback = _decode_icon(group.icon_payload)
            if fallback:
                group.button.setIcon(fallback)
        elif created:
            group.button.setIcon(_icon_for_profile(profile))
        self._move_group_button(group)
        self._update_group_button_metrics(group)
        if group.display_name and not group.cards:
            group.button.setToolTip(group.display_name)
        return group

    def _detach_button(self, button: QToolButton) -> None:
        for layout in (self._pin_layout, self.tasks):
            idx = layout.indexOf(button)
            if idx >= 0:
                layout.takeAt(idx)

    def _move_group_button(self, group: TaskGroup) -> None:
        button = group.button
        self._detach_button(button)
        layout = self._pin_layout if group.pinned else self.tasks
        alignment = Qt.AlignHCenter if self._side in ("left", "right") else Qt.AlignVCenter
        if layout is self._pin_layout and self._side not in ("left", "right"):
            alignment = Qt.AlignVCenter
        layout.addWidget(button, 0, alignment)
        if group.pinned and group.profile not in self._pin_order:
            self._pin_order.append(group.profile)

    def _show_button_menu(self, profile: str, global_pos: QPoint) -> None:
        group = self._groups.get(profile)
        if not group:
            return
        menu = QMenu(self)
        if group.pinned:
            action = menu.addAction("Unpin from taskbar", lambda: self._unpin_profile(profile))
            action.setEnabled(group.removable)
        else:
            menu.addAction("Pin to taskbar", lambda: self._pin_profile(profile))
        if group.cards:
            menu.addSeparator()
            menu.addAction("Close all windows", lambda: self._close_group_cards(profile))
        if menu.actions():
            menu.exec(global_pos)

    def _close_group_cards(self, profile: str) -> None:
        group = self._groups.get(profile)
        if not group:
            return
        for card in list(group.cards):
            try:
                card.close()
            except Exception:
                pass

    def _pin_profile(self, profile: str) -> None:
        group = self._groups.get(profile)
        if not group or group.pinned:
            return
        group.pinned = True
        group.removable = True
        if not group.display_name:
            group.display_name = group.button.toolTip() or profile.title()
        if not group.launcher_id:
            group.launcher_id = profile
        self._move_group_button(group)
        self._store_group_icon_snapshot(group)
        self._pin_records[profile] = {
            "profile": profile,
            "title": group.display_name,
            "icon": group.icon_payload,
            "removable": True,
            "launcher": group.launcher_id,
        }
        if profile not in self._pin_order:
            self._pin_order.append(profile)
        self._refresh_group_tooltip(profile)
        self._refresh_group_metrics()
        self._sync_pin_state()

    def _unpin_profile(self, profile: str) -> None:
        group = self._groups.get(profile)
        if not group or not group.pinned or not group.removable:
            return
        group.pinned = False
        self._pin_records.pop(profile, None)
        self._pin_order = [p for p in self._pin_order if p != profile]
        if group.cards:
            self._move_group_button(group)
            self._refresh_group_tooltip(profile)
            self._refresh_group_metrics()
        else:
            self._remove_group(profile, force=True)
        self._sync_pin_state()

    def _store_group_icon_snapshot(self, group: TaskGroup) -> None:
        icon_payload = _encode_icon(group.button.icon())
        if not icon_payload:
            return
        group.icon_payload = icon_payload
        rec = self._pin_records.get(group.profile)
        if rec is None:
            rec = {
                "profile": group.profile,
                "title": group.display_name or group.profile.title(),
                "removable": group.removable,
                "launcher": group.launcher_id or group.profile,
            }
            self._pin_records[group.profile] = rec
        rec["icon"] = icon_payload

    def _sync_pin_state(self) -> None:
        core = self._core
        if core is None or not hasattr(core, "update_taskbar_pin_state"):
            return
        payload: List[Dict[str, Any]] = []
        for profile in self._pin_order:
            group = self._groups.get(profile)
            if not group or not group.pinned or not group.removable:
                continue
            rec = dict(self._pin_records.get(profile, {}))
            if not rec.get("title"):
                rec["title"] = group.display_name or profile.title()
            if not rec.get("launcher"):
                rec["launcher"] = group.launcher_id or profile
            icon_payload = rec.get("icon") or group.icon_payload or _encode_icon(group.button.icon())
            if icon_payload:
                rec["icon"] = icon_payload
            rec["profile"] = profile
            rec["removable"] = True
            payload.append(rec)
        try:
            core.update_taskbar_pin_state(payload)
        except Exception as exc:
            log(f"Persisting taskbar pins failed: {exc}", logging.DEBUG)

    def _launch_profile(self, profile: str) -> None:
        target = profile
        group = self._groups.get(profile)
        if group and group.launcher_id:
            target = group.launcher_id
        launcher = getattr(self._core, "launch_task_profile", None)
        if callable(launcher):
            try:
                launcher(target)
            except Exception as exc:
                log(f"Taskbar launch failed for {target}: {exc}", logging.DEBUG)

    def side(self) -> str:
        return self._side

    def thickness(self) -> int:
        if self._side in ("left", "right"):
            value = self.width() or self.sizeHint().width()
        else:
            value = self.height() or self.sizeHint().height()
        return int(max(0, value))

    def set_side(self, side: str) -> None:
        normalized = side if side in self.SIDES else "bottom"
        self._apply_side(normalized)
        self._refresh_group_metrics()

    def _apply_side(self, side: str) -> None:
        self._side = side
        horizontal = side in ("bottom", "top")
        if horizontal:
            self.setMinimumHeight(40)
            self.setMaximumHeight(40)
            self.setFixedHeight(40)
            self.setMinimumWidth(0)
            self.setMaximumWidth(16777215)
            self.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Fixed)
            self.row.setDirection(QBoxLayout.LeftToRight)
            self.row.setContentsMargins(8, 4, 8, 4)
            self.row.setSpacing(6)
            self._pin_layout.setDirection(QBoxLayout.LeftToRight)
            self._pin_layout.setAlignment(Qt.AlignLeft | Qt.AlignVCenter)
            self._pinned_holder.setSizePolicy(QSizePolicy.Maximum, QSizePolicy.Fixed)
            self.tasks.setDirection(QBoxLayout.LeftToRight)
            self.tasks.setSpacing(6)
            self.tasks.setAlignment(Qt.AlignLeft | Qt.AlignVCenter)
            self._tasks_holder.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Fixed)
            self.row.setAlignment(self.start_btn, Qt.AlignVCenter)
            self.row.setAlignment(self._pinned_holder, Qt.AlignVCenter)
            self.row.setAlignment(self._tasks_holder, Qt.AlignVCenter)
            self.row.setAlignment(self.clock, Qt.AlignVCenter | Qt.AlignRight)
            self.clock.setAlignment(Qt.AlignVCenter | Qt.AlignRight)
            self.start_btn.setFixedHeight(30)
            self.start_btn.setMinimumWidth(120)
            self.start_btn.setMaximumWidth(220)
        else:
            self.setMinimumWidth(96)
            self.setMaximumWidth(96)
            self.setFixedWidth(96)
            self.setMinimumHeight(0)
            self.setMaximumHeight(16777215)
            self.setSizePolicy(QSizePolicy.Fixed, QSizePolicy.Expanding)
            self.row.setDirection(QBoxLayout.TopToBottom)
            self.row.setContentsMargins(6, 10, 6, 10)
            self.row.setSpacing(10)
            self._pin_layout.setDirection(QBoxLayout.TopToBottom)
            self._pin_layout.setAlignment(Qt.AlignHCenter | Qt.AlignTop)
            self._pinned_holder.setSizePolicy(QSizePolicy.Fixed, QSizePolicy.Expanding)
            self.tasks.setDirection(QBoxLayout.TopToBottom)
            self.tasks.setSpacing(6)
            self.tasks.setAlignment(Qt.AlignHCenter | Qt.AlignTop)
            self._tasks_holder.setSizePolicy(QSizePolicy.Fixed, QSizePolicy.Expanding)
            self.row.setAlignment(self.start_btn, Qt.AlignHCenter)
            self.row.setAlignment(self._pinned_holder, Qt.AlignHCenter)
            self.row.setAlignment(self._tasks_holder, Qt.AlignHCenter)
            self.row.setAlignment(self.clock, Qt.AlignHCenter)
            self.clock.setAlignment(Qt.AlignHCenter)
            self.start_btn.setFixedHeight(48)
            self.start_btn.setMinimumWidth(72)
            self.start_btn.setMaximumWidth(140)
        idx = self.row.indexOf(self._tasks_holder)
        if idx >= 0:
            self.row.setStretch(idx, 1)
        self._refresh_group_metrics()

    def _refresh_group_metrics(self) -> None:
        for group in self._groups.values():
            self._update_group_button_metrics(group)

    def _update_group_button_metrics(self, group: TaskGroup) -> None:
        btn = group.button
        if not btn:
            return
        if self._side in ("left", "right"):
            btn.setIconSize(QSize(36, 36))
            btn.setFixedSize(64, 64)
        else:
            btn.setIconSize(QSize(28, 28))
            btn.setFixedSize(44, 44)
        btn.setSizePolicy(QSizePolicy.Fixed, QSizePolicy.Fixed)
        layout = self._pin_layout if group.pinned else self.tasks
        alignment = Qt.AlignHCenter if self._side in ("left", "right") else Qt.AlignVCenter
        if layout is self._pin_layout and self._side not in ("left", "right"):
            alignment = Qt.AlignVCenter
        layout.setAlignment(btn, alignment)

    def _tick(self):
        self.clock.setText(QDateTime.currentDateTime().toString("hh:mm:ss yyyy-MM-dd"))

    def add_task(self, card: Card):
        profile = getattr(card, "task_profile", None) or card.title_label.text().lower() or f"card-{id(card)}"
        icon = getattr(card, "task_icon", None)
        if icon is None or icon.isNull():
            icon = QApplication.style().standardIcon(QStyle.SP_FileIcon)
        tooltip = getattr(card, "task_tooltip", "") or card.title_label.text()
        group = self._ensure_group(profile, pinned=False)
        if not group.display_name and tooltip:
            group.display_name = tooltip
        if icon and not icon.isNull():
            group.button.setIcon(icon)
            if group.pinned and not group.icon_payload:
                payload = _encode_icon(icon)
                if payload:
                    group.icon_payload = payload
                    rec = self._pin_records.get(profile)
                    if rec is not None:
                        rec["icon"] = payload
        elif group.pinned and group.icon_payload:
            fallback = _decode_icon(group.icon_payload)
            if fallback:
                group.button.setIcon(fallback)
        if group.pinned:
            self._store_group_icon_snapshot(group)
        if tooltip:
            group.button.setToolTip(tooltip)
        elif group.display_name:
            group.button.setToolTip(group.display_name)
        group.cards.append(card)
        group.index = len(group.cards) - 1
        self._card_group[card] = profile
        group.button.setChecked(True)
        self._refresh_group_tooltip(profile)

        card.closed.connect(lambda _=None, c=card: self._remove_card(c))
        card.minimized.connect(lambda _c, c=card: self._on_card_minimized(c))
        card.restored.connect(lambda _c, c=card: self._on_card_restored(c))
        card.destroyed.connect(lambda _=None, c=card: self._remove_card(c))

    def _activate_group(self, profile: str):
        group = self._prune_invalid_cards(profile)
        if not group:
            return
        if group.index >= len(group.cards):
            group.index = max(len(group.cards) - 1, 0)
        if not group.cards:
            if group.pinned:
                self._launch_profile(profile)
            else:
                self._remove_group(profile)
            return
        if len(group.cards) == 1:
            card = group.cards[0]
            if card.isVisible() and card.window() and card.window().isActiveWindow():
                card.hide()
                self._set_group_checked(profile)
            else:
                self._show_card(card)
                group.index = 0
            return
        group.index = (group.index + 1) % len(group.cards)
        card = group.cards[group.index]
        self._show_card(card)

    def _prune_invalid_cards(self, profile: str) -> Optional[TaskGroup]:
        group = self._groups.get(profile)
        if not group:
            return None
        if getattr(self, "_prune_guard", False):
            return group
        if any(card is None for card in group.cards):
            group.cards = [c for c in group.cards if c is not None]
            if not group.cards:
                group.index = 0
                if group.pinned:
                    group.button.setChecked(False)
                    fallback = _decode_icon(group.icon_payload) if group.icon_payload else None
                    if fallback:
                        group.button.setIcon(fallback)
                    else:
                        group.button.setIcon(_icon_for_profile(profile))
                    self._refresh_group_tooltip(profile)
                else:
                    self._remove_group(profile)
                    return None
            else:
                group.index = min(group.index, len(group.cards) - 1)
                self._refresh_group_tooltip(profile)
        invalid_cards = [card for card in list(group.cards) if not _is_card_valid(card)]
        if not invalid_cards:
            return group
        self._prune_guard = True
        try:
            for invalid in invalid_cards:
                self._remove_card(invalid)
        finally:
            self._prune_guard = False
        return self._groups.get(profile)

    def _show_card(self, card: Card):
        if not _is_card_valid(card):
            self._remove_card(card)
            return
        card.show()
        card.raise_()
        card.activateWindow()
        try:
            card.restored.emit(card)
        except Exception:
            pass
        profile = self._card_group.get(card)
        if profile:
            self._set_group_checked(profile)

    def _remove_card(self, card: Card):
        profile = self._card_group.pop(card, None)
        if not profile:
            return
        group = self._groups.get(profile)
        if not group:
            return
        group.cards = [c for c in group.cards if c is not card]
        if not group.cards:
            group.index = 0
            if group.pinned:
                group.button.setChecked(False)
                fallback = _decode_icon(group.icon_payload) if group.icon_payload else None
                if fallback:
                    group.button.setIcon(fallback)
                else:
                    group.button.setIcon(_icon_for_profile(profile))
                self._refresh_group_tooltip(profile)
            else:
                self._remove_group(profile)
        else:
            group.index = min(group.index, len(group.cards) - 1)
            self._refresh_group_tooltip(profile)
            self._set_group_checked(profile)

    def _remove_group(self, profile: str, force: bool = False):
        group = self._groups.get(profile)
        if not group:
            return
        if group.pinned and not force:
            group.cards = []
            group.index = 0
            group.button.setChecked(False)
            fallback = _decode_icon(group.icon_payload) if group.icon_payload else None
            if fallback:
                group.button.setIcon(fallback)
            else:
                group.button.setIcon(_icon_for_profile(profile))
            self._refresh_group_tooltip(profile)
            return
        group = self._groups.pop(profile, None)
        if not group:
            return
        btn = group.button
        if btn:
            self._detach_button(btn)
            btn.setParent(None)
            btn.deleteLater()

    def _set_group_checked(self, profile: str):
        group = self._prune_invalid_cards(profile)
        if not group:
            return
        any_visible = any(_is_card_valid(card) and card.isVisible() for card in group.cards)
        group.button.setChecked(any_visible)

    def _on_card_minimized(self, card: Card):
        profile = self._card_group.get(card)
        if profile:
            self._set_group_checked(profile)

    def _on_card_restored(self, card: Card):
        profile = self._card_group.get(card)
        if profile:
            self._set_group_checked(profile)

    def _refresh_group_tooltip(self, profile: str):
        group = self._groups.get(profile)
        if not group:
            return
        cleaned = []
        for card in group.cards:
            if not _is_card_valid(card):
                continue
            text = card.title_label.text() if hasattr(card.title_label, "text") else card.windowTitle()
            if text:
                cleaned.append(text)
        tooltip = "\n".join(cleaned) if cleaned else (group.display_name or profile)
        group.button.setToolTip(tooltip)

# --------------------------------------------------------------------------------------
# Settings panel (pull former toolbar items here)
# --------------------------------------------------------------------------------------
class SettingsPanel(QWidget):
    def __init__(self, core: "VirtualDesktopCore"):
        super().__init__(core)
        self.core = core
        self.t = core.t
        self.setObjectName("SettingsPanel")
        self._section_frames: Dict[str, QFrame] = {}
        self._pending_section: Optional[str] = None
        self._highlight_timer = QTimer(self)
        self._highlight_timer.setSingleShot(True)
        self._highlight_timer.timeout.connect(self._clear_section_highlight)
        accent_pressed = QColor(self.t.accent).darker(125).name(QColor.HexRgb)
        self.setStyleSheet(
            f"QWidget#SettingsPanel{{background:{self.t.card_bg};border:1px solid {self.t.card_border};border-radius:10px;}}"
            f"QLabel{{color:{self.t.header_fg};}} QComboBox,QLineEdit,QPlainTextEdit,QDoubleSpinBox{{background:#0b1828;color:#eaf2ff;border:1px solid {self.t.card_border};border-radius:6px;padding:6px;}}"
            f"QCheckBox{{color:#eaf2ff;}} QPushButton{{background:{self.t.accent};color:#fff;border:1px solid {self.t.card_border};border-radius:6px;padding:6px 10px;}}"
            f"QPushButton:hover{{background:{self.t.accent_hov};}}"
            f"QPushButton:pressed{{background:{accent_pressed};}}"
            f"QFrame#SectionFrame{{background:#0b1828;border:1px solid {self.t.card_border};border-radius:8px;}}"
            f"QFrame#SectionFrame[highlighted=\"true\"]{{border:2px solid {self.t.accent};background:#12284a;}}"
        )
        main = QVBoxLayout(self)
        main.setContentsMargins(12, 12, 12, 12)
        main.setSpacing(10)

        title = QLabel("Virtual Desktop Settings")
        title.setStyleSheet(f"color:{self.t.header_fg}; font:600 12pt 'Cascadia Code';")
        main.addWidget(title)

        self.scroll = QScrollArea(self)
        self.scroll.setWidgetResizable(True)
        self.scroll.setFrameShape(QFrame.NoFrame)
        main.addWidget(self.scroll, 1)

        content = QWidget(self.scroll)
        self.scroll.setWidget(content)
        content_layout = QVBoxLayout(content)
        content_layout.setContentsMargins(0, 0, 0, 0)
        content_layout.setSpacing(10)

        desktop_frame, desktop_layout = self._make_section("desktop", "Desktop")
        content_layout.addWidget(desktop_frame)

        display_frame, display_layout = self._make_section("display", "Display")
        content_layout.addWidget(display_frame)
        content_layout.addStretch(1)

        icon_row = QHBoxLayout()
        icon_row.addWidget(QLabel("Icon size"))
        self.cmb_icon = QComboBox()
        self.cmb_icon.addItems(["small", "medium", "large"])
        self.cmb_icon.setCurrentText(_load_state().get("icon_size", "medium"))
        icon_row.addWidget(self.cmb_icon)
        icon_row.addStretch(1)
        desktop_layout.addLayout(icon_row)

        sort_row = QHBoxLayout()
        sort_row.addWidget(QLabel("Desktop sort order"))
        self.cmb_sort = QComboBox()
        self.cmb_sort.addItem("Name", "name")
        self.cmb_sort.addItem("Type", "type")
        self.cmb_sort.addItem("Date modified", "date")
        stored_sort = str(_load_state().get("desktop_sort", "name")).lower()
        if stored_sort not in {"name", "type", "date"}:
            stored_sort = "name"
        idx_sort = self.cmb_sort.findData(stored_sort)
        if idx_sort >= 0:
            self.cmb_sort.setCurrentIndex(idx_sort)
        sort_row.addWidget(self.cmb_sort)
        sort_row.addStretch(1)
        desktop_layout.addLayout(sort_row)

        autohide_row = QHBoxLayout()
        autohide_row.addWidget(QLabel("Taskbar autohide"))
        self.chk_autohide = QCheckBox()
        self.chk_autohide.setChecked(bool(_load_state().get("taskbar_autohide", False)))
        autohide_row.addWidget(self.chk_autohide)
        autohide_row.addStretch(1)
        desktop_layout.addLayout(autohide_row)

        side_row = QHBoxLayout()
        side_row.addWidget(QLabel("Taskbar position"))
        self.cmb_taskbar_side = QComboBox()
        for label, value in (
            ("Bottom", "bottom"),
            ("Top", "top"),
            ("Left", "left"),
            ("Right", "right"),
        ):
            self.cmb_taskbar_side.addItem(label, value)
        stored_side = str(_load_state().get("taskbar_side", "bottom")).lower()
        if stored_side not in Taskbar.SIDES:
            stored_side = "bottom"
        idx_side = self.cmb_taskbar_side.findData(stored_side)
        if idx_side >= 0:
            self.cmb_taskbar_side.setCurrentIndex(idx_side)
        side_row.addWidget(self.cmb_taskbar_side)
        side_row.addStretch(1)
        desktop_layout.addLayout(side_row)

        external_row = QHBoxLayout()
        external_row.addWidget(QLabel("Allow browsing outside workspace"))
        self.chk_external = QCheckBox()
        self.chk_external.setChecked(bool(_load_state().get("allow_external_browse", False)))
        external_row.addWidget(self.chk_external)
        external_row.addStretch(1)
        desktop_layout.addLayout(external_row)

        close_cfg = core.start_panel_close_config()
        close_row = QHBoxLayout()
        close_row.addWidget(QLabel("Start menu close behavior"))
        self.cmb_start_close = QComboBox()
        self.cmb_start_close.addItem("Click off (stay open)", "click")
        self.cmb_start_close.addItem("Auto close after delay", "auto")
        idx_close = self.cmb_start_close.findData(close_cfg.get("mode", "click"))
        if idx_close < 0:
            idx_close = 0
        self.cmb_start_close.setCurrentIndex(idx_close)
        close_row.addWidget(self.cmb_start_close)
        self.spin_start_close_delay = QSpinBox()
        self.spin_start_close_delay.setRange(1, 10)
        self.spin_start_close_delay.setSuffix(" s")
        try:
            delay_sec = int(round(close_cfg.get("auto_delay_ms", DEFAULT_START_PANEL_AUTO_DELAY_MS) / 1000))
        except Exception:
            delay_sec = int(round(DEFAULT_START_PANEL_AUTO_DELAY_MS / 1000))
        if delay_sec <= 0:
            delay_sec = 1
        delay_sec = max(1, min(10, delay_sec))
        self.spin_start_close_delay.setValue(delay_sec)
        close_row.addWidget(self.spin_start_close_delay)
        close_row.addStretch(1)
        desktop_layout.addLayout(close_row)

        self.cmb_start_close.currentIndexChanged.connect(self._update_start_close_controls)
        self._update_start_close_controls()

        bg_cfg = core.canvas.background_config()

        scale_row = QHBoxLayout()
        scale_row.addWidget(QLabel("Card scale"))
        self.spin_card_scale = QDoubleSpinBox()
        self.spin_card_scale.setRange(CARD_SCALE_MIN, CARD_SCALE_MAX)
        self.spin_card_scale.setDecimals(2)
        self.spin_card_scale.setSingleStep(0.05)
        self.spin_card_scale.setKeyboardTracking(False)
        self.spin_card_scale.setValue(core.card_scale())
        self.spin_card_scale.setSuffix("×")
        scale_row.addWidget(self.spin_card_scale)
        scale_row.addStretch(1)
        display_layout.addLayout(scale_row)

        mode_row = QHBoxLayout()
        mode_row.addWidget(QLabel("Background mode"))
        self.cmb_bg_mode = QComboBox()
        self.cmb_bg_mode.addItem("Solid (gradient)", BackgroundMode.SOLID)
        self.cmb_bg_mode.addItem("Image", BackgroundMode.STATIC)
        self.cmb_bg_mode.addItem("Animated GIF", BackgroundMode.GIF)
        self.cmb_bg_mode.addItem("Video", BackgroundMode.VIDEO)
        self.cmb_bg_mode.addItem("Live GL viewport", BackgroundMode.GL)
        idx_mode = self.cmb_bg_mode.findData(bg_cfg.mode)
        if idx_mode >= 0:
            self.cmb_bg_mode.setCurrentIndex(idx_mode)
        mode_row.addWidget(self.cmb_bg_mode)
        mode_row.addStretch(1)
        display_layout.addLayout(mode_row)

        path_row = QHBoxLayout()
        path_row.addWidget(QLabel("Background source"))
        self.bg_path_edit = QLineEdit(bg_cfg.source)
        self.bg_path_edit.setReadOnly(True)
        path_row.addWidget(self.bg_path_edit, 1)
        self.btn_bg_browse = QPushButton("Browse…")
        path_row.addWidget(self.btn_bg_browse)
        display_layout.addLayout(path_row)

        fit_row = QHBoxLayout()
        fit_row.addWidget(QLabel("Image fit"))
        self.cmb_bg_fit = QComboBox()
        self.cmb_bg_fit.addItem("Fill", BackgroundFit.FILL)
        self.cmb_bg_fit.addItem("Fit", BackgroundFit.FIT)
        self.cmb_bg_fit.addItem("Center", BackgroundFit.CENTER)
        self.cmb_bg_fit.addItem("Tile", BackgroundFit.TILE)
        idx_fit = self.cmb_bg_fit.findData(bg_cfg.fit)
        if idx_fit >= 0:
            self.cmb_bg_fit.setCurrentIndex(idx_fit)
        fit_row.addWidget(self.cmb_bg_fit)
        fit_row.addStretch(1)
        display_layout.addLayout(fit_row)

        flags_row = QHBoxLayout()
        self.chk_bg_loop = QCheckBox("Loop playback")
        self.chk_bg_loop.setChecked(bool(bg_cfg.loop))
        self.chk_bg_mute = QCheckBox("Mute audio")
        self.chk_bg_mute.setChecked(bool(bg_cfg.mute))
        flags_row.addWidget(self.chk_bg_loop)
        flags_row.addWidget(self.chk_bg_mute)
        flags_row.addStretch(1)
        display_layout.addLayout(flags_row)

        self.cmb_bg_mode.currentIndexChanged.connect(self._update_bg_controls)
        self.btn_bg_browse.clicked.connect(self._browse_background)
        self._update_bg_controls()

        action_row = QHBoxLayout()
        btn_apply = QPushButton("Apply")
        btn_close = QPushButton("Close")
        action_row.addStretch(1)
        action_row.addWidget(btn_apply)
        action_row.addWidget(btn_close)
        main.addLayout(action_row)

        btn_apply.clicked.connect(self._apply)
        btn_close.clicked.connect(self.core._close_settings)

    def _apply(self):
        st = _load_state()
        st["icon_size"] = self.cmb_icon.currentText().strip()
        st["taskbar_autohide"] = bool(self.chk_autohide.isChecked())
        side_data = self.cmb_taskbar_side.currentData()
        side_value = side_data if isinstance(side_data, str) else "bottom"
        if side_value not in Taskbar.SIDES:
            side_value = "bottom"
        st["taskbar_side"] = side_value
        st["allow_external_browse"] = bool(self.chk_external.isChecked())
        sort_data = self.cmb_sort.currentData()
        sort_value = sort_data if isinstance(sort_data, str) else str(self.cmb_sort.currentText()).lower()
        if sort_value not in {"name", "type", "date"}:
            sort_value = "name"
        st["desktop_sort"] = sort_value
        mode_data = self.cmb_start_close.currentData()
        mode_value = mode_data if isinstance(mode_data, str) else "click"
        if mode_value not in ("click", "auto"):
            mode_value = "click"
        delay_seconds = int(self.spin_start_close_delay.value())
        delay_seconds = max(1, min(10, delay_seconds))
        delay_ms = delay_seconds * 1000
        self.core.set_start_panel_close_behavior(mode_value, delay_ms, persist=False)
        st["start_panel_close"] = dict(self.core.start_panel_close_config())
        st["card_scale"] = float(self.spin_card_scale.value())
        _save_state(st)
        self.core.set_taskbar_autohide(st["taskbar_autohide"])
        self.core.set_taskbar_side(st["taskbar_side"], persist=False)
        self.core.set_allow_external_browse(st["allow_external_browse"])
        self.core.canvas._set_sort_mode(sort_value)
        self.core.set_card_scale(st["card_scale"])
        cfg = BackgroundConfig.from_state(self.core.canvas.background_config().to_state())
        mode_data = self.cmb_bg_mode.currentData()
        mode = mode_data if isinstance(mode_data, BackgroundMode) else BackgroundMode.SOLID
        cfg.mode = mode
        if mode == BackgroundMode.SOLID:
            cfg.source = ""
        else:
            cfg.source = self.bg_path_edit.text().strip()
        fit_data = self.cmb_bg_fit.currentData()
        cfg.fit = fit_data if isinstance(fit_data, BackgroundFit) else BackgroundFit.FILL
        cfg.loop = bool(self.chk_bg_loop.isChecked())
        cfg.mute = bool(self.chk_bg_mute.isChecked())
        if cfg.source and not self.core.canvas.validate_background_source(cfg.source):
            return
        self.core.canvas.set_background_config(cfg)
        self.core.canvas._refresh_icons()
        self.core.canvas._arrange_icons()
        self.core._toast("Settings applied.")
        QApplication.processEvents()

    def _current_mode(self) -> BackgroundMode:
        mode_data = self.cmb_bg_mode.currentData()
        return mode_data if isinstance(mode_data, BackgroundMode) else BackgroundMode.SOLID

    def _update_bg_controls(self):
        mode = self._current_mode()
        is_solid = mode == BackgroundMode.SOLID
        is_image = mode in (BackgroundMode.STATIC, BackgroundMode.GIF)
        is_video = mode == BackgroundMode.VIDEO
        self.bg_path_edit.setEnabled(not is_solid)
        self.btn_bg_browse.setEnabled(not is_solid)
        self.cmb_bg_fit.setEnabled(is_image)
        self.chk_bg_loop.setEnabled(mode in (BackgroundMode.GIF, BackgroundMode.VIDEO))
        self.chk_bg_mute.setEnabled(is_video)

    def _update_start_close_controls(self) -> None:
        mode = self.cmb_start_close.currentData()
        self.spin_start_close_delay.setEnabled(mode == "auto")

    def _browse_background(self):
        mode = self._current_mode()
        if mode == BackgroundMode.SOLID:
            return
        path = self.core.canvas.prompt_background_path(mode)
        if path:
            self.bg_path_edit.setText(path)

    def _make_section(self, key: str, title: str) -> Tuple[QFrame, QVBoxLayout]:
        frame = QFrame(self)
        frame.setObjectName("SectionFrame")
        frame.setProperty("highlighted", "false")
        layout = QVBoxLayout(frame)
        layout.setContentsMargins(12, 10, 12, 12)
        layout.setSpacing(8)
        header = QLabel(title)
        header.setStyleSheet(f"color:{self.t.header_fg}; font:600 11pt 'Cascadia Code';")
        layout.addWidget(header)
        self._section_frames[key] = frame
        return frame, layout

    def _set_section_highlight(self, frame: QFrame, highlighted: bool) -> None:
        frame.setProperty("highlighted", "true" if highlighted else "false")
        style = frame.style()
        if style:
            style.unpolish(frame)
            style.polish(frame)
        frame.update()

    def _clear_section_highlight(self) -> None:
        for frame in self._section_frames.values():
            self._set_section_highlight(frame, False)

    def _apply_section_focus(self) -> None:
        if not self._pending_section:
            return
        frame = self._section_frames.get(self._pending_section)
        self._pending_section = None
        if not frame:
            return
        self._clear_section_highlight()
        self._set_section_highlight(frame, True)
        self.scroll.ensureWidgetVisible(frame, 0, 48)
        focus_target = None
        for child in frame.findChildren(QWidget):
            if child.focusPolicy() != Qt.NoFocus:
                focus_target = child
                break
        if focus_target:
            focus_target.setFocus(Qt.OtherFocusReason)
        self._highlight_timer.start(1600)

    def focus_section(self, section: Optional[str]) -> None:
        if not section:
            return
        key = section.lower()
        if key not in self._section_frames:
            return
        self._pending_section = key
        QTimer.singleShot(0, self._apply_section_focus)

    def showEvent(self, event):
        super().showEvent(event)
        if self._pending_section:
            QTimer.singleShot(0, self._apply_section_focus)

# --------------------------------------------------------------------------------------
# Core desktop widget
# --------------------------------------------------------------------------------------
class VirtualDesktopCore(QWidget):
    """Embeddable desktop widget."""
    def __init__(self, workspace: Optional[str] = None, parent: Optional[QWidget] = None):
        super().__init__(parent)
        self.t = Theme()
        self._workspace = workspace or VDSK_ROOT
        self._template_card: Optional[Card] = None
        self._tasks_card: Optional[Card] = None
        self._tasks_widget: Optional["TaskCard"] = None
        self._operator_card: Optional[Card] = None
        self._notes_card: Optional[Card] = None
        self._notes_widget: Optional[QWidget] = None
        self._notes_window: Optional[QMainWindow] = None
        self._notes_card_tag: Optional[str] = None
        self._sys_console: Optional[SystemConsole] = None
        self._error_card: Optional[Card] = None
        self._error_widget: Optional[ErrorCenterCard] = None
        self._system_card: Optional[SystemOverviewCard] = None
        st = _load_state()
        self._card_scale: float = self._clamp_card_scale(st.get("card_scale", 1.0))
        self._allow_external_browse = bool(st.get("allow_external_browse", False))
        self._taskbar_autohide = bool(st.get("taskbar_autohide", False))
        self._taskbar_side = self._normalize_taskbar_side(st.get("taskbar_side", "bottom"))
        self._start_panel_close = self._normalize_start_panel_close(st.get("start_panel_close"))
        self._taskbar_pin_state: List[Dict[str, Any]] = self._normalize_taskbar_pins(st.get("taskbar_pins"))
        tasks_dataset = os.path.join(SCRIPT_DIR, "datasets", "tasks.jsonl")
        self.task_mgr = TaskManager(tasks_dataset, self._workspace)
        if hasattr(self.task_mgr, "start_system_metrics_job"):
            try:
                self.task_mgr.start_system_metrics_job()
            except Exception:
                log("Unable to start system metrics job", logging.DEBUG)
        if hasattr(self.task_mgr, "stop_system_metrics_job"):
            self.destroyed.connect(lambda *_: self.task_mgr.stop_system_metrics_job())

        self._layout = QGridLayout(self)
        self._layout.setContentsMargins(0, 0, 0, 0)
        self._layout.setSpacing(0)

        # Canvas + camera
        canvas_size = self._current_screen_size()
        self.canvas = DesktopCanvas(self.t, canvas_size, self, core=self)
        self.camera = Camera(self.canvas, self)

        # Taskbar
        self.taskbar = Taskbar(self.t, self)
        self.taskbar.configure_pins(self._effective_taskbar_pins())
        self.taskbar.request_start_menu.connect(self._toggle_start_panel)
        self.taskbar.set_side(self._taskbar_side)
        self._apply_taskbar_side()

        # Docked Start panel (hidden initially)
        self.start_panel = StartPanel(self)
        self.start_panel.cursor_exited.connect(self._hide_start_panel)
        self.start_panel.hide()
        self._start_panel_filter_installed = False
        try:
            self.start_panel.warm_index_async()
        except Exception:
            pass
        self._apply_start_panel_close_behavior()
        self.destroyed.connect(lambda *_: self._remove_start_panel_click_filter())

        # Settings panel (card-like small)
        self._settings_card: Optional[Card] = None
        self._settings_panel_widget: Optional[SettingsPanel] = None

        # Automation state
        self._card_seq: int = 0
        self._card_lookup: Dict[int, Card] = {}
        self._last_focus: Optional[Card] = None

        # Debounced screen sync
        self._last_synced_size: Optional[QSize] = None
        self._force_native_taskbar_offset = False
        self._sync_timer = QTimer(self); self._sync_timer.setSingleShot(True)
        self._sync_timer.timeout.connect(self._sync_canvas_to_screen)
        QTimer.singleShot(0, self._sync_canvas_to_screen)

        # Initial workspace
        self.load_workspace(self._workspace)

    # ---------- actions ----------
    def load_workspace(self, folder: Optional[str] = None) -> None:
        folder = folder or self._workspace
        if not folder or not os.path.isdir(folder): return
        if hasattr(self.task_mgr, "set_workspace"):
            try:
                self.task_mgr.set_workspace(folder)
            except Exception:
                log("Task manager workspace update failed", logging.DEBUG)
        self.canvas._refresh_icons()

    def clear_icons(self):
        self.canvas._icons.clear()

    def _iter_cards(self) -> List[Card]:
        return [w for w in self.canvas.findChildren(Card) if isinstance(w, Card)]

    def _enforce_single_card(self, new_card: Card) -> None:
        """Ensure only ``new_card`` remains attached to the desktop."""
        for existing in list(self._iter_cards()):
            if existing is new_card:
                continue
            close = getattr(existing, "_close_card", None)
            try:
                if callable(close):
                    close()
                else:
                    existing.close()
            except Exception:
                try:
                    existing.close()
                except Exception:
                    log(
                        "Failed to close previous card during single-card enforcement",
                        logging.DEBUG,
                    )

    @staticmethod
    def _clamp_card_scale(value: object) -> float:
        try:
            scale = float(value)
        except (TypeError, ValueError):
            return 1.0
        return max(CARD_SCALE_MIN, min(scale, CARD_SCALE_MAX))

    @staticmethod
    def _normalize_taskbar_side(value: object) -> str:
        try:
            side = str(value).lower()
        except Exception:
            return "bottom"
        return side if side in Taskbar.SIDES else "bottom"

    @staticmethod
    def _normalize_start_panel_close(value: object) -> Dict[str, int]:
        config = dict(START_PANEL_CLOSE_DEFAULT)
        if isinstance(value, dict):
            mode = value.get("mode", config["mode"])
            try:
                mode_str = str(mode).lower()
            except Exception:
                mode_str = config["mode"]
            if mode_str not in ("click", "auto"):
                mode_str = config["mode"]
            delay_raw = value.get("auto_delay_ms", config["auto_delay_ms"])
            try:
                delay = int(delay_raw)
            except Exception:
                delay = config["auto_delay_ms"]
            lo = min(START_PANEL_AUTO_DELAY_MIN_MS, START_PANEL_AUTO_DELAY_MAX_MS)
            hi = max(START_PANEL_AUTO_DELAY_MIN_MS, START_PANEL_AUTO_DELAY_MAX_MS)
            delay = max(lo, min(delay, hi))
            config = {"mode": mode_str, "auto_delay_ms": delay}
        return config

    def _normalize_taskbar_pins(self, value: object) -> List[Dict[str, Any]]:
        pins: List[Dict[str, Any]] = []
        if not isinstance(value, Sequence):
            return pins
        seen: set[str] = set()
        for entry in value:
            if not isinstance(entry, Mapping):
                continue
            raw_profile = entry.get("profile")
            try:
                profile = str(raw_profile).strip()
            except Exception:
                profile = ""
            if not profile or profile in seen:
                continue
            seen.add(profile)
            title_raw = entry.get("title")
            title = str(title_raw).strip() if isinstance(title_raw, str) else ""
            if not title:
                title = profile.title()
            icon_payload = entry.get("icon") if isinstance(entry.get("icon"), str) and entry.get("icon") else None
            launcher_raw = entry.get("launcher")
            launcher = (
                str(launcher_raw).strip()
                if isinstance(launcher_raw, str) and launcher_raw.strip()
                else profile
            )
            pins.append(
                {
                    "profile": profile,
                    "title": title,
                    "icon": icon_payload,
                    "removable": True,
                    "launcher": launcher,
                }
            )
        return pins

    def _default_taskbar_pins(self) -> List[Dict[str, Any]]:
        explorer_icon = _encode_icon(_icon_for_profile("explorer"))
        return [
            {
                "profile": "explorer",
                "title": "Desktop Explorer",
                "icon": explorer_icon,
                "removable": False,
                "launcher": "explorer",
            }
        ]

    def _effective_taskbar_pins(self) -> List[Dict[str, Any]]:
        entries: List[Dict[str, Any]] = []
        seen: set[str] = set()
        for base in self._default_taskbar_pins():
            entry = dict(base)
            profile = entry.get("profile", "")
            if isinstance(profile, str) and profile:
                seen.add(profile)
            icon_payload = entry.get("icon") if isinstance(entry.get("icon"), str) else None
            if not icon_payload:
                icon_payload = _encode_icon(_icon_for_profile(str(profile)))
                entry["icon"] = icon_payload
            entries.append(entry)
        for stored in self._taskbar_pin_state:
            profile = stored.get("profile")
            if not isinstance(profile, str) or not profile or profile in seen:
                continue
            title = stored.get("title") if isinstance(stored.get("title"), str) else ""
            if not title:
                title = profile.title()
            icon_payload = stored.get("icon") if isinstance(stored.get("icon"), str) else None
            if not icon_payload:
                icon_payload = _encode_icon(_icon_for_profile(profile))
            launcher_raw = stored.get("launcher")
            launcher = (
                str(launcher_raw).strip()
                if isinstance(launcher_raw, str) and launcher_raw.strip()
                else profile
            )
            entries.append(
                {
                    "profile": profile,
                    "title": title,
                    "icon": icon_payload,
                    "removable": True,
                    "launcher": launcher,
                }
            )
            seen.add(profile)
        return entries

    def update_taskbar_pin_state(self, entries: Sequence[Mapping[str, Any]]) -> None:
        normalized = self._normalize_taskbar_pins(entries)
        self._taskbar_pin_state = normalized
        st = _load_state()
        st["taskbar_pins"] = normalized
        _save_state(st)

    def launch_task_profile(self, profile: Optional[str]) -> None:
        if profile is None:
            return
        try:
            key = str(profile).strip()
        except Exception:
            return
        if not key:
            return
        mapping: Dict[str, Callable[[], None]] = {
            "explorer": self._open_explorer,
            "tasks": lambda: self._open_tasks(),
            "operator-manager": self._open_operator_manager,
            "codex-terminal": self.open_codex_terminal,
            "template-terminal": lambda: self.toggle_template_terminal(True),
            "error-center": self._open_error_center,
            "system-overview": self._open_system_overview,
            "notes": self._open_user_guided_notes,
            "settings": self._open_settings_panel,
        }
        callback = mapping.get(key)
        if callback is None:
            return
        try:
            callback()
        except Exception as exc:
            log(f"Taskbar launch failed for profile {key}: {exc}", logging.DEBUG)

    def start_panel_close_config(self) -> Dict[str, int]:
        return dict(self._start_panel_close)

    def start_panel_close_mode(self) -> str:
        return self._start_panel_close.get("mode", START_PANEL_CLOSE_DEFAULT["mode"])

    def start_panel_auto_close_delay(self) -> int:
        try:
            return int(self._start_panel_close.get("auto_delay_ms", DEFAULT_START_PANEL_AUTO_DELAY_MS))
        except Exception:
            return DEFAULT_START_PANEL_AUTO_DELAY_MS

    def start_panel_auto_close_enabled(self) -> bool:
        return self.start_panel_close_mode() == "auto"

    def set_start_panel_close_behavior(self, mode: str, delay_ms: int, *, persist: bool = True) -> None:
        config = self._normalize_start_panel_close({"mode": mode, "auto_delay_ms": delay_ms})
        if config != self._start_panel_close:
            self._start_panel_close = config
            if persist:
                st = _load_state()
                st["start_panel_close"] = dict(config)
                _save_state(st)
            self._apply_start_panel_close_behavior()
            return
        if persist:
            st = _load_state()
            st["start_panel_close"] = dict(config)
            _save_state(st)

    def _apply_start_panel_close_behavior(self) -> None:
        panel = getattr(self, "start_panel", None)
        if panel:
            try:
                panel.refresh_close_behavior()
            except Exception:
                pass
        if panel and panel.isVisible():
            self._install_start_panel_click_filter()
        else:
            self._remove_start_panel_click_filter()

    def _install_start_panel_click_filter(self) -> None:
        if getattr(self, "_start_panel_filter_installed", False):
            return
        app = QApplication.instance()
        if not app:
            return
        app.installEventFilter(self)
        self._start_panel_filter_installed = True

    def _remove_start_panel_click_filter(self) -> None:
        if not getattr(self, "_start_panel_filter_installed", False):
            return
        app = QApplication.instance()
        if app:
            try:
                app.removeEventFilter(self)
            except Exception:
                pass
        self._start_panel_filter_installed = False

    def eventFilter(self, obj, event):
        panel = getattr(self, "start_panel", None)
        if (
            panel
            and panel.isVisible()
            and event is not None
            and event.type() == QEvent.MouseButtonPress
            and isinstance(event, QMouseEvent)
        ):
            if self._should_close_start_panel_on_click(event):
                self._hide_start_panel()
        return super().eventFilter(obj, event)

    def _should_close_start_panel_on_click(self, event: QMouseEvent) -> bool:
        if event.button() not in (Qt.LeftButton, Qt.RightButton, Qt.MiddleButton):
            return False
        panel = getattr(self, "start_panel", None)
        if not panel or not panel.isVisible():
            return False
        try:
            global_pos = event.globalPosition().toPoint()
        except AttributeError:
            global_pos = event.globalPos()
        local = panel.mapFromGlobal(global_pos)
        return not panel.rect().contains(local)

    def card_scale(self) -> float:
        return float(self._card_scale)

    def _scaled_card_dimensions(self) -> Tuple[int, int]:
        width = max(MIN_CARD_WIDTH, int(round(BASE_CARD_WIDTH * self._card_scale)))
        height = max(MIN_CARD_HEIGHT, int(round(BASE_CARD_HEIGHT * self._card_scale)))
        return width, height

    def _apply_scale_to_card(self, card: Card, ratio: float) -> None:
        if ratio <= 0:
            return
        geom = card.geometry()
        center = geom.center()
        width = max(MIN_CARD_WIDTH, int(round(geom.width() * ratio)))
        height = max(MIN_CARD_HEIGHT, int(round(geom.height() * ratio)))
        card.resize(width, height)
        new_geom = card.geometry()
        new_geom.moveCenter(center)
        x, y = new_geom.x(), new_geom.y()
        parent = card.parentWidget()
        if parent:
            rect = parent.rect()
            max_x = max(8, rect.width() - width - 8)
            max_y = max(8, rect.height() - height - 8)
            x = max(8, min(x, max_x))
            y = max(8, min(y, max_y))
        card.move(x, y)
        setattr(card, "_vd_scale", self._card_scale)

    def set_card_scale(self, scale: float, *, persist: bool = True) -> None:
        target = self._clamp_card_scale(scale)
        if math.isclose(target, self._card_scale, rel_tol=1e-3):
            return
        previous = self._card_scale if self._card_scale else 1.0
        self._card_scale = target
        ratio = target / previous if previous else 1.0
        for card in self._iter_cards():
            self._apply_scale_to_card(card, ratio)
        if persist:
            st = _load_state()
            st["card_scale"] = self._card_scale
            _save_state(st)
        QApplication.processEvents()

    def taskbar_side(self) -> str:
        return getattr(self, "_taskbar_side", "bottom")

    def set_taskbar_side(self, side: str, *, persist: bool = True) -> None:
        normalized = self._normalize_taskbar_side(side)
        previous = getattr(self, "_taskbar_side", "bottom")
        self._taskbar_side = normalized
        self._apply_taskbar_side()
        if persist and normalized != previous:
            st = _load_state()
            st["taskbar_side"] = normalized
            _save_state(st)
        if normalized != previous:
            self._sync_canvas_to_screen()
        else:
            self._position_start_panel()

    def _apply_taskbar_side(self) -> None:
        layout = getattr(self, "_layout", None)
        if layout is None:
            return
        camera = getattr(self, "camera", None)
        taskbar = getattr(self, "taskbar", None)
        if not camera or not taskbar:
            return
        layout.removeWidget(camera)
        layout.removeWidget(taskbar)
        taskbar.set_side(self._taskbar_side)
        # reset stretches for 2x2 grid
        for row in range(2):
            layout.setRowStretch(row, 0)
        for col in range(2):
            layout.setColumnStretch(col, 0)
        side = self._taskbar_side
        if side == "top":
            layout.addWidget(taskbar, 0, 0)
            layout.addWidget(camera, 1, 0)
            layout.setRowStretch(1, 1)
            layout.setColumnStretch(0, 1)
        elif side == "bottom":
            layout.addWidget(camera, 0, 0)
            layout.addWidget(taskbar, 1, 0)
            layout.setRowStretch(0, 1)
            layout.setColumnStretch(0, 1)
        elif side == "left":
            layout.addWidget(taskbar, 0, 0)
            layout.addWidget(camera, 0, 1)
            layout.setColumnStretch(1, 1)
            layout.setRowStretch(0, 1)
        else:  # right
            layout.addWidget(camera, 0, 0)
            layout.addWidget(taskbar, 0, 1)
            layout.setColumnStretch(0, 1)
            layout.setRowStretch(0, 1)
        layout.invalidate()
        if hasattr(self, "start_panel") and self.start_panel.isVisible():
            self._position_start_panel()

    def taskbar_insets(self) -> Dict[str, int]:
        insets = {"left": 0, "top": 0, "right": 0, "bottom": 0}
        bar = getattr(self, "taskbar", None)
        if not bar:
            return insets
        if getattr(self, "_taskbar_autohide", False) and not bar.underMouse():
            thickness = 0
        else:
            thickness = bar.thickness()
        if thickness <= 0:
            return insets
        side = self._taskbar_side
        if side == "left":
            insets["left"] = thickness
        elif side == "right":
            insets["right"] = thickness
        elif side == "top":
            insets["top"] = thickness
        else:
            insets["bottom"] = thickness
        return insets

    def _position_start_panel(self) -> None:
        panel = getattr(self, "start_panel", None)
        if not panel or not panel.isVisible():
            return
        geom = self._compute_start_panel_rect(panel.size())
        panel.setGeometry(geom)
        panel.raise_()

    def _compute_start_panel_rect(self, size: QSize) -> QRect:
        side = self._taskbar_side
        core_rect = self.rect()
        taskbar_rect = self.taskbar.geometry() if self.taskbar else QRect()
        start_pos = self.taskbar.start_btn.mapTo(self, QPoint(0, 0)) if self.taskbar else QPoint(0, 0)
        start_rect = QRect(start_pos, self.taskbar.start_btn.size() if self.taskbar else QSize(0, 0))
        return self._start_panel_geometry_for_side(side, core_rect, taskbar_rect, start_rect, size)

    @staticmethod
    def _start_panel_geometry_for_side(
        side: str,
        core_rect: QRect,
        taskbar_rect: QRect,
        start_rect: QRect,
        panel_size: QSize,
    ) -> QRect:
        normalized = VirtualDesktopCore._normalize_taskbar_side(side)
        width = max(0, int(panel_size.width()))
        height = max(0, int(panel_size.height()))
        pad = 10

        def clamp(value: int, low: int, high: int) -> int:
            if high < low:
                return low
            return max(low, min(value, high))

        max_x = core_rect.width() - width - pad
        max_y = core_rect.height() - height - pad
        start_center = start_rect.center()
        if normalized in ("bottom", "top"):
            anchor_x = clamp(start_center.x() - width // 2, pad, max_x)
            if normalized == "bottom":
                anchor_y = clamp(taskbar_rect.top() - height + 2, pad, max_y)
            else:
                anchor_y = clamp(taskbar_rect.bottom() + 2, pad, max_y)
        else:
            anchor_y = clamp(start_center.y() - height // 2, pad, max_y)
            if normalized == "left":
                anchor_x = clamp(taskbar_rect.right() + 2, pad, max_x)
            else:
                anchor_x = clamp(taskbar_rect.left() - width - 2, pad, max_x)
        return QRect(anchor_x, anchor_y, width, height)

    def _attach_card(
        self,
        card: Card,
        *,
        task_profile: Optional[str] = None,
        task_icon: Optional[QIcon] = None,
        task_tooltip: Optional[str] = None,
    ) -> Card:
        self._enforce_single_card(card)
        card.setParent(self.canvas)
        card_id = self._register_card(card)
        card.setMinimumSize(MIN_CARD_WIDTH, MIN_CARD_HEIGHT)
        if card.width() <= 0 or card.height() <= 0:
            width, height = self._scaled_card_dimensions()
            card.resize(width, height)
        setattr(card, "_vd_scale", self._card_scale)
        self._center_card(card)
        card.show()
        card.raise_()
        card.activateWindow()
        tooltip = task_tooltip or self._card_title(card) or "Card"
        profile = task_profile or self._derive_task_profile(self._card_title(card))
        card.set_task_metadata(profile, task_icon, tooltip)
        card.moved.connect(lambda: self._maybe_refocus(card))
        card.closed.connect(self._on_card_closed)
        self.taskbar.add_task(card)
        self._last_focus = card
        log(f"Card added: {self._card_title(card)} (id={card_id})")
        return card

    def add_card(
        self,
        widget: QWidget,
        title: str = "Card",
        *,
        task_profile: Optional[str] = None,
        task_icon: Optional[QIcon] = None,
        task_tooltip: Optional[str] = None,
    ) -> Card:
        card = Card(self.t, title, self.canvas)
        self._enforce_single_card(card)
        widget.setParent(card.body)
        lay = QVBoxLayout(card.body); lay.setContentsMargins(10, 10, 10, 10); lay.addWidget(widget)
        tooltip = task_tooltip or title
        profile = task_profile or self._derive_task_profile(title)
        return self._attach_card(card, task_profile=profile, task_icon=task_icon, task_tooltip=tooltip)

    def _derive_task_profile(self, title: str) -> str:
        base = title.split("—")[0].strip().lower() if title else "card"
        base = base.replace(" ", "-") or "card"
        return base

    def _center_card(self, card: Card) -> None:
        canvas = self.canvas
        if not canvas:
            return
        viewport = self.camera.viewport() if self.camera else None
        h_scroll = self.camera.horizontalScrollBar() if self.camera else None
        v_scroll = self.camera.verticalScrollBar() if self.camera else None
        offset_x = h_scroll.value() if h_scroll else 0
        offset_y = v_scroll.value() if v_scroll else 0
        if viewport:
            vw = viewport.size()
            cx = offset_x + vw.width() // 2 - card.width() // 2
            cy = offset_y + vw.height() // 2 - card.height() // 2
        else:
            rect = canvas.rect()
            cx = rect.center().x() - card.width() // 2
            cy = rect.center().y() - card.height() // 2
        bounds = canvas.rect()
        max_x = bounds.width() - card.width() - 8
        max_y = bounds.height() - card.height() - 8
        x = max(8, min(cx, max_x))
        y = max(8, min(cy, max_y))
        card.move(x, y)

    def _bring_card_forward(self, card: Card):
        try:
            card.show(); card.raise_(); card.activateWindow()
            self.raise_(); self.activateWindow()
            self.camera.center_on_widget(card)
        except Exception:
            pass

    def _maybe_refocus(self, w: QWidget):
        self.camera.center_on_widget(w)

    def _maybe_clear_focus(self, w: QWidget):
        if getattr(self, "_last_focus", None) is w:
            self._last_focus = None

    def _register_card(self, card: Card) -> int:
        self._card_seq += 1
        card_id = self._card_seq
        setattr(card, "_automation_id", card_id)
        self._card_lookup[card_id] = card
        try:
            card.destroyed.connect(lambda _=None, ident=card_id: self._card_lookup.pop(ident, None))
        except Exception:
            pass
        return card_id

    def _card_title(self, card: Card) -> str:
        if hasattr(card, "title_label") and card.title_label.text():
            return str(card.title_label.text())
        title = card.windowTitle() if hasattr(card, "windowTitle") else ""
        return str(title or "")

    @Slot(object)
    def _on_card_closed(self, card: object) -> None:
        if not isinstance(card, Card):
            return
        self._maybe_clear_focus(card)
        card_id = getattr(card, "_automation_id", None)
        if isinstance(card_id, int):
            self._card_lookup.pop(card_id, None)

    def taskbar_offset(self) -> int:
        return int(self.taskbar_insets().get("bottom", 0))

    def set_taskbar_autohide(self, enabled: bool) -> None:
        self._taskbar_autohide = bool(enabled)

    def allow_external_browse(self) -> bool:
        return bool(getattr(self, "_allow_external_browse", False))

    def set_allow_external_browse(self, enabled: bool) -> None:
        self._allow_external_browse = bool(enabled)

    def has_user_guided_notes(self) -> bool:
        return _USER_GUIDED_NOTES_FACTORY is not None

    def mark_start_index_stale(self) -> None:
        panel = getattr(self, "start_panel", None)
        if panel and hasattr(panel, "mark_index_stale"):
            panel.mark_index_stale()

    def _current_screen(self) -> Optional["QScreen"]:
        win = self.window()
        screen = None
        if win and hasattr(win, "windowHandle"):
            try:
                handle = win.windowHandle()
            except Exception:
                handle = None
            if handle is not None:
                try:
                    screen = handle.screen()
                except Exception:
                    screen = None
        if screen is None:
            try:
                global_pos = self.mapToGlobal(self.rect().center())
            except Exception:
                global_pos = QPoint()
            screen = QGuiApplication.screenAt(global_pos)
        if screen is None:
            screen = QGuiApplication.primaryScreen()
        return screen

    def _current_screen_size(self) -> QSize:
        screen = self._current_screen()
        if screen is None:
            return QSize(0, 0)
        geom = screen.geometry()
        return geom.size()

    def set_force_native_taskbar_offset(self, enabled: bool) -> None:
        self._force_native_taskbar_offset = bool(enabled)

    def _sync_canvas_to_screen(self, force_native_taskbar: bool = False):
        if force_native_taskbar:
            self._force_native_taskbar_offset = True
        screen = self._current_screen()
        is_fullscreen = self._is_borderless_fullscreen()
        is_maximized = self._is_window_maximized()
        use_screen_bounds = is_fullscreen or is_maximized

        top_margin = 0
        bottom_margin = 0
        adjusted = QSize()

        if use_screen_bounds:
            geom = None
            available = None
            if screen is not None:
                try:
                    geom = screen.geometry()
                except Exception:
                    geom = None
                try:
                    available = screen.availableGeometry()
                except Exception:
                    available = None
            if geom is not None:
                base_width = geom.width()
                base_height = geom.height()
            else:
                base_size = self._current_screen_size()
                base_width = base_size.width()
                base_height = base_size.height()

            if is_fullscreen:
                target_width = base_width
                target_height = base_height
                top_margin = 0
                bottom_margin = 0
            else:
                target_width = base_width
                if geom is not None and available is not None:
                    top_margin = max(0, available.top() - geom.top())
                    bottom_margin = max(0, geom.bottom() - available.bottom())
                    target_width = available.width()
                should_use_native_taskbar = (
                    is_maximized
                    and screen is not None
                    and (
                        self._force_native_taskbar_offset
                        or self._should_use_native_taskbar_offset()
                    )
                )
                if should_use_native_taskbar:
                    try:
                        native_offset = int(self._native_windows_taskbar_height())
                    except Exception:
                        native_offset = 0
                    bottom_margin = max(bottom_margin, native_offset)
                target_height = max(0, base_height - top_margin - bottom_margin)
                if is_maximized and geom is not None and available is not None:
                    target_height = min(target_height, available.height())
            adjusted = QSize(max(0, target_width), target_height)
        else:
            camera = getattr(self, "camera", None)
            viewport_size = QSize()
            if camera is not None:
                try:
                    viewport = camera.viewport()
                except Exception:
                    viewport = None
                if viewport is not None:
                    viewport_size = viewport.size()
                if (not viewport_size.isValid() or viewport_size.isEmpty()) and hasattr(camera, "size"):
                    try:
                        viewport_size = camera.size()
                    except Exception:
                        viewport_size = QSize()
            if not viewport_size.isValid() or viewport_size.isEmpty():
                viewport_size = self.size()
            adjusted = QSize(max(0, viewport_size.width()), max(0, viewport_size.height()))

        layout = getattr(self, "_layout", None)
        if layout is not None:
            layout_top_margin = top_margin
            layout_bottom_margin = bottom_margin
            side = self.taskbar_side()
            if side in ("bottom", "top"):
                taskbar = getattr(self, "taskbar", None)
                thickness = 0
                if taskbar is not None and hasattr(taskbar, "thickness"):
                    try:
                        thickness = int(taskbar.thickness())
                    except Exception:
                        thickness = 0
                if thickness <= 0:
                    thickness = 40
                if side == "bottom" and bottom_margin > 0:
                    layout_bottom_margin = max(0, int(bottom_margin) - thickness)
                if side == "top" and top_margin > 0:
                    layout_top_margin = max(0, int(top_margin) - thickness)
            layout_top_margin = int(layout_top_margin)
            layout_bottom_margin = int(layout_bottom_margin)
            margins = layout.contentsMargins()
            if (
                margins.left() != 0
                or margins.top() != layout_top_margin
                or margins.right() != 0
                or margins.bottom() != layout_bottom_margin
            ):
                layout.setContentsMargins(0, layout_top_margin, 0, layout_bottom_margin)
        if self._last_synced_size and adjusted == self._last_synced_size:
            return
        self._last_synced_size = QSize(adjusted)
        self.canvas.resize(adjusted)
        self.camera.center_on_widget(self.canvas)
        log(f"Canvas synced to screen: {adjusted.width()}x{adjusted.height()}")

    def _should_use_native_taskbar_offset(self) -> bool:
        if self.taskbar_side() != "bottom":
            return False
        if self._is_borderless_fullscreen():
            return False
        return self._is_window_maximized()

    def _is_borderless_fullscreen(self) -> bool:
        win = self.window()
        if not win:
            return False
        try:
            return bool(win.isFullScreen())
        except Exception:
            return False

    def _is_window_maximized(self) -> bool:
        win = self.window()
        if not win:
            return False
        try:
            if hasattr(win, "isMaximized") and win.isMaximized():
                return True
        except Exception:
            return False
        try:
            state = win.windowState() if hasattr(win, "windowState") else None
        except Exception:
            state = None
        if state is None:
            return False
        try:
            return bool(state & Qt.WindowMaximized)
        except Exception:
            return False

    @staticmethod
    def _native_windows_taskbar_height() -> int:
        return _query_windows_taskbar_height()

    def _toast(self, msg: str, *, kind: str = "info"):
        box = QWidget()
        box.setAttribute(Qt.WA_StyledBackground, True)
        v = QVBoxLayout(box); v.setContentsMargins(12, 12, 12, 12); v.setSpacing(4)
        lab = QLabel(msg)
        lab.setWordWrap(True)
        if kind == "error":
            box.setStyleSheet("background:#3a0f19; border:1px solid #ff6d88; border-radius:12px;")
            lab.setStyleSheet("color:#ffeef4; font:600 10pt 'Cascadia Code';")
            icon = QApplication.style().standardIcon(QStyle.SP_MessageBoxCritical)
            title = "Blocked"
            profile = "toast-blocked"
            timeout = 3200
        else:
            box.setStyleSheet("background:#0f1d33; border:1px solid #2f72ff; border-radius:12px;")
            lab.setStyleSheet("color:#eaf2ff; font:600 10pt 'Cascadia Code';")
            icon = QApplication.style().standardIcon(QStyle.SP_MessageBoxInformation)
            title = "Notice"
            profile = "toast"
            timeout = 2000
        v.addWidget(lab)
        card = self.add_card(box, title, task_profile=profile, task_icon=icon, task_tooltip=msg)
        timer = QTimer(self)
        timer.setSingleShot(True)
        cleaned = False
        close_card = _make_guarded_card_method(card, "_close_card")

        def _cleanup_timer() -> None:
            nonlocal cleaned
            if cleaned:
                return
            cleaned = True
            try:
                if timer.isActive():
                    timer.stop()
            except Exception:
                pass
            timer.deleteLater()

        def _close_card_if_valid() -> None:
            try:
                close_card()
            finally:
                _cleanup_timer()

        timer.timeout.connect(_close_card_if_valid)

        def _cancel_timer_on_destroyed(*_args: object) -> None:
            _cleanup_timer()

        try:
            card.destroyed.connect(_cancel_timer_on_destroyed)
        except Exception:
            pass

        timer.start(timeout)
        log(f"Toast[{kind}]: {msg}")

    # ---------- Automation hooks ----------
    def list_cards(self) -> List[Dict[str, object]]:
        """Return metadata for all open cards in a deterministic order."""
        cards: List[Dict[str, object]] = []
        for card in sorted(self._iter_cards(), key=lambda c: getattr(c, "_automation_id", 0)):
            card_id = getattr(card, "_automation_id", None)
            if not isinstance(card_id, int):
                card_id = self._register_card(card)
            cards.append(self._serialize_card(card, card_id))
        return cards

    def _serialize_card(self, card: Card, card_id: int) -> Dict[str, object]:
        title = self._card_title(card)
        geometry = {
            "card": _widget_geometry_snapshot(card),
            "header": _widget_geometry_snapshot(getattr(card, "header", None)),
            "body": _widget_geometry_snapshot(getattr(card, "body", None)),
        }
        data: Dict[str, object] = {
            "id": card_id,
            "title": title,
            "profile": getattr(card, "task_profile", ""),
            "tooltip": getattr(card, "task_tooltip", title),
            "persist_tag": getattr(card, "_persist_tag", None),
            "visible": bool(card.isVisible()),
            "maximized": bool(getattr(card, "_maximized", False)),
            "geometry": geometry,
        }
        return data

    def focus_card(self, identifier: Union[int, str]) -> bool:
        """Focus the first card matching the identifier (id or title)."""
        target: Optional[Card] = None
        if isinstance(identifier, int):
            target = self._card_lookup.get(identifier)
        else:
            name = str(identifier or "").strip()
            if not name:
                return False
            # Prefer exact match, then case-insensitive, then substring
            for card in self._iter_cards():
                if self._card_title(card) == name:
                    target = card
                    break
            if target is None:
                lowered = name.lower()
                for card in self._iter_cards():
                    if self._card_title(card).lower() == lowered:
                        target = card
                        break
            if target is None:
                lowered = name.lower()
                for card in self._iter_cards():
                    if lowered in self._card_title(card).lower():
                        target = card
                        break
        if target is None:
            return False
        if not target.isVisible():
            target.show()
        self._bring_card_forward(target)
        self._last_focus = target
        return True

    def list_icons(self) -> List[Dict[str, object]]:
        """List desktop icons with geometry suitable for automation."""
        icons: List[Dict[str, object]] = []
        icon_widgets = getattr(self.canvas, "_icons", {})
        for path in sorted(icon_widgets.keys()):
            widget = icon_widgets.get(path)
            if widget is None:
                continue
            entry: Dict[str, object] = {
                "path": path,
                "title": widget.text() if hasattr(widget, "text") else os.path.basename(path),
                "kind": "folder" if os.path.isdir(path) else "file",
                "geometry": _widget_geometry_snapshot(widget),
            }
            icons.append(entry)
        return icons

    def open(self, path: str) -> Dict[str, object]:
        """Open a path inside the Virtual Desktop and report success."""
        result: Dict[str, object] = {"success": False, "card_id": None, "path": path}
        if not path:
            result["error"] = "empty path"
            return result
        target = path
        if not os.path.isabs(target):
            base = self._workspace or VDSK_ROOT
            target = os.path.join(base, path)
        target = os.path.abspath(target)
        result["resolved_path"] = target
        if not os.path.exists(target):
            result["error"] = "path not found"
            return result
        before = set(self._card_lookup.keys())
        try:
            self.open_any_path(target)
        except Exception as exc:
            log(f"Automation open failed: {exc}", logging.WARNING)
            result["error"] = str(exc)
            return result
        app = QApplication.instance()
        if app is not None:
            try:
                app.processEvents()
            except Exception:
                pass
        after = set(self._card_lookup.keys())
        new_ids = sorted(after - before)
        result["success"] = True
        if new_ids:
            result["card_id"] = new_ids[-1]
        return result

    def search(self, query: str, facet: Optional[str] = None) -> Dict[str, object]:
        """Run the Start menu search without mutating UI state."""
        panel = getattr(self, "start_panel", None)
        if panel is None:
            return {"query": query, "facet": facet or "all", "Apps": [], "Recent": [], "Files": []}
        q = (query or "").strip()
        if not q:
            return {"query": q, "facet": facet or panel._facet, "Apps": [], "Recent": [], "Files": []}
        allowed = {key for key, _ in getattr(panel, "FACETS", [])}
        prev_facet = panel._facet
        facet_to_use = prev_facet
        if facet:
            candidate = str(facet).strip().lower()
            facet_to_use = candidate if candidate in allowed else "all"
        try:
            panel._facet = facet_to_use
            panel._ensure_index()
            results = panel._perform_search(q)
        finally:
            panel._facet = prev_facet
        return self._serialize_search_results(results, facet_to_use, q)

    def _serialize_search_results(
        self, results: Dict[str, List[Dict[str, object]]], facet: str, query: str
    ) -> Dict[str, object]:
        payload: Dict[str, object] = {"query": query, "facet": facet, "Apps": [], "Recent": [], "Files": []}
        apps_serialized: List[Dict[str, object]] = []
        for item in results.get("Apps", []):
            apps_serialized.append(
                {
                    "id": str(item.get("id", "")),
                    "title": str(item.get("title", "")),
                    "tooltip": str(item.get("tooltip", item.get("title", ""))),
                }
            )
        payload["Apps"] = apps_serialized
        recent_serialized: List[Dict[str, object]] = []
        for item in results.get("Recent", []):
            entry: Dict[str, object] = {
                "title": str(item.get("title") or item.get("path") or ""),
                "path": str(item.get("path", "")),
                "kind": str(item.get("kind", "")),
            }
            if item.get("ts") is not None:
                try:
                    entry["ts"] = int(item.get("ts"))
                except Exception:
                    pass
            recent_serialized.append(entry)
        payload["Recent"] = recent_serialized
        files_serialized: List[Dict[str, object]] = []
        for item in results.get("Files", []):
            files_serialized.append(
                {
                    "title": str(item.get("title", "")),
                    "path": str(item.get("path", "")),
                    "kind": str(item.get("kind", "")),
                }
            )
        payload["Files"] = files_serialized
        return payload

    def geometry_snapshot(self) -> Dict[str, object]:
        """Provide geometry for key widgets (camera, taskbar, start)."""
        snapshot: Dict[str, object] = {
            "workspace_root": self._workspace or VDSK_ROOT,
            "taskbar_autohide": bool(self._taskbar_autohide),
            "taskbar_offset": self.taskbar_offset(),
            "taskbar_side": self.taskbar_side(),
            "core": _widget_geometry_snapshot(self),
            "camera": _widget_geometry_snapshot(self.camera),
            "camera_viewport": _widget_geometry_snapshot(self.camera.viewport() if self.camera else None),
            "canvas": _widget_geometry_snapshot(self.canvas),
            "taskbar": _widget_geometry_snapshot(self.taskbar),
            "start_button": _widget_geometry_snapshot(self.taskbar.start_btn if self.taskbar else None),
        }
        snapshot["start_panel"] = _widget_geometry_snapshot(self.start_panel if self.start_panel.isVisible() else None)
        snapshot["cards"] = self.list_cards()
        snapshot["icons"] = self.list_icons()
        return snapshot

    # ---------- Start panel ----------
    def _hide_start_panel(self) -> None:
        if getattr(self, "start_panel", None) and self.start_panel.isVisible():
            self.start_panel.hide()
        self._remove_start_panel_click_filter()

    def _toggle_start_panel(self):
        if self.start_panel.isVisible():
            self._hide_start_panel()
            return
        horizontal = self._taskbar_side in ("bottom", "top")
        thickness = self.taskbar.thickness() if self.taskbar else 0
        available_width = self.width() - (thickness if not horizontal else 0) - 30
        available_height = self.height() - (thickness if horizontal else 0) - 30
        available_width = max(200, available_width)
        available_height = max(200, available_height)
        min_size = self.start_panel.minimumSize().expandedTo(self.start_panel.minimumSizeHint())
        min_width = max(0, min_size.width())
        min_height = max(0, min_size.height())
        if horizontal:
            base_width = min(780, max(260, available_width))
            base_height = max(240, int(self.height() * 0.55))
        else:
            base_width = min(560, max(240, available_width))
            base_height = max(260, available_height)
        width = max(base_width, min_width)
        height = max(base_height, min_height)
        width = min(width, available_width)
        height = min(height, available_height)
        panel_size = QSize(int(width), int(height))
        geom = self._compute_start_panel_rect(panel_size)
        self.start_panel.setParent(self)
        self.start_panel.setProperty("side", self._taskbar_side)
        panel_style = self.start_panel.style()
        if panel_style:
            panel_style.unpolish(self.start_panel)
            panel_style.polish(self.start_panel)
        self.start_panel.setGeometry(geom)
        self._apply_start_panel_close_behavior()
        self.start_panel._rebuild_apps_views()
        self.start_panel._populate_recent()
        self.start_panel.show()
        self.start_panel.raise_()
        self._install_start_panel_click_filter()

    # ---------- Settings ----------
    def _open_settings_panel(self, section: Optional[str] = None):
        if self._settings_card and self._settings_card.isVisible():
            self._bring_card_forward(self._settings_card)
            if section and isinstance(self._settings_panel_widget, SettingsPanel):
                self._settings_panel_widget.focus_section(section)
            return
        panel = SettingsPanel(self)
        self._settings_panel_widget = panel
        settings_icon = QApplication.style().standardIcon(QStyle.SP_FileDialogDetailedView)
        self._settings_card = self.add_card(
            panel,
            "Virtual Desktop Settings",
            task_profile="settings",
            task_icon=settings_icon,
            task_tooltip="Virtual Desktop Settings",
        )
        tag = "(builtin:settings)"
        self._settings_card.set_persist_tag(tag)
        _restore_card_geom(self._settings_card, "template", tag)
        self._settings_card.moved.connect(lambda: _save_card_geom(self._settings_card, "template", tag))
        self._settings_card.resized.connect(lambda: _save_card_geom(self._settings_card, "template", tag))
        self._settings_card.closed.connect(lambda _=None: self._on_settings_closed())
        if section:
            panel.focus_section(section)

    def _close_settings(self):
        if self._settings_card:
            self._settings_card._close_card()
        self._on_settings_closed()

    def _on_settings_closed(self) -> None:
        self._settings_card = None
        self._settings_panel_widget = None

    # ---------- App launchers ----------
    def _load_script_dialog(self):
        path, _ = _non_native_open_file(self, "Load Script as Card…", self._workspace or SCRIPT_DIR,
                                        "Python (*.py);;Executables (*.exe *.bat *.cmd *.sh);;All files (*.*)")
        if not path: return
        self.open_any_path(path)

    def open_any_path(self, path: str):
        if not path:
            return
        resolved = os.path.abspath(path)
        if not _is_contained(resolved) and not self.allow_external_browse():
            self._toast("Blocked: path is outside the Virtual Desktop workspace.", kind="error")
            log(f"Blocked open outside workspace: {resolved}", logging.WARNING)
            return
        if os.path.isdir(resolved):
            widget = ExplorerCard(resolved, self.open_any_path, self.t, refresh_hook=self.canvas._refresh_icons)
            explorer_icon = QApplication.style().standardIcon(QStyle.SP_DirIcon)
            card = self.add_card(
                widget,
                f"Explorer — {os.path.basename(resolved) or resolved}",
                task_profile="explorer",
                task_icon=explorer_icon,
                task_tooltip=resolved,
            )
            tag = f"(explorer:{resolved})"
            card.set_persist_tag(tag)
            _restore_card_geom(card, "template", tag)
            card.moved.connect(lambda: _save_card_geom(card, "template", tag))
            card.resized.connect(lambda: _save_card_geom(card, "template", tag))
            self._bring_card_forward(card)
            self.mark_start_index_stale()
            return

        ext = os.path.splitext(resolved)[1].lower()
        if ext in {".txt", ".md", ".log", ".ini", ".cfg", ".json"}:
            widget = TextViewer(resolved, self.t)
            title = f"Text — {os.path.basename(resolved)}"
            text_icon = QApplication.style().standardIcon(QStyle.SP_FileDialogDetailedView)
            card = self.add_card(
                widget,
                title,
                task_profile="text-viewer",
                task_icon=text_icon,
                task_tooltip=resolved,
            )
            tag = resolved
            card.set_persist_tag(tag)
            _restore_card_geom(card, "text", tag)
            card.moved.connect(lambda: _save_card_geom(card, "text", tag))
            card.resized.connect(lambda: _save_card_geom(card, "text", tag))
            self._bring_card_forward(card)
            _remember_card("text", resolved, title)
        elif ext in {".png", ".jpg", ".jpeg", ".gif", ".bmp"}:
            widget = ImageViewer(resolved, self.t)
            title = f"Image — {os.path.basename(resolved)}"
            image_icon = QApplication.style().standardIcon(QStyle.SP_FileDialogContentsView)
            card = self.add_card(
                widget,
                title,
                task_profile="image-viewer",
                task_icon=image_icon,
                task_tooltip=resolved,
            )
            tag = resolved
            card.set_persist_tag(tag)
            _restore_card_geom(card, "image", tag)
            card.moved.connect(lambda: _save_card_geom(card, "image", tag))
            card.resized.connect(lambda: _save_card_geom(card, "image", tag))
            self._bring_card_forward(card)
            _remember_card("image", resolved, title)
        elif ext == ".py":
            if self._load_python_as_card(resolved, persist_key=resolved) is None:
                self._load_process_card(resolved, os.path.basename(resolved), persist_key=resolved)
        else:
            self._load_process_card(resolved, os.path.basename(resolved), persist_key=resolved)
        self.mark_start_index_stale()
        QApplication.processEvents()

    def _call_factory(self, factory):
        sig = inspect.signature(factory)
        if "embedded" in sig.parameters:
            return factory(None, embedded=True)
        return factory(None)

    def _instantiate_card_from_factory(
        self,
        factory: Callable[..., object],
        *,
        default_title: str,
        task_profile: Optional[str] = None,
        task_icon: Optional[QIcon] = None,
        task_tooltip: Optional[str] = None,
    ) -> Tuple[Card, Dict[str, object]]:
        output = self._call_factory(factory)
        title = default_title
        profile = task_profile
        icon = task_icon
        tooltip = task_tooltip
        metadata: Dict[str, object] = {}

        payload: object = output
        extras: Sequence[object] = []
        if isinstance(output, (list, tuple)):
            seq = list(output)
            payload = seq[0] if seq else None
            extras = seq[1:]
            if extras and isinstance(extras[0], str):
                maybe_title = extras[0].strip()
                if maybe_title:
                    title = maybe_title
                extras = extras[1:]
            if extras and isinstance(extras[0], Mapping):
                meta_map = dict(extras[0])
                maybe_title = meta_map.get("title")
                if isinstance(maybe_title, str) and maybe_title.strip():
                    title = maybe_title.strip()
                maybe_profile = meta_map.get("task_profile")
                if isinstance(maybe_profile, str) and maybe_profile.strip():
                    profile = maybe_profile.strip()
                maybe_tooltip = meta_map.get("task_tooltip")
                if isinstance(maybe_tooltip, str) and maybe_tooltip.strip():
                    tooltip = maybe_tooltip.strip()
                maybe_icon = meta_map.get("task_icon")
                if isinstance(maybe_icon, QIcon):
                    icon = maybe_icon
                if meta_map.get("persist_tag") is not None:
                    metadata["persist_tag"] = str(meta_map["persist_tag"])

        final_title = title or default_title
        final_profile = profile
        final_icon = icon
        final_tooltip = tooltip or final_title

        if isinstance(payload, Card):
            card = payload
            if final_title and final_title != self._card_title(card) and hasattr(card, "title_label"):
                card.title_label.setText(final_title)
            if not final_profile:
                existing_profile = getattr(card, "task_profile", None)
                if isinstance(existing_profile, str) and existing_profile:
                    final_profile = existing_profile
                else:
                    final_profile = "card"
            if final_icon is None:
                existing_icon = getattr(card, "task_icon", None)
                if isinstance(existing_icon, QIcon) and not existing_icon.isNull():
                    final_icon = existing_icon
            if not final_tooltip:
                existing_tooltip = getattr(card, "task_tooltip", None)
                if isinstance(existing_tooltip, str) and existing_tooltip:
                    final_tooltip = existing_tooltip
                else:
                    final_tooltip = final_title
            card = self._attach_card(
                card,
                task_profile=final_profile,
                task_icon=final_icon,
                task_tooltip=final_tooltip,
            )
        elif isinstance(payload, QWidget):
            final_profile = final_profile or "python-card"
            card = self.add_card(
                payload,
                final_title,
                task_profile=final_profile,
                task_icon=final_icon,
                task_tooltip=final_tooltip,
            )
        else:
            raise RuntimeError("factory returned unsupported object")

        metadata.setdefault("title", final_title)
        metadata.setdefault("task_profile", final_profile)
        if final_icon is not None:
            metadata.setdefault("task_icon", final_icon)
        metadata.setdefault("task_tooltip", final_tooltip)
        return card, metadata

    def _load_python_as_card(
        self,
        path: str,
        persist_key: Optional[str]=None,
        nice_title: Optional[str]=None,
        task_profile: Optional[str]=None,
        task_icon: Optional[QIcon]=None,
        task_tooltip: Optional[str]=None,
    ) -> Optional[Card]:
        log(f"Load python as card: {path}")
        try:
            name = f"card_{int(time.time())}_{os.path.splitext(os.path.basename(path))[0]}"
            spec = importlib.util.spec_from_file_location(name, path)
            if not spec or not spec.loader:
                raise RuntimeError("spec loader failed")
            mod = importlib.util.module_from_spec(spec)
            sys.modules[name] = mod
            spec.loader.exec_module(mod)  # type: ignore
        except Exception as e:
            self._toast(f"Import failed: {e}")
            log(f"Import failed: {e}", logging.ERROR)
            return None

        factory = getattr(mod, "build_widget", None)
        if not callable(factory):
            factory = getattr(mod, "create_card", None)
        if not callable(factory):
            self._toast("No build_widget/create_card; running as process instead.")
            log("card factory not found; falling back to process", logging.INFO)
            return None

        default_title = nice_title or os.path.basename(path)
        default_icon = task_icon or QApplication.style().standardIcon(QStyle.SP_DesktopIcon)
        default_profile = task_profile or "python-card"
        default_tooltip = task_tooltip or path

        old_flag = os.environ.get("CODEX_EMBEDDED")
        os.environ["CODEX_EMBEDDED"] = "1"  # hint for embedded-compatible widgets
        try:
            card, card_meta = self._instantiate_card_from_factory(
                factory,
                default_title=default_title,
                task_profile=default_profile,
                task_icon=default_icon,
                task_tooltip=default_tooltip,
            )
        except Exception as e:
            if old_flag is None:
                os.environ.pop("CODEX_EMBEDDED", None)
            else:
                os.environ["CODEX_EMBEDDED"] = old_flag
            self._toast(f"factory error: {e}")
            log(
                f"factory error: {e}\n{traceback.format_exc()}",
                logging.ERROR,
            )
            return None
        finally:
            if old_flag is None:
                os.environ.pop("CODEX_EMBEDDED", None)
            else:
                os.environ["CODEX_EMBEDDED"] = old_flag

        persist_tag = persist_key or str(card_meta.get("persist_tag", "")).strip() or None
        if persist_tag:
            card.set_persist_tag(persist_tag)
            _restore_card_geom(card, "py_card", persist_tag)
            card.moved.connect(lambda: _save_card_geom(card, "py_card", persist_tag))
            card.resized.connect(lambda: _save_card_geom(card, "py_card", persist_tag))

        title_for_log = str(card_meta.get("title", default_title))
        card.closed.connect(lambda _: log(f"Card closed: {title_for_log}"))
        self._bring_card_forward(card)
        _remember_card("py_card", path, title_for_log)
        log(f"Card loaded: {title_for_log}")
        return card

    def _load_process_card(self, path: str, title: str, persist_key: Optional[str]=None):
        spec = build_launch_spec(path, SCRIPT_DIR)
        log(f"Run process as card: {spec.argv}")

        approved_launch = self.allow_external_browse()
        embed_candidate = should_embed_external_app(spec, ALLOWLIST)

        if embed_candidate:
            approved_launch = True
            try:
                external_widget = ExternalAppCard(
                    self.t,
                    spec,
                    toast_cb=lambda msg, kind="info": self._toast(msg, kind=kind),
                    log_cb=lambda message, level=logging.INFO: log(message, level),
                )
            except Exception as exc:  # pragma: no cover - defensive guard
                log(f"[external-app] failed to initialize for {path}: {exc}", logging.ERROR)
            else:
                started = False
                try:
                    started = external_widget.start()
                except Exception as exc:  # pragma: no cover - Qt failures
                    log(f"[external-app] start error for {path}: {exc}", logging.ERROR)
                if started:
                    proc_icon, _ = _icon_for_path(spec.target_path or spec.original_path)
                    card = self.add_card(
                        external_widget,
                        f"App — {title}",
                        task_profile="external-app",
                        task_icon=proc_icon,
                        task_tooltip=spec.original_path,
                    )
                    external_widget.attach_card(card)
                    external_widget.request_close.connect(card._close_card)
                    external_widget.process_finished.connect(
                        lambda code, detail, source=spec.original_path: self._handle_external_exit(source, code, detail)
                    )
                    external_widget.fallback_requested.connect(
                        lambda reason, _spec=spec, _title=title, _persist=persist_key, _card=card, _widget=external_widget, _approved=approved_launch: self._handle_external_fallback(
                            reason,
                            _spec,
                            _title,
                            _persist,
                            _approved,
                            _card,
                            _widget,
                        )
                    )
                    card.closed.connect(lambda _=None: external_widget.shutdown())
                    if persist_key:
                        card.set_persist_tag(persist_key)
                        _restore_card_geom(card, "external-app", persist_key)
                        card.moved.connect(lambda: _save_card_geom(card, "external-app", persist_key))
                        card.resized.connect(lambda: _save_card_geom(card, "external-app", persist_key))
                    self._bring_card_forward(card)
                    _remember_card("external-app", spec.original_path, title)
                    return
                external_widget.deleteLater()

        self._open_process_error_card(
            spec,
            title,
            persist_key,
            allow_external_exec=approved_launch,
        )

    def _open_process_error_card(
        self,
        spec: LaunchSpec,
        title: str,
        persist_key: Optional[str],
        *,
        allow_external_exec: bool = False,
    ) -> None:
        cmd = spec.argv if spec.argv else [spec.original_path]
        widget = ProcessErrorCard(
            self.t,
            cmd,
            cwd=spec.cwd,
            guard=_validate_process_request,
            allow_external_exec=allow_external_exec,
            violation_cb=lambda m: self._toast(m, kind="error"),
        )
        widget.isolation_requested.connect(
            lambda message, code, src=spec.original_path: self._handle_process_isolation(message, code, src)
        )
        icon_source = spec.target_path or spec.original_path
        proc_icon, _ = _icon_for_path(icon_source)
        card = self.add_card(
            widget,
            f"Process — {title}",
            task_profile="process",
            task_icon=proc_icon,
            task_tooltip=spec.original_path,
        )
        widget.close_requested.connect(card.close)
        card.closed.connect(lambda _=None: widget.stop())
        if persist_key:
            card.set_persist_tag(persist_key)
            _restore_card_geom(card, "process", persist_key)
            card.moved.connect(lambda: _save_card_geom(card, "process", persist_key))
            card.resized.connect(lambda: _save_card_geom(card, "process", persist_key))
        self._bring_card_forward(card)
        _remember_card("process", spec.original_path, title)

    def _handle_external_exit(self, path: str, exit_code: int, detail: str) -> None:
        name = os.path.basename(path) or path
        if exit_code != 0:
            message = detail or f"{name} exited with code {exit_code}."
            self._toast(message, kind="error")
            log(f"[external-app] {message} — {path}", logging.ERROR)
        else:
            log(f"[external-app] {name} exited normally.")

    def _handle_external_fallback(
        self,
        reason: str,
        spec: LaunchSpec,
        title: str,
        persist_key: Optional[str],
        approved_external: bool,
        card: "Card",
        _widget: ExternalAppCard,
    ) -> None:
        log(f"[external-app] fallback: {reason} — {spec.original_path}", logging.WARNING)
        try:
            card._close_card()
        except Exception:
            try:
                card.close()
            except Exception:
                pass
        QTimer.singleShot(
            0,
            lambda: self._open_process_error_card(
                spec,
                title,
                persist_key,
                allow_external_exec=approved_external or self.allow_external_browse(),
            ),
        )

    def _handle_process_isolation(self, message: str, code: Optional[int], path: str) -> None:
        detail = message or "Process failure detected."
        if code is not None:
            detail = f"{detail} (exit code {code})"
        self._toast(detail, kind="error")
        log(f"[process-error] {detail} — {path}", logging.ERROR)

    def _open_system_console(self):
        if self._sys_console and self._sys_console.isVisible():
            self._sys_console.raise_(); self._sys_console.activateWindow(); return
        self._sys_console = SystemConsole(self.t, LOG_PATH)
        parent_window = self.window()
        if parent_window:
            self._sys_console.setParent(parent_window, Qt.Window)  # containment with window chrome
        else:
            self._sys_console.setWindowFlag(Qt.Window, True)
        self._sys_console.show()
        log("System Console opened")

    def _open_error_center(self) -> None:
        if self._error_card and self._error_card.isVisible():
            self._bring_card_forward(self._error_card)
            self.camera.center_on_widget(self._error_card)
            return
        can_open_tasks = not isinstance(self.task_mgr, _FallbackTaskManager)
        callback = self._open_tasks_from_error_center if can_open_tasks else None
        widget = ErrorCenterCard(self.t, LOG_PATH, open_task=callback)
        if can_open_tasks:
            widget.task_requested.connect(self._open_tasks_from_error_center)
        else:
            widget.set_open_task_callback(None)
        error_icon = QApplication.style().standardIcon(QStyle.SP_MessageBoxCritical)
        card = self.add_card(
            widget,
            "Error Center",
            task_profile="error-center",
            task_icon=error_icon,
            task_tooltip="Error Center",
        )
        tag = "(builtin:error-center)"
        card.set_persist_tag(tag)
        _restore_card_geom(card, "builtin", tag)
        card.moved.connect(lambda: _save_card_geom(card, "builtin", tag))
        card.resized.connect(lambda: _save_card_geom(card, "builtin", tag))
        card.closed.connect(self._on_error_center_closed)
        self._error_card = card
        self._error_widget = widget
        self._bring_card_forward(card)
        self.camera.center_on_widget(card)
        _remember_card("builtin", tag, "Error Center")
        log("Error Center opened")

    def _on_error_center_closed(self, *_):
        self._error_card = None
        self._error_widget = None

    def _open_tasks_from_error_center(self, task_id: Optional[str]) -> None:
        if not task_id:
            return
        self._open_tasks(task_id=task_id)

    def _open_code_editor(self, path: Optional[str] = None) -> None:
        if not path:
            self._toast("No file selected for editor.")
            return
        resolved = path
        if not os.path.isabs(resolved):
            base = self._workspace or VDSK_ROOT
            resolved = os.path.join(base, path)
        if not os.path.isfile(resolved):
            self._toast(f"File not found: {resolved}")
            log(f"Editor open skipped; missing file {resolved}", logging.WARNING)
            return
        try:
            storage_root = Path(self._workspace or VDSK_ROOT) / "memory"
            widget = build_editor_widget(
                parent=None,
                initial_path=resolved,
                storage_root=storage_root,
            )
        except Exception as exc:
            self._toast("Unable to open editor card.")
            log(f"Editor widget failed for {resolved}: {exc}", logging.ERROR)
            return
        title = f"Editor — {os.path.basename(resolved)}"
        editor_icon = QApplication.style().standardIcon(QStyle.SP_FileDialogDetailedView)
        card = self.add_card(
            widget,
            title,
            task_profile="editor",
            task_icon=editor_icon,
            task_tooltip=resolved,
        )
        tag = f"(editor:{resolved})"
        card.set_persist_tag(tag)
        _restore_card_geom(card, "editor", tag)
        card.moved.connect(lambda: _save_card_geom(card, "editor", tag))
        card.resized.connect(lambda: _save_card_geom(card, "editor", tag))
        self._bring_card_forward(card)
        self.camera.center_on_widget(card)
        _remember_card("editor", resolved, title)
        log(f"Editor opened for {resolved}")

    def _open_terminal_at(self, directory: Optional[str] = None) -> None:
        base = directory or self._workspace or SCRIPT_DIR
        cwd = base if os.path.isdir(base) else os.path.dirname(base) or (self._workspace or SCRIPT_DIR)
        if not os.path.isdir(cwd):
            self._toast(f"Folder not found: {cwd}")
            log(f"Terminal launch skipped; missing folder {cwd}", logging.WARNING)
            return
        if os.name == "nt":
            shell = os.environ.get("COMSPEC", "cmd.exe")
            cmd = [shell]
        else:
            shell = os.environ.get("SHELL", "/bin/bash")
            cmd = [shell]
        title = f"Terminal — {os.path.basename(cwd) or cwd}"
        widget = ProcessConsole(
            self.t,
            cmd,
            cwd=cwd,
            guard=_validate_process_request,
            violation_cb=lambda m: self._toast(m, kind="error"),
        )
        term_icon = QApplication.style().standardIcon(QStyle.SP_ComputerIcon)
        card = self.add_card(
            widget,
            title,
            task_profile="terminal",
            task_icon=term_icon,
            task_tooltip=cwd,
        )
        tag = f"(terminal:{cwd})"
        card.set_persist_tag(tag)
        _restore_card_geom(card, "process", tag)
        card.moved.connect(lambda: _save_card_geom(card, "process", tag))
        card.resized.connect(lambda: _save_card_geom(card, "process", tag))
        self._bring_card_forward(card)
        self.camera.center_on_widget(card)
        _remember_card("process", cwd, title)
        log(f"Terminal card opened at {cwd}")

    def _open_explorer(self):
        widget = ExplorerCard(self._workspace, self.open_any_path, self.t, refresh_hook=self.canvas._refresh_icons)
        explorer_icon = QApplication.style().standardIcon(QStyle.SP_DirIcon)
        card = self.add_card(
            widget,
            "Desktop Explorer",
            task_profile="explorer",
            task_icon=explorer_icon,
            task_tooltip=self._workspace,
        )
        tag = "(builtin:explorer)"
        card.set_persist_tag(tag)
        _restore_card_geom(card, "template", tag)
        card.moved.connect(lambda: _save_card_geom(card, "template", tag))
        card.resized.connect(lambda: _save_card_geom(card, "template", tag))
        self._bring_card_forward(card)

    def _open_operator_manager(self) -> None:
        if self._operator_card:
            self._bring_card_forward(self._operator_card)
            return
        widget = OperatorManagerWidget(self.t)
        ops_icon = QApplication.style().standardIcon(QStyle.SP_DesktopIcon)
        card = self.add_card(
            widget,
            "Operator Manager",
            task_profile="operator-manager",
            task_icon=ops_icon,
            task_tooltip="Operator Manager",
        )
        tag = "(builtin:operators)"
        card.set_persist_tag(tag)
        card.closed.connect(lambda _: setattr(self, "_operator_card", None))
        self._operator_card = card
        self._bring_card_forward(card)
        _remember_card("builtin", tag, "Operator Manager")
        log("Operator Manager opened")

    def _open_tasks(self, task_id: Optional[str] = None) -> None:
        if self._tasks_card and self._tasks_card.isVisible():
            self._bring_card_forward(self._tasks_card)
            self.camera.center_on_widget(self._tasks_card)
            if task_id:
                QTimer.singleShot(0, lambda: self._focus_task(task_id))
            return
        widget = open_card(
            self.task_mgr,
            self.t,
            self._open_code_editor,
            self._open_terminal_at,
            workspace_root=self._workspace,
            source="desktop",
        )
        if widget is None:
            return
        tasks_icon = QApplication.style().standardIcon(QStyle.SP_FileDialogListView)
        card = self.add_card(
            widget,
            "Tasks",
            task_profile="tasks",
            task_icon=tasks_icon,
            task_tooltip="Tasks",
        )
        tag = "(builtin:tasks)"
        card.set_persist_tag(tag)
        _restore_card_geom(card, "template", tag)
        card.moved.connect(lambda: _save_card_geom(card, "template", tag))
        card.resized.connect(lambda: _save_card_geom(card, "template", tag))
        card.closed.connect(self._on_tasks_card_closed)
        self._tasks_card = card
        self._tasks_widget = widget
        self._bring_card_forward(card)
        self.camera.center_on_widget(card)
        _remember_card("template", "(builtin:tasks)", "Tasks")
        log("Tasks card opened")
        if task_id:
            QTimer.singleShot(200, lambda: self._focus_task(task_id))

    def _open_user_guided_notes(self) -> Optional[Card]:
        if _USER_GUIDED_NOTES_FACTORY is None:
            self._toast("User-Guided Notes is unavailable.", kind="error")
            log("User_Guided_Notes factory unavailable", logging.INFO)
            return None
        if self._notes_window and self._notes_window.isVisible():
            try:
                self._notes_window.show()
                self._notes_window.raise_()
                self._notes_window.activateWindow()
            except Exception:
                pass
            return None
        if self._notes_card and self._notes_card.isVisible():
            self._bring_card_forward(self._notes_card)
            self.camera.center_on_widget(self._notes_card)
            return self._notes_card
        notes_icon = QApplication.style().standardIcon(QStyle.SP_FileDialogDetailedView)
        try:
            card, meta = self._instantiate_card_from_factory(
                _USER_GUIDED_NOTES_FACTORY,
                default_title="User-Guided Notes",
                task_profile="notes",
                task_icon=notes_icon,
                task_tooltip="User-Guided Notes",
            )
        except Exception as exc:
            self._toast("Unable to open Notes card.", kind="error")
            log(
                f"Notes card factory failed: {exc}\n{traceback.format_exc()}",
                logging.ERROR,
            )
            return None

        tag = str(meta.get("persist_tag") or "(builtin:user-guided-notes)")
        if tag:
            self._notes_card_tag = tag
            self._configure_notes_card(card, tag)
        else:
            self._notes_card_tag = None
            card.closed.connect(self._on_notes_card_closed)
        self._notes_card = card
        widget = self._extract_notes_widget(card)
        if widget is not None:
            self._install_notes_widget(widget)
        self._bring_card_forward(card)
        self.camera.center_on_widget(card)
        title = str(meta.get("title", "User-Guided Notes"))
        _remember_card("builtin", tag, title)
        log("User-Guided Notes card opened")
        return card

    def _configure_notes_card(self, card: Card, tag: str) -> None:
        card.set_persist_tag(tag)
        _restore_card_geom(card, "builtin", tag)
        card.moved.connect(lambda: _save_card_geom(card, "builtin", tag))
        card.resized.connect(lambda: _save_card_geom(card, "builtin", tag))
        card.closed.connect(self._on_notes_card_closed)

    def _extract_notes_widget(self, card: Card) -> Optional[QWidget]:
        widget: Optional[QWidget] = None
        if _USER_GUIDED_NOTES_WIDGET_CLASS is not None:
            try:
                widget = card.findChild(_USER_GUIDED_NOTES_WIDGET_CLASS)  # type: ignore[arg-type]
            except Exception:
                widget = None
        if widget is None:
            body_layout = card.body.layout()
            if body_layout and body_layout.count():
                candidate = body_layout.itemAt(0).widget()
                if isinstance(candidate, QWidget):
                    widget = candidate
        return widget

    def _install_notes_widget(self, widget: QWidget) -> None:
        if self._notes_widget is widget:
            self._set_notes_embedded_state(True)
            return
        if self._notes_widget is not None and self._notes_widget is not widget:
            self._disconnect_notes_widget()
        self._notes_widget = widget
        self._set_notes_embedded_state(True)
        try:
            widget.request_detach.connect(self._detach_notes_widget)  # type: ignore[attr-defined]
            widget.request_redock.connect(self._redock_notes_widget)  # type: ignore[attr-defined]
        except Exception:
            pass
        try:
            widget.destroyed.connect(self._clear_notes_widget)  # type: ignore[attr-defined]
        except Exception:
            pass

    def _disconnect_notes_widget(self) -> None:
        if self._notes_widget is None:
            return
        try:
            self._notes_widget.request_detach.disconnect(self._detach_notes_widget)  # type: ignore[attr-defined]
        except Exception:
            pass
        try:
            self._notes_widget.request_redock.disconnect(self._redock_notes_widget)  # type: ignore[attr-defined]
        except Exception:
            pass
        try:
            self._notes_widget.destroyed.disconnect(self._clear_notes_widget)  # type: ignore[attr-defined]
        except Exception:
            pass

    def _set_notes_embedded_state(self, embedded: bool) -> None:
        widget = self._notes_widget
        if widget is None:
            return
        apply_state = getattr(widget, "apply_embedded_state", None)
        if callable(apply_state):
            try:
                apply_state(embedded)
            except Exception:
                pass

    def _detach_notes_widget(self, widget: object) -> None:
        if widget is not self._notes_widget or self._notes_widget is None:
            return
        if _USER_GUIDED_NOTES_WINDOW_CLASS is None:
            self._toast("Pop-out window unavailable.", kind="error")
            self._set_notes_embedded_state(True)
            return
        card = self._notes_card
        if card is None:
            if self._notes_window:
                try:
                    self._notes_window.show()
                    self._notes_window.raise_()
                    self._notes_window.activateWindow()
                except Exception:
                    pass
            return
        if self._notes_card_tag:
            _save_card_geom(card, "builtin", self._notes_card_tag)
        body_layout = card.body.layout()
        if body_layout:
            body_layout.removeWidget(self._notes_widget)
        self._notes_widget.setParent(None)
        self._set_notes_embedded_state(False)
        try:
            window = _USER_GUIDED_NOTES_WINDOW_CLASS(self._notes_widget)  # type: ignore[misc]
        except Exception as exc:
            self._toast("Unable to pop out Notes window.", kind="error")
            log(f"Notes window creation failed: {exc}", logging.ERROR)
            if body_layout:
                body_layout.addWidget(self._notes_widget)
            self._set_notes_embedded_state(True)
            return
        self._notes_window = window
        try:
            window.destroyed.connect(self._on_notes_window_destroyed)
        except Exception:
            pass
        _restore_window_geom(window, "notes")
        try:
            window.show()
            window.raise_()
            window.activateWindow()
        except Exception:
            pass
        self._notes_card = None
        card.close()

    def _redock_notes_widget(self, widget: object) -> None:
        if widget is not self._notes_widget or self._notes_widget is None:
            return
        window = self._notes_window
        if window is None:
            self._set_notes_embedded_state(True)
            return
        _save_window_geom(window, "notes")
        taken_widget: Optional[QWidget] = None
        try:
            taken_widget = window.takeCentralWidget()
        except Exception:
            taken_widget = None
        if taken_widget is not None and taken_widget is not self._notes_widget:
            self._install_notes_widget(taken_widget)
        widget_obj = self._notes_widget
        if widget_obj is None:
            window.close()
            self._notes_window = None
            return
        widget_obj.setParent(None)
        notes_icon = QApplication.style().standardIcon(QStyle.SP_FileDialogDetailedView)
        card = self.add_card(
            widget_obj,
            "User-Guided Notes",
            task_profile="notes",
            task_icon=notes_icon,
            task_tooltip="User-Guided Notes",
        )
        self._notes_card = card
        if self._notes_card_tag:
            self._configure_notes_card(card, self._notes_card_tag)
        else:
            card.closed.connect(self._on_notes_card_closed)
        self._set_notes_embedded_state(True)
        self._bring_card_forward(card)
        self.camera.center_on_widget(card)
        window.close()
        self._notes_window = None

    def _on_notes_card_closed(self, card: object) -> None:
        if self._notes_card is card:
            self._notes_card = None
        if not self._notes_window:
            self._notes_card_tag = None

    def _on_notes_window_destroyed(self, *args) -> None:
        self._notes_window = None

    def _clear_notes_widget(self, *args) -> None:
        self._disconnect_notes_widget()
        self._notes_widget = None
        if not self._notes_window:
            self._notes_card = None
            self._notes_card_tag = None
    def _open_system_overview(self) -> None:
        if self._system_card and self._system_card.isVisible():
            self._bring_card_forward(self._system_card)
            self.camera.center_on_widget(self._system_card)
            return
        dataset_path = getattr(self.task_mgr, "dataset_path", None)
        try:
            dataset_root = Path(dataset_path).resolve().parent if dataset_path else Path(SCRIPT_DIR, "datasets")
        except Exception:
            dataset_root = Path(SCRIPT_DIR, "datasets")
        card = SystemOverviewCard(self.t, dataset_root, parent=self.canvas)
        tag = "(builtin:system-overview)"
        system_icon = QApplication.style().standardIcon(QStyle.SP_DesktopIcon)
        card = self._attach_card(
            card,
            task_profile="system-overview",
            task_icon=system_icon,
            task_tooltip="System Overview",
        )
        card.set_persist_tag(tag)
        _restore_card_geom(card, "builtin", tag)
        card.moved.connect(lambda: _save_card_geom(card, "builtin", tag))
        card.resized.connect(lambda: _save_card_geom(card, "builtin", tag))
        card.closed.connect(self._on_system_card_closed)
        self._system_card = card
        _remember_card("builtin", tag, "System Overview")
        self._bring_card_forward(card)
        self.camera.center_on_widget(card)
        log("System Overview opened")

    def _on_tasks_card_closed(self, *_):
        self._tasks_card = None
        self._tasks_widget = None

    def _on_system_card_closed(self, *_):
        self._system_card = None

    def _focus_task(self, task_id: Optional[str]) -> None:
        if not task_id or not self._tasks_widget:
            return
        panel = getattr(self._tasks_widget, "panel", None)
        if panel is None:
            return
        try:
            panel.refresh()
        except Exception:
            log(f"Task panel refresh failed for focus: {task_id}", logging.DEBUG)
        list_widget = getattr(panel, "list", None)
        if list_widget is None:
            return
        for idx in range(list_widget.count()):
            item = list_widget.item(idx)
            if item and item.data(Qt.UserRole) == task_id:
                list_widget.setCurrentItem(item)
                list_widget.scrollToItem(item)
                break

    def toggle_template_terminal(self, on: bool):
        tag = "(builtin:template)"
        if on:
            if self._template_card:
                self._bring_card_forward(self._template_card); self.camera.center_on_widget(self._template_card); return
            widget = TemplateTerminal(self.t)
            template_icon = QApplication.style().standardIcon(QStyle.SP_ComputerIcon)
            card = self.add_card(
                widget,
                "Template Terminal",
                task_profile="template-terminal",
                task_icon=template_icon,
                task_tooltip="Template Terminal",
            )
            card.set_persist_tag(tag)
            _restore_card_geom(card, "template", tag)
            card.moved.connect(lambda: _save_card_geom(card, "template", tag))
            card.resized.connect(lambda: _save_card_geom(card, "template", tag))
            def on_closed(_):
                self._template_card = None
            card.closed.connect(on_closed)
            self._template_card = card
            _remember_card("template", "(builtin)", "Template Terminal")
            self._bring_card_forward(card)
            self.camera.center_on_widget(card)
            log("Template Terminal opened")
        else:
            if self._template_card:
                c = self._template_card; self._template_card = None
                try: c._close_card()
                except Exception: pass
                log("Template Terminal closed")

    def _resolve_codex_terminal_path(self) -> Optional[str]:
        candidates = [
            os.environ.get("CODEX_TERMINAL_PATH", "").strip(),
            os.path.join(SCRIPT_DIR, "Codex_Terminal.py"),
            os.path.join(os.getcwd(), "Codex_Terminal.py"),
        ]
        path = next((p for p in candidates if p and os.path.isfile(p)), None)
        if path:
            return path
        selected, _ = _non_native_open_file(
            self,
            "Select Codex_Terminal.py",
            SCRIPT_DIR,
            "Python (*.py)",
        )
        return selected or None

    def open_codex_terminal(self):
        # Try common locations or prompt. Keep containment via non-native dialog.
        path = self._resolve_codex_terminal_path()
        if not path:
            QMessageBox.information(self, "Codex", "Codex_Terminal.py not found.")
            return
        codex_icon = QApplication.style().standardIcon(QStyle.SP_DesktopIcon)
        previous_env = os.environ.get("CODEX_WORKSPACE")
        workspace = workspace_root()
        applied_env = False
        if workspace:
            os.environ["CODEX_WORKSPACE"] = workspace
            applied_env = True
        try:
            card = self._load_python_as_card(
                path,
                persist_key=path,
                nice_title="Codex Terminal",
                task_profile="codex-terminal",
                task_icon=codex_icon,
                task_tooltip=path,
            )
        finally:
            if applied_env:
                if previous_env is None:
                    os.environ.pop("CODEX_WORKSPACE", None)
                else:
                    os.environ["CODEX_WORKSPACE"] = previous_env
        if card is None:
            log("[Codex] embed failed; showing System Console.", logging.ERROR)
            self._open_system_console()

# --------------------------------------------------------------------------------------
# Text/Image viewers
# --------------------------------------------------------------------------------------
class TextViewer(QWidget):
    def __init__(self, path: str, theme: Theme):
        super().__init__()
        v = QVBoxLayout(self); v.setContentsMargins(10,10,10,10); v.setSpacing(8)
        self.info = QLabel(os.path.basename(path)); self.info.setStyleSheet(f"color:{theme.text_muted}; font:600 10pt 'Cascadia Code';")
        v.addWidget(self.info)
        self.edit = QPlainTextEdit(self); self.edit.setReadOnly(True)
        apply_contrast_palette(self.edit, theme.editor_bg, theme.editor_fg)
        self.edit.setStyleSheet(
            f"QPlainTextEdit{{ background:{theme.editor_bg}; color:{theme.editor_fg}; border:1px solid {theme.card_border}; "
            f"selection-background-color:{theme.editor_sel}; font-family:'Cascadia Code',Consolas,monospace; }}"
        )
        try:
            with open(path, "r", encoding="utf-8", errors="replace") as f:
                self.edit.setPlainText(f.read())
        except Exception as e:
            self.edit.setPlainText(f"[Error] {e}")
        v.addWidget(self.edit, 1)

class ImageViewer(QWidget):
    def __init__(self, path: str, theme: Theme):
        super().__init__()
        v = QVBoxLayout(self); v.setContentsMargins(10,10,10,10); v.setSpacing(8)
        self.info = QLabel(os.path.basename(path)); self.info.setStyleSheet(f"color:{theme.text_muted}; font:600 10pt 'Cascadia Code';")
        v.addWidget(self.info)
        self.label = QLabel(self); self.label.setAlignment(Qt.AlignCenter)
        self.label.setStyleSheet(f"background:{theme.editor_bg}; border:1px solid {theme.card_border};")
        pix = QPixmap(path)
        if pix.isNull():
            self.label.setText("Unable to load image.")
        else:
            self.label.setPixmap(pix.scaled(1024, 768, Qt.KeepAspectRatio, Qt.SmoothTransformation))
        v.addWidget(self.label, 1)
        self.label.setScaledContents(False)

# --------------------------------------------------------------------------------------
# Process console (fallback)
# --------------------------------------------------------------------------------------
class ProcessConsole(QWidget):
    def __init__(
        self,
        theme: Theme,
        cmd: List[str],
        cwd: Optional[str] = None,
        guard: Optional[Callable[[List[str], Optional[str], bool], Tuple[bool, str]]] = None,
        *,
        allow_external_exec: bool = False,
        violation_cb: Optional[Callable[[str], None]] = None,
    ):
        super().__init__()
        self.t = theme
        self.cmd = list(cmd)
        self.cwd = os.path.abspath(cwd or SCRIPT_DIR)
        self.proc: Optional[subprocess.Popen] = None
        self.reader: Optional[threading.Thread] = None
        self._kill = threading.Event()
        self._guard = guard
        self._allow_external_exec = bool(allow_external_exec)
        self._violation_cb = violation_cb

        v = QVBoxLayout(self); v.setContentsMargins(10, 10, 10, 10); v.setSpacing(8)
        row = QHBoxLayout(); row.setSpacing(8)
        self.btn_start = QPushButton("Start"); self.btn_stop = QPushButton("Stop"); self.btn_stop.setEnabled(False)
        for b in (self.btn_start, self.btn_stop):
            b.setStyleSheet(f"QPushButton{{color:#fff;background:{self.t.accent};border:1px solid {self.t.card_border};border-radius:6px;padding:6px 10px;}}"
                            f"QPushButton:hover{{background:{self.t.accent_hov};}}")
        row.addWidget(self.btn_start); row.addWidget(self.btn_stop); row.addStretch(1)
        v.addLayout(row)

        self.console = QPlainTextEdit(self); self.console.setReadOnly(True)
        apply_contrast_palette(self.console, theme.editor_bg, theme.editor_fg)
        self.console.setStyleSheet(
            f"QPlainTextEdit{{ background:{theme.editor_bg}; color:{theme.editor_fg}; "
            f"selection-background-color:{self.t.editor_sel}; border:1px solid {self.t.card_border}; "
            f"font-family:'Cascadia Code',Consolas,monospace; }}"
        )
        v.addWidget(self.console, 1)
        self.btn_start.clicked.connect(self._start)
        self.btn_stop.clicked.connect(self._stop)

    def _println(self, s: str):
        self.console.appendPlainText(s)
        log(f"[process] {s}")

    def _start(self):
        if self.proc and self.proc.poll() is None: return
        detail = None
        if self._guard:
            allowed, detail = self._guard(self.cmd, self.cwd, self._allow_external_exec)
            if not allowed:
                message = detail or "Blocked: command rejected."
                self._println(message)
                log(f"[process] blocked: {' '.join(self.cmd)} — {message}", logging.WARNING)
                if self._violation_cb:
                    try:
                        self._violation_cb(message)
                    except Exception:
                        log("[process] violation callback failed", logging.DEBUG)
                return
        try:
            self._println(f"Run: {' '.join(self.cmd)}")
            if detail:
                log(f"[process] launching {detail} (cwd={self.cwd})")
            self.proc = subprocess.Popen(self.cmd, cwd=self.cwd, text=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        except Exception as e:
            self._println(f"Error: {e}"); return
        self._kill.clear()
        self.reader = threading.Thread(target=self._reader, daemon=True); self.reader.start()
        self.btn_start.setEnabled(False); self.btn_stop.setEnabled(True)
        self._println("Streaming output…")

    def _stop(self):
        if not self.proc: return
        self._kill.set()
        try: self.proc.terminate()
        except Exception: pass
        self.btn_start.setEnabled(True); self.btn_stop.setEnabled(False)
        self._println("Terminated")

    def _reader(self):
        assert self.proc and self.proc.stdout
        for line in self.proc.stdout:
            if self._kill.is_set(): break
            s = line.rstrip("\n")
            self.console.appendPlainText(s)
            log(f"[out] {s}")
        self.btn_start.setEnabled(True); self.btn_stop.setEnabled(False)

# --------------------------------------------------------------------------------------
# Persistence helpers
# --------------------------------------------------------------------------------------
def _restore_card_geom(card: Card, kind: str, persist_tag: str):
    st = _load_state(); key = _geom_key_for(kind, persist_tag)
    g = st.get("geom", {}).get(key)
    if not g: return
    try:
        saved_x = int(g["x"])
        saved_y = int(g["y"])
        saved_w = int(g["w"])
        saved_h = int(g["h"])
        saved_scale = float(g.get("scale", 1.0)) if g.get("scale") is not None else 1.0
        current_scale = float(getattr(card, "_vd_scale", saved_scale or 1.0))
        x, y, w, h = saved_x, saved_y, saved_w, saved_h
        if saved_scale > 0 and current_scale > 0 and not math.isclose(saved_scale, current_scale, rel_tol=1e-3):
            ratio = current_scale / saved_scale
            w = max(MIN_CARD_WIDTH, int(round(saved_w * ratio)))
            h = max(MIN_CARD_HEIGHT, int(round(saved_h * ratio)))
            center_x = saved_x + saved_w / 2
            center_y = saved_y + saved_h / 2
            x = int(round(center_x - w / 2))
            y = int(round(center_y - h / 2))
        parent = card.parentWidget()
        if parent:
            rect = parent.rect()
            max_x = max(8, rect.width() - w - 8)
            max_y = max(8, rect.height() - h - 8)
            x = max(8, min(x, max_x))
            y = max(8, min(y, max_y))
        card.resize(w, h); card.move(x, y)
        setattr(card, "_vd_scale", current_scale)
    except Exception:
        pass

def _save_card_geom(card: Card, kind: str, persist_tag: str):
    st = _load_state(); key = _geom_key_for(kind, persist_tag)
    st.setdefault("geom", {})[key] = {
        "x": card.x(),
        "y": card.y(),
        "w": card.width(),
        "h": card.height(),
        "scale": float(getattr(card, "_vd_scale", 1.0)),
    }
    _save_state(st)

def _restore_window_geom(window: QWidget, key: str) -> None:
    st = _load_state()
    payload = st.get("window_geom", {}).get(key)
    if not isinstance(payload, dict):
        return
    try:
        x = int(payload.get("x"))
        y = int(payload.get("y"))
        w = int(payload.get("w"))
        h = int(payload.get("h"))
    except Exception:
        return
    window.setGeometry(x, y, max(w, 1), max(h, 1))

def _save_window_geom(window: QWidget, key: str) -> None:
    geom = window.geometry()
    st = _load_state()
    st.setdefault("window_geom", {})[key] = {
        "x": geom.x(),
        "y": geom.y(),
        "w": geom.width(),
        "h": geom.height(),
    }
    _save_state(st)

# --------------------------------------------------------------------------------------
# Window wrapper
# --------------------------------------------------------------------------------------
class VirtualDesktopWindow(QMainWindow):
    def __init__(self, workspace: Optional[str] = None):
        super().__init__()
        self.t = Theme()
        pal = self.palette()
        # High-contrast window and text
        pal.setColor(QPalette.Window, QColor("#0a1430"))
        pal.setColor(QPalette.Base, QColor("#0a1430"))
        pal.setColor(QPalette.Text, QColor("#e6f0ff"))
        pal.setColor(QPalette.WindowText, QColor("#e6f0ff"))
        self.setPalette(pal)
        self.setWindowTitle("Virtual Desktop")
        self.core = VirtualDesktopCore(workspace=workspace, parent=self)
        self.setCentralWidget(self.core)

        # Menubar retains system-level items; former top toolbar actions moved into Start/Settings
        self._menu()
        self._shortcuts()

        # Start maximized with border so Min/Max/Close work; Fullscreen toggle is optional
        QTimer.singleShot(0, self.showMaximized)

        self.installEventFilter(self)
        self._is_fitting = False
        self._last_window_state = self.windowState()
        self._current_screen = self.windowHandle().screen() if self.windowHandle() else None
        if self.windowHandle():
            self.windowHandle().screenChanged.connect(self._handle_screen_changed)
        self._fit_timer = QTimer(self); self._fit_timer.setSingleShot(True)
        self._fit_timer.timeout.connect(self.fit_to_current_screen)
        self._force_taskbar_clear_timer = QTimer(self)
        self._force_taskbar_clear_timer.setSingleShot(True)
        self._force_taskbar_clear_timer.timeout.connect(self._clear_forced_native_taskbar_offset)
        self._pending_maximize_fit = False

    def _menu(self):
        bar: QMenuBar = self.menuBar()
        bar.setStyleSheet(
            f"""
            QMenuBar {{
                background: {self.t.menu_bg};
                color: {self.t.menu_fg};
                border: none;
            }}
            QMenuBar::item {{
                background: transparent;
                padding: 4px 8px;
            }}
            QMenuBar::item:selected {{ background: #0f1d33; }}
            QMenu {{
                background: #0b1828;
                color: {self.t.menu_fg};
                border: 1px solid {self.t.card_border};
            }}
            QMenu::item:selected {{ background: {self.t.accent}; color: #ffffff; }}
            """
        )
        view = bar.addMenu("&View")
        a_full = QAction("Toggle Fullscreen (Alt+Enter)", self); a_full.setShortcut("Alt+Return")
        a_full.triggered.connect(self._toggle_fullscreen); view.addAction(a_full)
        a_center = QAction("Center on Desktop (Ctrl+Home)", self); a_center.setShortcut("Ctrl+Home")
        a_center.triggered.connect(lambda: self.core.camera.center_on_widget(self.core.canvas)); view.addAction(a_center)
        a_fit = QAction("Fit to Current Screen", self); a_fit.setShortcut("Ctrl+0")
        a_fit.triggered.connect(self.fit_to_current_screen); view.addAction(a_fit)

        tools = bar.addMenu("&Tools")
        tools.addAction("Settings…", self.core._open_settings_panel)
        tools.addAction("System Console", self.core._open_system_console)
        tools.addAction("Error Center", self.core._open_error_center)
        tools.addAction("Open Desktop Explorer", self.core._open_explorer)
        tools.addAction("Template Terminal", lambda: self.core.toggle_template_terminal(True))
        tools.addAction("Load Script as Card…", self.core._load_script_dialog)
        tools.addAction("Open Codex_Terminal.py", self.core.open_codex_terminal)

        bar.addMenu("&Help").addAction("About", lambda: QMessageBox.information(self, "Virtual Desktop", "Contained virtual desktop. All dialogs non-native to keep containment.\nMin/Max/Close on each card.\nStart panel attached to taskbar."))

    def _shortcuts(self):
        def pan_guarded(dx, dy): self.core.camera.pan(dx, dy)
        self.addAction(self._mk_action("Ctrl+Left", lambda: pan_guarded(-160, 0)))
        self.addAction(self._mk_action("Ctrl+Right", lambda: pan_guarded(+160, 0)))
        self.addAction(self._mk_action("Ctrl+Up", lambda: pan_guarded(0, -160)))
        self.addAction(self._mk_action("Ctrl+Down", lambda: pan_guarded(0, +160)))

    def _mk_action(self, shortcut: str, fn):
        a = QAction(self); a.setShortcut(QKeySequence(shortcut)); a.triggered.connect(fn); return a

    def resizeEvent(self, event: QResizeEvent):
        super().resizeEvent(event)
        if self._is_fitting:
            return
        if self.isFullScreen():
            return
        if bool(self.windowState() & Qt.WindowMaximized):
            return
        timer = getattr(self.core, "_sync_timer", None)
        if timer is not None:
            timer.start(0)
        else:
            QTimer.singleShot(0, self.core._sync_canvas_to_screen)

    def showEvent(self, e):
        super().showEvent(e)
        QTimer.singleShot(0, self.fit_to_current_screen)

    def eventFilter(self, obj, ev):
        if ev.type() == QEvent.WindowStateChange:
            state_event: QWindowStateChangeEvent | None = None
            if isinstance(ev, QWindowStateChangeEvent):
                state_event = ev
            old_state = None
            if state_event is not None:
                getter = getattr(state_event, "oldState", None)
                if callable(getter):
                    try:
                        old_state = getter()
                    except Exception:
                        old_state = None
            if old_state is None:
                old_state = Qt.WindowStates(self._last_window_state)
            new_state = self.windowState()
            was_maximized = bool(old_state & Qt.WindowMaximized)
            is_maximized = bool(new_state & Qt.WindowMaximized)
            self._last_window_state = new_state
            if self._is_fitting:
                return super().eventFilter(obj, ev)
            if is_maximized and not was_maximized:
                self._pending_maximize_fit = True
                if not self._fit_timer.isActive():
                    self._fit_timer.start(10)
            elif was_maximized and not is_maximized:
                self._pending_maximize_fit = False
                self._fit_timer.stop()
        return super().eventFilter(obj, ev)

    def _handle_screen_changed(self, screen):
        if screen is self._current_screen:
            return
        self._current_screen = screen
        if self._is_fitting:
            return
        self._pending_maximize_fit = bool(self.windowState() & Qt.WindowMaximized)
        self._fit_timer.start(10)

    def _clear_forced_native_taskbar_offset(self):
        self.core.set_force_native_taskbar_offset(False)

    def fit_to_current_screen(self, *, force_native_taskbar: bool = False):
        if self._is_fitting:
            return
        self._is_fitting = True
        try:
            self._fit_timer.stop()
            if self.isFullScreen():
                if force_native_taskbar:
                    self.core.set_force_native_taskbar_offset(True)
                    self._force_taskbar_clear_timer.stop()
                self.core._sync_canvas_to_screen(force_native_taskbar=force_native_taskbar)
                if force_native_taskbar:
                    self._force_taskbar_clear_timer.start(0)
                self._pending_maximize_fit = False
                return
            scr = None
            if self.windowHandle() and self.windowHandle().screen():
                scr = self.windowHandle().screen()
            if not scr:
                scr = QGuiApplication.screenAt(self.frameGeometry().center())
            if not scr:
                scr = QGuiApplication.primaryScreen()
            self._current_screen = scr
            target_geom = QRect(scr.availableGeometry())
            applied = False
            should_force_taskbar = force_native_taskbar or self._pending_maximize_fit
            tolerance_px = 2

            def _within_tolerance(rect: QRect, target: QRect, tol: int) -> bool:
                return (
                    abs(rect.left() - target.left()) <= tol
                    and abs(rect.top() - target.top()) <= tol
                    and abs(rect.width() - target.width()) <= tol
                    and abs(rect.height() - target.height()) <= tol
                )

            handle = self.windowHandle()
            margins = None
            if handle is not None:
                try:
                    margins = handle.frameMargins()
                except Exception:
                    margins = None

            frame_rect = QRect()
            if handle is not None:
                try:
                    frame_rect = QRect(handle.frameGeometry())
                except Exception:
                    frame_rect = QRect()
            if not frame_rect.isValid() or frame_rect.isNull():
                frame_candidate = QRect(self.frameGeometry())
                if frame_candidate.isValid() and not frame_candidate.isNull():
                    frame_rect = frame_candidate

            def _apply_margins(rect: QRect) -> QRect:
                if margins is None or not rect.isValid() or rect.isNull():
                    return rect

                def _margin_value(name: str) -> int:
                    getter = getattr(margins, name, None)
                    value = 0.0
                    if callable(getter):
                        try:
                            value = getter()
                        except Exception:
                            value = 0.0
                    elif getter is not None:
                        value = getter
                    try:
                        return int(round(float(value)))
                    except Exception:
                        return 0

                left = _margin_value("left")
                top = _margin_value("top")
                right = _margin_value("right")
                bottom = _margin_value("bottom")
                adjusted_frame = QRect(rect)
                adjusted_frame.adjust(left, top, -right, -bottom)
                if adjusted_frame.isValid() and not adjusted_frame.isNull():
                    return adjusted_frame
                return rect

            is_maximized = bool(self.windowState() & Qt.WindowMaximized)
            current_client = QRect()
            if is_maximized:
                current_client = _apply_margins(frame_rect)
            else:
                if handle is not None:
                    try:
                        candidate = QRect(handle.geometry())
                    except Exception:
                        candidate = QRect()
                    if candidate.isValid() and not candidate.isNull():
                        current_client = candidate
                if not current_client.isValid() or current_client.isNull():
                    geom_candidate = QRect(self.geometry())
                    if geom_candidate.isValid() and not geom_candidate.isNull():
                        current_client = geom_candidate
                if not current_client.isValid() or current_client.isNull():
                    normal_candidate = QRect(self.normalGeometry())
                    if normal_candidate.isValid() and not normal_candidate.isNull():
                        current_client = normal_candidate

            if margins is not None and not is_maximized:
                current_client = _apply_margins(current_client)
            if current_client.isNull() or not current_client.isValid():
                current_client = QRect(target_geom)

            if is_maximized:
                matches_target = _within_tolerance(current_client, target_geom, tolerance_px)
                if matches_target:
                    self._pending_maximize_fit = False
                else:
                    should_force_taskbar = True
                    self.core.set_force_native_taskbar_offset(True)
                    self._force_taskbar_clear_timer.stop()

                    target_rect = QRect(target_geom)

                    def _apply_maximized_geometry():
                        try:
                            window = self.windowHandle()
                            if window is not None:
                                window.setGeometry(target_rect)
                                return
                        except Exception:
                            pass
                        try:
                            self.setGeometry(target_rect)
                        except Exception:
                            self.showMaximized()

                    self._pending_maximize_fit = False
                    QTimer.singleShot(0, _apply_maximized_geometry)
                    applied = True
            if should_force_taskbar and not applied:
                self.core.set_force_native_taskbar_offset(True)
                self._force_taskbar_clear_timer.stop()
            self.core._sync_canvas_to_screen(force_native_taskbar=should_force_taskbar)
            if should_force_taskbar:
                self._force_taskbar_clear_timer.start(0)
            self._pending_maximize_fit = False
            if applied:
                log(
                    f"Window fit to monitor: {target_geom.width()}x{target_geom.height()} @ {scr.name()}"
                )
            elif bool(self.windowState() & Qt.WindowMaximized):
                log(
                    "Window fit skipped — already aligned within tolerance; "
                    f"screen {scr.name()} available {target_geom.width()}x{target_geom.height()}"
                )
            else:
                log(
                    "Window fit skipped — not maximized; "
                    f"screen {scr.name()} available {target_geom.width()}x{target_geom.height()}"
                )
        finally:
            self._is_fitting = False

    def _toggle_fullscreen(self):
        if self.isFullScreen(): self.showNormal(); log("Exit fullscreen")
        else: self.showFullScreen(); log("Enter fullscreen")
        QTimer.singleShot(50, self.core._sync_canvas_to_screen)

# --------------------------------------------------------------------------------------
# Elevation helpers (Windows)
# --------------------------------------------------------------------------------------
def _is_windows() -> bool:
    return os.name == "nt"


def _query_windows_taskbar_height() -> int:
    if not _is_windows():
        return 0
    try:
        from ctypes import wintypes
    except Exception:
        return 0

    class RECT(ctypes.Structure):
        _fields_ = [
            ("left", ctypes.c_long),
            ("top", ctypes.c_long),
            ("right", ctypes.c_long),
            ("bottom", ctypes.c_long),
        ]

    class APPBARDATA(ctypes.Structure):
        _fields_ = [
            ("cbSize", ctypes.c_uint),
            ("hWnd", wintypes.HWND),
            ("uCallbackMessage", ctypes.c_uint),
            ("uEdge", ctypes.c_uint),
            ("rc", RECT),
            ("lParam", ctypes.c_long),
        ]

    ABM_GETTASKBARPOS = 0x00000005
    data = APPBARDATA()
    data.cbSize = ctypes.sizeof(APPBARDATA)
    try:
        result = ctypes.windll.shell32.SHAppBarMessage(ABM_GETTASKBARPOS, ctypes.byref(data))
    except Exception:
        return 0
    if not result:
        return 0
    if data.uEdge != 3:  # only bottom-aligned taskbar contributes to height offset
        return 0
    height = int(data.rc.bottom - data.rc.top)
    return max(0, height)


def _is_admin_windows() -> bool:
    if not _is_windows(): return True
    try:
        return ctypes.windll.shell32.IsUserAnAdmin()
    except Exception:
        return False
def _elevate_windows_if_needed():
    if not _is_windows(): return
    if os.environ.get("VD_NO_ELEVATE") == "1": return
    if _is_admin_windows(): return
    try:
        r = ctypes.windll.shell32.ShellExecuteW(None, "runas", sys.executable, f"\"{os.path.abspath(__file__)}\"", None, 1)
        if r > 32: sys.exit(0)
    except Exception as e:
        log(f"[elevate] failed: {e}", logging.WARNING)

# --------------------------------------------------------------------------------------
# Embedding API
# --------------------------------------------------------------------------------------
def build_widget(parent: Optional[QWidget] = None, workspace: Optional[str] = None):
    return VirtualDesktopCore(workspace=workspace, parent=parent)

def create_card(parent: Optional[QWidget] = None):
    w = build_widget(parent=parent, workspace=VDSK_ROOT)
    return w, "Virtual Desktop"

# --------------------------------------------------------------------------------------
# CLI
# --------------------------------------------------------------------------------------
def _parse_args():
    ap = argparse.ArgumentParser(description="Virtual Desktop")
    ap.add_argument("--open", dest="open_path", help="Load a script/binary as a Card")
    ap.add_argument("--show-template", action="store_true", help="Show the Template Terminal on launch")
    ap.add_argument("--workspace", help="Folder to scan for files on launch")
    return ap.parse_args()

def main():
    _elevate_windows_if_needed()
    args = _parse_args()
    app = QApplication(sys.argv)
    win = VirtualDesktopWindow(workspace=args.workspace)
    if args.show_template:
        QTimer.singleShot(0, lambda: win.core.toggle_template_terminal(True))
    if args.open_path:
        QTimer.singleShot(0, lambda: win.core.open_any_path(args.open_path))
    win.show()
    log("Application exec()")
    rc = app.exec()
    log(f"Application exit code: {rc}")
    sys.exit(rc)

if __name__ == "__main__":
    main()
```

Virtual_Desktop.py — Windows-style virtual desktop (contained), with Start panel and card window controls.

Directives satisfied:
- All former top toolbar actions moved into Start panel and Settings; no floating top bar.
- Start menu is a docked panel that rises from the taskbar and stays attached to the bottom.
- Window has standard minimize, maximize, close in the top-right (Qt title bar). Starts maximized with border.
- Each Card has its own Minimize, Max/Restore, Close buttons. Minimize hides to taskbar, restore via task button.
- Desktop edge trim removed. Background is clean blue gradient. High contrast enforced for text vs background.
- No drag-out to OS. No file URL clipboard exports. All dialogs non-native and modal to keep containment.
- Explorer and desktop icons support rename with extensions. Type/extension changes reflect immediately.
- Visual refreshes are immediate after file ops. QFileSystemWatcher also keeps UI current.
- Codex_Terminal.py can be launched from Start ▸ Apps ▸ Codex Terminal as an embedded card (factory supports embedded=True).  # See note re: citation in chat.

Notes:
- Contrast rule: inline comments and palettes ensure readable foreground/background in all states.
- Start panel includes: Apps (Explorer, Codex Terminal, Template Terminal), Recent, Settings, Power menu, Search.
- Settings panel collects previous toolbar utilities and view toggles.
**Classes:** _FallbackTaskManager, Theme, SystemConsole, TemplateTerminal, ExplorerCard, CardSizeGrip, Card, SystemOverviewCard, DesktopIcon, DesktopCanvas, Camera, StartPanel, TaskGroup, Taskbar, SettingsPanel, VirtualDesktopCore, TextViewer, ImageViewer, ProcessConsole, VirtualDesktopWindow
**Functions:** workspace_root(), _is_contained(path), _safe_resolve(path_str), _build_allowlist(), _make_card_pointer(card), _is_card_valid(card), _make_guarded_card_method(card, method), _try_provider_icon(path), _fallback_icon_for_path(path), _icon_for_path(path_like), _clear_native_icon_caches(), _resolve_executable_path(cmd, cwd), _validate_process_request(cmd, cwd, allow_external), log(msg, level), _encode_icon(icon, size), _decode_icon(data), _icon_for_profile(profile), _load_state(), _save_state(state), _remember_card(kind, path, title), _geom_key_for(kind, persist_tag), _rect_to_dict(rect), _widget_geometry_snapshot(widget), _script_type_label(path), _score_from_error_count(error_count), _score_bucket_key(score), _last_run_bucket(last_run_ts), _flatten_metrics_summary(summary), _filter_metrics_rows(rows), _score_distribution(rows), _fallback_build_editor_widget(parent, initial_path), _fallback_open_card(), apply_contrast_palette(w, bg_hex, fg_hex), _non_native_open_files(parent, caption, start_dir, filt), _non_native_open_file(parent, caption, start_dir, filt), _non_native_open_dir(parent, caption, start_dir), _restore_card_geom(card, kind, persist_tag), _save_card_geom(card, kind, persist_tag), _restore_window_geom(window, key), _save_window_geom(window, key), _is_windows(), _query_windows_taskbar_height(), _is_admin_windows(), _elevate_windows_if_needed(), build_widget(parent, workspace), create_card(parent), _parse_args(), main()


## Module `background\base.py`

```python
"""Background layer abstractions for the Virtual Desktop."""

from __future__ import annotations

from dataclasses import dataclass
from enum import Enum
from typing import Callable, Dict, Optional

from PySide6.QtCore import QObject, QSize
from PySide6.QtGui import QPainter


class BackgroundMode(str, Enum):
    """Supported background layer types."""

    SOLID = "solid"
    STATIC = "image"
    GIF = "gif"
    VIDEO = "video"
    GL = "gl"


class BackgroundFit(str, Enum):
    """Scaling strategies for image-backed backgrounds."""

    FILL = "fill"
    FIT = "fit"
    CENTER = "center"
    TILE = "tile"


@dataclass
class BackgroundConfig:
    """Runtime configuration for a background layer."""

    mode: BackgroundMode = BackgroundMode.SOLID
    source: str = ""
    fit: BackgroundFit = BackgroundFit.FILL
    loop: bool = True
    mute: bool = True
    playback_rate: float = 1.0

    @classmethod
    def from_state(cls, raw: object) -> "BackgroundConfig":
        """Create a config from the persisted vd_state entry."""

        if isinstance(raw, dict):
            mode = raw.get("mode", BackgroundMode.SOLID)
            source = raw.get("source", "")
            fit = raw.get("fit", BackgroundFit.FILL)
            loop = bool(raw.get("loop", True))
            mute = bool(raw.get("mute", True))
            try:
                playback_rate = float(raw.get("playback_rate", 1.0))
            except Exception:
                playback_rate = 1.0
        elif isinstance(raw, str) and raw:
            mode = BackgroundMode.STATIC
            source = raw
            fit = BackgroundFit.FILL
            loop = True
            mute = True
            playback_rate = 1.0
        else:
            mode = BackgroundMode.SOLID
            source = ""
            fit = BackgroundFit.FILL
            loop = True
            mute = True
            playback_rate = 1.0

        try:
            mode = BackgroundMode(mode)
        except Exception:
            mode = BackgroundMode.SOLID
        try:
            fit = BackgroundFit(fit)
        except Exception:
            fit = BackgroundFit.FILL
        return cls(mode=mode, source=source, fit=fit, loop=loop, mute=mute, playback_rate=playback_rate)

    def to_state(self) -> Dict[str, object]:
        """Serialize to vd_state-compatible dictionary."""

        return {
            "mode": self.mode.value,
            "source": self.source,
            "fit": self.fit.value,
            "loop": bool(self.loop),
            "mute": bool(self.mute),
            "playback_rate": float(self.playback_rate),
        }


class BackgroundLayer(QObject):
    """Interface implemented by background layer engines."""

    def __init__(self, canvas):
        super().__init__(canvas)
        self.canvas = canvas

    def start(self, config: BackgroundConfig) -> None:
        """Activate the background using the provided configuration."""

    def stop(self) -> None:
        """Deactivate the background and release resources."""

    def paint(self, painter: QPainter, rect) -> bool:  # pragma: no cover - tiny wrapper
        """Draw into the canvas. Return True if painting handled."""

        return False

    def resize(self, size: QSize) -> None:
        """Resize hook used by the canvas when it changes dimensions."""


class BackgroundManager(QObject):
    """Lifecycle coordinator for desktop background layers."""

    def __init__(self, canvas):
        super().__init__(canvas)
        self.canvas = canvas
        self._factories: Dict[BackgroundMode, Callable[[object], BackgroundLayer]] = {}
        self._instances: Dict[BackgroundMode, BackgroundLayer] = {}
        self._active: Optional[BackgroundLayer] = None
        self._active_mode: Optional[BackgroundMode] = None

    def register(self, mode: BackgroundMode, factory: Callable[[object], BackgroundLayer]) -> None:
        self._factories[mode] = factory

    def apply(self, config: Optional[BackgroundConfig]) -> None:
        if config is None:
            self.clear()
            return
        if self._active and self._active_mode != config.mode:
            self._active.stop()
            self._active = None
            self._active_mode = None
        factory = self._factories.get(config.mode)
        if factory is None:
            self.clear()
            return
        layer = self._instances.get(config.mode)
        if layer is None:
            layer = factory(self.canvas)
            self._instances[config.mode] = layer
        self._active = layer
        self._active_mode = config.mode
        layer.start(config)
        layer.resize(self.canvas.size())
        self.canvas.update()

    def clear(self) -> None:
        if self._active:
            self._active.stop()
        self._active = None
        self._active_mode = None
        self.canvas.update()

    def paint(self, painter: QPainter, rect) -> bool:
        if self._active:
            return bool(self._active.paint(painter, rect))
        return False

    def resize(self, size: QSize) -> None:
        if self._active:
            self._active.resize(size)

    @property
    def active_mode(self) -> Optional[BackgroundMode]:
        return self._active_mode
```

Background layer abstractions for the Virtual Desktop.
**Classes:** BackgroundMode, BackgroundFit, BackgroundConfig, BackgroundLayer, BackgroundManager


## Module `background\gif.py`

```python
"""Animated GIF background implementation."""

from __future__ import annotations

import os
from typing import Optional

from PySide6.QtCore import Qt, QSize
from PySide6.QtGui import QMovie
from PySide6.QtWidgets import QLabel

from .base import BackgroundConfig, BackgroundFit, BackgroundLayer


class GifBg(BackgroundLayer):
    """Display an animated GIF behind desktop icons."""

    def __init__(self, canvas):
        super().__init__(canvas)
        self._label = QLabel(canvas)
        self._label.setObjectName("DesktopGifBackground")
        self._label.setAlignment(Qt.AlignCenter)
        self._label.setAttribute(Qt.WA_TransparentForMouseEvents, True)
        self._label.hide()
        self._movie: Optional[QMovie] = None
        self._config: Optional[BackgroundConfig] = None

    def start(self, config: BackgroundConfig) -> None:
        self._config = config
        if self._movie:
            self._movie.stop()
        if not (config.source and os.path.isfile(config.source)):
            self.stop()
            return
        movie = QMovie(config.source)
        if not movie.isValid():
            self.stop()
            return
        self._movie = movie
        self._label.setMovie(movie)
        self._label.show()
        self._label.lower()
        self.resize(self.canvas.size())
        movie.start()

    def stop(self) -> None:
        if self._movie:
            self._movie.stop()
        self._movie = None
        self._label.clear()
        self._label.hide()

    def resize(self, size: QSize) -> None:
        self._label.setGeometry(0, 0, size.width(), size.height())
        if not self._movie or not self._config:
            return
        fit = self._config.fit
        if fit == BackgroundFit.CENTER:
            self._label.setScaledContents(False)
            self._label.setAlignment(Qt.AlignCenter)
        else:
            self._label.setScaledContents(True)
            self._label.setAlignment(Qt.AlignCenter)
            self._movie.setScaledSize(size)

    def paint(self, *_args) -> bool:
        # Rendering handled by QLabel/QMovie.
        return bool(self._movie)
```

Animated GIF background implementation.
**Classes:** GifBg


## Module `background\gl.py`

```python
"""Programmable OpenGL background layer."""

from __future__ import annotations

import logging
from typing import Callable, Optional, TYPE_CHECKING

from PySide6.QtCore import QSize

from .base import BackgroundConfig, BackgroundLayer
from .live_engine import LiveScriptViewport

LOGGER = logging.getLogger("VirtualDesktop.GLBackground")

if TYPE_CHECKING:  # pragma: no cover - typing only
    from .live_engine import LiveScriptViewport as _ViewportType


class GLViewportBg(BackgroundLayer):
    """Host a programmable OpenGL viewport as the background."""

    def __init__(self, canvas):
        super().__init__(canvas)
        self._viewport: Optional["_ViewportType"] = None
        self._config: Optional[BackgroundConfig] = None

    def _ensure_viewport(self) -> bool:
        if LiveScriptViewport is None:
            LOGGER.warning("Qt OpenGL widgets unavailable; GL background disabled")
            return False
        if self._viewport is None:
            self._viewport = LiveScriptViewport(self.canvas)
            self._viewport.setObjectName("DesktopGLViewport")
            self._viewport.hide()
        checker = self._resolve_heavy_checker()
        if checker:
            self._viewport.set_heavy_process_checker(checker)
        return True

    def start(self, config: BackgroundConfig) -> None:
        self._config = config
        if not (config.source and self._ensure_viewport()):
            self.stop()
            return
        assert self._viewport is not None
        try:
            base_fps = LiveScriptViewport.DEFAULT_FPS if LiveScriptViewport else 60.0
            playback = float(config.playback_rate or 1.0)
            fps = max(LiveScriptViewport.MIN_FPS, min(LiveScriptViewport.MAX_FPS, base_fps * playback))
        except Exception:
            fps = LiveScriptViewport.DEFAULT_FPS if LiveScriptViewport else 60.0
        self._viewport.set_fps_cap(fps)
        self._viewport.set_script(config.source)
        checker = self._resolve_heavy_checker()
        if checker:
            self._viewport.set_heavy_process_checker(checker)
        self._viewport.show()
        self._viewport.lower()
        self.resize(self.canvas.size())
        self._viewport.start()

    def stop(self) -> None:
        if self._viewport:
            self._viewport.stop()
            self._viewport.hide()
        self._config = None

    def resize(self, size: QSize) -> None:
        if self._viewport:
            self._viewport.setGeometry(0, 0, size.width(), size.height())

    def paint(self, *_args) -> bool:
        return bool(self._viewport and self._viewport.isVisible())

    def _resolve_heavy_checker(self) -> Optional[Callable[[], bool]]:
        if self.canvas is None or self.canvas.window() is None:
            return None
        window = self.canvas.window()
        checker = getattr(window, "is_heavy_process_active", None)
        if callable(checker):
            return lambda: bool(checker())
        return None
```

Programmable OpenGL background layer.
**Classes:** GLViewportBg


## Module `background\live_engine.py`

```python
"""Live OpenGL background engine with script hot-reload and throttled rendering."""

from __future__ import annotations

import importlib.util
import logging
import os
import sys
import time
from dataclasses import dataclass
from types import ModuleType
from typing import Callable, Optional

from PySide6.QtCore import QObject, QTimer, Qt

try:  # Optional dependency: OpenGL widget may be unavailable in headless envs
    from PySide6.QtOpenGLWidgets import QOpenGLWidget
except Exception:  # pragma: no cover - optional dependency guard
    QOpenGLWidget = None  # type: ignore

try:  # Optional: use psutil when available to gauge heavy system load
    import psutil  # type: ignore
except Exception:  # pragma: no cover - optional dependency guard
    psutil = None  # type: ignore

LOGGER = logging.getLogger("VirtualDesktop.LiveEngine")


@dataclass
class ScriptHooks:
    """Bundle of lifecycle hooks exposed by a background script."""

    module: ModuleType
    path: str
    mtime: float

    def invoke(self, name: str, *args) -> None:
        func = getattr(self.module, name, None)
        if callable(func):
            func(*args)


class LiveScriptController(QObject):
    """Manage loading and hot-reloading of a background script module."""

    def __init__(self, parent: Optional[QObject] = None) -> None:
        super().__init__(parent)
        self._hooks: Optional[ScriptHooks] = None
        self._script_path: Optional[str] = None
        self._missing_warned = False

    @property
    def module(self) -> Optional[ModuleType]:
        return self._hooks.module if self._hooks else None

    @property
    def script_path(self) -> str:
        return self._script_path or ""

    def set_script(self, path: Optional[str]) -> None:
        self._script_path = path or ""
        self._missing_warned = False
        if not self._script_path:
            self._hooks = None
            return
        self._load(force=True)

    def reload_if_changed(self) -> bool:
        """Reload the script when the file timestamp changes or becomes available."""

        if not self._script_path:
            return False
        try:
            mtime = os.path.getmtime(self._script_path)
        except OSError:
            if not self._missing_warned:
                LOGGER.warning("Live background script missing: %s", self._script_path)
                self._missing_warned = True
            self._hooks = None
            return False
        if not self._hooks:
            self._load(force=True)
            return self._hooks is not None
        if mtime <= self._hooks.mtime:
            return False
        self._load(force=True)
        return self._hooks is not None and self._hooks.mtime == mtime

    def _load(self, force: bool = False) -> None:
        path = self._script_path
        if not path:
            self._hooks = None
            return
        try:
            mtime = os.path.getmtime(path)
        except OSError:
            if not self._missing_warned:
                LOGGER.warning("Live background script not found: %s", path)
                self._missing_warned = True
            self._hooks = None
            return
        if not force and self._hooks and mtime <= self._hooks.mtime:
            return
        spec = importlib.util.spec_from_file_location("vdsk_live_background", path)
        if not spec or not spec.loader:
            LOGGER.error("Unable to create spec for live background script: %s", path)
            self._hooks = None
            return
        module = importlib.util.module_from_spec(spec)
        try:
            loader = spec.loader
            assert loader is not None
            loader.exec_module(module)  # type: ignore[union-attr]
        except Exception:
            LOGGER.exception("Live background script import failed")
            self._hooks = None
            return
        sys.modules[spec.name] = module
        self._hooks = ScriptHooks(module=module, path=path, mtime=mtime)
        self._missing_warned = False

    def call(self, name: str, *args) -> None:
        if not self._hooks:
            return
        try:
            self._hooks.invoke(name, *args)
        except Exception:
            LOGGER.exception("Live background script %s() failed", name)


if QOpenGLWidget is None:  # pragma: no cover - executed when Qt OpenGL widget missing
    LiveScriptViewport = None  # type: ignore
else:

    class LiveScriptViewport(QOpenGLWidget):  # pragma: no cover - requires OpenGL context
        """OpenGL viewport that executes scripted hooks at a capped frame rate."""

        DEFAULT_FPS = 60.0
        MIN_FPS = 5.0
        MAX_FPS = 120.0
        RESOURCE_POLL_INTERVAL = 1.0
        CPU_THRESHOLD = 85.0
        MEMORY_THRESHOLD = 90.0

        def __init__(self, parent=None) -> None:
            super().__init__(parent)
            self.setAttribute(Qt.WA_TransparentForMouseEvents, True)
            self.setUpdateBehavior(QOpenGLWidget.PartialUpdate)
            self._controller = LiveScriptController(self)
            self._timer = QTimer(self)
            self._timer.setTimerType(Qt.PreciseTimer)
            self._timer.timeout.connect(self._tick)
            self._fps_cap = self.DEFAULT_FPS
            self._pending_dt = 0.0
            self._last_frame_time: Optional[float] = None
            self._needs_init = False
            self._heavy_checker: Optional[Callable[[], bool]] = None
            self._resource_flag = False
            self._last_resource_poll = 0.0

        # ---- configuration helpers -------------------------------------------------
        def set_script(self, path: Optional[str]) -> None:
            self._controller.set_script(path)
            self._needs_init = True
            self._last_frame_time = None
            if path:
                self._ensure_running()
            else:
                self.stop()

        def set_fps_cap(self, fps: float) -> None:
            fps = max(self.MIN_FPS, min(self.MAX_FPS, float(fps) if fps else self.DEFAULT_FPS))
            self._fps_cap = fps
            if self._timer.isActive():
                self._ensure_running()

        def set_heavy_process_checker(self, checker: Optional[Callable[[], bool]]) -> None:
            self._heavy_checker = checker

        def start(self) -> None:
            if not self._timer.isActive():
                self._ensure_running()

        def stop(self) -> None:
            self._timer.stop()

        # ---- Qt lifecycle ----------------------------------------------------------
        def initializeGL(self) -> None:
            self._needs_init = True
            self._last_frame_time = time.monotonic()

        def resizeGL(self, w: int, h: int) -> None:
            self._controller.call("resize", w, h)

        def paintGL(self) -> None:
            module = self._controller.module
            if module is None:
                return
            if self._needs_init and self.isValid():
                self._controller.call("init", self)
                self._needs_init = False
            dt = self._pending_dt
            if dt < 0:
                dt = 0.0
            self._controller.call("update", dt)
            self._controller.call("render", self)

        def showEvent(self, event):  # pragma: no cover - thin Qt wrapper
            super().showEvent(event)
            self._ensure_running()

        def hideEvent(self, event):  # pragma: no cover - thin Qt wrapper
            super().hideEvent(event)
            self.stop()

        # ---- internal helpers ------------------------------------------------------
        def _ensure_running(self) -> None:
            if not self._controller.module and not self._controller.script_path:
                return
            interval_ms = int(max(1.0, 1000.0 / self._fps_cap))
            self._timer.start(interval_ms)

        def _tick(self) -> None:
            changed = self._controller.reload_if_changed()
            if self._controller.module is None:
                return
            if changed:
                self._needs_init = True
            if not self._should_render():
                self._last_frame_time = None
                return
            now = time.monotonic()
            if self._last_frame_time is None:
                self._pending_dt = 0.0
            else:
                self._pending_dt = max(0.0, now - self._last_frame_time)
            self._last_frame_time = now
            self.update()

        def _should_render(self) -> bool:
            if not self.isVisible():
                return False
            window = self.window()
            if window is not None:
                if hasattr(window, "isMinimized") and window.isMinimized():
                    return False
                if not window.isVisible():
                    return False
            if self._heavy_checker and self._heavy_checker():
                return False
            now = time.monotonic()
            if now - self._last_resource_poll >= self.RESOURCE_POLL_INTERVAL:
                self._resource_flag = self._system_is_heavy()
                self._last_resource_poll = now
            if self._resource_flag:
                return False
            return True

        def _system_is_heavy(self) -> bool:
            if psutil is None:
                return False
            try:
                cpu = psutil.cpu_percent(interval=None)
                if cpu >= self.CPU_THRESHOLD:
                    return True
                mem = psutil.virtual_memory().percent
                return mem >= self.MEMORY_THRESHOLD
            except Exception:
                return False
```

Live OpenGL background engine with script hot-reload and throttled rendering.
**Classes:** ScriptHooks, LiveScriptController


## Module `background\static.py`

```python
"""Static image background implementation."""

from __future__ import annotations

import os
from typing import Optional

from PySide6.QtCore import Qt, QRect
from PySide6.QtGui import QPixmap, QPainter, QBrush

from .base import BackgroundConfig, BackgroundFit, BackgroundLayer


class StaticImageBg(BackgroundLayer):
    """Render a still image as the desktop background."""

    def __init__(self, canvas):
        super().__init__(canvas)
        self._pixmap: Optional[QPixmap] = None
        self._config: Optional[BackgroundConfig] = None

    def start(self, config: BackgroundConfig) -> None:
        self._config = config
        if config.source and os.path.isfile(config.source):
            pixmap = QPixmap(config.source)
            self._pixmap = pixmap if not pixmap.isNull() else None
        else:
            self._pixmap = None

    def stop(self) -> None:
        self._pixmap = None

    def paint(self, painter: QPainter, rect: QRect) -> bool:
        if not self._pixmap or not self._config:
            return False
        fit = self._config.fit
        if fit == BackgroundFit.TILE:
            brush = QBrush(self._pixmap)
            painter.fillRect(rect, brush)
            return True
        if fit == BackgroundFit.CENTER:
            target = self._pixmap.rect()
            target.moveCenter(rect.center())
            painter.drawPixmap(target, self._pixmap)
            return True
        mode = Qt.KeepAspectRatio
        if fit == BackgroundFit.FILL:
            mode = Qt.KeepAspectRatioByExpanding
        scaled = self._pixmap.scaled(rect.size(), mode, Qt.SmoothTransformation)
        painter.drawPixmap(rect, scaled)
        return True
```

Static image background implementation.
**Classes:** StaticImageBg


## Module `background\video.py`

```python
"""Video background implementation."""

from __future__ import annotations

import os
from typing import Optional

from PySide6.QtCore import Qt, QSize, QUrl

try:  # QtMultimedia may be missing in minimal environments
    from PySide6.QtMultimedia import QAudioOutput, QMediaPlayer
    from PySide6.QtMultimediaWidgets import QVideoWidget
except Exception:  # pragma: no cover - optional dependency guard
    QAudioOutput = None  # type: ignore
    QMediaPlayer = None  # type: ignore
    QVideoWidget = None  # type: ignore

from .base import BackgroundConfig, BackgroundLayer


class VideoBg(BackgroundLayer):
    """Loop a muted video behind the desktop icons."""

    def __init__(self, canvas):
        super().__init__(canvas)
        self._player: Optional[QMediaPlayer] = None
        self._audio: Optional[QAudioOutput] = None
        self._widget: Optional[QVideoWidget] = None
        self._config: Optional[BackgroundConfig] = None

    # Helper to lazily construct multimedia stack
    def _ensure_stack(self) -> bool:
        if QMediaPlayer is None or QVideoWidget is None or QAudioOutput is None:
            return False
        if self._player is None:
            self._player = QMediaPlayer(self.canvas)
            self._audio = QAudioOutput(self.canvas)
            self._player.setAudioOutput(self._audio)
            self._widget = QVideoWidget(self.canvas)
            self._widget.setObjectName("DesktopVideoBackground")
            self._widget.setAttribute(Qt.WA_TransparentForMouseEvents, True)
            self._widget.hide()
            self._player.mediaStatusChanged.connect(self._handle_status)
        return True

    def start(self, config: BackgroundConfig) -> None:
        self._config = config
        if not (config.source and os.path.isfile(config.source)):
            self.stop()
            return
        if not self._ensure_stack():
            self.stop()
            return
        assert self._player and self._widget and self._audio  # satisfy type checkers
        self._player.stop()
        self._player.setSource(QUrl.fromLocalFile(config.source))
        try:
            loops = -1 if config.loop else 1
            self._player.setLoops(loops)
        except Exception:
            pass
        self._audio.setMuted(bool(config.mute))
        self._player.setPlaybackRate(config.playback_rate or 1.0)
        self._widget.show()
        self._widget.lower()
        self.resize(self.canvas.size())
        self._player.play()

    def stop(self) -> None:
        if self._player:
            self._player.stop()
        if self._widget:
            self._widget.hide()
        self._config = None

    def resize(self, size: QSize) -> None:
        if self._widget:
            self._widget.setGeometry(0, 0, size.width(), size.height())

    def paint(self, *_args) -> bool:
        return bool(self._widget and self._widget.isVisible())

    def _handle_status(self, status) -> None:  # pragma: no cover - signal callback
        if not self._player or not self._config or QMediaPlayer is None:
            return
        try:
            end_status = QMediaPlayer.MediaStatus.EndOfMedia
        except Exception:  # Fallback for older Qt
            end_status = getattr(QMediaPlayer, "EndOfMedia", None)
        if getattr(self._config, "loop", True) and status == end_status:
            self._player.setPosition(0)
            self._player.play()
```

Video background implementation.
**Classes:** VideoBg


## Module `background\__init__.py`

```python
"""Virtual Desktop background layer implementations."""

from .base import BackgroundConfig, BackgroundFit, BackgroundLayer, BackgroundManager, BackgroundMode
from .static import StaticImageBg
from .gif import GifBg
from .video import VideoBg
from .gl import GLViewportBg
from .live_engine import LiveScriptViewport

__all__ = [
    "BackgroundConfig",
    "BackgroundFit",
    "BackgroundLayer",
    "BackgroundManager",
    "BackgroundMode",
    "StaticImageBg",
    "GifBg",
    "VideoBg",
    "GLViewportBg",
    "LiveScriptViewport",
]
```

Virtual Desktop background layer implementations.


## Module `editor\card.py`

```python
"""PySide6 editor card with inline chat, notes, and summarization."""

from __future__ import annotations

import html
import json
import keyword
import os
import re
import subprocess
import sys
import threading
import uuid
from dataclasses import dataclass
from datetime import datetime
from pathlib import Path
from typing import Dict, Iterable, List, Optional, Sequence

from PySide6.QtCore import Qt, QRect, QSize, QTimer, QUrl
from PySide6.QtGui import (
    QColor,
    QFont,
    QPainter,
    QPalette,
    QTextCharFormat,
    QTextCursor,
    QSyntaxHighlighter,
)
from PySide6.QtWidgets import (
    QFileDialog,
    QComboBox,
    QHBoxLayout,
    QLabel,
    QListWidget,
    QListWidgetItem,
    QMessageBox,
    QPlainTextEdit,
    QPushButton,
    QSizePolicy,
    QSplitter,
    QTabWidget,
    QTextBrowser,
    QTextEdit,
    QVBoxLayout,
    QWidget,
)

from . import logic_doc

try:  # pragma: no cover - optional import
    from Codex_Terminal import OllamaClient  # type: ignore
except Exception:  # pragma: no cover - fallback when module unavailable
    OllamaClient = None  # type: ignore


_STORAGE_ROOT = Path("memory")
_CHAT_DIR_NAME = "editor_chats"
_NOTES_DIR_NAME = "editor_notes"
_TIMESTAMP_FORMAT = "%Y-%m-%dT%H:%M:%SZ"
_SLUG_PATTERN = re.compile(r"[^a-zA-Z0-9]+")


@dataclass
class Theme:
    """Minimal theme definition for consistent styling."""

    background: str = "#0b1828"
    foreground: str = "#d6e6ff"
    panel_bg: str = "#101d33"
    accent: str = "#1E5AFF"
    muted: str = "#9bb4dd"


@dataclass
class ConversationEntry:
    role: str
    content: str
    model: str
    timestamp: str


@dataclass
class PinnedNote:
    note_id: str
    content: str
    source: str
    timestamp: str

    def title(self) -> str:
        for line in self.content.splitlines():
            stripped = line.strip()
            if stripped:
                if len(stripped) > 60:
                    return stripped[:57] + "…"
                return stripped
        return "(empty note)"


def _slug_for_path(path: Optional[Path]) -> str:
    if path is None:
        return "buffer"
    try:
        resolved = path.resolve()
    except Exception:
        resolved = path
    slug = _SLUG_PATTERN.sub("-", str(resolved)).strip("-")
    return slug or "buffer"


class LineNumberArea(QWidget):
    def __init__(self, editor: "CodeEditor") -> None:
        super().__init__(editor)
        self._editor = editor

    def sizeHint(self) -> QSize:  # pragma: no cover - trivial
        return QSize(self._editor.line_number_area_width(), 0)

    def paintEvent(self, event) -> None:  # pragma: no cover - trivial paint hook
        self._editor.line_number_area_paint_event(event)


class CodeEditor(QPlainTextEdit):
    """Plain text editor with line numbers and themed palette."""

    def __init__(self, theme: Theme, parent: Optional[QWidget] = None) -> None:
        super().__init__(parent)
        self._theme = theme
        self._line_area = LineNumberArea(self)
        self._error_selections: List[QTextEdit.ExtraSelection] = []
        self._current_line_selection: Optional[QTextEdit.ExtraSelection] = None
        self.blockCountChanged.connect(self._update_line_area_width)
        self.updateRequest.connect(self._update_line_area)
        self.cursorPositionChanged.connect(self._highlight_current_line)
        self.setLineWrapMode(QPlainTextEdit.NoWrap)
        self.setTabStopDistance(4 * self.fontMetrics().horizontalAdvance(" "))
        self.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        self._apply_palette()
        self._update_line_area_width(0)
        self._highlight_current_line()

    def _apply_palette(self) -> None:
        palette = self.palette()
        bg = QColor(self._theme.background)
        fg = QColor(self._theme.foreground)
        sel = QColor(self._theme.accent)
        for group in (QPalette.Active, QPalette.Inactive, QPalette.Disabled):
            palette.setColor(group, QPalette.Base, bg)
            palette.setColor(group, QPalette.Text, fg)
            palette.setColor(group, QPalette.Window, bg)
            palette.setColor(group, QPalette.WindowText, fg)
            palette.setColor(group, QPalette.Highlight, sel)
            palette.setColor(group, QPalette.HighlightedText, QColor("#ffffff"))
        self.setPalette(palette)
        self.setStyleSheet(
            "QPlainTextEdit {"
            f" border: 1px solid #1b2a3f;"
            f" border-radius: 10px;"
            f" font-family: 'Cascadia Code', Consolas, monospace;"
            f" font-size: 11pt;"
            f" color: {self._theme.foreground};"
            f" background-color: {self._theme.background};"
            "}"
        )


    def _apply_extra_selections(self) -> None:
        selections: List[QTextEdit.ExtraSelection] = []
        if self._current_line_selection is not None:
            selections.append(self._current_line_selection)
        selections.extend(self._error_selections)
        super().setExtraSelections(selections)

    def line_number_area_width(self) -> int:
        digits = len(str(max(1, self.blockCount())))
        space = 10 + self.fontMetrics().horizontalAdvance("9") * digits
        return space

    def _update_line_area_width(self, _new_block_count: int) -> None:
        self.setViewportMargins(self.line_number_area_width(), 0, 0, 0)

    def _update_line_area(self, rect: QRect, dy: int) -> None:  # pragma: no cover - UI
        if dy:
            self._line_area.scroll(0, dy)
        else:
            self._line_area.update(0, rect.y(), self._line_area.width(), rect.height())
        if rect.contains(self.viewport().rect()):
            self._update_line_area_width(0)

    def resizeEvent(self, event) -> None:  # pragma: no cover - UI
        super().resizeEvent(event)
        cr = self.contentsRect()
        self._line_area.setGeometry(
            QRect(cr.left(), cr.top(), self.line_number_area_width(), cr.height())
        )

    def line_number_area_paint_event(self, event) -> None:  # pragma: no cover - UI
        painter = QPainter(self._line_area)
        painter.fillRect(event.rect(), QColor("#0f1d33"))
        block = self.firstVisibleBlock()
        block_number = block.blockNumber()
        top = self.blockBoundingGeometry(block).translated(self.contentOffset()).top()
        bottom = top + self.blockBoundingRect(block).height()
        height = self.fontMetrics().height()
        while block.isValid() and top <= event.rect().bottom():
            if block.isVisible() and bottom >= event.rect().top():
                number = str(block_number + 1)
                painter.setPen(QColor(self._theme.muted))
                painter.drawText(
                    0,
                    int(top),
                    self._line_area.width() - 6,
                    int(height),
                    Qt.AlignRight,
                    number,
                )
            block = block.next()
            top = bottom
            bottom = top + self.blockBoundingRect(block).height()
            block_number += 1

    def _highlight_current_line(self) -> None:
        if self.isReadOnly():  # pragma: no cover - simple guard
            return
        selection = QTextEdit.ExtraSelection()
        selection.cursor = self.textCursor()
        selection.cursor.clearSelection()
        selection.format.setBackground(QColor(30, 90, 255, 40))
        selection.format.setProperty(QTextCharFormat.FullWidthSelection, True)
        self._current_line_selection = selection
        self._apply_extra_selections()

    def set_error_lines(self, lines: Sequence[int]) -> None:
        selections: List[QTextEdit.ExtraSelection] = []
        fmt = QTextCharFormat()
        fmt.setBackground(QColor(255, 107, 107, 80))
        fmt.setProperty(QTextCharFormat.FullWidthSelection, True)
        doc = self.document()
        for line in lines:
            block = doc.findBlockByLineNumber(max(line - 1, 0))
            if not block.isValid():
                continue
            cursor = QTextCursor(block)
            selection = QTextEdit.ExtraSelection()
            selection.cursor = cursor
            selection.cursor.clearSelection()
            selection.format = fmt
            selections.append(selection)
        self._error_selections = selections
        self._apply_extra_selections()


class BasicHighlighter(QSyntaxHighlighter):
    """Lightweight syntax highlighter for a few common languages."""

    def __init__(self, document, language: str = "plain") -> None:
        super().__init__(document)
        self._language = language
        self._keyword_format = QTextCharFormat()
        self._keyword_format.setForeground(QColor("#5ccfe6"))
        bold = QFont()
        bold.setBold(True)
        self._keyword_format.setFont(bold)
        self._comment_format = QTextCharFormat()
        self._comment_format.setForeground(QColor("#7a88b9"))
        self._string_format = QTextCharFormat()
        self._string_format.setForeground(QColor("#c5e478"))
        self._heading_format = QTextCharFormat()
        self._heading_format.setForeground(QColor("#84a9ff"))
        self._number_format = QTextCharFormat()
        self._number_format.setForeground(QColor("#f78c6c"))
        self._patterns: List[re.Pattern[str]] = []
        self._update_patterns()
    def set_language(self, language: str) -> None:
        if language == self._language:
            return
        self._language = language
        self._update_patterns()
        self.rehighlight()

    def _update_patterns(self) -> None:
        self._patterns.clear()
        if self._language == "python":
            kw = "|".join(map(re.escape, keyword.kwlist))
            self._patterns.append(re.compile(rf"\b({kw})\b"))
            self._comment_re = re.compile(r"#[^\n]*")
            self._string_re = re.compile(
                r"('''.*?'''|\"\"\".*?\"\"\"|'[^'\\]*(?:\\.[^'\\]*)*'|\"[^\"\\]*(?:\\.[^\"\\]*)*\")",
                re.S,
            )
            self._number_re = re.compile(r"\b[0-9]+\b")
        elif self._language == "markdown":
            self._heading_re = re.compile(r"^#{1,6}.*$", re.M)
            self._code_fence_re = re.compile(r"```.*?```", re.S)
        elif self._language == "json":
            self._string_re = re.compile(r'"[^"\\]*(?:\\.[^"\\]*)*"')
            self._number_re = re.compile(r"\b-?(?:0|[1-9][0-9]*)(?:\.[0-9]+)?(?:[eE][+-]?[0-9]+)?\b")
            self._keyword_re = re.compile(r"\b(true|false|null)\b")
        else:
            self._comment_re = None
            self._string_re = None
            self._number_re = None

    def highlightBlock(self, text: str) -> None:  # pragma: no cover - rendering
        if self._language == "python":
            for pat in self._patterns:
                for match in pat.finditer(text):
                    self.setFormat(match.start(), match.end() - match.start(), self._keyword_format)
            if getattr(self, "_comment_re", None):
                for match in self._comment_re.finditer(text):
                    self.setFormat(match.start(), match.end() - match.start(), self._comment_format)
            if getattr(self, "_string_re", None):
                for match in self._string_re.finditer(text):
                    self.setFormat(match.start(), match.end() - match.start(), self._string_format)
            if getattr(self, "_number_re", None):
                for match in self._number_re.finditer(text):
                    self.setFormat(match.start(), match.end() - match.start(), self._number_format)
        elif self._language == "markdown":
            if getattr(self, "_heading_re", None):
                for match in self._heading_re.finditer(text):
                    self.setFormat(match.start(), match.end() - match.start(), self._heading_format)
            if getattr(self, "_code_fence_re", None):
                for match in self._code_fence_re.finditer(text):
                    self.setFormat(match.start(), match.end() - match.start(), self._string_format)
        elif self._language == "json":
            if getattr(self, "_string_re", None):
                for match in self._string_re.finditer(text):
                    self.setFormat(match.start(), match.end() - match.start(), self._string_format)
            if getattr(self, "_number_re", None):
                for match in self._number_re.finditer(text):
                    self.setFormat(match.start(), match.end() - match.start(), self._number_format)
            if getattr(self, "_keyword_re", None):
                for match in self._keyword_re.finditer(text):
                    self.setFormat(match.start(), match.end() - match.start(), self._keyword_format)


class EditorCard(QWidget):
    """Code/markdown editor with summaries, chat, notes, and console."""

    def __init__(
        self,
        *,
        initial_path: Optional[str] = None,
        client: Optional[logic_doc.ChatClient] = None,
        model: str = logic_doc.DEFAULT_SUMMARY_MODEL,
        theme: Theme = Theme(),
        parent: Optional[QWidget] = None,
        storage_root: Optional[os.PathLike[str] | str] = None,
    ) -> None:
        super().__init__(parent)
        self.setObjectName("EditorCard")
        self._theme = theme
        self._model = model
        self._client = client
        self._current_path: Optional[Path] = Path(initial_path) if initial_path else None
        self._summaries: List[logic_doc.SegmentSummary] = []
        self._chat_entries: List[ConversationEntry] = []
        self._notes: dict[str, PinnedNote] = {}
        self._active_note_id: Optional[str] = None
        self._storage_root = Path(storage_root) if storage_root else _STORAGE_ROOT
        self._chat_dir = self._storage_root / _CHAT_DIR_NAME
        self._notes_dir = self._storage_root / _NOTES_DIR_NAME
        self._chat_dir.mkdir(parents=True, exist_ok=True)
        self._notes_dir.mkdir(parents=True, exist_ok=True)
        self._chat_log_path = self._chat_dir / f"{_slug_for_path(self._current_path)}.jsonl"
        self._notes_path = self._notes_dir / f"{_slug_for_path(self._current_path)}.json"
        self._project_root: Optional[Path] = self._discover_project_root()
        self._output_link_map: Dict[str, "ErrorLocation"] = {}
        self._init_ui()
        self._load_chat_history()
        self._load_notes()
        if self._current_path:
            self.load_file(self._current_path)
        else:
            self._update_title()
    def _init_ui(self) -> None:
        layout = QVBoxLayout(self)
        layout.setContentsMargins(16, 16, 16, 16)
        layout.setSpacing(10)

        header = QHBoxLayout()
        header.setSpacing(10)
        self.title_label = QLabel("Editor")
        self.title_label.setStyleSheet("font: 600 12pt 'Cascadia Code';")
        header.addWidget(self.title_label)
        header.addStretch(1)
        self.status_label = QLabel("")
        self.status_label.setStyleSheet(f"color: {self._theme.muted};")
        header.addWidget(self.status_label)
        layout.addLayout(header)

        tools = QHBoxLayout()
        tools.setSpacing(8)
        self.save_btn = QPushButton("Save")
        self.save_btn.setCursor(Qt.PointingHandCursor)
        self.save_btn.clicked.connect(self._save_file)
        tools.addWidget(self.save_btn)

        self.save_as_btn = QPushButton("Save As…")
        self.save_as_btn.setCursor(Qt.PointingHandCursor)
        self.save_as_btn.clicked.connect(self._save_file_as)
        tools.addWidget(self.save_as_btn)

        self.summarize_btn = QPushButton("Summarize document")
        self.summarize_btn.setCursor(Qt.PointingHandCursor)
        self.summarize_btn.clicked.connect(self.summarize_document)
        tools.addWidget(self.summarize_btn)

        self.diff_btn = QPushButton("Preview Diff")
        self.diff_btn.setCursor(Qt.PointingHandCursor)
        self.diff_btn.clicked.connect(self._preview_diff)
        tools.addWidget(self.diff_btn)

        self.run_btn = QPushButton("Run")
        self.run_btn.setCursor(Qt.PointingHandCursor)
        self.run_btn.clicked.connect(self._run_current_file)
        tools.addWidget(self.run_btn)

        self.test_btn = QPushButton("Run Tests")
        self.test_btn.setCursor(Qt.PointingHandCursor)
        self.test_btn.clicked.connect(self._run_tests)
        tools.addWidget(self.test_btn)
        tools.addStretch(1)
        layout.addLayout(tools)

        self.editor = CodeEditor(self._theme, self)
        self.editor.setObjectName("editorText")
        self.editor.document().modificationChanged.connect(self._on_modification_changed)

        self.highlighter = BasicHighlighter(self.editor.document())

        self.segment_list = QListWidget(self)
        self.segment_list.setObjectName("segmentList")
        self.segment_list.setSelectionMode(QListWidget.SingleSelection)
        self.segment_list.itemSelectionChanged.connect(self._segment_selected)

        self.segment_summary = QTextBrowser(self)
        self.segment_summary.setObjectName("segmentSummary")
        self.segment_summary.setOpenExternalLinks(True)
        self.segment_summary.setPlaceholderText("Select a section to preview its summary.")
        self.segment_summary.document().setDefaultStyleSheet(
            f"body {{ color: {self._theme.foreground}; background-color: {self._theme.panel_bg}; }}"
        )

        self.report_output = QPlainTextEdit(self)
        self.report_output.setObjectName("reportOutput")
        self.report_output.setReadOnly(True)
        self.report_output.setPlaceholderText("Generated markdown report will appear here.")
        self.report_output.setLineWrapMode(QPlainTextEdit.WidgetWidth)

        summary_tab = QWidget(self)
        summary_layout = QVBoxLayout(summary_tab)
        summary_layout.setContentsMargins(0, 0, 0, 0)
        summary_layout.setSpacing(8)
        summary_layout.addWidget(self.segment_list, 1)
        summary_layout.addWidget(self.segment_summary, 1)
        summary_layout.addWidget(self.report_output, 1)

        chat_tab = self._build_chat_tab()
        notes_tab = self._build_notes_tab()

        self.side_tabs = QTabWidget(self)
        self.side_tabs.addTab(summary_tab, "Summaries")
        self.side_tabs.addTab(chat_tab, "Chat")
        self.side_tabs.addTab(notes_tab, "Notes")

        top_splitter = QSplitter(Qt.Horizontal, self)
        top_splitter.setChildrenCollapsible(False)
        top_splitter.addWidget(self.editor)
        top_splitter.addWidget(self.side_tabs)
        top_splitter.setStretchFactor(0, 3)
        top_splitter.setStretchFactor(1, 2)

        self.diff_output = QPlainTextEdit(self)
        self.diff_output.setReadOnly(True)
        self.diff_output.setPlaceholderText("Diff preview will appear here.")

        self.run_output = QTextBrowser(self)
        self.run_output.setOpenLinks(False)
        self.run_output.setPlaceholderText("Run and test output will appear here.")
        self.run_output.anchorClicked.connect(self._handle_output_link)

        self.console_tabs = QTabWidget(self)
        self.console_tabs.addTab(self.diff_output, "Diff")
        self.console_tabs.addTab(self.run_output, "Run/Test")

        main_splitter = QSplitter(Qt.Vertical, self)
        main_splitter.setChildrenCollapsible(False)
        main_splitter.addWidget(top_splitter)
        main_splitter.addWidget(self.console_tabs)
        main_splitter.setStretchFactor(0, 3)
        main_splitter.setStretchFactor(1, 1)
        layout.addWidget(main_splitter, 1)

        self._set_status("Ready")
        self._populate_model_list()

    def _build_chat_tab(self) -> QWidget:
        tab = QWidget(self)
        layout = QVBoxLayout(tab)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(8)

        controls = QHBoxLayout()
        controls.setSpacing(6)
        model_label = QLabel("Model:")
        model_label.setStyleSheet(f"color: {self._theme.muted};")
        controls.addWidget(model_label)
        self.chat_model_combo = QComboBox(tab)
        controls.addWidget(self.chat_model_combo, 1)
        self.chat_pin_btn = QPushButton("Pin to notes")
        self.chat_pin_btn.clicked.connect(self._pin_selected_chat)
        controls.addWidget(self.chat_pin_btn)
        layout.addLayout(controls)

        self.chat_list = QListWidget(tab)
        self.chat_list.setSelectionMode(QListWidget.SingleSelection)
        layout.addWidget(self.chat_list, 1)

        self.chat_input = QPlainTextEdit(tab)
        self.chat_input.setPlaceholderText("Ask a question about this file…")
        self.chat_input.setFixedHeight(90)
        layout.addWidget(self.chat_input)

        bottom = QHBoxLayout()
        bottom.setSpacing(6)
        self.chat_status = QLabel("")
        self.chat_status.setStyleSheet(f"color: {self._theme.muted};")
        bottom.addWidget(self.chat_status, 1)
        self.chat_send_btn = QPushButton("Send")
        self.chat_send_btn.clicked.connect(self._send_chat_message)
        bottom.addWidget(self.chat_send_btn)
        layout.addLayout(bottom)
        return tab

    def _build_notes_tab(self) -> QWidget:
        tab = QWidget(self)
        layout = QVBoxLayout(tab)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(8)

        buttons = QHBoxLayout()
        buttons.setSpacing(6)
        self.note_new_btn = QPushButton("New note")
        self.note_new_btn.clicked.connect(self._create_note)
        buttons.addWidget(self.note_new_btn)
        self.note_pin_selection_btn = QPushButton("Pin selection")
        self.note_pin_selection_btn.clicked.connect(self._pin_editor_selection)
        buttons.addWidget(self.note_pin_selection_btn)
        self.note_delete_btn = QPushButton("Delete")
        self.note_delete_btn.clicked.connect(self._delete_note)
        buttons.addWidget(self.note_delete_btn)
        buttons.addStretch(1)
        layout.addLayout(buttons)

        self.note_list = QListWidget(tab)
        self.note_list.setSelectionMode(QListWidget.SingleSelection)
        self.note_list.itemSelectionChanged.connect(self._on_note_selected)
        layout.addWidget(self.note_list, 1)

        self.note_editor = QPlainTextEdit(tab)
        self.note_editor.setPlaceholderText("Select or create a note to edit…")
        layout.addWidget(self.note_editor, 1)

        save_row = QHBoxLayout()
        save_row.setSpacing(6)
        self.note_status = QLabel("")
        self.note_status.setStyleSheet(f"color: {self._theme.muted};")
        save_row.addWidget(self.note_status, 1)
        self.note_save_btn = QPushButton("Save note")
        self.note_save_btn.clicked.connect(self._save_note_content)
        save_row.addWidget(self.note_save_btn)
        layout.addLayout(save_row)
        return tab

    def load_file(self, path: os.PathLike[str] | str) -> None:
        try:
            source = Path(path)
            text = source.read_text(encoding="utf-8")
        except Exception as exc:
            self.editor.setPlainText(f"[open failed] {exc}")
            self._set_status(f"Failed to open {path}: {exc}")
            return
        self._current_path = source
        self._project_root = self._discover_project_root()
        self.editor.setPlainText(text)
        self.editor.document().setModified(False)
        self._update_title()
        self._chat_log_path = self._chat_dir / f"{_slug_for_path(self._current_path)}.jsonl"
        self._notes_path = self._notes_dir / f"{_slug_for_path(self._current_path)}.json"
        self._load_chat_history()
        self._load_notes()
        self.highlighter.set_language(self._language_for_path(self._current_path))
        self._set_status(f"Loaded {source.name}")

    def summarize_document(self) -> None:
        text = self.editor.toPlainText()
        segments = logic_doc.parse_segments(text, fallback_title=self._current_title())
        if not segments:
            self._set_status("No sections detected.")
            return
        client = self._ensure_client()
        summaries = logic_doc.summarize_segments(
            segments,
            client=client,
            model=self._model,
        )
        self._summaries = summaries
        report = logic_doc.build_summary_markdown(summaries, source=self._current_path)
        self.report_output.setPlainText(report)
        self._populate_segments()
        saved = logic_doc.write_report(self._current_path, report)
        if saved is not None:
            self._set_status(f"Summary saved to {saved.name}")
        else:
            self._set_status("Summary generated (unsaved buffer).")

    @property
    def chat_log_path(self) -> Path:
        return self._chat_log_path

    @property
    def notes_path(self) -> Path:
        return self._notes_path

    def _ensure_client(self) -> Optional[logic_doc.ChatClient]:
        if self._client is not None:
            return self._client
        if OllamaClient is None:
            return None
        self._client = OllamaClient()  # type: ignore[call-arg]
        return self._client

    def _current_title(self) -> str:
        if self._current_path is None:
            return "Document"
        return self._current_path.name

    def _populate_segments(self) -> None:
        self.segment_list.clear()
        for summary in self._summaries:
            title = f"{summary.segment.title} (L{summary.segment.start_line})"
            if summary.error:
                title += " — error"
            item = QListWidgetItem(title, self.segment_list)
            item.setData(Qt.UserRole, summary)
        if self.segment_list.count():
            self.segment_list.setCurrentRow(0)

    def _segment_selected(self) -> None:
        items = self.segment_list.selectedItems()
        if not items:
            self.segment_summary.clear()
            return
        summary: logic_doc.SegmentSummary = items[0].data(Qt.UserRole)
        if summary.error:
            self.segment_summary.setPlainText(f"Summary failed: {summary.error}")
        else:
            self.segment_summary.setPlainText(summary.summary or "(empty summary)")
        self._jump_to_line(summary.segment.start_line)

    def _jump_to_line(self, line: int) -> None:
        doc = self.editor.document()
        block = doc.findBlockByLineNumber(max(line - 1, 0))
        cursor = QTextCursor(block)
        self.editor.setTextCursor(cursor)
        self.editor.centerCursor()

    def _set_status(self, message: str) -> None:
        self.status_label.setText(message)

    def _update_title(self) -> None:
        name = self._current_title()
        if self.editor.document().isModified():
            name = f"*{name}"
        self.title_label.setText(f"Editor — {name}")

    def _on_modification_changed(self, _changed: bool) -> None:
        self._update_title()

    def _language_for_path(self, path: Optional[Path]) -> str:
        if not path:
            return "plain"
        suffix = path.suffix.lower()
        if suffix == ".py":
            return "python"
        if suffix in {".md", ".markdown"}:
            return "markdown"
        if suffix in {".json", ".jsonl"}:
            return "json"
        return "plain"
    def _save_file(self) -> None:
        if self._current_path is None:
            self._save_file_as()
            return
        try:
            self._current_path.write_text(self.editor.toPlainText(), encoding="utf-8")
        except Exception as exc:
            QMessageBox.warning(self, "Save failed", str(exc))
            self._set_status(f"Save failed: {exc}")
            return
        self.editor.document().setModified(False)
        self._set_status(f"Saved {self._current_path.name}")

    def _save_file_as(self) -> None:
        suggested = str(self._current_path) if self._current_path else ""
        filename, _ = QFileDialog.getSaveFileName(self, "Save File", suggested)
        if not filename:
            return
        self._current_path = Path(filename)
        self._project_root = self._discover_project_root()
        try:
            self._current_path.write_text(self.editor.toPlainText(), encoding="utf-8")
        except Exception as exc:
            QMessageBox.warning(self, "Save failed", str(exc))
            self._set_status(f"Save failed: {exc}")
            return
        self.editor.document().setModified(False)
        self._update_title()
        self._chat_log_path = self._chat_dir / f"{_slug_for_path(self._current_path)}.jsonl"
        self._notes_path = self._notes_dir / f"{_slug_for_path(self._current_path)}.json"
        self._set_status(f"Saved {self._current_path.name}")

    def _populate_model_list(self) -> None:
        models: Sequence[str] = []
        client = self._ensure_client()
        if client is not None and hasattr(client, "list_models"):
            try:
                ok, names, _ = client.list_models()  # type: ignore[attr-defined]
            except Exception:
                ok, names = False, []
            if ok and names:
                models = sorted(set(names))
        if not models:
            models = sorted({self._model, "codex", "llama3:8b", "qwen3:8b"})
        self.chat_model_combo.clear()
        self.chat_model_combo.addItems(models)
        idx = self.chat_model_combo.findText(self._model)
        if idx >= 0:
            self.chat_model_combo.setCurrentIndex(idx)

    def _load_chat_history(self) -> None:
        self._chat_entries.clear()
        if self._chat_log_path.exists():
            try:
                with self._chat_log_path.open("r", encoding="utf-8") as fh:
                    for line in fh:
                        try:
                            data = json.loads(line)
                        except json.JSONDecodeError:
                            continue
                        entry = ConversationEntry(
                            role=data.get("role", "user"),
                            content=data.get("content", ""),
                            model=data.get("model", self._model),
                            timestamp=data.get("timestamp", self._now()),
                        )
                        self._chat_entries.append(entry)
            except Exception:
                self._chat_entries.clear()
        self._refresh_chat_view()

    def _refresh_chat_view(self) -> None:
        self.chat_list.clear()
        for entry in self._chat_entries:
            prefix = "You" if entry.role == "user" else "Assistant"
            item = QListWidgetItem(f"{prefix} — {entry.timestamp}\n{entry.content}")
            item.setData(Qt.UserRole, entry)
            self.chat_list.addItem(item)
        if self.chat_list.count():
            self.chat_list.scrollToBottom()

    def _append_chat_entry(self, entry: ConversationEntry, persist: bool = True) -> None:
        self._chat_entries.append(entry)
        if persist:
            try:
                with self._chat_log_path.open("a", encoding="utf-8") as fh:
                    fh.write(json.dumps(entry.__dict__) + "\n")
            except Exception:
                pass
        self._refresh_chat_view()

    def _send_chat_message(self) -> None:
        text = self.chat_input.toPlainText().strip()
        if not text:
            self._set_chat_status("Enter a prompt to send.")
            return
        model = self.chat_model_combo.currentText() or self._model
        entry = ConversationEntry(role="user", content=text, model=model, timestamp=self._now())
        self._append_chat_entry(entry)
        self.chat_input.clear()
        client = self._ensure_client()
        if client is None:
            self._set_chat_status("LLM client unavailable; logged prompt only.")
            return
        messages = [{"role": item.role, "content": item.content} for item in self._chat_entries]
        self._set_chat_status("Contacting model…")
        self._toggle_chat_enabled(False)

        def worker() -> tuple[bool, str, str]:
            try:
                return client.chat(model, messages)  # type: ignore[attr-defined]
            except Exception as exc:  # pragma: no cover - defensive
                return False, "", str(exc)

        self._run_async(worker, lambda result: self._handle_chat_response(model, result))

    def _handle_chat_response(self, model: str, result: tuple[bool, str, str]) -> None:
        ok, content, error = result
        if ok and content.strip():
            entry = ConversationEntry(role="assistant", content=content.strip(), model=model, timestamp=self._now())
            self._append_chat_entry(entry)
            self._set_chat_status("Response received.")
        else:
            self._set_chat_status(error or "Model returned no content.")
        self._toggle_chat_enabled(True)

    def _toggle_chat_enabled(self, enabled: bool) -> None:
        self.chat_send_btn.setEnabled(enabled)
        self.chat_input.setEnabled(enabled)
        self.chat_model_combo.setEnabled(enabled)

    def _set_chat_status(self, message: str) -> None:
        self.chat_status.setText(message)

    def _pin_selected_chat(self) -> None:
        items = self.chat_list.selectedItems()
        if not items:
            self._set_chat_status("Select a message to pin.")
            return
        entry: ConversationEntry = items[0].data(Qt.UserRole)
        self._create_note_from_text(entry.content, source=f"chat:{entry.role}")
        self._set_chat_status("Pinned chat message to notes.")
    def _load_notes(self) -> None:
        self._notes.clear()
        if self._notes_path.exists():
            try:
                data = json.loads(self._notes_path.read_text(encoding="utf-8"))
                if isinstance(data, list):
                    for node in data:
                        try:
                            note = PinnedNote(
                                note_id=node["note_id"],
                                content=node.get("content", ""),
                                source=node.get("source", "manual"),
                                timestamp=node.get("timestamp", self._now()),
                            )
                            self._notes[note.note_id] = note
                        except Exception:
                            continue
            except Exception:
                self._notes.clear()
        self._refresh_notes_view()

    def _refresh_notes_view(self) -> None:
        self.note_list.clear()
        for note in self._notes.values():
            item = QListWidgetItem(f"{note.title()}\n{note.source} — {note.timestamp}")
            item.setData(Qt.UserRole, note.note_id)
            self.note_list.addItem(item)
        if self.note_list.count():
            self.note_list.setCurrentRow(0)
        else:
            self.note_editor.clear()
            self._active_note_id = None

    def _create_note(self) -> None:
        note_id = uuid.uuid4().hex
        note = PinnedNote(note_id=note_id, content="", source="manual", timestamp=self._now())
        self._notes[note_id] = note
        self._persist_notes()
        self._refresh_notes_view()
        self._select_note(note_id)
        self._set_note_status("Created empty note.")

    def _pin_editor_selection(self) -> None:
        cursor = self.editor.textCursor()
        text = cursor.selectedText().replace("\u2029", "\n").strip()
        if not text:
            self._set_note_status("Select text in the editor first.")
            return
        self._create_note_from_text(text, source="editor")
        self._set_note_status("Pinned editor selection.")

    def _create_note_from_text(self, text: str, *, source: str) -> None:
        note_id = uuid.uuid4().hex
        note = PinnedNote(note_id=note_id, content=text.strip(), source=source, timestamp=self._now())
        self._notes[note_id] = note
        self._persist_notes()
        self._refresh_notes_view()
        self._select_note(note_id)

    def _delete_note(self) -> None:
        items = self.note_list.selectedItems()
        if not items:
            self._set_note_status("Select a note to delete.")
            return
        note_id = items[0].data(Qt.UserRole)
        if note_id in self._notes:
            del self._notes[note_id]
            self._persist_notes()
            self._refresh_notes_view()
            self._set_note_status("Deleted note.")

    def _on_note_selected(self) -> None:
        items = self.note_list.selectedItems()
        if not items:
            self._active_note_id = None
            self.note_editor.clear()
            return
        note_id = items[0].data(Qt.UserRole)
        note = self._notes.get(note_id)
        self._active_note_id = note_id
        if note:
            self.note_editor.setPlainText(note.content)
        else:
            self.note_editor.clear()

    def _save_note_content(self) -> None:
        if not self._active_note_id or self._active_note_id not in self._notes:
            self._set_note_status("Select a note to save.")
            return
        note = self._notes[self._active_note_id]
        note.content = self.note_editor.toPlainText().strip()
        note.timestamp = self._now()
        self._persist_notes()
        self._refresh_notes_view()
        self._select_note(self._active_note_id)
        self._set_note_status("Note saved.")

    def _persist_notes(self) -> None:
        try:
            payload = [note.__dict__ for note in self._notes.values()]
            self._notes_path.write_text(json.dumps(payload, indent=2), encoding="utf-8")
        except Exception:
            pass

    def _select_note(self, note_id: str) -> None:
        for idx in range(self.note_list.count()):
            item = self.note_list.item(idx)
            if item.data(Qt.UserRole) == note_id:
                self.note_list.setCurrentRow(idx)
                return

    def _set_note_status(self, message: str) -> None:
        self.note_status.setText(message)

    def _preview_diff(self) -> None:
        if self._current_path is None:
            self._set_status("Save file before diff preview.")
            return
        if self.editor.document().isModified():
            self._set_status("Save changes before generating diff.")
            return

        def worker() -> tuple[int, str, str]:
            try:
                result = subprocess.run(
                    ["git", "diff", "--", str(self._current_path)],
                    cwd=self._current_path.parent,
                    capture_output=True,
                    text=True,
                )
                return result.returncode, result.stdout, result.stderr
            except Exception as exc:  # pragma: no cover - defensive
                return 1, "", str(exc)

        self._set_status("Running git diff…")
        self._run_async(worker, self._update_diff_output)

    def _update_diff_output(self, result: tuple[int, str, str]) -> None:
        rc, out, err = result
        if rc != 0:
            self.diff_output.setPlainText(err or out or "git diff failed")
            self._set_status("Diff preview failed.")
        else:
            self.diff_output.setPlainText(out or "(no changes)")
            self._set_status("Diff preview updated.")

    def _run_current_file(self) -> None:
        if self._current_path is None:
            self._set_status("Save file before running.")
            return
        if self.editor.document().isModified():
            self._set_status("Save changes before running.")
            return
        if self._current_path.suffix != ".py":
            self._set_status("Run is supported for Python files only.")
            return
        command = [sys.executable, str(self._current_path)]
        self._start_command("Run", command, self._current_path.parent)

    def _run_tests(self) -> None:
        project_root = self._ensure_project_root()
        if project_root is None:
            self._set_status("Project root not found for tests.")
            return
        command = [sys.executable, str(project_root / "tools" / "manage_tests.py")]
        self._start_command("Tests", command, project_root)

    def _start_command(self, label: str, command: Sequence[str], cwd: Path) -> None:
        def worker() -> CommandResult:
            try:
                result = subprocess.run(
                    command,
                    cwd=cwd,
                    capture_output=True,
                    text=True,
                )
                return CommandResult(
                    label=label,
                    command=list(command),
                    returncode=result.returncode,
                    stdout=result.stdout,
                    stderr=result.stderr,
                )
            except Exception as exc:  # pragma: no cover - defensive
                return CommandResult(
                    label=label,
                    command=list(command),
                    returncode=1,
                    stdout="",
                    stderr=str(exc),
                )

        self._set_status(f"{label} running…")
        self._prepare_run_output()
        self._run_async(worker, self._handle_command_result)

    def _prepare_run_output(self) -> None:
        self.console_tabs.setCurrentWidget(self.run_output)
        self.run_output.setHtml("<i>Running…</i>")
        self._output_link_map.clear()
        self.editor.set_error_lines([])

    def _handle_command_result(self, result: CommandResult) -> None:
        html_output, link_map = self._compose_output_html(result)
        self._output_link_map = link_map
        self.run_output.setHtml(html_output)
        self._highlight_editor_errors(link_map.values())
        if result.returncode == 0:
            self._set_status(f"{result.label} completed.")
        else:
            self._set_status(f"{result.label} failed ({result.returncode}).")

    def _compose_output_html(self, result: CommandResult) -> tuple[str, Dict[str, "ErrorLocation"]]:
        command_str = html.escape(" ".join(result.command))
        header = (
            f'<div style="color:{self._theme.muted}; font-family:\'Cascadia Code\', Consolas, monospace;">'
            f'$ {command_str}</div>'
        )
        streams_html, link_map = self._compose_stream_sections(result.stdout, result.stderr)
        return header + streams_html, link_map

    def _compose_stream_sections(
        self, stdout: str, stderr: str
    ) -> tuple[str, Dict[str, "ErrorLocation"]]:
        sections: List[str] = []
        link_map: Dict[str, ErrorLocation] = {}
        counter = 0
        for prefix, title, content, color in (
            ("stdout", "Standard Output", stdout, "#7bc6ff"),
            ("stderr", "Standard Error", stderr, "#ff9b9b"),
        ):
            if not content:
                continue
            block_html, block_links, counter = self._render_output_with_links(
                content, prefix, counter
            )
            sections.append(
                '<div style="margin-bottom:8px;">'
                f'<div style="color:{color}; font-weight:600;">{title}</div>'
                '<div style="font-family:\'Cascadia Code\', Consolas, monospace; white-space:pre-wrap;">'
                f'{block_html}</div></div>'
            )
            link_map.update(block_links)
        if not sections:
            sections.append(
                '<div style="font-family:\'Cascadia Code\', Consolas, monospace;"><i>(no output)</i></div>'
            )
        return "".join(sections), link_map

    def _render_output_with_links(
        self, text: str, prefix: str, start_index: int
    ) -> tuple[str, Dict[str, "ErrorLocation"], int]:
        lines = text.splitlines()
        if not lines:
            lines = [""]
        html_lines: List[str] = []
        link_map: Dict[str, ErrorLocation] = {}
        counter = start_index
        for raw in lines:
            locations = self._find_error_locations(raw)
            escaped = html.escape(raw) if raw else "&nbsp;"
            if locations:
                primary = locations[0]
                anchor = f"{prefix}-{counter}"
                counter += 1
                link_map[anchor] = primary
                html_lines.append(
                    '<span style="color:#ff6b6b;">'
                    f'<a href="{anchor}" style="color:#ff6b6b; text-decoration: underline;">'
                    f'{escaped}</a></span>'
                )
                for extra in locations[1:]:
                    anchor = f"{prefix}-{counter}"
                    counter += 1
                    link_map[anchor] = extra
                    html_lines.append(
                        '<span style="color:#ff6b6b;">↳ '
                        f'<a href="{anchor}" style="color:#ff6b6b; text-decoration: underline;">'
                        f'{html.escape(extra.path.name)}:{extra.line}</a></span>'
                    )
            else:
                html_lines.append(escaped)
        return "<br>".join(html_lines), link_map, counter

    def _find_error_locations(self, line: str) -> List["ErrorLocation"]:
        locations: List[ErrorLocation] = []
        seen: set[tuple[Path, int]] = set()
        for pattern in (_TRACEBACK_RE, _PYTEST_RE):
            for match in pattern.finditer(line):
                raw_path, line_text = match.groups()[:2]
                resolved = self._resolve_error_path(raw_path)
                if resolved is None:
                    continue
                try:
                    line_no = int(line_text)
                except ValueError:
                    continue
                key = (resolved, line_no)
                if key in seen:
                    continue
                seen.add(key)
                locations.append(ErrorLocation(resolved, line_no))
        return locations

    def _resolve_error_path(self, raw_path: str) -> Optional[Path]:
        candidate = Path(raw_path.strip().strip("'\""))
        possibilities: List[Path] = []
        if candidate.is_absolute():
            possibilities.append(candidate)
        else:
            if self._project_root is not None:
                possibilities.append(self._project_root / candidate)
            if self._current_path is not None:
                possibilities.append(self._current_path.parent / candidate)
        for option in possibilities:
            try:
                resolved = option.resolve()
            except Exception:
                resolved = option
            if resolved.exists():
                return resolved
        if self._current_path is not None and candidate.name == self._current_path.name:
            return self._current_path
        if candidate.is_absolute():
            return candidate
        return None

    def _highlight_editor_errors(self, locations: Iterable["ErrorLocation"]) -> None:
        if self._current_path is None:
            self.editor.set_error_lines([])
            return
        try:
            current = self._current_path.resolve()
        except Exception:
            current = self._current_path
        lines = sorted(
            {loc.line for loc in locations if self._paths_match(loc.path, current)}
        )
        self.editor.set_error_lines(lines)

    def _paths_match(self, left: Path, right: Path) -> bool:
        try:
            return left.resolve() == right.resolve()
        except Exception:
            return left == right

    def _handle_output_link(self, url: QUrl) -> None:
        key = url.toString()
        location = self._output_link_map.get(key)
        if location is None:
            return
        if self._current_path is not None and self._paths_match(
            location.path, self._current_path
        ):
            self._jump_to_line(location.line)
        else:
            self._set_status(f"Open {location.path}:{location.line} in editor")

    def _discover_project_root(self) -> Optional[Path]:
        if self._current_path is None:
            return None
        search = self._current_path.parent
        for candidate in [search, *search.parents]:
            if (candidate / "tools" / "manage_tests.py").exists():
                return candidate
            if (candidate / ".git").exists():
                return candidate
        return None

    def _ensure_project_root(self) -> Optional[Path]:
        if self._project_root is None or not self._project_root.exists():
            self._project_root = self._discover_project_root()
        return self._project_root

    def _run_async(self, worker, callback) -> None:
        def runner():
            outcome = worker()
            QTimer.singleShot(0, lambda: callback(outcome))

        threading.Thread(target=runner, daemon=True).start()

    def _now(self) -> str:
        return datetime.utcnow().strftime(_TIMESTAMP_FORMAT)


@dataclass
class CommandResult:
    label: str
    command: List[str]
    returncode: int
    stdout: str
    stderr: str


@dataclass
class ErrorLocation:
    path: Path
    line: int


_TRACEBACK_RE = re.compile(r'File "([^"]+)", line (\d+)')
_PYTEST_RE = re.compile(r'([^\s:]+\.py):(\d+)')


def build_widget(
    parent: Optional[QWidget] = None,
    *,
    initial_path: Optional[str] = None,
    client: Optional[logic_doc.ChatClient] = None,
    model: str = logic_doc.DEFAULT_SUMMARY_MODEL,
    theme: Optional[Theme] = None,
    storage_root: Optional[os.PathLike[str] | str] = None,
) -> EditorCard:
    """Factory used by the Virtual Desktop to create the editor card."""

    return EditorCard(
        initial_path=initial_path,
        client=client,
        model=model,
        theme=theme or Theme(),
        parent=parent,
        storage_root=storage_root,
    )
```

PySide6 editor card with inline chat, notes, and summarization.
**Classes:** Theme, ConversationEntry, PinnedNote, LineNumberArea, CodeEditor, BasicHighlighter, EditorCard, CommandResult, ErrorLocation
**Functions:** _slug_for_path(path), build_widget(parent)


## Module `editor\logic_doc.py`

```python
"""Utilities for summarizing architecture logic documents."""

from __future__ import annotations

from dataclasses import dataclass
from datetime import datetime, timezone
from pathlib import Path
from typing import Iterable, List, Optional, Protocol, Sequence, Tuple
import re

DEFAULT_SUMMARY_MODEL = "qwen3:8b"
_DEFAULT_SYSTEM_PROMPT = (
    "You summarize internal architecture documentation. "
    "Capture responsibilities, data flows, and integration notes for each section. "
    "Return 2-3 bullet points per section, using concise language and avoiding repetition."
)


class ChatClient(Protocol):
    """Protocol describing the subset of Ollama-style chat client we require."""

    def chat(
        self,
        model: str,
        messages: Sequence[dict],
        images: Optional[Sequence[str]] = None,
    ) -> Tuple[bool, str, str]:
        ...


@dataclass
class Segment:
    """Represents a logical section within a document."""

    title: str
    start_line: int
    end_line: int
    content: str

    @property
    def span_label(self) -> str:
        if self.start_line == self.end_line:
            return f"Line {self.start_line}"
        return f"Lines {self.start_line}-{self.end_line}"


@dataclass
class SegmentSummary:
    """Holds the LLM-generated summary (or an error) for a segment."""

    segment: Segment
    summary: str
    error: Optional[str] = None


_IGNORED_TOKENS = {"GitHub", "Copy"}
_slug_pattern = re.compile(r"[^a-z0-9]+")


def _looks_like_heading(lines: List[str], index: int, stripped: str) -> bool:
    if not stripped:
        return False
    if stripped in _IGNORED_TOKENS:
        return False
    if stripped.startswith(('#', '*', '-', '>')):
        return stripped.startswith('#')
    prev_blank = index == 0 or not lines[index - 1].strip()
    next_blank = index == len(lines) - 1 or not lines[index + 1].strip()
    if not (prev_blank and next_blank):
        return False
    if ':' in stripped and not stripped.endswith(':'):
        return False
    if any(ch in stripped for ch in '.?!;') and not stripped.endswith(':'):
        return False
    return True


def parse_segments(text: str, *, fallback_title: str = "Document") -> List[Segment]:
    """Split *text* into logical segments using simple heading heuristics."""

    lines = text.splitlines()
    headings: List[Tuple[int, str]] = []
    for idx, raw in enumerate(lines):
        stripped = raw.strip()
        if stripped.startswith('#'):
            title = stripped.lstrip('#').strip() or fallback_title
            headings.append((idx, title))
            continue
        if _looks_like_heading(lines, idx, stripped):
            title = stripped.rstrip(':').strip()
            headings.append((idx, title or fallback_title))
    segments: List[Segment] = []
    if not headings:
        end_line = len(lines) or 1
        segments.append(
            Segment(
                title=fallback_title,
                start_line=1,
                end_line=end_line,
                content=text.strip(),
            )
        )
        return segments
    for pos, (line_no, title) in enumerate(headings):
        body_start = line_no + 1
        body_end = headings[pos + 1][0] if pos + 1 < len(headings) else len(lines)
        if body_end < body_start:
            body_end = body_start
        content = "\n".join(lines[body_start:body_end]).strip()
        segments.append(
            Segment(
                title=title,
                start_line=line_no + 1,
                end_line=body_end if body_end > body_start else line_no + 1,
                content=content,
            )
        )
    return segments


def load_segments(path: Path) -> List[Segment]:
    """Load the file at *path* and return detected segments."""

    data = path.read_text(encoding="utf-8")
    return parse_segments(data, fallback_title=path.name)


def _build_messages(segment: Segment, instructions: Optional[str]) -> List[dict]:
    user_prompt = (
        f"Summarize the following section from the Codex architecture reference.\n"
        f"Section: {segment.title}\n"
        f"Location: {segment.span_label}\n\n"
        f"{segment.content.strip()}"
    ).strip()
    system_prompt = instructions or _DEFAULT_SYSTEM_PROMPT
    return [
        {"role": "system", "content": system_prompt},
        {"role": "user", "content": user_prompt},
    ]


def summarize_segments(
    segments: Iterable[Segment],
    *,
    client: Optional[ChatClient],
    model: str = DEFAULT_SUMMARY_MODEL,
    instructions: Optional[str] = None,
) -> List[SegmentSummary]:
    """Call *client* to summarize each segment and return structured results."""

    results: List[SegmentSummary] = []
    for segment in segments:
        if client is None:
            results.append(
                SegmentSummary(
                    segment=segment,
                    summary="",
                    error="LLM client unavailable",
                )
            )
            continue
        try:
            messages = _build_messages(segment, instructions)
            ok, content, err = client.chat(model, messages)
        except Exception as exc:  # pragma: no cover - defensive
            results.append(
                SegmentSummary(segment=segment, summary="", error=str(exc))
            )
            continue
        if not ok:
            results.append(
                SegmentSummary(segment=segment, summary="", error=err or "unknown error")
            )
        else:
            results.append(
                SegmentSummary(segment=segment, summary=content.strip(), error=None)
            )
    return results


def _slugify(title: str) -> str:
    slug = _slug_pattern.sub('-', title.lower()).strip('-')
    return slug or "section"


def segment_anchor(segment: Segment, source: Optional[Path]) -> str:
    """Return a markdown-friendly anchor for *segment*."""

    if source is not None:
        return f"editor://{source.name}?line={segment.start_line}"
    return f"#{_slugify(segment.title)}"


def build_summary_markdown(
    summaries: Sequence[SegmentSummary],
    *,
    source: Optional[Path] = None,
) -> str:
    """Render a markdown report for the supplied segment *summaries*."""

    timestamp = datetime.now(timezone.utc).isoformat()
    header = [
        "# Logic Document Review",
        "",
        f"- Source: {source.as_posix() if source else 'unsaved buffer'}",
        f"- Generated: {timestamp}",
        "",
    ]
    toc = ["## Table of Contents"]
    for summary in summaries:
        suffix = " (error)" if summary.error else ""
        toc.append(
            f"- [{summary.segment.title}{suffix}]({segment_anchor(summary.segment, source)})"
        )
    toc.append("")
    body: List[str] = []
    for summary in summaries:
        body.append(f"## {summary.segment.title}")
        body.append(f"*{summary.segment.span_label}*")
        if summary.error:
            body.append(f"> ❌ Summary failed: {summary.error}")
        else:
            text = summary.summary.strip()
            body.append(text or "_No summary produced._")
        body.append("")
    return "\n".join(header + toc + body).rstrip() + "\n"


def write_report(source: Optional[Path], content: str) -> Optional[Path]:
    """Persist *content* alongside *source* and return the report path."""

    if source is None:
        return None
    base = source.stem or source.name
    target = source.with_name(f"{base}.logic-summary.md")
    target.write_text(content, encoding="utf-8")
    return target
```

Utilities for summarizing architecture logic documents.
**Classes:** ChatClient, Segment, SegmentSummary
**Functions:** _looks_like_heading(lines, index, stripped), parse_segments(text), load_segments(path), _build_messages(segment, instructions), summarize_segments(segments), _slugify(title), segment_anchor(segment, source), build_summary_markdown(summaries), write_report(source, content)


## Module `editor\__init__.py`

```python
"""Editor package exports."""

from .card import build_widget, EditorCard

__all__ = ["build_widget", "EditorCard"]
```

Editor package exports.


## Module `errors\process_error_card.py`

```python
"""Red-themed process error console card for the Virtual Desktop."""

from __future__ import annotations

import html
import os
import subprocess
import threading
import time
from typing import Callable, Iterable, List, Optional, Sequence

from PySide6.QtCore import Qt, QTimer, Signal, Slot
from PySide6.QtWidgets import (
    QHBoxLayout,
    QLabel,
    QPushButton,
    QTextBrowser,
    QVBoxLayout,
    QWidget,
)

from tasks.models import ErrorRecord, append_error_record

RecordWriter = Callable[[ErrorRecord], None]
GuardFn = Callable[[Sequence[str], Optional[str], bool], tuple[bool, str]]
ViolationCallback = Callable[[str], None]


class ProcessErrorCard(QWidget):
    """Widget that launches subprocesses and captures their error output."""

    isolation_requested = Signal(str, object)
    close_requested = Signal()

    _append_entry = Signal(str, str)
    _set_status = Signal(str, bool)
    _set_buttons = Signal(bool, bool)

    def __init__(
        self,
        theme,
        cmd: Sequence[str],
        *,
        cwd: Optional[str] = None,
        guard: Optional[GuardFn] = None,
        allow_external_exec: bool = False,
        violation_cb: Optional[ViolationCallback] = None,
        record_writer: Optional[RecordWriter] = None,
    ) -> None:
        super().__init__()
        self._theme = theme
        self._cmd = list(cmd)
        self._cwd = os.path.abspath(cwd or os.getcwd())
        self._guard = guard
        self._allow_external_exec = bool(allow_external_exec)
        self._violation_cb = violation_cb
        self._record_writer = record_writer or append_error_record

        self._proc: Optional[subprocess.Popen[str]] = None
        self._stdout_thread: Optional[threading.Thread] = None
        self._stderr_thread: Optional[threading.Thread] = None
        self._wait_thread: Optional[threading.Thread] = None
        self._kill = threading.Event()
        self._terminated_by_user = False
        self._stderr_lines: List[str] = []
        self._stderr_lock = threading.Lock()
        self._running = False

        self._append_entry.connect(self._handle_append)
        self._set_status.connect(self._handle_status)
        self._set_buttons.connect(self._handle_buttons)

        root = QVBoxLayout(self)
        root.setContentsMargins(12, 12, 12, 12)
        root.setSpacing(8)

        title = QLabel("Process Error Console", self)
        title.setStyleSheet("color:#ffb8b8;font:700 12pt 'Cascadia Code';")
        root.addWidget(title)

        self._status_label = QLabel("Ready", self)
        self._status_label.setStyleSheet("color:#ff9292;font:500 9pt 'Segoe UI';")
        root.addWidget(self._status_label)

        buttons = QHBoxLayout()
        buttons.setSpacing(8)
        self._btn_start = QPushButton("Start", self)
        self._btn_stop = QPushButton("Stop", self)
        self._btn_stop.setEnabled(False)
        accent = getattr(theme, "accent", "#ff5c5c")
        border = getattr(theme, "card_border", "#5c1010")
        hover = getattr(theme, "accent_hov", "#ff7676")
        for button in (self._btn_start, self._btn_stop):
            button.setCursor(Qt.PointingHandCursor)
            button.setStyleSheet(
                "QPushButton{color:#fff;background:%s;border:1px solid %s;border-radius:6px;padding:6px 12px;}"
                "QPushButton:hover{background:%s;}"
                % (accent, border, hover)
            )
        buttons.addWidget(self._btn_start)
        buttons.addWidget(self._btn_stop)
        buttons.addStretch(1)
        root.addLayout(buttons)

        self._log = QTextBrowser(self)
        self._log.setAcceptRichText(True)
        self._log.document().setDefaultStyleSheet(
            "body{background:#230000;color:#ffecec;font-family:'Cascadia Code',Consolas,monospace;font-size:10pt;}"
            ".stdout{color:#f5dada;}"
            ".stderr{color:#ff6b6b;font-weight:600;}"
            ".status{color:#ffb347;font-style:italic;}"
            ".meta{color:#ff9292;}"
        )
        self._log.setStyleSheet(
            "QTextBrowser{background:#230000;color:#ffecec;border:1px solid #5c1010;border-radius:10px;padding:8px;}"
        )
        root.addWidget(self._log, 1)

        self._btn_start.clicked.connect(self.start)
        self._btn_stop.clicked.connect(self.stop)

    # ------------------------------------------------------------------
    @property
    def is_running(self) -> bool:
        """Return True if the subprocess is currently running."""

        return self._running

    # ------------------------------------------------------------------
    @Slot()
    def start(self) -> None:
        """Start the configured subprocess."""

        if self._proc and self._proc.poll() is None:
            return
        if not self._cmd:
            self._set_status.emit("No command configured.", True)
            return
        if self._guard:
            allowed, detail = self._guard(self._cmd, self._cwd, self._allow_external_exec)
            if not allowed:
                message = detail or "Command blocked."
                self._set_status.emit(message, True)
                if self._violation_cb:
                    try:
                        self._violation_cb(message)
                    except Exception:
                        pass
                return
        try:
            self._append_entry.emit("meta", f"Launching: {' '.join(self._cmd)}")
            self._proc = subprocess.Popen(
                self._cmd,
                cwd=self._cwd,
                text=True,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                bufsize=1,
            )
        except Exception as exc:  # pragma: no cover - launch guards
            reason = f"Launch failed: {exc}"
            self._set_status.emit(reason, True)
            self._record_failure(reason, exit_code=None)
            self.isolation_requested.emit(reason, None)
            return

        self._running = True
        self._kill.clear()
        self._terminated_by_user = False
        self._stderr_lines.clear()
        self._set_buttons.emit(False, True)
        self._set_status.emit("Process started.", False)

        if self._proc.stdout:
            self._stdout_thread = threading.Thread(
                target=self._stream_reader,
                args=(self._proc.stdout, "stdout"),
                daemon=True,
            )
            self._stdout_thread.start()
        if self._proc.stderr:
            self._stderr_thread = threading.Thread(
                target=self._stream_reader,
                args=(self._proc.stderr, "stderr"),
                daemon=True,
            )
            self._stderr_thread.start()
        self._wait_thread = threading.Thread(target=self._await_exit, daemon=True)
        self._wait_thread.start()

    # ------------------------------------------------------------------
    @Slot()
    def stop(self) -> None:
        """Terminate the running subprocess if any."""

        if not self._proc or self._proc.poll() is not None:
            return
        self._terminated_by_user = True
        self._kill.set()
        try:
            self._proc.terminate()
        except Exception:
            pass
        self._set_status.emit("Termination requested.", False)

    # ------------------------------------------------------------------
    def _stream_reader(self, pipe: Iterable[str], channel: str) -> None:
        for raw in pipe:
            if self._kill.is_set():
                break
            text = raw.rstrip("\n")
            if channel == "stderr":
                with self._stderr_lock:
                    self._stderr_lines.append(text)
            self._append_entry.emit(channel, text)

    # ------------------------------------------------------------------
    def _await_exit(self) -> None:
        assert self._proc is not None
        code = self._proc.wait()
        self._running = False
        self._kill.set()
        if self._stdout_thread:
            self._stdout_thread.join(timeout=0.5)
        if self._stderr_thread:
            self._stderr_thread.join(timeout=0.5)
        self._proc = None
        self._set_buttons.emit(True, False)

        if self._terminated_by_user:
            self._set_status.emit("Process terminated by user.", False)
            return
        if code == 0:
            self._set_status.emit("Process completed successfully.", False)
            return

        reason = self._summarise_failure(code)
        self._set_status.emit(reason, True)
        self._record_failure(reason, exit_code=code)
        self.isolation_requested.emit(reason, code)
        QTimer.singleShot(0, lambda: self.close_requested.emit())

    # ------------------------------------------------------------------
    def _summarise_failure(self, code: int) -> str:
        with self._stderr_lock:
            tail = [line for line in self._stderr_lines if line]
        detail = tail[-1] if tail else "no stderr output"
        return f"Process failed (code {code}): {detail}"

    # ------------------------------------------------------------------
    def _record_failure(self, message: str, *, exit_code: Optional[int]) -> None:
        record = ErrorRecord(
            ts=time.time(),
            level="ERROR",
            kind="Runtime",
            msg=f"{message} — cmd={' '.join(self._cmd)}",
            path=self._cmd[0] if self._cmd else None,
            task_id=None,
        )
        try:
            self._record_writer(record)
        except Exception:
            pass

    # ------------------------------------------------------------------
    @Slot(str, str)
    def _handle_append(self, channel: str, text: str) -> None:
        escaped = html.escape(text)
        self._log.append(f"<div class='{channel}'>{escaped}</div>")
        cursor = self._log.textCursor()
        cursor.movePosition(cursor.End)
        self._log.setTextCursor(cursor)

    # ------------------------------------------------------------------
    @Slot(str, bool)
    def _handle_status(self, text: str, is_error: bool) -> None:
        self._status_label.setText(text)
        self._append_entry.emit("status" if is_error else "meta", text)

    # ------------------------------------------------------------------
    @Slot(bool, bool)
    def _handle_buttons(self, start_enabled: bool, stop_enabled: bool) -> None:
        self._btn_start.setEnabled(start_enabled)
        self._btn_stop.setEnabled(stop_enabled)
```

Red-themed process error console card for the Virtual Desktop.
**Classes:** ProcessErrorCard


## Module `errors\__init__.py`

```python
"""Error handling widgets and helpers."""

from .process_error_card import ProcessErrorCard

__all__ = ["ProcessErrorCard"]
```

Error handling widgets and helpers.


## Module `tasks\bus.py`

```python
"""Lightweight in-process pub/sub bus for task updates.

This module exposes ``publish`` and ``subscribe`` helpers so different
components (Codex Terminal, Virtual Desktop, etc.) can react to task
changes without tight coupling. The implementation keeps the API very
small yet provides:

* A fixed list of allowed topics (mirroring the task spec).
* Optional ``task.*`` wildcard subscribers for convenience.
* Thread-safe subscribe/publish operations guarded by ``RLock``.
* An unsubscribe handle so listeners can be cleaned up deterministically.
* Defensive logging so one faulty subscriber will not break others.
"""
from __future__ import annotations

from collections import defaultdict
import logging
from threading import RLock
from typing import Callable, List, MutableMapping

__all__ = [
    "TASK_TOPICS",
    "Subscription",
    "publish",
    "subscribe",
]

logger = logging.getLogger(__name__)

Subscriber = Callable[[dict], None]

TASK_TOPICS = {
    "task.created",
    "task.updated",
    "task.status",
    "task.diff",
    "task.deleted",
    "task.conversation",
    "system.metrics",
}
_WILDCARD_TOPIC = "task.*"


class Subscription:
    """Handle returned from :func:`subscribe` that can detach a listener."""

    __slots__ = ("_topic", "_callback", "_active")

    def __init__(self, topic: str, callback: Subscriber) -> None:
        self._topic = topic
        self._callback = callback
        self._active = True

    @property
    def active(self) -> bool:
        """Whether the subscription is currently registered."""

        return self._active

    def unsubscribe(self) -> None:
        """Remove the callback from the bus. Safe to call multiple times."""

        if not self._active:
            return
        with _LOCK:
            listeners = _SUBSCRIBERS.get(self._topic)
            if listeners is None:
                self._active = False
                return
            try:
                listeners.remove(self._callback)
            except ValueError:
                pass
            else:
                if not listeners:
                    _SUBSCRIBERS.pop(self._topic, None)
            self._active = False

    # Support ``handle()`` as syntactic sugar for ``handle.unsubscribe()``.
    def __call__(self) -> None:  # pragma: no cover - sugar
        self.unsubscribe()


_SUBSCRIBERS: MutableMapping[str, List[Subscriber]] = defaultdict(list)
_LOCK = RLock()


def _validate_topic(topic: str, allow_wildcard: bool = False) -> None:
    if topic in TASK_TOPICS:
        return
    if allow_wildcard and topic == _WILDCARD_TOPIC:
        return
    raise ValueError(f"Unsupported topic: {topic!r}")


def subscribe(topic: str, callback: Subscriber) -> Subscription:
    """Register ``callback`` for ``topic`` and return an unsubscribe handle."""

    if not callable(callback):
        raise TypeError("callback must be callable")
    _validate_topic(topic, allow_wildcard=True)

    with _LOCK:
        _SUBSCRIBERS[topic].append(callback)
    return Subscription(topic, callback)


def publish(topic: str, payload: dict) -> None:
    """Broadcast ``payload`` to subscribers registered for ``topic``."""

    if not isinstance(payload, dict):
        raise TypeError("payload must be a dictionary")
    _validate_topic(topic)

    with _LOCK:
        listeners = list(_SUBSCRIBERS.get(topic, ()))
        wildcard_listeners = list(_SUBSCRIBERS.get(_WILDCARD_TOPIC, ()))

    for callback in (*listeners, *wildcard_listeners):
        try:
            callback(payload)
        except Exception:  # pragma: no cover - defensive logging
            logger.exception("Error dispatching %s to %r", topic, callback)
```

Lightweight in-process pub/sub bus for task updates.

This module exposes ``publish`` and ``subscribe`` helpers so different
components (Codex Terminal, Virtual Desktop, etc.) can react to task
changes without tight coupling. The implementation keeps the API very
small yet provides:

* A fixed list of allowed topics (mirroring the task spec).
* Optional ``task.*`` wildcard subscribers for convenience.
* Thread-safe subscribe/publish operations guarded by ``RLock``.
* An unsubscribe handle so listeners can be cleaned up deterministically.
* Defensive logging so one faulty subscriber will not break others.
**Classes:** Subscription
**Functions:** _validate_topic(topic, allow_wildcard), subscribe(topic, callback), publish(topic, payload)


## Module `tasks\card.py`

```python
from __future__ import annotations

import json
import logging
from datetime import UTC, datetime
from pathlib import Path
from typing import Callable, List, Optional, Sequence

from PySide6.QtWidgets import (
    QFrame,
    QHBoxLayout,
    QLabel,
    QMessageBox,
    QPushButton,
    QVBoxLayout,
    QWidget,
)

from .bus import Subscription, publish, subscribe
from .models import TASKS_FILE, Task, TaskEvent, append_event, update_task
from .panel import TaskPanel
from tools.system_metrics import SystemMetricsJob

logger = logging.getLogger(__name__)

__all__ = [
    "TaskManager",
    "TaskCard",
    "open_card",
]


class TaskManager:
    """Lightweight loader for task dataset records."""

    def __init__(self, dataset_path: str | Path | None = None, workspace_root: str | Path | None = None) -> None:
        path = Path(dataset_path) if dataset_path else TASKS_FILE
        self.dataset_path = path
        self.dataset_path.parent.mkdir(parents=True, exist_ok=True)
        self._workspace_root: Optional[Path] = Path(workspace_root).resolve() if workspace_root else None
        self._metrics_job: Optional[SystemMetricsJob] = None

    # ------------------------------------------------------------------
    def set_workspace(self, workspace_root: str | Path | None) -> None:
        """Update the workspace root used for resolving relative paths."""

        self._workspace_root = Path(workspace_root).resolve() if workspace_root else None

    # ------------------------------------------------------------------
    def list_tasks(self) -> List[Task]:
        """Return all task entries from the dataset."""

        if not self.dataset_path.exists():
            return []
        tasks: List[Task] = []
        with self.dataset_path.open("r", encoding="utf-8") as fh:
            for line in fh:
                line = line.strip()
                if not line:
                    continue
                try:
                    payload = json.loads(line)
                except json.JSONDecodeError:
                    continue
                try:
                    tasks.append(Task.from_dict(payload))
                except Exception:
                    logger.debug("Skipping malformed task payload: %r", payload)
        return tasks

    # ------------------------------------------------------------------
    def get_task(self, task_id: str) -> Optional[Task]:
        """Return a single task by identifier."""

        for task in self.list_tasks():
            if task.id == task_id:
                return task
        return None

    # ------------------------------------------------------------------
    def resolve_path(self, candidate: Optional[str]) -> Optional[Path]:
        """Resolve ``candidate`` against the workspace root if needed."""

        if not candidate:
            return None
        path = Path(candidate)
        if not path.is_absolute():
            base = self._workspace_root or Path.cwd()
            path = base / path
        return path

    # ------------------------------------------------------------------
    def start_system_metrics_job(
        self,
        interval_seconds: int = 900,
        *,
        targets: Optional[Sequence[str | Path]] = None,
    ) -> None:
        """Start a background job that refreshes system metrics periodically."""

        if interval_seconds <= 0:
            raise ValueError("interval_seconds must be positive")
        self.stop_system_metrics_job()

        datasets_root = self.dataset_path.parent

        def _publish(summary: dict) -> None:
            try:
                components = summary.get("components", {})
                publish(
                    "system.metrics",
                    {
                        "generated_at": summary.get("generated_at"),
                        "components": list(components.keys()),
                    },
                )
            except Exception:
                logger.exception("Failed to publish system metrics summary")

        job = SystemMetricsJob(
            interval=float(interval_seconds),
            targets=targets,
            datasets_root=datasets_root,
            db_path=datasets_root / "system_metrics.db",
            publish_callback=_publish,
        )
        self._metrics_job = job
        job.start()

    # ------------------------------------------------------------------
    def stop_system_metrics_job(self) -> None:
        """Stop the background system metrics refresher if active."""

        if self._metrics_job is not None:
            try:
                self._metrics_job.stop()
            finally:
                self._metrics_job = None


class TaskCard(QWidget):
    """Card widget presenting global task list with contextual actions."""

    def __init__(
        self,
        manager: TaskManager,
        theme,
        open_editor: Callable[[str], None],
        open_terminal: Optional[Callable[[str], None]] = None,
        workspace_root: str | Path | None = None,
        source: str = "desktop",
        parent: Optional[QWidget] = None,
    ) -> None:
        super().__init__(parent)
        self.manager = manager
        self.manager.set_workspace(workspace_root)
        self._theme = theme
        self._open_editor = open_editor
        self._open_terminal = open_terminal
        self._source = source
        self._selected_task: Optional[Task] = None
        self._subscriptions: List[Subscription] = []

        self.setObjectName("TasksCard")
        self.setStyleSheet(
            (
                "QWidget#TasksCard{background:#0c1320;border:1px solid #1f2b3a;border-radius:12px;}"
                "QLabel{color:#e9f3ff;}"
            )
        )

        layout = QVBoxLayout(self)
        layout.setContentsMargins(16, 16, 16, 16)
        layout.setSpacing(12)

        header = QLabel("Tasks — All Sessions", self)
        header.setStyleSheet("font:700 12pt 'Segoe UI'; color:#eaf2ff;")
        layout.addWidget(header)

        self.panel = TaskPanel(manager.dataset_path, self)
        # Disable inline creation to keep desktop card focused on review/actions.
        self.panel.new_task_input.setEnabled(False)
        self.panel.new_task_input.setPlaceholderText("Create tasks from Codex Terminal runs.")
        layout.addWidget(self.panel, 1)

        action_frame = QFrame(self)
        action_frame.setObjectName("TasksCardActions")
        action_frame.setStyleSheet(
            (
                "QFrame#TasksCardActions{background:#0a111e;border:1px solid #1d2b3c;"
                "border-radius:10px;}"
            )
        )
        action_row = QHBoxLayout(action_frame)
        action_row.setContentsMargins(12, 10, 12, 10)
        action_row.setSpacing(10)

        self.btn_open_editor = QPushButton("Open in Editor", action_frame)
        self.btn_open_terminal = QPushButton("Open Terminal", action_frame)
        self.btn_archive = QPushButton("Archive", action_frame)

        button_style = (
            "QPushButton{{background:{accent};color:#ffffff;border-radius:6px;"
            "border:1px solid {border};padding:6px 14px;font-weight:600;}}"
            "QPushButton:hover{{background:{accent_hov};}}"
            "QPushButton:disabled{{background:#1b2c44;color:#6c7a96;border:1px solid #1b2c44;}}"
        ).format(
            accent=self._theme.accent,
            border=self._theme.card_border,
            accent_hov=self._theme.accent_hov,
        )
        for btn in (self.btn_open_editor, self.btn_open_terminal, self.btn_archive):
            btn.setStyleSheet(button_style)
            action_row.addWidget(btn)

        action_row.addStretch(1)
        layout.addWidget(action_frame)

        self.panel.task_selected.connect(self._on_task_selected)
        self.panel.status_changed.connect(self._apply_status_change)
        self.panel.load_conversationRequested.connect(self._publish_conversation_request)

        self.btn_open_editor.clicked.connect(self._open_selected_in_editor)
        self.btn_open_terminal.clicked.connect(self._open_selected_in_terminal)
        self.btn_archive.clicked.connect(self._archive_selected_task)

        self._update_action_state()
        self._install_bus_subscriptions()
        self.destroyed.connect(lambda *_: self._teardown())

    # ------------------------------------------------------------------
    def refresh(self) -> None:
        """Force a dataset reload."""

        self.panel.refresh()
        if self._selected_task:
            updated = self.manager.get_task(self._selected_task.id)
            if updated:
                self._selected_task = updated
            self._update_action_state()

    # ------------------------------------------------------------------
    def _install_bus_subscriptions(self) -> None:
        topics = {
            "task.created": self._on_task_payload,
            "task.updated": self._on_task_payload,
            "task.status": self._on_status_payload,
            "task.deleted": self._on_status_payload,
            "task.diff": self._on_diff_payload,
        }
        for topic, callback in topics.items():
            try:
                self._subscriptions.append(subscribe(topic, callback))
            except Exception:  # pragma: no cover - defensive guard
                logger.exception("Failed to subscribe to %s", topic)

    # ------------------------------------------------------------------
    def _teardown(self) -> None:
        for handle in self._subscriptions:
            try:
                handle.unsubscribe()
            except Exception:  # pragma: no cover - defensive cleanup
                logger.exception("Error unsubscribing task handle")
        self._subscriptions.clear()

    # ------------------------------------------------------------------
    def _on_task_selected(self, task_id: str) -> None:
        self._selected_task = self.manager.get_task(task_id)
        self._update_action_state()

    # ------------------------------------------------------------------
    def _on_task_payload(self, payload: dict) -> None:
        task = self._task_from_payload(payload)
        if task is None:
            self.panel.refresh()
            return
        self.panel.update_task(task)
        if self._selected_task and self._selected_task.id == task.id:
            self._selected_task = task
        self._update_action_state()

    # ------------------------------------------------------------------
    def _on_status_payload(self, payload: dict) -> None:
        task_id = payload.get("id") if isinstance(payload, dict) else None
        if not task_id:
            return
        task = self.manager.get_task(str(task_id))
        if task:
            self.panel.update_task(task)
            if self._selected_task and self._selected_task.id == task.id:
                self._selected_task = task
                self._update_action_state()
        else:
            self.panel.refresh()

    # ------------------------------------------------------------------
    def _on_diff_payload(self, payload: dict) -> None:  # noqa: ARG002 - payload unused beyond refresh
        self.panel.refresh()
        if self._selected_task:
            latest = self.manager.get_task(self._selected_task.id)
            if latest:
                self._selected_task = latest
        self._update_action_state()

    # ------------------------------------------------------------------
    def _publish_conversation_request(self, task_id: str, conversation_id: str) -> None:
        conv = (conversation_id or "").strip()
        if not conv:
            return
        payload = {
            "id": task_id,
            "conversation_id": conv,
            "session_id": self._selected_task.session_id if self._selected_task else "",
            "source": self._source,
        }
        try:
            publish("task.conversation", payload)
        except Exception:  # pragma: no cover - defensive guard
            logger.exception("Failed to publish conversation request from TaskCard")

    # ------------------------------------------------------------------
    def _task_from_payload(self, payload: dict | None) -> Optional[Task]:
        if not isinstance(payload, dict):
            return None
        try:
            return Task.from_dict(payload)
        except Exception:
            logger.debug("Task payload missing fields: %r", payload)
            task_id = payload.get("id")
            if task_id:
                return self.manager.get_task(str(task_id))
        return None

    # ------------------------------------------------------------------
    def _update_action_state(self) -> None:
        has_task = self._selected_task is not None
        self.btn_open_editor.setEnabled(has_task and self._resolve_primary_path(self._selected_task) is not None)
        self.btn_open_terminal.setEnabled(has_task and self._open_terminal is not None)
        self.btn_archive.setEnabled(has_task)

    # ------------------------------------------------------------------
    def _resolve_primary_path(self, task: Optional[Task]) -> Optional[Path]:
        if not task:
            return None
        for candidate in list(task.files or []):
            resolved = self.manager.resolve_path(candidate)
            if resolved is not None:
                return resolved
        if task.run_log_path:
            resolved = self.manager.resolve_path(task.run_log_path)
            if resolved is not None:
                return resolved
        return None

    # ------------------------------------------------------------------
    def _resolve_directory(self, task: Optional[Task]) -> Path:
        workspace = self.manager.resolve_path(".")
        if task is None:
            return workspace or Path.cwd()
        primary = self._resolve_primary_path(task)
        if primary and primary.exists():
            return primary.parent
        if primary:
            return primary.parent
        if task.run_log_path:
            resolved = self.manager.resolve_path(task.run_log_path)
            if resolved:
                return resolved.parent
        return workspace or Path.cwd()

    # ------------------------------------------------------------------
    def _open_selected_in_editor(self) -> None:
        if not self._selected_task:
            return
        path = self._resolve_primary_path(self._selected_task)
        if path is None or not self._open_editor:
            QMessageBox.information(self, "Tasks", "Task has no associated files to open.")
            return
        if not path.exists():
            QMessageBox.information(self, "Tasks", f"File not found: {path}")
            return
        self._open_editor(str(path))

    # ------------------------------------------------------------------
    def _open_selected_in_terminal(self) -> None:
        if not self._selected_task or not self._open_terminal:
            return
        directory = self._resolve_directory(self._selected_task)
        if not directory.exists():
            QMessageBox.information(self, "Tasks", f"Folder not found: {directory}")
            return
        self._open_terminal(str(directory))

    # ------------------------------------------------------------------
    def _archive_selected_task(self) -> None:
        if not self._selected_task:
            return
        self._update_status(self._selected_task.id, "deleted")

    # ------------------------------------------------------------------
    def _apply_status_change(self, task_id: str, status: str) -> None:
        if not task_id or not status:
            return
        self._update_status(task_id, status)

    # ------------------------------------------------------------------
    def _update_status(self, task_id: str, status: str) -> None:
        now = datetime.now(UTC).timestamp()
        try:
            updated = update_task(task_id, status=status, updated_ts=now)
            append_event(
                TaskEvent(ts=now, task_id=task_id, event="status", by=self._source, to=status)
            )
        except ValueError:
            QMessageBox.warning(self, "Tasks", f"Task {task_id} no longer exists.")
            self.panel.refresh()
            return
        except Exception:
            logger.exception("Failed to update task %s", task_id)
            QMessageBox.warning(self, "Tasks", "Unable to update the selected task.")
            return

        publish("task.status", {"id": updated.id, "status": updated.status})
        publish("task.updated", updated.to_dict())
        if status == "deleted":
            publish("task.deleted", {"id": updated.id})
        self.panel.update_task(updated)
        if self._selected_task and self._selected_task.id == updated.id:
            self._selected_task = updated
        self._update_action_state()


def open_card(
    manager: TaskManager,
    theme,
    open_editor: Callable[[str], None],
    open_terminal: Optional[Callable[[str], None]] = None,
    workspace_root: str | Path | None = None,
    parent: Optional[QWidget] = None,
    source: str = "desktop",
) -> Optional[TaskCard]:
    """Factory returning a configured :class:`TaskCard` widget."""

    try:
        return TaskCard(
            manager=manager,
            theme=theme,
            open_editor=open_editor,
            open_terminal=open_terminal,
            workspace_root=workspace_root,
            source=source,
            parent=parent,
        )
    except Exception:  # pragma: no cover - guard unexpected Qt errors
        logger.exception("Failed to create TaskCard")
        QMessageBox.critical(parent, "Tasks", "Unable to open Tasks card.")
        return None
```

**Classes:** TaskManager, TaskCard
**Functions:** open_card(manager, theme, open_editor, open_terminal, workspace_root, parent, source)


## Module `tasks\diffs.py`

```python
"""Helpers for capturing per-task diff statistics.

The helpers prefer Git ``--numstat`` output whenever the workspace is a
repository. If the workspace is not Git-controlled or a given file is
untracked, the module falls back to maintaining lightweight text
snapshots so we can still compute line-level additions/removals.

Each diff capture updates the corresponding :class:`~tasks.models.Task`
record, appends a :class:`~tasks.models.DiffSnapshot` to
``datasets/diffs.jsonl``, and emits a ``task.diff`` event on the shared
bus so UI surfaces stay synchronized.
"""
from __future__ import annotations

import difflib
import json
import subprocess
import time
from dataclasses import dataclass
from pathlib import Path
from typing import Dict, Iterable, List, Optional, Sequence, Set, Tuple

from .bus import publish
from .models import (
    DATASETS_DIR,
    DIFFS_FILE,
    DiffSnapshot,
    TaskDiffSummary,
    update_task,
)

__all__ = ["record_diff"]

_SNAPSHOT_ROOT = DATASETS_DIR / "runs"


@dataclass(slots=True)
class _Target:
    """Normalized representation of a candidate file path."""

    abs_path: Path
    rel_workspace: str
    rel_repo: Optional[str] = None


def record_diff(
    task_id: str,
    files: Optional[Iterable[str]] = None,
    workspace_root: str | Path | None = None,
    timestamp: float | None = None,
) -> Optional[DiffSnapshot]:
    """Capture diff statistics for ``task_id`` and persist the results.

    Args:
        task_id: Identifier of the task being updated.
        files: Optional explicit list of files to diff. When omitted, all
            repository changes are considered.
        workspace_root: Working directory the task operates within.
        timestamp: Optional explicit timestamp. Defaults to ``time.time()``.

    Returns:
        The :class:`DiffSnapshot` that was recorded, or ``None`` when no
        diff information was available and no update occurred.
    """

    if not task_id:
        raise ValueError("task_id is required")

    workspace = Path(workspace_root or Path.cwd()).resolve()
    ts = float(timestamp) if timestamp is not None else time.time()

    targets = _normalize_targets(files, workspace)

    repo_root = _detect_git_repo(workspace)
    if repo_root:
        for target in targets.values():
            try:
                rel_repo = target.abs_path.resolve().relative_to(repo_root)
            except ValueError:
                continue
            target.rel_repo = rel_repo.as_posix()

    git_added = git_removed = 0
    git_files: List[str] = []
    git_handled: Set[Path] = set()
    if repo_root:
        git_added, git_removed, git_files, git_handled = _git_numstat(
            repo_root, workspace, targets
        )

    snapshot_added = snapshot_removed = 0
    snapshot_files: List[str] = []
    if targets:
        snapshot_added, snapshot_removed, snapshot_files = _snapshot_diff(
            task_id, targets, git_handled
        )

    total_added = git_added + snapshot_added
    total_removed = git_removed + snapshot_removed
    all_files = _unique(git_files + snapshot_files)

    if not all_files and not targets and total_added == 0 and total_removed == 0:
        # Nothing to record (no repo changes and no explicit targets provided).
        return None

    # Update the task record and persist a snapshot for auditing.
    updated = update_task(
        task_id,
        diffs=TaskDiffSummary(added=total_added, removed=total_removed).to_dict(),
        updated_ts=ts,
    )

    snapshot = DiffSnapshot(
        ts=ts,
        task_id=task_id,
        added=total_added,
        removed=total_removed,
        files=all_files,
    )
    _append_diff_snapshot(snapshot)

    publish(
        "task.diff",
        {
            "id": updated.id,
            "added": total_added,
            "removed": total_removed,
            "files": list(all_files),
        },
    )
    return snapshot


def _normalize_targets(files: Optional[Iterable[str]], workspace: Path) -> Dict[Path, _Target]:
    if not files:
        return {}

    targets: Dict[Path, _Target] = {}
    for entry in files:
        if not entry:
            continue
        candidate = Path(entry)
        abs_path = candidate if candidate.is_absolute() else (workspace / candidate)
        abs_path = abs_path.resolve()
        rel_workspace = _relative_to_workspace(abs_path, workspace)
        targets[abs_path] = _Target(abs_path=abs_path, rel_workspace=rel_workspace)
    return targets


def _relative_to_workspace(path: Path, workspace: Path) -> str:
    try:
        rel = path.relative_to(workspace)
        return rel.as_posix()
    except ValueError:
        return path.as_posix()


def _detect_git_repo(start: Path) -> Optional[Path]:
    try:
        result = subprocess.run(
            ["git", "-C", str(start), "rev-parse", "--show-toplevel"],
            check=False,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
        )
    except FileNotFoundError:
        return None
    if result.returncode != 0:
        return None
    top = result.stdout.strip()
    if not top:
        return None
    return Path(top).resolve()


def _git_numstat(
    repo_root: Path,
    workspace: Path,
    targets: Dict[Path, _Target],
) -> Tuple[int, int, List[str], Set[Path]]:
    paths = sorted({target.rel_repo for target in targets.values() if target.rel_repo})

    cmd: List[str] = [
        "git",
        "-C",
        str(repo_root),
        "--no-optional-locks",
        "diff",
        "--numstat",
    ]
    if paths:
        cmd.append("--")
        cmd.extend(paths)

    try:
        result = subprocess.run(
            cmd,
            check=False,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
        )
    except FileNotFoundError:
        return 0, 0, [], set()
    if result.returncode != 0:
        return 0, 0, [], set()

    added_total = removed_total = 0
    files: List[str] = []
    handled: Set[Path] = set()

    for line in result.stdout.splitlines():
        parsed = _parse_numstat_line(line)
        if not parsed:
            continue
        added, removed, rel_path = parsed
        abs_path = (repo_root / rel_path).resolve()
        files.append(_relative_to_workspace(abs_path, workspace))
        added_total += added
        removed_total += removed
        if abs_path in targets:
            handled.add(abs_path)
    return added_total, removed_total, _unique(files), handled


def _parse_numstat_line(line: str) -> Optional[Tuple[int, int, str]]:
    parts = line.strip().split("\t", 2)
    if len(parts) != 3:
        return None
    added_str, removed_str, path_field = parts
    added = _parse_int(added_str)
    removed = _parse_int(removed_str)
    normalized = _normalize_numstat_path(path_field)
    if not normalized:
        return None
    return added, removed, normalized


def _parse_int(value: str) -> int:
    try:
        return int(value)
    except ValueError:
        return 0


def _normalize_numstat_path(field: str) -> str:
    field = field.strip()
    if not field:
        return ""
    if " => " in field:
        return _normalize_rename(field, " => ")
    if "->" in field:
        return _normalize_rename(field, "->")
    return field


def _normalize_rename(field: str, token: str) -> str:
    cleaned = field.replace("{", "").replace("}", "")
    parts = cleaned.split(token, 1)
    if len(parts) != 2:
        return cleaned.strip()
    left, right = parts[0].strip(), parts[1].strip()
    if "/" in left:
        prefix = left.rsplit("/", 1)[0]
        if prefix:
            if right.startswith(prefix):
                return right
            return f"{prefix}/{right}"
    return right


def _snapshot_diff(
    task_id: str,
    targets: Dict[Path, _Target],
    skip: Set[Path],
) -> Tuple[int, int, List[str]]:
    added_total = removed_total = 0
    files: List[str] = []
    for abs_path, target in targets.items():
        if abs_path in skip:
            continue
        added, removed = _compute_snapshot_counts(task_id, abs_path, target.rel_workspace)
        if added or removed:
            files.append(target.rel_workspace)
        added_total += added
        removed_total += removed
    return added_total, removed_total, _unique(files)


def _compute_snapshot_counts(task_id: str, abs_path: Path, rel_path: str) -> Tuple[int, int]:
    snapshot_file = _snapshot_file(task_id, rel_path)

    previous_lines: List[str] = []
    if snapshot_file.exists():
        previous_lines = snapshot_file.read_text(encoding="utf-8", errors="ignore").splitlines()

    current_lines: List[str] = []
    file_exists = abs_path.exists()
    if file_exists:
        current_lines = abs_path.read_text(encoding="utf-8", errors="ignore").splitlines()

    added = removed = 0
    for line in difflib.ndiff(previous_lines, current_lines):
        if line.startswith("+ "):
            added += 1
        elif line.startswith("- "):
            removed += 1

    if file_exists:
        snapshot_file.parent.mkdir(parents=True, exist_ok=True)
        snapshot_file.write_text(
            "\n".join(current_lines),
            encoding="utf-8",
        )
    elif snapshot_file.exists():
        snapshot_file.unlink()

    return added, removed


def _snapshot_file(task_id: str, rel_path: str) -> Path:
    safe_parts = [part for part in Path(rel_path).parts if part not in ("", ".", "..")]
    snapshot_root = _SNAPSHOT_ROOT / task_id / "snapshot"
    return (snapshot_root / Path(*safe_parts)).resolve()


def _append_diff_snapshot(snapshot: DiffSnapshot) -> None:
    DIFFS_FILE.parent.mkdir(parents=True, exist_ok=True)
    with DIFFS_FILE.open("a", encoding="utf-8") as fh:
        fh.write(json.dumps(snapshot.to_dict(), ensure_ascii=False) + "\n")


def _unique(values: Sequence[str]) -> List[str]:
    seen = set()
    result: List[str] = []
    for value in values:
        if value in seen:
            continue
        seen.add(value)
        result.append(value)
    return result
```

Helpers for capturing per-task diff statistics.

The helpers prefer Git ``--numstat`` output whenever the workspace is a
repository. If the workspace is not Git-controlled or a given file is
untracked, the module falls back to maintaining lightweight text
snapshots so we can still compute line-level additions/removals.

Each diff capture updates the corresponding :class:`~tasks.models.Task`
record, appends a :class:`~tasks.models.DiffSnapshot` to
``datasets/diffs.jsonl``, and emits a ``task.diff`` event on the shared
bus so UI surfaces stay synchronized.
**Classes:** _Target
**Functions:** record_diff(task_id, files, workspace_root, timestamp), _normalize_targets(files, workspace), _relative_to_workspace(path, workspace), _detect_git_repo(start), _git_numstat(repo_root, workspace, targets), _parse_numstat_line(line), _parse_int(value), _normalize_numstat_path(field), _normalize_rename(field, token), _snapshot_diff(task_id, targets, skip), _compute_snapshot_counts(task_id, abs_path, rel_path), _snapshot_file(task_id, rel_path), _append_diff_snapshot(snapshot), _unique(values)


## Module `tasks\drawer.py`

```python
"""Slide-out drawer wrapper around :class:`tasks.task_panel.TaskPanel`."""
from __future__ import annotations

import logging
import uuid
from datetime import UTC, datetime
from pathlib import Path
from typing import List, Optional

from PySide6.QtCore import Qt
from PySide6.QtWidgets import QDockWidget, QFrame, QSizePolicy, QVBoxLayout, QWidget

from .bus import Subscription, publish, subscribe
from .models import TASKS_FILE, Task, TaskEvent, append_event, append_task, update_task
from .task_panel import TaskPanel

logger = logging.getLogger(__name__)

__all__ = ["TaskDrawer"]


class TaskDrawer(QFrame):
    """Right-aligned container that hosts the shared :class:`TaskPanel` UI."""

    def __init__(
        self,
        session_id: str,
        dataset_path: Optional[Path] = None,
        source: str = "terminal",
        parent: Optional[QWidget] = None,
    ) -> None:
        super().__init__(parent)
        self.setObjectName("TaskDrawer")
        self.setFocusPolicy(Qt.NoFocus)
        self.setSizePolicy(QSizePolicy.Fixed, QSizePolicy.Expanding)
        self.setStyleSheet(
            "QFrame#TaskDrawer{background:#0a111e;border-left:1px solid #1d2b3c;}"
        )

        self._session_id = session_id or "terminal"
        self._source = source or "terminal"
        self._dataset_path = Path(dataset_path) if dataset_path else TASKS_FILE

        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)

        self.panel = TaskPanel(self._dataset_path, self)
        self.panel.setFeatures(QDockWidget.NoDockWidgetFeatures)
        self.panel.setTitleBarWidget(QWidget(self.panel))
        layout.addWidget(self.panel)

        width_hint = max(360, self.panel.sizeHint().width())
        self.setFixedWidth(width_hint)

        self.panel.new_taskRequested.connect(self._create_task)
        self.panel.status_changed.connect(self._apply_status_change)
        self.panel.load_conversationRequested.connect(self._publish_conversation_request)

        self._subscriptions: List[Subscription] = [
            subscribe("task.created", self._on_task_payload),
            subscribe("task.updated", self._on_task_payload),
        ]
        self.destroyed.connect(lambda *_: self._teardown())

    # ------------------------------------------------------------------
    def refresh(self) -> None:
        """Refresh the embedded panel from disk."""

        self.panel.refresh()

    # ------------------------------------------------------------------
    def _teardown(self) -> None:
        for handle in self._subscriptions:
            try:
                handle.unsubscribe()
            except Exception:  # pragma: no cover - defensive cleanup
                logger.exception("Failed to unsubscribe task drawer handle")
        self._subscriptions.clear()

    # ------------------------------------------------------------------
    def _create_task(self, title: str) -> None:
        title = (title or "").strip()
        if not title:
            return
        now = datetime.now(UTC).timestamp()
        task_id = self._generate_task_id()
        task = Task(
            id=task_id,
            title=title,
            status="open",
            created_ts=now,
            updated_ts=now,
            session_id=self._session_id,
            source=self._source,
            codex_conversation_id=self._session_id,
        )
        try:
            append_task(task)
            append_event(TaskEvent(ts=now, task_id=task_id, event="created", by=self._source))
        except Exception:
            logger.exception("Failed to persist new task: %s", task_id)
            return

        publish("task.created", task.to_dict())
        publish("task.updated", task.to_dict())
        self.panel.update_task(task)

    # ------------------------------------------------------------------
    def _publish_conversation_request(self, task_id: str, conversation_id: str) -> None:
        conv = (conversation_id or "").strip()
        if not conv:
            return
        payload = {
            "id": task_id,
            "conversation_id": conv,
            "session_id": self._session_id,
            "source": self._source,
        }
        try:
            publish("task.conversation", payload)
        except Exception:  # pragma: no cover - defensive guard
            logger.exception("Failed to publish task conversation request")

    # ------------------------------------------------------------------
    def _apply_status_change(self, task_id: str, status: str) -> None:
        if not task_id or not status:
            return
        now = datetime.now(UTC).timestamp()
        try:
            updated = update_task(task_id, status=status, updated_ts=now)
            append_event(
                TaskEvent(
                    ts=now,
                    task_id=task_id,
                    event="status",
                    by=self._source,
                    to=status,
                )
            )
        except ValueError:
            logger.warning("Task %s not found when applying status", task_id)
            self.panel.refresh()
            return
        except Exception:
            logger.exception("Failed to update task status for %s", task_id)
            return

        publish("task.status", {"id": updated.id, "status": updated.status})
        publish("task.updated", updated.to_dict())
        self.panel.update_task(updated)

    # ------------------------------------------------------------------
    def _on_task_payload(self, payload: dict) -> None:
        if not isinstance(payload, dict):
            return
        try:
            task = Task.from_dict(payload)
        except Exception:
            logger.debug("Skipping malformed task payload: %r", payload)
            self.panel.refresh()
            return
        self.panel.update_task(task)

    # ------------------------------------------------------------------
    def _generate_task_id(self) -> str:
        stamp = datetime.now(UTC).strftime("%Y%m%d%H%M%S")
        return f"tsk_{stamp}_{uuid.uuid4().hex[:6]}"
```

Slide-out drawer wrapper around :class:`tasks.task_panel.TaskPanel`.
**Classes:** TaskDrawer


## Module `tasks\models.py`

```python
"""Task data models and JSONL persistence helpers.

This module provides dataclasses that model Codex tasks and helper
functions to persist them in append-only datasets housed under
``datasets/``. The APIs keep the on-disk format aligned with the
specification documented in ``concepts/dev_logic/Task System.md``.
"""
from __future__ import annotations

from collections import deque
from dataclasses import dataclass, field
import json
import os
from pathlib import Path
from typing import Any, Dict, Iterable, List, Optional, Tuple

__all__ = [
    "Task",
    "TaskEvent",
    "DiffSnapshot",
    "ErrorRecord",
    "append_task",
    "update_task",
    "append_event",
    "append_run_log",
    "append_run_output",
    "load_run_log_tail",
    "resolve_run_log_path",
    "append_error_record",
]

DATASETS_DIR = Path(__file__).resolve().parent.parent / "datasets"
TASKS_FILE = DATASETS_DIR / "tasks.jsonl"
EVENTS_FILE = DATASETS_DIR / "task_events.jsonl"
DIFFS_FILE = DATASETS_DIR / "diffs.jsonl"
ERRORS_FILE = DATASETS_DIR / "errors.jsonl"
_RUNS_SUBDIR = "runs"
_RUN_LOG_FILENAME = "run.log"


@dataclass(slots=True)
class TaskDiffSummary:
    """Summary of cumulative diff counts attached to a task."""

    added: int = 0
    removed: int = 0

    def to_dict(self) -> Dict[str, int]:
        return {"added": int(self.added), "removed": int(self.removed)}


@dataclass(slots=True)
class Task:
    """Representation of a tracked task entry."""

    id: str
    title: str
    status: str
    created_ts: float
    updated_ts: float
    session_id: str
    source: str
    labels: List[str] = field(default_factory=list)
    diffs: TaskDiffSummary = field(default_factory=TaskDiffSummary)
    files: List[str] = field(default_factory=list)
    run_log_path: Optional[str] = None
    codex_conversation_id: Optional[str] = None
    parent_id: Optional[str] = None

    def to_dict(self) -> Dict[str, Any]:
        return {
            "id": self.id,
            "title": self.title,
            "status": self.status,
            "created_ts": self.created_ts,
            "updated_ts": self.updated_ts,
            "session_id": self.session_id,
            "source": self.source,
            "labels": list(self.labels),
            "diffs": self.diffs.to_dict(),
            "files": list(self.files),
            "run_log_path": self.run_log_path,
            "codex_conversation_id": self.codex_conversation_id,
            "parent_id": self.parent_id,
        }

    @classmethod
    def from_dict(cls, payload: Dict[str, Any]) -> "Task":
        diffs = payload.get("diffs") or {}
        summary = TaskDiffSummary(
            added=int(diffs.get("added", 0)),
            removed=int(diffs.get("removed", 0)),
        )
        return cls(
            id=str(payload["id"]),
            title=str(payload["title"]),
            status=str(payload["status"]),
            created_ts=float(payload["created_ts"]),
            updated_ts=float(payload["updated_ts"]),
            session_id=str(payload["session_id"]),
            source=str(payload["source"]),
            labels=list(payload.get("labels", [])),
            diffs=summary,
            files=list(payload.get("files", [])),
            run_log_path=payload.get("run_log_path"),
            codex_conversation_id=payload.get("codex_conversation_id"),
            parent_id=payload.get("parent_id"),
        )


@dataclass(slots=True)
class TaskEvent:
    """Immutable event describing a change to a task."""

    ts: float
    task_id: str
    event: str
    by: Optional[str] = None
    to: Optional[str] = None
    data: Optional[Dict[str, Any]] = None

    def to_dict(self) -> Dict[str, Any]:
        payload: Dict[str, Any] = {
            "ts": self.ts,
            "task_id": self.task_id,
            "event": self.event,
        }
        if self.by is not None:
            payload["by"] = self.by
        if self.to is not None:
            payload["to"] = self.to
        if self.data is not None:
            payload["data"] = self.data
        return payload


@dataclass(slots=True)
class DiffSnapshot:
    """Snapshot of diff statistics emitted during a task run."""

    ts: float
    task_id: str
    added: int
    removed: int
    files: List[str] = field(default_factory=list)

    def to_dict(self) -> Dict[str, Any]:
        return {
            "ts": self.ts,
            "task_id": self.task_id,
            "added": int(self.added),
            "removed": int(self.removed),
            "files": list(self.files),
        }


@dataclass(slots=True)
class ErrorRecord:
    """Structured record describing a captured error event."""

    ts: float
    level: str
    kind: str
    msg: str
    path: Optional[str] = None
    task_id: Optional[str] = None

    def to_dict(self) -> Dict[str, Any]:
        payload: Dict[str, Any] = {
            "ts": float(self.ts),
            "level": str(self.level),
            "kind": str(self.kind),
            "msg": str(self.msg),
        }
        if self.path is not None:
            payload["path"] = self.path
        if self.task_id is not None:
            payload["task_id"] = self.task_id
        return payload


def _ensure_datasets_dir() -> None:
    DATASETS_DIR.mkdir(parents=True, exist_ok=True)


def _append_jsonl(path: Path, payload: Dict[str, Any]) -> None:
    _ensure_datasets_dir()
    with path.open("a", encoding="utf-8") as fh:
        fh.write(json.dumps(payload, ensure_ascii=False) + "\n")


def _read_jsonl(path: Path) -> List[Dict[str, Any]]:
    if not path.exists():
        return []
    items: List[Dict[str, Any]] = []
    with path.open("r", encoding="utf-8") as fh:
        for line in fh:
            line = line.strip()
            if not line:
                continue
            try:
                items.append(json.loads(line))
            except json.JSONDecodeError:
                continue
    return items


def _write_jsonl_atomic(path: Path, records: Iterable[Dict[str, Any]]) -> None:
    _ensure_datasets_dir()
    tmp_path = path.with_suffix(path.suffix + ".tmp")
    with tmp_path.open("w", encoding="utf-8") as fh:
        for record in records:
            fh.write(json.dumps(record, ensure_ascii=False) + "\n")
    os.replace(tmp_path, path)


def _dataset_root(candidate: Optional[Path]) -> Path:
    return Path(candidate) if candidate else DATASETS_DIR


def append_error_record(record: ErrorRecord) -> None:
    """Persist ``record`` to the shared ``errors.jsonl`` dataset."""

    _append_jsonl(ERRORS_FILE, record.to_dict())


def resolve_run_log_path(task: Task, dataset_root: Optional[Path] = None) -> Tuple[Path, str]:
    """Return absolute and relative run-log paths for ``task``.

    Args:
        task: Task instance describing the record being updated.
        dataset_root: Optional override for the datasets directory root.

    Returns:
        Tuple of ``(absolute_path, relative_posix)``.
    """

    root = _dataset_root(dataset_root)
    if task.run_log_path:
        raw = Path(task.run_log_path)
    else:
        raw = Path(_RUNS_SUBDIR) / task.id / _RUN_LOG_FILENAME
    absolute = raw if raw.is_absolute() else root / raw
    relative = raw.as_posix()
    return absolute, relative


def append_run_log(
    task: Task,
    lines: Iterable[str] | str,
    dataset_root: Optional[Path] = None,
    *,
    channel: Optional[str] = None,
) -> Tuple[Path, str, bool]:
    """Append ``lines`` to the task run log, creating directories as needed.

    Args:
        task: Task whose run log is being updated.
        lines: Text lines to append. Strings are treated as a single line.
        dataset_root: Optional root directory for datasets (defaults to
            :data:`DATASETS_DIR`).
        channel: Optional label such as ``"stdout"`` or ``"stderr"`` to prefix
            each line with ``[channel] ``.

    Returns:
        ``(absolute_path, relative_posix, created)`` where ``created`` indicates
        the task previously lacked a ``run_log_path`` value.
    """

    absolute, relative = resolve_run_log_path(task, dataset_root)
    absolute.parent.mkdir(parents=True, exist_ok=True)

    created = task.run_log_path is None

    entries: List[str]
    if isinstance(lines, str):
        entries = [lines]
    else:
        entries = [str(line) for line in lines]

    if entries:
        prefix = f"[{channel}]" if channel else ""
        with absolute.open("a", encoding="utf-8") as fh:
            for entry in entries:
                text = entry.rstrip("\n")
                if prefix:
                    text = f"{prefix} {text}" if text else prefix
                if text:
                    fh.write(text + "\n")
                else:
                    fh.write("\n")
    else:
        absolute.touch(exist_ok=True)

    if task.run_log_path is None:
        task.run_log_path = relative

    return absolute, relative, created


def append_run_output(
    task: Task,
    *,
    stdout: str = "",
    stderr: str = "",
    dataset_root: Optional[Path] = None,
) -> Tuple[Path, str, bool]:
    """Append captured stdout/stderr streams to the task run log."""

    created = False
    path: Optional[Path] = None
    relative: Optional[str] = None

    if stdout:
        path, relative, created_stdout = append_run_log(
            task,
            stdout.splitlines(),
            dataset_root,
            channel="stdout",
        )
        created = created or created_stdout

    if stderr:
        path, relative, created_stderr = append_run_log(
            task,
            stderr.splitlines(),
            dataset_root,
            channel="stderr",
        )
        created = created or created_stderr

    if path is None or relative is None:
        path, relative = resolve_run_log_path(task, dataset_root)
        path.parent.mkdir(parents=True, exist_ok=True)
        path.touch(exist_ok=True)
        if task.run_log_path is None:
            task.run_log_path = relative
            created = True

    return path, relative, created


def load_run_log_tail(
    task: Task,
    dataset_root: Optional[Path] = None,
    *,
    max_lines: int = 200,
) -> List[str]:
    """Return the last ``max_lines`` entries from the task run log."""

    if max_lines <= 0:
        return []
    if not task.run_log_path:
        return []

    absolute, _ = resolve_run_log_path(task, dataset_root)
    if not absolute.exists():
        return []

    tail: deque[str] = deque(maxlen=int(max_lines))
    with absolute.open("r", encoding="utf-8", errors="replace") as fh:
        for line in fh:
            tail.append(line.rstrip("\n"))
    return list(tail)


def append_task(task: Task) -> None:
    """Append a task entry to ``tasks.jsonl``."""

    _append_jsonl(TASKS_FILE, task.to_dict())


def update_task(task_id: str, **changes: Any) -> Task:
    """Apply updates to a task entry and rewrite the dataset atomically.

    Args:
        task_id: Identifier of the task to update.
        **changes: Key/value pairs to merge into the stored representation.

    Returns:
        The updated :class:`Task` instance.

    Raises:
        ValueError: If the task identifier does not exist.
    """

    records = _read_jsonl(TASKS_FILE)
    updated_record: Optional[Dict[str, Any]] = None
    for record in records:
        if record.get("id") == task_id:
            record.update(changes)
            updated_record = record
            break
    if updated_record is None:
        raise ValueError(f"Task '{task_id}' does not exist")
    _write_jsonl_atomic(TASKS_FILE, records)
    return Task.from_dict(updated_record)


def append_event(event: TaskEvent) -> None:
    """Append a task event to ``task_events.jsonl``."""

    _append_jsonl(EVENTS_FILE, event.to_dict())
```

Task data models and JSONL persistence helpers.

This module provides dataclasses that model Codex tasks and helper
functions to persist them in append-only datasets housed under
``datasets/``. The APIs keep the on-disk format aligned with the
specification documented in ``concepts/dev_logic/Task System.md``.
**Classes:** TaskDiffSummary, Task, TaskEvent, DiffSnapshot, ErrorRecord
**Functions:** _ensure_datasets_dir(), _append_jsonl(path, payload), _read_jsonl(path), _write_jsonl_atomic(path, records), _dataset_root(candidate), append_error_record(record), resolve_run_log_path(task, dataset_root), append_run_log(task, lines, dataset_root), append_run_output(task), load_run_log_tail(task, dataset_root), append_task(task), update_task(task_id), append_event(event)


## Module `tasks\panel.py`

```python
from __future__ import annotations

from dataclasses import dataclass
from datetime import datetime
import json
from pathlib import Path
from typing import Iterable, List, Optional

from PySide6.QtCore import Qt, Signal
from PySide6.QtGui import QColor, QFont, QPalette
from PySide6.QtWidgets import (
    QAbstractItemView,
    QComboBox,
    QDockWidget,
    QFrame,
    QHBoxLayout,
    QLabel,
    QLineEdit,
    QListWidget,
    QListWidgetItem,
    QPushButton,
    QSizePolicy,
    QSpacerItem,
    QVBoxLayout,
    QWidget,
    QPlainTextEdit,
)

from .models import TASKS_FILE, Task, load_run_log_tail


STATUS_ORDER = [
    "all",
    "open",
    "merged",
    "closed",
    "cancelled",
    "failed",
    "deleted",
]


@dataclass(slots=True)
class _TaskRowData:
    task: Task
    matches_filter: bool = True


class _StatusPill(QLabel):
    """High-contrast badge representing a task status."""

    _PILL_STYLES = {
        "open": ("#1b8a5a", "#ffffff"),
        "merged": ("#6f42c1", "#ffffff"),
        "closed": ("#c0392b", "#ffffff"),
        "cancelled": ("#475061", "#ffffff"),
    }

    _TEXT_STYLES = {
        "failed": "#ff6b6b",
        "deleted": "#96a3bb",
    }

    def __init__(self, status: str, parent: Optional[QWidget] = None) -> None:
        super().__init__(parent)
        status_key = status.lower()
        font = QFont("Segoe UI", 9)
        font.setBold(True)
        self.setFont(font)
        if status_key in self._PILL_STYLES:
            bg, fg = self._PILL_STYLES[status_key]
            self.setText(status.capitalize())
            self.setStyleSheet(
                (
                    "QLabel{{padding:2px 8px;border-radius:8px;font-weight:600;"
                    "background:{bg};color:{fg};border:1px solid #0b1524;}}"
                ).format(bg=bg, fg=fg)
            )
        else:
            color = self._TEXT_STYLES.get(status_key, "#e9f3ff")
            self.setText(status.capitalize())
            self.setStyleSheet(
                (
                    "QLabel{{padding:0px;font-weight:600;"
                    "color:{color};background:transparent;}}"
                ).format(color=color)
            )


class _TaskRowWidget(QWidget):
    """Widget rendered inside the list view for each task."""

    def __init__(self, task: Task, parent: Optional[QWidget] = None) -> None:
        super().__init__(parent)
        self.task = task
        layout = QHBoxLayout(self)
        layout.setContentsMargins(8, 4, 8, 4)
        layout.setSpacing(10)

        self.pill = _StatusPill(task.status, self)
        layout.addWidget(self.pill)

        self.title = QLabel(task.title, self)
        self.title.setStyleSheet("color:#e9f3ff;font:600 10pt 'Segoe UI';")
        self.title.setWordWrap(True)
        layout.addWidget(self.title, 1)

        diff_text = _format_diff(task)
        self.diff = QLabel(diff_text, self)
        self.diff.setStyleSheet("color:#bcd5ff;font:500 9pt 'Segoe UI';")
        layout.addWidget(self.diff)

        ts_label = QLabel(_format_timestamp(task.updated_ts), self)
        ts_label.setStyleSheet("color:#8ea4c9;font:500 9pt 'Segoe UI';")
        layout.addWidget(ts_label)

        self.setAutoFillBackground(True)
        palette = self.palette()
        bg = QColor("#0c1320")
        palette.setColor(QPalette.Window, bg)
        self.setPalette(palette)


def _format_diff(task: Task) -> str:
    added = task.diffs.added if task.diffs else 0
    removed = task.diffs.removed if task.diffs else 0
    return f"+{added} \u2212{removed}"


def _format_timestamp(ts: float) -> str:
    try:
        dt = datetime.fromtimestamp(float(ts))
    except (TypeError, ValueError, OSError):
        return "--"
    return dt.strftime("%Y-%m-%d %H:%M")


class TaskPanel(QDockWidget):
    """Dockable Tasks panel shared by Terminal and Virtual Desktop."""

    task_selected = Signal(str)
    new_taskRequested = Signal(str)
    status_changed = Signal(str, str)
    load_conversationRequested = Signal(str, str)

    def __init__(self, dataset_path: str | Path | None = None, parent: Optional[QWidget] = None) -> None:
        super().__init__("Tasks", parent)
        self.setObjectName("TaskPanelDock")
        self.setAllowedAreas(Qt.LeftDockWidgetArea | Qt.RightDockWidgetArea)
        self.setFeatures(QDockWidget.DockWidgetMovable | QDockWidget.DockWidgetClosable)
        self.dataset_path = Path(dataset_path) if dataset_path else TASKS_FILE
        self._dataset_root = self.dataset_path.parent
        self._tasks: List[_TaskRowData] = []
        self._selected_task: Optional[Task] = None
        self._log_placeholder = "No run log entries yet."
        self._active_conversation_id: Optional[str] = None
        self._build_ui()
        self.refresh()

    # ------------------------------------------------------------------
    def _build_ui(self) -> None:
        container = QWidget(self)
        container.setObjectName("TaskPanelContainer")
        layout = QVBoxLayout(container)
        layout.setContentsMargins(12, 12, 12, 12)
        layout.setSpacing(12)

        header = QHBoxLayout()
        header.setSpacing(8)
        self.filter_combo = QComboBox(container)
        self.filter_combo.addItems([status.capitalize() for status in STATUS_ORDER])
        self.filter_combo.currentIndexChanged.connect(self._apply_filters)
        self.filter_combo.setStyleSheet(
            "QComboBox{background:#0a111e;color:#eaf2ff;border:1px solid #1d2b3c;"
            "border-radius:6px;padding:4px 8px;}"
            "QComboBox QAbstractItemView{background:#0b1624;color:#eaf2ff;}"
        )
        header.addWidget(self.filter_combo)

        self.search_edit = QLineEdit(container)
        self.search_edit.setPlaceholderText("Search tasks…")
        self.search_edit.textChanged.connect(self._apply_filters)
        self.search_edit.setStyleSheet(
            "QLineEdit{background:#0b1624;color:#e9f3ff;border:1px solid #203040;"
            "border-radius:6px;padding:6px 10px;font:10pt 'Segoe UI';}"
            "QLineEdit:focus{border:1px solid #2f72ff;}"
        )
        header.addWidget(self.search_edit, 1)

        layout.addLayout(header)

        self.list = QListWidget(container)
        self.list.setSelectionMode(QAbstractItemView.SingleSelection)
        self.list.itemSelectionChanged.connect(self._on_item_selected)
        self.list.setUniformItemSizes(False)
        self.list.setSpacing(4)
        self.list.setStyleSheet(
            "QListWidget{background:#0c1320;color:#e9f3ff;border:1px solid #1f2b3a;"
            "border-radius:8px;padding:4px;}"
            "QListWidget::item{margin:2px;padding:2px;border-radius:6px;}"
            "QListWidget::item:selected{background:#1f3a5b;}"
        )
        layout.addWidget(self.list, 1)

        self.detail = QFrame(container)
        self.detail.setFrameShape(QFrame.StyledPanel)
        self.detail.setObjectName("TaskDetailPopover")
        self.detail.setStyleSheet(
            "QFrame#TaskDetailPopover{background:#0b1624;border:1px solid #25405f;"
            "border-radius:10px;}"
        )
        detail_layout = QVBoxLayout(self.detail)
        detail_layout.setContentsMargins(12, 12, 12, 12)
        detail_layout.setSpacing(8)

        self.detail_title = QLabel("Select a task to view details", self.detail)
        self.detail_title.setStyleSheet("color:#eaf2ff;font:600 11pt 'Segoe UI';")
        self.detail_title.setWordWrap(True)
        detail_layout.addWidget(self.detail_title)

        status_row = QHBoxLayout()
        status_row.setSpacing(6)
        status_label = QLabel("Status:", self.detail)
        status_label.setStyleSheet("color:#bcd5ff;font:500 9pt 'Segoe UI';")
        status_row.addWidget(status_label)

        self.status_combo = QComboBox(self.detail)
        for status in STATUS_ORDER[1:]:
            self.status_combo.addItem(status.capitalize(), status)
        self.status_combo.setStyleSheet(
            "QComboBox{background:#0a111e;color:#eaf2ff;border:1px solid #1d2b3c;"
            "border-radius:6px;padding:4px 8px;}"
            "QComboBox QAbstractItemView{background:#0b1624;color:#eaf2ff;}"
        )
        status_row.addWidget(self.status_combo, 1)

        self.status_apply = QPushButton("Update", self.detail)
        self.status_apply.clicked.connect(self._emit_status_change)
        self.status_apply.setStyleSheet(
            "QPushButton{background:#1E5AFF;color:#ffffff;border-radius:6px;"
            "padding:6px 12px;border:1px solid #1b3b73;font-weight:600;}"
            "QPushButton:hover{background:#2f72ff;}"
        )
        status_row.addWidget(self.status_apply)
        detail_layout.addLayout(status_row)

        self.detail_diff = QLabel("+0 \u22120", self.detail)
        self.detail_diff.setStyleSheet("color:#bcd5ff;font:500 9pt 'Segoe UI';")
        detail_layout.addWidget(self.detail_diff)

        self.detail_timestamps = QLabel("--", self.detail)
        self.detail_timestamps.setStyleSheet("color:#8ea4c9;font:500 9pt 'Segoe UI';")
        self.detail_timestamps.setWordWrap(True)
        detail_layout.addWidget(self.detail_timestamps)

        self.detail_labels = QLabel("", self.detail)
        self.detail_labels.setStyleSheet("color:#8ea4c9;font:500 9pt 'Segoe UI';")
        self.detail_labels.setWordWrap(True)
        detail_layout.addWidget(self.detail_labels)

        self.detail_log_label = QLabel("Run log", self.detail)
        self.detail_log_label.setStyleSheet("color:#bcd5ff;font:600 9pt 'Segoe UI';")
        detail_layout.addWidget(self.detail_log_label)

        self.detail_log = QPlainTextEdit(self.detail)
        self.detail_log.setReadOnly(True)
        self.detail_log.setLineWrapMode(QPlainTextEdit.NoWrap)
        self.detail_log.setFont(QFont("Consolas", 9))
        self.detail_log.setStyleSheet(
            "QPlainTextEdit{background:#07101c;color:#e9f3ff;border:1px solid #203040;"
            "border-radius:6px;padding:8px;}"
        )
        self.detail_log.setFixedHeight(160)
        self.detail_log.setPlainText(self._log_placeholder)
        detail_layout.addWidget(self.detail_log)

        self.load_conversation_btn = QPushButton("Load Conversation", self.detail)
        self.load_conversation_btn.setEnabled(False)
        self.load_conversation_btn.setStyleSheet(
            "QPushButton{background:#1E5AFF;color:#ffffff;border-radius:6px;"
            "padding:6px 12px;border:1px solid #1b3b73;font-weight:600;}"
            "QPushButton:hover{background:#2f72ff;}"
            "QPushButton:disabled{background:#1b2c44;color:#6c7a96;border:1px solid #1b2c44;}"
        )
        self.load_conversation_btn.clicked.connect(self._emit_load_conversation)
        detail_layout.addWidget(self.load_conversation_btn, 0, Qt.AlignLeft)

        layout.addWidget(self.detail)

        footer = QHBoxLayout()
        footer.setSpacing(8)
        self.new_task_input = QLineEdit(container)
        self.new_task_input.setPlaceholderText("Create new task…")
        self.new_task_input.returnPressed.connect(self._on_new_task_requested)
        self.new_task_input.setStyleSheet(
            "QLineEdit{background:#0b1624;color:#e9f3ff;border:1px solid #203040;"
            "border-radius:6px;padding:6px 10px;font:10pt 'Segoe UI';}"
            "QLineEdit:focus{border:1px solid #2f72ff;}"
        )
        footer.addWidget(self.new_task_input, 1)
        footer.addItem(QSpacerItem(12, 1, QSizePolicy.Fixed, QSizePolicy.Minimum))
        layout.addLayout(footer)

        container.setLayout(layout)
        self.setWidget(container)

        apply_palette(container)
        apply_palette(self.list)
        apply_palette(self.detail)
        apply_palette(self.new_task_input)
        apply_palette(self.search_edit)

    # ------------------------------------------------------------------
    def refresh(self) -> None:
        """Reload tasks from the dataset path."""
        if not self.dataset_path.exists():
            self._tasks = []
            self._apply_filters()
            return
        records: List[Task] = []
        with self.dataset_path.open("r", encoding="utf-8") as fh:
            for line in fh:
                line = line.strip()
                if not line:
                    continue
                try:
                    payload = json.loads(line)
                    records.append(Task.from_dict(payload))
                except json.JSONDecodeError:
                    continue
        self.set_tasks(records)

    # ------------------------------------------------------------------
    def set_tasks(self, tasks: Iterable[Task]) -> None:
        self._tasks = [_TaskRowData(task=task) for task in tasks]
        self._apply_filters()

    # ------------------------------------------------------------------
    def update_task(self, task: Task) -> None:
        for row in self._tasks:
            if row.task.id == task.id:
                row.task = task
                break
        else:
            self._tasks.append(_TaskRowData(task=task))
        self._apply_filters(preserve_selection=True)

    # ------------------------------------------------------------------
    def _apply_filters(self, preserve_selection: bool = False) -> None:
        search_text = self.search_edit.text().strip().lower()
        status_filter = STATUS_ORDER[self.filter_combo.currentIndex()]
        selected_id = self._selected_task.id if (preserve_selection and self._selected_task) else None

        self.list.blockSignals(True)
        self.list.clear()
        matched_task: Optional[Task] = None

        for row in self._tasks:
            task = row.task
            matches_status = status_filter == "all" or task.status.lower() == status_filter
            matches_search = not search_text or (
                search_text in task.title.lower()
                or search_text in task.id.lower()
                or any(search_text in label.lower() for label in task.labels)
            )
            row.matches_filter = matches_status and matches_search
            if not row.matches_filter:
                continue
            item = QListWidgetItem(self.list)
            item.setData(Qt.UserRole, task.id)
            widget = _TaskRowWidget(task, self.list)
            self.list.addItem(item)
            self.list.setItemWidget(item, widget)
            if selected_id and task.id == selected_id:
                item.setSelected(True)
                matched_task = task

        self.list.blockSignals(False)
        if not preserve_selection or not matched_task:
            self._selected_task = None
            self.detail_title.setText("Select a task to view details")
            self.status_combo.blockSignals(True)
            self.status_combo.setCurrentIndex(0)
            self.status_combo.blockSignals(False)
            self.detail_diff.setText("+0 \u22120")
            self.detail_timestamps.setText("--")
            self.detail_labels.setText("")
            self._update_log_view(None)
            self._update_conversation_button(None)
        else:
            self._selected_task = matched_task
            self._populate_detail(matched_task)

    # ------------------------------------------------------------------
    def _on_item_selected(self) -> None:
        items = self.list.selectedItems()
        if not items:
            self._selected_task = None
            self._apply_filters()
            return
        task_id = items[0].data(Qt.UserRole)
        for row in self._tasks:
            if row.task.id == task_id:
                self._selected_task = row.task
                self._populate_detail(row.task)
                self.task_selected.emit(row.task.id)
                break

    # ------------------------------------------------------------------
    def _populate_detail(self, task: Task) -> None:
        self.detail_title.setText(task.title)
        status_index = self.status_combo.findData(task.status)
        self.status_combo.blockSignals(True)
        if status_index >= 0:
            self.status_combo.setCurrentIndex(status_index)
        else:
            self.status_combo.setCurrentIndex(0)
        self.status_combo.blockSignals(False)
        self.detail_diff.setText(_format_diff(task))
        created = _format_timestamp(task.created_ts)
        updated = _format_timestamp(task.updated_ts)
        self.detail_timestamps.setText(f"Created: {created}\nUpdated: {updated}")
        if task.labels:
            labels = ", ".join(task.labels)
            self.detail_labels.setText(f"Labels: {labels}")
        else:
            self.detail_labels.setText("")
        self._update_log_view(task)
        self._update_conversation_button(task)

    # ------------------------------------------------------------------
    def _emit_status_change(self) -> None:
        if not self._selected_task:
            return
        status = self.status_combo.currentData()
        if not status or status == self._selected_task.status:
            return
        self.status_changed.emit(self._selected_task.id, status)

    # ------------------------------------------------------------------
    def _on_new_task_requested(self) -> None:
        text = self.new_task_input.text().strip()
        if not text:
            return
        self.new_taskRequested.emit(text)
        self.new_task_input.clear()


    def _update_log_view(self, task: Optional[Task]) -> None:
        if not hasattr(self, "detail_log"):
            return
        if task is None:
            self.detail_log.setPlainText(self._log_placeholder)
            return
        lines = load_run_log_tail(task, self._dataset_root, max_lines=200)
        if lines:
            self.detail_log.setPlainText("\n".join(lines))
        else:
            self.detail_log.setPlainText(self._log_placeholder)
        scrollbar = self.detail_log.verticalScrollBar()
        if scrollbar:
            scrollbar.setValue(scrollbar.maximum())

    def _update_conversation_button(self, task: Optional[Task]) -> None:
        if not hasattr(self, "load_conversation_btn"):
            return
        identifier: Optional[str] = None
        if task is not None:
            cid = (task.codex_conversation_id or "").strip()
            identifier = cid or (task.session_id or "").strip()
        self._active_conversation_id = identifier or None
        if identifier:
            self.load_conversation_btn.setEnabled(True)
            self.load_conversation_btn.setToolTip("Load the linked Codex transcript into the chat window.")
        else:
            self.load_conversation_btn.setEnabled(False)
            self.load_conversation_btn.setToolTip("No linked Codex conversation for this task.")

    def _emit_load_conversation(self) -> None:
        if not self._selected_task or not self._active_conversation_id:
            return
        self.load_conversationRequested.emit(self._selected_task.id, self._active_conversation_id)


def apply_palette(widget: QWidget) -> None:
    """Apply the high-contrast palette to the given widget."""

    palette = widget.palette()
    bg = QColor("#0c1320")
    fg = QColor("#e9f3ff")
    for group in (QPalette.Active, QPalette.Inactive, QPalette.Disabled):
        palette.setColor(group, QPalette.Window, bg)
        palette.setColor(group, QPalette.WindowText, fg)
        palette.setColor(group, QPalette.Base, QColor("#0b1624"))
        palette.setColor(group, QPalette.Text, fg)
        palette.setColor(group, QPalette.Button, QColor("#1E5AFF"))
        palette.setColor(group, QPalette.ButtonText, QColor("#ffffff"))
        palette.setColor(group, QPalette.Highlight, QColor("#1f3a5b"))
        palette.setColor(group, QPalette.HighlightedText, QColor("#ffffff"))
    widget.setPalette(palette)
```

**Classes:** _TaskRowData, _StatusPill, _TaskRowWidget, TaskPanel
**Functions:** _format_diff(task), _format_timestamp(ts), apply_palette(widget)


## Module `tasks\task_panel.py`

```python
"""Compatibility shim for legacy imports."""

from .panel import TaskPanel, apply_palette

__all__ = ["TaskPanel", "apply_palette"]
```

Compatibility shim for legacy imports.


## Module `tasks\__init__.py`

```python
"""Task system public exports."""

from .bus import Subscription, publish, subscribe
from .diffs import record_diff
from .models import (
    DiffSnapshot,
    Task,
    TaskEvent,
    append_event,
    append_task,
    update_task,
)

__all__ = [
    "Task", 
    "TaskEvent",
    "DiffSnapshot",
    "append_task",
    "append_event",
    "update_task",
    "record_diff",
    "publish",
    "subscribe",
    "Subscription",
]
```

Task system public exports.


## Module `tests\conftest.py`

```python
import os
import tempfile
import shutil
import pytest

_TEST_WORKSPACE = tempfile.mkdtemp(prefix="codex_workspace_")
os.environ["CODEX_WORKSPACE"] = _TEST_WORKSPACE


@pytest.fixture(scope="session", autouse=True)
def _cleanup_workspace():
    yield
    shutil.rmtree(_TEST_WORKSPACE, ignore_errors=True)
```

**Functions:** _cleanup_workspace()


## Module `tests\test_chat_input_repo_reference.py`

```python
from __future__ import annotations

import os
from pathlib import Path

import pytest

pytest.importorskip("PySide6")

from PySide6.QtCore import Qt, QEvent, QObject, Signal
from PySide6.QtGui import QKeyEvent, QTextCursor
from PySide6.QtWidgets import QApplication, QWidget

from Codex_Terminal import ChatInput
from repo_reference_helper import RepoReference


class StubCard:
    def __init__(self, workspace: Path):
        self.workspace = workspace

    def _convert_to_png(self, path: Path) -> Path:
        return path


@pytest.fixture
def qt_app():
    app = QApplication.instance()
    if app is None:
        app = QApplication([])
    return app


class DummyHelper(QObject):
    refreshed = Signal()

    def __init__(self, reference: RepoReference):
        super().__init__()
        self._reference = reference

    def suggestions(self, query: str, limit: int = 5):
        return [self._reference]

    def refresh(self) -> None:  # pragma: no cover - not exercised in test
        pass


def test_chat_input_tab_accepts_repo_reference(qt_app):
    workspace = Path(os.environ["CODEX_WORKSPACE"])
    parent = QWidget()
    card = StubCard(workspace)
    input_widget = ChatInput(card, parent)

    # Swap the repo helper for a deterministic stub
    original_helper = input_widget._repo_helper
    original_helper.deleteLater()
    reference = RepoReference(workspace / "docs" / "index.md", "docs/index.md", "file")
    dummy_helper = DummyHelper(reference)
    input_widget._repo_helper = dummy_helper
    dummy_helper.refreshed.connect(input_widget._handle_repo_refresh)

    captured = []
    input_widget.referenceAccepted.connect(lambda payload: captured.append(payload))

    input_widget.setPlainText("docs/in")
    cursor = input_widget.textCursor()
    cursor.movePosition(QTextCursor.End)
    input_widget.setTextCursor(cursor)
    input_widget._update_suggestions()
    qt_app.processEvents()

    event = QKeyEvent(QEvent.KeyPress, Qt.Key_Tab, Qt.NoModifier)
    QApplication.sendEvent(input_widget, event)
    qt_app.processEvents()

    assert input_widget.toPlainText() == "docs/index.md"
    assert captured == [{"path": "docs/index.md", "type": "file"}]
    refs = input_widget.consume_references()
    assert refs == [{"path": "docs/index.md", "type": "file"}]
    assert not input_widget._suggestion_popup.isVisible()

    # Ensure references clear after consumption
    assert input_widget.consume_references() == []
```

**Classes:** StubCard, DummyHelper
**Functions:** qt_app(), test_chat_input_tab_accepts_repo_reference(qt_app)


## Module `tests\test_codex_approval_prompts.py`

```python
import types

import pytest
from PySide6.QtWidgets import QApplication

import Codex_Terminal as sct


@pytest.fixture(scope="module")
def qapp():
    app = QApplication.instance()
    if app is None:
        app = QApplication([])
    return app


def test_parse_single_prompt_block():
    delta = (
        "Allow command?\n\n"
        "> rm -rf temp\n"
        "[y] Yes\n"
        "[n] No\n"
        "[a] Always allow\n"
    )
    events = sct.ChatCard._parse_codex_approval_events(delta)
    assert len(events) == 1
    prompt_event = events[0]
    assert prompt_event.kind == "prompt"
    prompt = prompt_event.payload
    assert isinstance(prompt, sct.ApprovalPrompt)
    assert prompt.header == "Allow command?"
    assert "> rm -rf temp" in prompt.body
    assert prompt.options["yes"] == "y"
    assert prompt.options["no"] == "n"
    assert prompt.options["always"] == "a"


def test_parse_multiple_prompts_in_delta():
    delta = (
        "System ready.\n\n"
        "Allow command?\n> echo hi\n[y] Yes\n[n] No\n\n"
        "Approve and run this plan?\n- Step 1\n- Step 2\n(y) Yes\n(n) No\n"
    )
    events = sct.ChatCard._parse_codex_approval_events(delta)
    kinds = [evt.kind for evt in events]
    assert kinds == ["text", "prompt", "prompt"]
    assert events[0].payload.strip() == "System ready."


def test_parse_prompt_with_box_glyph_layout():
    delta = (
        "╭─ Allow Codex to run git status?\n"
        "│ Codex wants to run:\n"
        "│   git status\n"
        "│\n"
        "▌ Yes   Always allow   No   Provide feedback\n"
        "│  y     always        n    feedback\n"
        "╰─ Choose an option:\n"
    )
    events = sct.ChatCard._parse_codex_approval_events(delta)
    prompt_events = [evt for evt in events if evt.kind == "prompt"]
    assert prompt_events, "Expected at least one prompt event"
    prompt = prompt_events[0].payload
    assert isinstance(prompt, sct.ApprovalPrompt)
    assert prompt.header == "Allow Codex to run git status?"
    assert "Codex wants to run:" in prompt.body
    assert "git status" in prompt.body
    assert "Yes" not in prompt.body
    assert prompt.options["yes"] == "y"
    assert prompt.options["always"] == "always"
    assert prompt.options["no"] == "n"
    assert prompt.options["feedback"] == "feedback"


def test_parse_select_colon_prompt():
    delta = (
        "Select: Harden the Codex task event flow.\n"
        "> Should Codex mark action payloads with event metadata?\n"
        "[y] Yes — include codex_action_type.\n"
        "[n] No — leave current behavior.\n"
    )
    events = sct.ChatCard._parse_codex_approval_events(delta)
    prompt_events = [evt for evt in events if evt.kind == "prompt"]
    assert prompt_events, "Expected select header to produce a prompt"
    prompt = prompt_events[0].payload
    assert isinstance(prompt, sct.ApprovalPrompt)
    assert prompt.header.startswith("Select: Harden the Codex task event flow")
    assert prompt.options["yes"] == "y"
    assert prompt.options["no"] == "n"


def test_parse_falls_back_to_plain_text():
    delta = "No approval needed."
    events = sct.ChatCard._parse_codex_approval_events(delta)
    assert len(events) == 1
    evt = events[0]
    assert evt.kind == "text"
    assert evt.payload == "No approval needed."


def test_widget_sends_tokens_and_updates_status(qapp):
    prompt = sct.ApprovalPrompt(
        header="Allow command?",
        body="> dir",
        options={
            "yes": "y",
            "always": "always",
            "no": "n",
            "feedback": "feedback",
        },
    )
    captured = []

    def _capture(widget, action, token):
        captured.append((widget, action, token))

    widget = sct.ApprovalPromptWidget(sct.Theme(), prompt, _capture)
    widget._handle_click("yes")
    assert captured[0][1:] == ("yes", "y")
    widget.mark_submitted("yes")
    assert "Sent: Yes" in widget._status.text()
    assert not widget.is_active()


def test_dismissal_disables_buttons(qapp):
    prompt = sct.ApprovalPrompt(
        header="Approve edit?",
        body="Update file?",
        options=sct.DEFAULT_APPROVAL_TOKENS.copy(),
    )
    widget = sct.ApprovalPromptWidget(sct.Theme(), prompt, lambda *a: None)
    widget.mark_dismissed("Prompt dismissed.")
    assert widget._status.text() == "Prompt dismissed."
    assert not widget.is_active()


def test_handle_approval_decision_sends_token(qapp):
    events = []

    class DummyBridge:
        def __init__(self):
            self.pid = 1

        def running(self):
            return True

        def send_text(self, token):
            events.append(("send_text", token))
            return True

        def press_enter_async(self, hwnd):
            events.append(("enter", hwnd))

    view = types.SimpleNamespace(
        append_message=lambda *a, **k: events.append(("view", a, k))
    )
    led_signal = types.SimpleNamespace(
        emit=lambda state: events.append(("led", state))
    )
    dummy = types.SimpleNamespace(
        bridge=DummyBridge(),
        view=view,
        codex_led_signal=led_signal,
        _codex_status=lambda msg: events.append(("status", msg)),
        _ui_hwnd=lambda: 0,
    )

    prompt = sct.ApprovalPrompt(
        header="Allow command?",
        body="",
        options=sct.DEFAULT_APPROVAL_TOKENS.copy(),
    )
    widget = sct.ApprovalPromptWidget(sct.Theme(), prompt, lambda *a: None)

    sct.ChatCard._handle_approval_decision(dummy, widget, "yes", "y")

    assert ("send_text", "y") in events
    assert any(ev for ev in events if ev == ("led", "yellow"))
    assert any("Approval → Yes" in ev[1] for ev in events if ev[0] == "status")
    assert not widget.is_active()
```

**Functions:** qapp(), test_parse_single_prompt_block(), test_parse_multiple_prompts_in_delta(), test_parse_prompt_with_box_glyph_layout(), test_parse_select_colon_prompt(), test_parse_falls_back_to_plain_text(), test_widget_sends_tokens_and_updates_status(qapp), test_dismissal_disables_buttons(qapp), test_handle_approval_decision_sends_token(qapp)


## Module `tests\test_codex_terminal_embedding.py`

```python
import copy
import tempfile
from pathlib import Path

from PySide6.QtWidgets import QApplication

import Codex_Terminal as sct


def _ensure_app():
    app = QApplication.instance()
    if app is None:
        app = QApplication([])
    return app


def _patch_transit(monkeypatch, target, settings_path=None):
    def _transit_dir():
        target.mkdir(parents=True, exist_ok=True)
        return target

    monkeypatch.setattr(sct, "transit_dir", _transit_dir)
    monkeypatch.setattr(sct, "_legacy_transit_candidates", lambda: [])
    if settings_path is not None:
        monkeypatch.setattr(sct, "SETTINGS_JSON", settings_path)


def test_embedded_build_widget_uses_chat_card(monkeypatch, tmp_path):
    _ensure_app()
    monkeypatch.setattr(sct.OllamaClient, "health", lambda self: (True, "OK"))
    target = tmp_path / "Terminal Desktop"
    _patch_transit(monkeypatch, target, tmp_path / "settings.json")

    window, _ = sct.build_widget(embedded=True)
    try:
        central = window.centralWidget()
        assert isinstance(central, sct.ChatCard)
        assert central is window.chat
        assert window.desktop is None
    finally:
        window.close()


def test_standalone_build_widget_creates_terminal_desktop_dir(
    monkeypatch, tmp_path,
):
    _ensure_app()
    monkeypatch.setattr(sct.OllamaClient, "health", lambda self: (True, "OK"))

    target = tmp_path / "Terminal Desktop"
    _patch_transit(monkeypatch, target, tmp_path / "settings.json")

    window, _ = sct.build_widget(embedded=False)
    try:
        assert target.exists() and target.is_dir()
        central = window.centralWidget()
        assert isinstance(central, sct.TerminalDesktop)
    finally:
        window.close()


def test_terminal_desktop_first_run_centers_proxy(monkeypatch):
    app = _ensure_app()
    monkeypatch.setattr(sct.OllamaClient, "health", lambda self: (True, "OK"))
    target = Path(tempfile.mkdtemp()) / "Terminal Desktop"
    settings_path = target.parent / "settings.json"
    _patch_transit(monkeypatch, target, settings_path)

    initial_settings = copy.deepcopy(sct.DEFAULT_SETTINGS)
    initial_settings["terminal_desktop"] = {
        "width": 980,
        "height": 620,
        "x": -1,
        "y": -1,
    }

    monkeypatch.setattr(sct, "load_codex_settings", lambda: initial_settings)

    saved = []

    def _capture(settings):
        saved.append(copy.deepcopy(settings))
        initial_settings.update(settings)

    monkeypatch.setattr(sct, "save_codex_settings", _capture)

    window, _ = sct.build_widget(embedded=False)
    try:
        window.show()
        desktop = window.desktop
        assert isinstance(desktop, sct.TerminalDesktop)

        for _ in range(50):
            app.processEvents()
            if desktop.canvas.width() > 0 and desktop.canvas.height() > 0:
                break
        else:
            raise AssertionError("canvas size did not initialize")

        for _ in range(10):
            app.processEvents()

        geom = desktop.proxy.geometry()
        canvas_w = desktop.canvas.width()
        canvas_h = desktop.canvas.height()
        assert canvas_w > 0 and canvas_h > 0

        expected_x = max(0, (canvas_w - geom.width()) // 2)
        expected_y = max(0, (canvas_h - geom.height()) // 2)
        assert geom.x() == expected_x
        assert geom.y() == expected_y

        assert saved
        persisted = saved[-1]["terminal_desktop"]
        assert persisted["x"] == expected_x
        assert persisted["y"] == expected_y
    finally:
        window.close()
```

**Functions:** _ensure_app(), _patch_transit(monkeypatch, target, settings_path), test_embedded_build_widget_uses_chat_card(monkeypatch, tmp_path), test_standalone_build_widget_creates_terminal_desktop_dir(monkeypatch, tmp_path), test_terminal_desktop_first_run_centers_proxy(monkeypatch)


## Module `tests\test_codex_terminal_run_checked.py`

```python
import json
import subprocess
import sys
from collections import defaultdict
from pathlib import Path
from typing import List, Tuple

import pytest

from Codex_Terminal import run_checked
from tasks import diffs as task_diffs
from tasks import models as task_models
from tasks.bus import subscribe
from tasks.models import Task, append_task


@pytest.fixture(autouse=True)
def _isolate_datasets(tmp_path: Path, monkeypatch: pytest.MonkeyPatch):
    dataset_root = tmp_path / "datasets"
    replacements = {
        "DATASETS_DIR": dataset_root,
        "TASKS_FILE": dataset_root / "tasks.jsonl",
        "EVENTS_FILE": dataset_root / "task_events.jsonl",
        "DIFFS_FILE": dataset_root / "diffs.jsonl",
    }
    for attr, value in replacements.items():
        monkeypatch.setattr(task_models, attr, value, raising=False)

    diff_replacements = {
        "DATASETS_DIR": dataset_root,
        "DIFFS_FILE": dataset_root / "diffs.jsonl",
        "_SNAPSHOT_ROOT": dataset_root / "runs",
    }
    for attr, value in diff_replacements.items():
        monkeypatch.setattr(task_diffs, attr, value, raising=False)

    yield


@pytest.fixture(autouse=True)
def _reset_bus(monkeypatch: pytest.MonkeyPatch):
    from tasks import bus

    fresh = defaultdict(list)
    monkeypatch.setattr(bus, "_SUBSCRIBERS", fresh, raising=False)
    yield
    monkeypatch.setattr(bus, "_SUBSCRIBERS", defaultdict(list), raising=False)


def _read_jsonl(path: Path) -> List[dict]:
    if not path.exists():
        return []
    contents = path.read_text(encoding="utf-8")
    lines = (line for line in contents.splitlines() if line)
    return [json.loads(line) for line in lines]


def _init_repo(repo: Path) -> None:
    repo.mkdir()
    subprocess.run(
        ["git", "init"],
        cwd=repo,
        check=True,
        stdout=subprocess.PIPE,
    )
    subprocess.run(
        ["git", "config", "user.email", "codex@example.com"],
        cwd=repo,
        check=True,
    )
    subprocess.run(
        ["git", "config", "user.name", "Codex"],
        cwd=repo,
        check=True,
    )
    sample = repo / "sample.txt"
    sample.write_text("alpha\nbeta\n", encoding="utf-8")
    subprocess.run(["git", "add", "sample.txt"], cwd=repo, check=True)
    subprocess.run(["git", "commit", "-m", "init"], cwd=repo, check=True)


def _make_task(task_id: str) -> Task:
    task = Task(
        id=task_id,
        title="Task",
        status="open",
        created_ts=1.0,
        updated_ts=1.0,
        session_id="sess",
        source="terminal",
    )
    append_task(task)
    return task


def test_run_checked_marks_task_merged_on_success(tmp_path: Path):
    repo = tmp_path / "repo"
    _init_repo(repo)
    task = _make_task("tsk_merge")

    events: List[Tuple[str, dict]] = []
    handle_status = subscribe(
        "task.status",
        lambda payload: events.append(("task.status", payload)),
    )
    handle_update = subscribe(
        "task.updated",
        lambda payload: events.append(("task.updated", payload)),
    )
    try:
        script = (
            "from pathlib import Path\n"
            "p = Path('sample.txt')\n"
            "p.write_text(p.read_text() + 'gamma\\n')\n"
        )
        cmd = [sys.executable, "-c", script]
        rc, _, _ = run_checked(cmd, cwd=repo, task=task)
    finally:
        handle_status.unsubscribe()
        handle_update.unsubscribe()

    assert rc == 0

    records = _read_jsonl(task_models.TASKS_FILE)
    stored = next(item for item in records if item["id"] == task.id)
    assert stored["status"] == "merged"
    assert stored["diffs"]["added"] >= 1

    status_events = [
        item
        for item in _read_jsonl(task_models.EVENTS_FILE)
        if item.get("event") == "status" and item.get("task_id") == task.id
    ]
    assert status_events and status_events[-1]["to"] == "merged"
    assert status_events[-1]["data"]["exit_code"] == 0

    assert any(topic == "task.status" for topic, _ in events)
    assert any(topic == "task.updated" for topic, _ in events)


def test_run_checked_marks_task_failed_on_nonzero_exit(tmp_path: Path):
    repo = tmp_path / "repo"
    _init_repo(repo)
    task = _make_task("tsk_fail")

    events: List[Tuple[str, dict]] = []
    handle_status = subscribe(
        "task.status",
        lambda payload: events.append(("task.status", payload)),
    )
    handle_update = subscribe(
        "task.updated",
        lambda payload: events.append(("task.updated", payload)),
    )
    try:
        cmd = [
            sys.executable,
            "-c",
            "import sys\n"
            "sys.exit(5)",
        ]
        rc, _, _ = run_checked(cmd, cwd=repo, task=task)
    finally:
        handle_status.unsubscribe()
        handle_update.unsubscribe()

    assert rc == 5

    records = _read_jsonl(task_models.TASKS_FILE)
    stored = next(item for item in records if item["id"] == task.id)
    assert stored["status"] == "failed"

    status_events = [
        item
        for item in _read_jsonl(task_models.EVENTS_FILE)
        if item.get("event") == "status" and item.get("task_id") == task.id
    ]
    assert status_events and status_events[-1]["to"] == "failed"
    assert status_events[-1]["data"]["exit_code"] == 5

    assert any(topic == "task.status" for topic, _ in events)
    assert any(topic == "task.updated" for topic, _ in events)


def test_run_checked_marks_task_cancelled_when_flagged(tmp_path: Path):
    repo = tmp_path / "repo"
    _init_repo(repo)
    task = _make_task("tsk_cancel")

    events: List[Tuple[str, dict]] = []
    handle_status = subscribe(
        "task.status",
        lambda payload: events.append(("task.status", payload)),
    )
    handle_update = subscribe(
        "task.updated",
        lambda payload: events.append(("task.updated", payload)),
    )
    try:
        cmd = [sys.executable, "-c", "print('cancelled run')"]
        rc, _, _ = run_checked(cmd, cwd=repo, task=task, cancelled=True)
    finally:
        handle_status.unsubscribe()
        handle_update.unsubscribe()

    assert rc == 0

    records = _read_jsonl(task_models.TASKS_FILE)
    stored = next(item for item in records if item["id"] == task.id)
    assert stored["status"] == "cancelled"

    status_events = [
        item
        for item in _read_jsonl(task_models.EVENTS_FILE)
        if item.get("event") == "status" and item.get("task_id") == task.id
    ]
    assert status_events and status_events[-1]["to"] == "cancelled"
    assert status_events[-1]["data"]["cancelled"] is True

    assert any(topic == "task.status" for topic, _ in events)
    assert any(topic == "task.updated" for topic, _ in events)


def test_run_checked_keeps_task_open_without_changes(tmp_path: Path):
    repo = tmp_path / "repo"
    _init_repo(repo)
    task = _make_task("tsk_open")

    events: List[Tuple[str, dict]] = []
    handle_status = subscribe(
        "task.status",
        lambda payload: events.append(("task.status", payload)),
    )
    handle_update = subscribe(
        "task.updated",
        lambda payload: events.append(("task.updated", payload)),
    )
    try:
        cmd = [sys.executable, "-c", "print('noop')"]
        rc, _, _ = run_checked(cmd, cwd=repo, task=task)
    finally:
        handle_status.unsubscribe()
        handle_update.unsubscribe()

    assert rc == 0

    records = _read_jsonl(task_models.TASKS_FILE)
    stored = next(item for item in records if item["id"] == task.id)
    assert stored["status"] == "open"

    status_events = [
        item
        for item in _read_jsonl(task_models.EVENTS_FILE)
        if item.get("event") == "status" and item.get("task_id") == task.id
    ]
    assert not status_events
    assert events == []
```

**Functions:** _isolate_datasets(tmp_path, monkeypatch), _reset_bus(monkeypatch), _read_jsonl(path), _init_repo(repo), _make_task(task_id), test_run_checked_marks_task_merged_on_success(tmp_path), test_run_checked_marks_task_failed_on_nonzero_exit(tmp_path), test_run_checked_marks_task_cancelled_when_flagged(tmp_path), test_run_checked_keeps_task_open_without_changes(tmp_path)


## Module `tests\test_conversation_retrieve.py`

```python
import json

from Codex_Terminal import ConversationIO


class DummyOllama:
    def embeddings(self, model, text):
        vec = [1.0, 0.0] if "hello" in text else [0.0, 1.0]
        return True, vec, ""


def test_conversation_jsonl_and_retrieve(tmp_path):
    archive_root = tmp_path / "archive"
    conv = ConversationIO(
        tmp_path,
        "dummy",
        DummyOllama(),
        True,
        session_token="session-a",
        archive_root=archive_root,
    )
    conv.append("user", "hello world", [])
    conv.append("assistant", "foo bar", [])
    data_path = tmp_path / "conversation.jsonl"
    vec_path = tmp_path / "conversation.vec"
    assert data_path.exists()
    lines = [
        json.loads(line)
        for line in data_path.read_text().splitlines()
    ]
    assert lines[0]["text"] == "hello world"
    assert vec_path.exists()
    res = conv.retrieve("hello", k=1)
    assert res and res[0]["text"] == "hello world"


def test_session_rollover_archives_logs(tmp_path):
    archive_root = tmp_path / "archive"
    conv_a = ConversationIO(
        tmp_path,
        "dummy",
        DummyOllama(),
        True,
        session_token="session-a",
        archive_root=archive_root,
    )
    conv_a.append("user", "hello world", [])
    assert (tmp_path / "conversation.jsonl").exists()

    conv_b = ConversationIO(
        tmp_path,
        "dummy",
        DummyOllama(),
        True,
        session_token="session-b",
        archive_root=archive_root,
    )

    archive_dirs = sorted(p for p in archive_root.iterdir() if p.is_dir())
    assert archive_dirs, "expected archived session"
    archived_jsonl = archive_dirs[0] / "conversation.jsonl"
    assert archived_jsonl.exists()
    archived_lines = [
        json.loads(line)
        for line in archived_jsonl.read_text().splitlines()
    ]
    assert archived_lines[0]["text"] == "hello world"
    meta = json.loads((archive_dirs[0] / "meta.json").read_text())
    assert meta["reason"] == "session-rollover"
    assert meta["entry_count"] == 1
    assert not conv_b.recent(1)


def test_length_threshold_archives_logs(tmp_path):
    archive_root = tmp_path / "archive"
    conv = ConversationIO(
        tmp_path,
        "dummy",
        DummyOllama(),
        True,
        session_token="session-threshold",
        archive_root=archive_root,
        max_entries=2,
        max_bytes=1_000_000,
    )
    conv.append("user", "first", [])
    conv.append("assistant", "second", [])
    conv.append("user", "third", [])

    archive_dirs = sorted(p for p in archive_root.iterdir() if p.is_dir())
    assert archive_dirs, "expected archive directory"
    archived_jsonl = archive_dirs[0] / "conversation.jsonl"
    archived_lines = [
        json.loads(line)
        for line in archived_jsonl.read_text().splitlines()
    ]
    assert len(archived_lines) == 2
    assert archived_lines[0]["text"] == "first"
    meta = json.loads((archive_dirs[0] / "meta.json").read_text())
    assert meta["reason"] == "length-threshold"

    remaining_lines = [
        json.loads(line)
        for line in (tmp_path / "conversation.jsonl").read_text().splitlines()
    ]
    assert len(remaining_lines) == 1
    assert remaining_lines[0]["text"] == "third"


def test_resolve_conversation_handles_live_and_archived(tmp_path):
    archive_root = tmp_path / "archive"
    conv = ConversationIO(
        tmp_path,
        "dummy",
        DummyOllama(),
        True,
        session_token="session-live",
        archive_root=archive_root,
    )
    conv.append("user", "hello", [])
    record_live = conv.resolve_conversation("session-live")
    assert record_live is not None
    assert record_live.source == "live"
    assert record_live.jsonl_path.exists()

    conv_archive = ConversationIO(
        tmp_path,
        "dummy",
        DummyOllama(),
        True,
        session_token="session-next",
        archive_root=archive_root,
    )
    record_archived = conv_archive.resolve_conversation("session-live")
    assert record_archived is not None
    assert record_archived.source == "archive"
    assert record_archived.jsonl_path.exists()
    assert record_archived.root.parent == archive_root
```

**Classes:** DummyOllama
**Functions:** test_conversation_jsonl_and_retrieve(tmp_path), test_session_rollover_archives_logs(tmp_path), test_length_threshold_archives_logs(tmp_path), test_resolve_conversation_handles_live_and_archived(tmp_path)


## Module `tests\test_editor_card.py`

```python
import json
import sys

from PySide6.QtWidgets import QApplication

from editor.card import CommandResult, EditorCard


def _ensure_app():
    app = QApplication.instance()
    if app is None:
        app = QApplication([])
    return app


def test_editor_card_generates_summaries(tmp_path):
    _ensure_app()
    document = tmp_path / "architecture.md"
    document.write_text(
        "Overview\n\n"
        "Intro paragraph.\n\n"
        "Section One\n\n"
        "Alpha body.\n\n"
        "Section Two:\n\n"
        "Beta body.\n",
        encoding="utf-8",
    )

    class StubClient:
        def __init__(self):
            self.calls = 0
            self.responses = [
                "- Overview summary",
                "- Alpha summary",
                "- Beta summary",
            ]

        def chat(self, model, messages, images=None):
            idx = min(self.calls, len(self.responses) - 1)
            response = self.responses[idx]
            self.calls += 1
            return True, response, ""

    card = EditorCard(initial_path=str(document), client=StubClient())
    card.summarize_document()

    assert card.segment_list.count() == 3
    assert card.report_output.toPlainText()

    card.segment_list.setCurrentRow(2)
    QApplication.processEvents()

    summary_text = card.segment_summary.toPlainText()
    assert "Beta summary" in summary_text

    cursor_line = card.editor.textCursor().blockNumber() + 1
    assert cursor_line == card._summaries[2].segment.start_line

    report_path = tmp_path / "architecture.logic-summary.md"
    assert report_path.exists()
    report = report_path.read_text(encoding="utf-8")
    assert "editor://architecture.md?line" in report


def test_editor_card_chat_and_notes(tmp_path):
    _ensure_app()
    document = tmp_path / "example.py"
    document.write_text("print('hi')\n", encoding="utf-8")

    card = EditorCard(
        initial_path=str(document),
        client=None,
        storage_root=tmp_path / "mem",
    )

    card.chat_input.setPlainText("Need help")
    card._send_chat_message()

    assert card.chat_log_path.exists()
    log_payload = [
        json.loads(line)
        for line in card.chat_log_path.read_text(encoding="utf-8").splitlines()
        if line
    ]
    assert log_payload and log_payload[0]["content"] == "Need help"

    card.editor.selectAll()
    card._pin_editor_selection()

    assert card.notes_path.exists()
    notes_data = json.loads(card.notes_path.read_text(encoding="utf-8"))
    assert isinstance(notes_data, list) and notes_data[0]["source"] == "editor"


def test_editor_card_highlights_run_errors(tmp_path):
    _ensure_app()
    script = tmp_path / "script.py"
    script.write_text("print('hi')\n", encoding="utf-8")

    card = EditorCard(initial_path=str(script), storage_root=tmp_path / "mem")
    card._prepare_run_output()

    stderr = f"{script}:1: RuntimeError"
    result = CommandResult(
        label="Run",
        command=[sys.executable, str(script)],
        returncode=1,
        stdout="",
        stderr=stderr,
    )

    card._handle_command_result(result)

    output_html = card.run_output.toHtml()
    assert "stderr-0" in output_html
    assert card._output_link_map["stderr-0"].line == 1
    highlights = [
        sel
        for sel in card.editor.extraSelections()
        if sel.format.background().color().red() > 200
    ]
    assert highlights
```

**Functions:** _ensure_app(), test_editor_card_generates_summaries(tmp_path), test_editor_card_chat_and_notes(tmp_path), test_editor_card_highlights_run_errors(tmp_path)


## Module `tests\test_error_console.py`

```python
import sys
from pathlib import Path

from PySide6.QtCore import Qt
from PySide6.QtWidgets import QApplication, QMainWindow

from error_console import ErrorConsole, StderrRedirector


def _ensure_app():
    app = QApplication.instance()
    if app is None:
        app = QApplication([])
    return app


def test_log_writes_file(tmp_path: Path):
    _ensure_app()
    console = ErrorConsole(tmp_path)
    win = QMainWindow()
    win.addDockWidget(Qt.BottomDockWidgetArea, console)
    console.log("boom")
    files = list(tmp_path.glob("*.log"))
    assert len(files) == 1
    assert "boom" in files[0].read_text(encoding="utf-8")


def test_stderr_redirect(tmp_path: Path):
    _ensure_app()
    console = ErrorConsole(tmp_path)
    redirect = StderrRedirector(console, sys.stderr)
    sys.stderr = redirect
    try:
        print("hello", file=sys.stderr)
    finally:
        sys.stderr = redirect.original
    files = list(tmp_path.glob("*.log"))
    assert files and "hello" in files[-1].read_text(encoding="utf-8")


def test_accepts_parent(tmp_path: Path):
    _ensure_app()
    win = QMainWindow()
    console = ErrorConsole(errors_dir=tmp_path, parent=win)
    win.addDockWidget(Qt.BottomDockWidgetArea, console)
    console.log("boom")
    assert console.parent() is win
```

**Functions:** _ensure_app(), test_log_writes_file(tmp_path), test_stderr_redirect(tmp_path), test_accepts_parent(tmp_path)


## Module `tests\test_external_app_embed_timeout.py`

```python
import sys
import types

import pytest

pytestmark = pytest.mark.skipif(
    not sys.platform.startswith("win"),
    reason="External app embedding is only available on Windows.",
)


def _ensure_qapp():
    from PySide6.QtWidgets import QApplication

    app = QApplication.instance()
    if app is None:
        app = QApplication([])
    return app


def test_external_app_waits_for_extended_timeout(monkeypatch):
    pytest.importorskip("PySide6")

    """Ledger 959d30d6-7381-4f97-925e-ef6ee16f124d: slow embeds respect extended timeout."""

    _ensure_qapp()

    import external_app_card as card

    class _StubSignal:
        def __init__(self):
            self._callbacks = []

        def connect(self, callback):
            self._callbacks.append(callback)

        def emit(self, *args, **kwargs):
            for callback in list(self._callbacks):
                callback(*args, **kwargs)

    class _StubTimer:
        def __init__(self, parent=None):
            self._interval = 0
            self._active = False
            self.timeout = _StubSignal()

        def setInterval(self, interval):
            self._interval = interval

        def start(self):
            self._active = True

        def stop(self):
            self._active = False

        def isActive(self):
            return self._active

    class _StubProcess:
        NotRunning = 0
        Starting = 1
        Running = 2

        def __init__(self, *_, **__):
            self._state = self.Running
            self._pid = 4321
            self.finished = _StubSignal()
            self.errorOccurred = _StubSignal()
            self._program = ""
            self._args = []
            self._cwd = ""

        def setProgram(self, program):
            self._program = program

        def setArguments(self, args):
            self._args = list(args)

        def setWorkingDirectory(self, cwd):
            self._cwd = cwd

        def start(self, program, args):
            self._program = program
            self._args = list(args)
            self._state = self.Running
            self._pid = 4321

        def waitForStarted(self, _msecs):
            return True

        def state(self):
            return self._state

        def processId(self):
            return self._pid

        def terminate(self):
            self._state = self.NotRunning

        def waitForFinished(self, _msecs):
            return True

        def kill(self):
            self._state = self.NotRunning

        def errorString(self):
            return ""

    class _Clock:
        def __init__(self):
            self.value = 0.0

        def __call__(self):
            return self.value

    clock = _Clock()

    monkeypatch.setattr(card, "QProcess", _StubProcess)
    monkeypatch.setattr(card, "QTimer", _StubTimer)
    monkeypatch.setattr(card.time, "monotonic", clock)

    spec = card.LaunchSpec(
        argv=["C:/slow.exe"],
        cwd="C:/",
        target_path="C:/slow.exe",
        original_path="C:/slow.exe",
    )

    theme = types.SimpleNamespace(header_fg="#fff")

    embedded = {}

    def _fake_embed(self, hwnd):
        embedded["hwnd"] = hwnd
        self._embedded_hwnd = hwnd

    monkeypatch.setattr(card.ExternalAppCard, "_embed_window", _fake_embed, raising=False)
    monkeypatch.setattr(card.ExternalAppCard, "_log", lambda *args, **kwargs: None, raising=False)

    attempts = {"count": 0}

    def _fake_find(_pid):
        attempts["count"] += 1
        if attempts["count"] < 2:
            return None
        return 0x0ABC

    monkeypatch.setattr(card, "_find_main_hwnd", _fake_find, raising=False)

    widget = card.ExternalAppCard(theme, spec, embed_timeout=15.0)
    assert widget.start()

    clock.value = 5.0
    widget._poll_for_window()
    assert "hwnd" not in embedded

    clock.value = 12.0
    widget._poll_for_window()

    assert embedded["hwnd"] == 0x0ABC
    assert not widget._fallback_emitted

    widget.shutdown()
```

**Functions:** _ensure_qapp(), test_external_app_waits_for_extended_timeout(monkeypatch)


## Module `tests\test_external_app_forced_shutdown.py`

```python
import logging
import sys
import types

import pytest

pytestmark = pytest.mark.skipif(
    not sys.platform.startswith("win"),
    reason="External app embedding is only available on Windows.",
)


def _ensure_qapp():
    from PySide6.QtWidgets import QApplication

    app = QApplication.instance()
    if app is None:
        app = QApplication([])
    return app


def test_shutdown_terminates_tracked_process_tree(monkeypatch):
    pytest.importorskip("PySide6")

    """Ensure orphaned external processes are terminated when the launcher is gone."""

    _ensure_qapp()

    import external_app_card as card

    class _StubSignal:
        def __init__(self):
            self._callbacks = []

        def connect(self, callback):
            self._callbacks.append(callback)

        def emit(self, *args, **kwargs):
            for callback in list(self._callbacks):
                callback(*args, **kwargs)

    class _StubTimer:
        def __init__(self, parent=None):
            self.timeout = _StubSignal()
            self._active = False

        def setInterval(self, _interval):
            return None

        def start(self):
            self._active = True

        def stop(self):
            self._active = False

        def isActive(self):
            return self._active

    class _StubProcess:
        NotRunning = 0
        Running = 1

        def __init__(self, *_, **__):
            self._state = self.NotRunning
            self.finished = _StubSignal()
            self.errorOccurred = _StubSignal()
            self._program = ""
            self._args = []
            self._cwd = ""

        def setProgram(self, program):
            self._program = program

        def setArguments(self, args):
            self._args = list(args)

        def setWorkingDirectory(self, cwd):
            self._cwd = cwd

        def start(self, program, args):
            self._program = program
            self._args = list(args)
            self._state = self.Running

        def waitForStarted(self, _timeout):
            return True

        def state(self):
            return self._state

        def terminate(self):
            self._state = self.NotRunning

        def waitForFinished(self, _timeout):
            self._state = self.NotRunning
            return True

        def kill(self):
            self._state = self.NotRunning

        def errorString(self):
            return ""

    monkeypatch.setattr(card, "QProcess", _StubProcess)
    monkeypatch.setattr(card, "QTimer", _StubTimer)

    spec = card.LaunchSpec(
        argv=["C:/dummy-launcher.exe"],
        cwd="C:/",
        target_path="C:/dummy-launcher.exe",
        original_path="C:/dummy-launcher.exe",
    )

    theme = types.SimpleNamespace(header_fg="#fff")

    toasts = []

    def _toast(message, *, kind="info"):
        toasts.append((message, kind))

    kernel_calls = {
        "open": [],
        "terminate": [],
        "wait": [],
        "close": [],
    }

    class _KernelStub:
        def OpenProcess(self, access, inherit, pid):
            kernel_calls["open"].append((access, inherit, pid))
            return pid

        def TerminateProcess(self, handle, exit_code):
            kernel_calls["terminate"].append((handle, exit_code))
            return True

        def WaitForSingleObject(self, handle, timeout):
            kernel_calls["wait"].append((handle, timeout))
            return 0

        def CloseHandle(self, handle):
            kernel_calls["close"].append(handle)
            return True

    kernel = _KernelStub()
    monkeypatch.setattr(card, "_kernel32", kernel)
    monkeypatch.setattr(card, "_enum_descendant_processes", lambda pid: {pid + 1})

    logs = []

    def _log(self, message, level=logging.INFO):
        logs.append((message, level))

    release_called = {"value": False}

    def _release(self):
        release_called["value"] = True

    monkeypatch.setattr(card.ExternalAppCard, "_log", _log, raising=False)
    monkeypatch.setattr(card.ExternalAppCard, "_release_window", _release, raising=False)

    widget = card.ExternalAppCard(theme, spec, toast_cb=_toast)
    widget._tracked_pid = 4321

    widget.shutdown()

    assert release_called["value"] is True
    assert widget._tracked_pid is None

    opened_pids = [pid for _, _, pid in kernel_calls["open"]]
    assert opened_pids == [4322, 4321]

    terminated_handles = [handle for handle, _ in kernel_calls["terminate"]]
    assert terminated_handles == [4322, 4321]

    waited_handles = [handle for handle, _ in kernel_calls["wait"]]
    assert waited_handles == [4322, 4321]

    assert kernel_calls["close"] == [4322, 4321]

    assert any("Forced termination" in entry[0] for entry in logs)
    levels = {entry[1] for entry in logs}
    assert logging.WARNING in levels

    assert toasts == [("Force closed external app after launcher exit.", "warning")]
```

**Functions:** _ensure_qapp(), test_shutdown_terminates_tracked_process_tree(monkeypatch)


## Module `tests\test_image_path_insertion.py`

```python
import types
import Codex_Terminal as sct


def test_on_images_from_editor_appends_path(tmp_path):
    img = tmp_path / "img.png"
    img.write_bytes(b"\x89PNG\r\n\x1a\n")
    events = []
    dummy = types.SimpleNamespace(
        pending_images=[],
        input=types.SimpleNamespace(
            append=lambda s: events.append(("append", s))
        ),
        _convert_to_png=lambda p: p,
        _append_html=lambda *a, **k: None,
        settings={"enable_vision": True},
    )
    sct.ChatCard._on_images_from_editor(dummy, [img])
    expected = f'view_image "{img.as_posix()}"'
    assert events == [("append", expected)]
```

**Functions:** test_on_images_from_editor_appends_path(tmp_path)


## Module `tests\test_image_pipeline.py`

```python
import base64

import pytest

import image_pipeline as ip

SMALL_PNG = base64.b64decode(
    (
        "iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR4"
        "nGNgYAAAAAMAASsJTYQAAAAASUVORK5CYII="
    )
)


@pytest.mark.skipif(ip.Image is None, reason="Pillow not installed")
def test_perform_ocr_with_stub_engine(tmp_path):
    class StubEngine:
        def image_to_string(self, image, lang="eng"):
            return "Hello\nWorld"

    img = tmp_path / "image.png"
    img.write_bytes(SMALL_PNG)

    result = ip.perform_ocr(img, engine=StubEngine())

    assert result.ok
    assert "Hello" in result.text
    assert "Hello" in result.markdown


@pytest.mark.skipif(ip.Image is None, reason="Pillow not installed")
def test_perform_ocr_missing_engine(tmp_path, monkeypatch):
    img = tmp_path / "image.png"
    img.write_bytes(SMALL_PNG)

    monkeypatch.setattr(ip, "pytesseract", None)
    result = ip.perform_ocr(img, engine=None)

    assert not result.ok
    assert "pytesseract" in (result.error or "").lower()


def test_analyze_image_invokes_client(tmp_path):
    img = tmp_path / "image.png"
    img.write_bytes(SMALL_PNG)

    class StubClient:
        def __init__(self):
            self.calls = []

        def chat(self, model, messages, images=None):
            # pragma: no cover - exercised indirectly
            self.calls.append((model, messages, images))
            return True, "Summary text", ""

    client = StubClient()
    result = ip.analyze_image(
        img,
        "ocr markdown",
        client=client,
        model="vision-model",
        user_text="hello",
    )

    assert result.ok
    assert result.summary == "Summary text"
    assert client.calls
    called_model, messages, images = client.calls[0]
    assert called_model == "vision-model"
    assert images and isinstance(images[0], str)
    content = messages[1]["content"]
    assert "OCR Markdown" in content


def test_analyze_image_requires_client(tmp_path):
    img = tmp_path / "image.png"
    img.write_bytes(SMALL_PNG)

    result = ip.analyze_image(
        img,
        "ocr markdown",
        client=None,
        model="vision-model",
    )

    assert not result.ok
    assert "client" in (result.error or "").lower()


@pytest.mark.skipif(ip.Image is None, reason="Pillow not installed")
def test_thumbnailize_conversation_markdown(tmp_path):
    conv = tmp_path / "conversation.md"
    images_dir = tmp_path / "images"
    images_dir.mkdir()

    first = images_dir / "first.png"
    second = images_dir / "second.png"
    third = images_dir / "third.png"
    for target in (first, second, third):
        target.write_bytes(SMALL_PNG)

    conv.write_text(
        "# Conversation\n\n"
        "**User:**\n\nHello\n\n"
        "![image](images/first.png)\n"
        "![image](images/second.png)\n"
        "![image](images/third.png)\n",
        encoding="utf-8",
    )

    updates = ip.thumbnailize_conversation_markdown(
        conv,
        keep_recent=1,
        max_size=(1, 1),
    )

    assert len(updates) == 2
    assert all(up.thumbnail_path.exists() for up in updates)

    text = conv.read_text(encoding="utf-8")
    assert "images/first_thumb.png" in text
    assert "images/second_thumb.png" in text
    assert "images/third.png" in text

    restored = ip.restore_conversation_image(conv, first)
    assert restored
    text_after = conv.read_text(encoding="utf-8")
    assert "images/first.png" in text_after
    assert "images/first_thumb.png" not in text_after
```

**Functions:** test_perform_ocr_with_stub_engine(tmp_path), test_perform_ocr_missing_engine(tmp_path, monkeypatch), test_analyze_image_invokes_client(tmp_path), test_analyze_image_requires_client(tmp_path), test_thumbnailize_conversation_markdown(tmp_path)


## Module `tests\test_live_engine.py`

```python
import time
from pathlib import Path

import pytest

from background.live_engine import LiveScriptController


def test_controller_loads_and_calls_hooks(tmp_path: Path) -> None:
    script = tmp_path / "bg.py"
    script.write_text(
        "state = {'init': 0, 'resize': None, 'update': 0, 'render': 0}\n"
        "def init(widget):\n    state['init'] += 1\n"
        "def resize(w, h):\n    state['resize'] = (w, h)\n"
        "def update(dt):\n    state['update'] += 1; state['last_dt'] = dt\n"
        "def render(widget):\n    state['render'] += 1\n",
        encoding="utf-8",
    )

    controller = LiveScriptController()
    controller.set_script(str(script))
    module = controller.module
    assert module is not None
    controller.call("init", object())
    controller.call("resize", 320, 200)
    controller.call("update", 0.016)
    controller.call("render", object())

    assert module.state["init"] == 1
    assert module.state["resize"] == (320, 200)
    assert module.state["update"] == 1
    assert module.state["render"] == 1
    assert module.state["last_dt"] == pytest.approx(0.016, rel=1e-3)

    # Modify the script to ensure reload picks up new behavior
    time.sleep(0.05)  # ensure filesystem mtime ticks
    script.write_text(
        "state = {'version': 2}\n"
        "def init(widget):\n    state['initialized'] = True\n",
        encoding="utf-8",
    )
    assert controller.reload_if_changed() is True
    new_module = controller.module
    assert new_module is not None
    assert new_module is not module
    controller.call("init", object())
    assert new_module.state["initialized"] is True


def test_controller_loads_after_file_appears(tmp_path: Path) -> None:
    script = tmp_path / "bg_missing.py"
    controller = LiveScriptController()
    controller.set_script(str(script))
    assert controller.module is None

    script.write_text("flag = 41\n", encoding="utf-8")
    assert controller.reload_if_changed() is True
    module = controller.module
    assert module is not None
    assert module.flag == 41
```

**Functions:** test_controller_loads_and_calls_hooks(tmp_path), test_controller_loads_after_file_appears(tmp_path)


## Module `tests\test_logic_doc.py`

```python
import editor.logic_doc as logic


def test_parse_segments_detects_headings():
    text = (
        "Overview\n\n"
        "Intro paragraph.\n\n"
        "Section One\n\n"
        "Details about one.\n\n"
        "Section Two:\n\n"
        "Details about two.\n"
    )

    segments = logic.parse_segments(text, fallback_title="Doc")

    titles = [seg.title for seg in segments]
    assert titles == ["Overview", "Section One", "Section Two"]
    assert segments[0].start_line == 1
    assert segments[1].start_line == 5
    assert segments[2].start_line == 9
    assert "Details about two" in segments[2].content


def test_parse_segments_falls_back_when_no_headings():
    text = "Single paragraph without headings.\nSecond line."

    segments = logic.parse_segments(text, fallback_title="Doc")

    assert len(segments) == 1
    assert segments[0].title == "Doc"
    assert segments[0].start_line == 1
    assert segments[0].end_line == 2


def test_summarize_segments_invokes_client():
    class StubClient:
        def __init__(self):
            self.calls = []
            self.responses = ["Summary A", "Summary B"]

        def chat(self, model, messages, images=None):
            self.calls.append((model, messages))
            return True, self.responses[len(self.calls) - 1], ""

    segs = [
        logic.Segment(
            title="Alpha",
            start_line=1,
            end_line=3,
            content="Alpha body",
        ),
        logic.Segment(
            title="Beta",
            start_line=4,
            end_line=6,
            content="Beta body",
        ),
    ]

    client = StubClient()
    results = logic.summarize_segments(segs, client=client, model="model")

    assert len(results) == 2
    assert results[0].summary == "Summary A"
    assert results[1].summary == "Summary B"
    assert client.calls[0][0] == "model"
    assert "Alpha" in client.calls[0][1][1]["content"]


def test_build_summary_markdown_includes_editor_links(tmp_path):
    segment = logic.Segment(
        title="Alpha",
        start_line=5,
        end_line=10,
        content="body",
    )
    summary = logic.SegmentSummary(segment=segment, summary="- point")
    source = tmp_path / "doc.md"
    source.write_text("Alpha\n", encoding="utf-8")

    markdown = logic.build_summary_markdown([summary], source=source)

    assert "editor://doc.md?line=5" in markdown
    assert "## Alpha" in markdown
    assert "point" in markdown

    target = logic.write_report(source, markdown)
    assert target and target.read_text(encoding="utf-8") == markdown
```

**Functions:** test_parse_segments_detects_headings(), test_parse_segments_falls_back_when_no_headings(), test_summarize_segments_invokes_client(), test_build_summary_markdown_includes_editor_links(tmp_path)


## Module `tests\test_manage_tests.py`

```python
import sys

from tools import manage_tests


def test_manage_tests_invokes_pytest(monkeypatch, capsys):
    calls = {}

    def fake_run(cmd, cwd=None, env=None):
        calls["cmd"] = cmd
        calls["cwd"] = cwd
        calls["env"] = env

        class Result:
            returncode = 0

        return Result()

    monkeypatch.setattr(manage_tests.subprocess, "run", fake_run)

    exit_code = manage_tests.main(["-k", "sample"])

    assert exit_code == 0
    assert calls["cmd"][:3] == [sys.executable, "-m", "pytest"]
    assert "-k" in calls["cmd"] and "sample" in calls["cmd"]
    assert calls["cwd"] == manage_tests.REPO_ROOT
    assert calls["env"].get("QT_QPA_PLATFORM") == "offscreen"
    output = capsys.readouterr().out
    assert "Running tests via pytest" in output
```

**Functions:** test_manage_tests_invokes_pytest(monkeypatch, capsys)


## Module `tests\test_memory_manager.py`

```python
import json
from pathlib import Path

from memory_manager import MemoryManager


def _text_embed(text: str):
    text_lower = text.lower()
    if "diagram" in text_lower:
        return [0.0, 1.0]
    if "world" in text_lower:
        return [1.0, 0.0]
    return [0.70710678, 0.70710678]


def _image_embed(path: Path):
    try:
        data = path.read_text(encoding="utf-8")
    except OSError:
        data = ""
    lower = data.lower()
    if "diagram" in lower:
        return [0.0, 1.0]
    return [1.0, 0.0]


def test_log_interaction_records_embeddings(tmp_path):
    manager = MemoryManager(
        tmp_path,
        text_embedder=_text_embed,
        image_embedder=_image_embed,
        enable_embeddings=True,
    )
    img_path = tmp_path / "image.txt"
    img_path.write_text("diagram sketch", encoding="utf-8")

    entry = manager.log_interaction(
        "session-a",
        "assistant",
        "hello world",
        images=[img_path],
        ocr_map={img_path.name: "diagram of world"},
        tags=["vision"],
        metadata={"source": "vision-pipeline"},
    )

    dataset_path = (
        tmp_path / "conversations" / "session-a" / "conversation.jsonl"
    )
    assert dataset_path.exists()
    dataset_text = dataset_path.read_text(encoding="utf-8")
    lines = [
        json.loads(line)
        for line in dataset_text.splitlines()
        if line
    ]
    last_line = lines[-1]
    assert last_line["metadata"]["source"] == "vision-pipeline"
    assert last_line["tags"] == ["vision"]
    image_entry = last_line["images"][0]
    assert image_entry["ocr_text"] == "diagram of world"
    assert image_entry["image_embedding"], "image embedding stored"
    assert image_entry["ocr_embedding"], "ocr embedding stored"
    assert entry["text_embedding"], "entry should include text embedding"


def test_search_images_uses_ocr_and_image_vectors(tmp_path):
    manager = MemoryManager(
        tmp_path,
        text_embedder=_text_embed,
        image_embedder=_image_embed,
        enable_embeddings=True,
    )
    img_path = tmp_path / "diagram.png"
    img_path.write_text("simple diagram", encoding="utf-8")
    manager.log_interaction(
        "session-b",
        "assistant",
        "initial response",
        images=[img_path],
        ocr_map={img_path.name: "diagram labels"},
        tags=["vision"],
        metadata={"id": 1},
    )

    fresh_manager = MemoryManager(
        tmp_path,
        text_embedder=_text_embed,
        image_embedder=_image_embed,
        enable_embeddings=True,
    )
    results = fresh_manager.search_images("diagram", k=1)
    assert results, "expected at least one match"
    top = results[0]
    assert top["session"] == "session-b"
    assert top["metadata"]["id"] == 1
    assert top["ocr_text"] == "diagram labels"
    assert top["score"] > 0.5

    filtered = fresh_manager.search_images(
        "diagram",
        k=1,
        session_filter="missing",
    )
    assert filtered == []
```

**Functions:** _text_embed(text), _image_embed(path), test_log_interaction_records_embeddings(tmp_path), test_search_images_uses_ocr_and_image_vectors(tmp_path)


## Module `tests\test_metrics_manager.py`

```python
from __future__ import annotations

from pathlib import Path

from metrics_manager import fetch_metrics, record_metrics


def test_record_metrics_writes_to_multiple_scopes(tmp_path: Path) -> None:
    local_db = tmp_path / "local.db"
    global_db = tmp_path / "global.db"
    entries = [
        {
            "timestamp": 123.0,
            "script_path": "tools/example.py",
            "score": 0.75,
            "runtime_ms": 42.0,
            "component": "tools/example.py",
            "metadata": {"line_count": 10},
        }
    ]

    result = record_metrics(
        entries,
        scopes=("local", "global"),
        db_paths={"local": local_db, "global": global_db},
    )

    assert result == {"local": 1, "global": 1}

    local_rows = fetch_metrics(scope="local", db_paths={"local": local_db})
    global_rows = fetch_metrics(scope="global", db_paths={"global": global_db})

    assert len(local_rows) == len(global_rows) == 1
    assert local_rows[0]["script_path"] == "tools/example.py"
    assert local_rows[0]["metadata"] == {"line_count": 10}
    assert global_rows[0]["component"] == "tools/example.py"


def test_fetch_metrics_filters_and_limits(tmp_path: Path) -> None:
    db_path = tmp_path / "metrics.db"
    record_metrics(
        [
            {
                "timestamp": 50.0,
                "script_path": "a.py",
                "score": 0.5,
                "runtime_ms": 5.0,
            },
            {
                "timestamp": 150.0,
                "script_path": "b.py",
                "score": 0.9,
                "runtime_ms": 7.5,
            },
        ],
        db_paths={"local": db_path},
    )

    record_metrics(
        [
            {
                "timestamp": 250.0,
                "script_path": "b.py",
                "score": 0.6,
                "runtime_ms": 8.0,
            }
        ],
        db_paths={"local": db_path},
    )

    only_b = fetch_metrics(
        scope="local",
        script_path="b.py",
        db_paths={"local": db_path},
    )
    assert all(row["script_path"] == "b.py" for row in only_b)
    assert only_b[0]["timestamp"] >= only_b[-1]["timestamp"]

    recent = fetch_metrics(
        scope="local",
        since=100.0,
        db_paths={"local": db_path},
    )
    assert all(row["timestamp"] >= 100.0 for row in recent)

    limited = fetch_metrics(
        scope="local",
        limit=1,
        db_paths={"local": db_path},
    )
    assert len(limited) == 1
    assert limited[0]["timestamp"] == max(row["timestamp"] for row in recent)
```

**Functions:** test_record_metrics_writes_to_multiple_scopes(tmp_path), test_fetch_metrics_filters_and_limits(tmp_path)


## Module `tests\test_process_error_card.py`

```python
"""Regression tests for the process error console card."""

from __future__ import annotations

import sys
import textwrap
import time
from pathlib import Path
from typing import List

from PySide6.QtWidgets import QApplication

from errors.process_error_card import ProcessErrorCard
from Virtual_Desktop import Theme


def _ensure_app() -> QApplication:
    app = QApplication.instance()
    if app is None:
        app = QApplication([])
    return app


def _drain_events(app: QApplication, deadline: float) -> None:
    while time.time() < deadline:
        app.processEvents()
        time.sleep(0.01)


def test_process_error_card_persists_failure(tmp_path: Path) -> None:
    app = _ensure_app()
    script = tmp_path / "fail.py"
    script.write_text(
        textwrap.dedent(
            """
            import sys
            sys.stderr.write("boom!\\n")
            sys.stderr.flush()
            sys.exit(2)
            """
        ),
        encoding="utf-8",
    )

    records: List = []
    isolation_events: List = []
    closes: List = []

    card = ProcessErrorCard(
        Theme(),
        [sys.executable, str(script)],
        cwd=str(tmp_path),
        record_writer=lambda record: records.append(record),
    )
    card.isolation_requested.connect(lambda message, code: isolation_events.append((message, code)))
    card.close_requested.connect(lambda: closes.append(True))
    card.start()

    deadline = time.time() + 5.0
    while card.is_running and time.time() < deadline:
        app.processEvents()
        time.sleep(0.05)
    _drain_events(app, time.time() + 0.2)

    assert records, "Failure should be persisted through the error dataset helper."
    payload = records[-1]
    assert "boom" in payload.msg
    assert payload.level == "ERROR"
    assert isolation_events and isolation_events[0][1] == 2
    assert closes, "Card should request closure after failure."
    assert "boom" in card._log.toPlainText()
```

Regression tests for the process error console card.
**Functions:** _ensure_app(), _drain_events(app, deadline), test_process_error_card_persists_failure(tmp_path)


## Module `tests\test_prompt_loader.py`

```python
import prompt_loader


def _reset_loader(tmp_path, monkeypatch):
    monkeypatch.setattr(prompt_loader, "PROMPTS_DIR", tmp_path)
    prompt_loader._PROMPT_CACHE.clear()


def test_prompt_loader_falls_back_to_default(tmp_path, monkeypatch):
    _reset_loader(tmp_path, monkeypatch)
    watcher = prompt_loader.get_prompt_watcher("chat_system")
    default_text = prompt_loader._PROMPT_DEFINITIONS["chat_system"].default
    assert watcher.text() == default_text
    created = tmp_path / "chat_system.txt"
    assert created.exists()
    assert created.read_text(encoding="utf-8").strip() == default_text


def test_prompt_loader_merges_overlay_and_hot_reload(tmp_path, monkeypatch):
    _reset_loader(tmp_path, monkeypatch)
    base = tmp_path / "chat_system.txt"
    base.write_text("Base", encoding="utf-8")
    overlay = tmp_path / "chat_system.overlay.txt"
    overlay.write_text("Overlay", encoding="utf-8")

    watcher = prompt_loader.get_prompt_watcher("chat_system")
    assert watcher.text() == "Base\n\nOverlay"

    overlay.write_text("Overlay v2", encoding="utf-8")
    assert watcher.text() == "Base\n\nOverlay v2"
```

**Functions:** _reset_loader(tmp_path, monkeypatch), test_prompt_loader_falls_back_to_default(tmp_path, monkeypatch), test_prompt_loader_merges_overlay_and_hot_reload(tmp_path, monkeypatch)


## Module `tests\test_repo_index.py`

```python
import json
from pathlib import Path

from memory_manager import RepositoryIndex


def _write_file(path: Path, content: str) -> None:
    path.parent.mkdir(parents=True, exist_ok=True)
    path.write_text(content, encoding="utf-8")


def test_repository_index_rebuild_and_query(tmp_path):
    repo_root = tmp_path / "repo"
    repo_root.mkdir()

    python_source = '''"""Example module."""


def add_task_bus(event):
    """Add an event to the in-memory task bus."""
    return {"event": event, "status": "queued"}


class TaskWorker:
    def greet(self, name: str) -> str:
        return f"hello {name}"
'''
    _write_file(repo_root / "src" / "tasks.py", python_source)

    markdown_doc = (
        "# Overview\n\n"
        "The task bus coordinates publish/subscribe flows.\n\n"
        "## Processing\n\n"
        "Workers acknowledge task completion.\n"
    )
    _write_file(repo_root / "docs" / "tasks.md", markdown_doc)

    data_root = tmp_path / "datasets"

    index = RepositoryIndex(repo_root=repo_root, data_root=data_root)
    summary = index.rebuild()

    assert summary["files_indexed"] == 2
    assert summary["segments"] >= 3

    index_path = data_root / "repo_index" / "index.jsonl"
    assert index_path.exists()

    entries = [
        json.loads(line)
        for line in index_path.read_text(encoding="utf-8").splitlines()
        if line
    ]
    assert entries, "expected index entries"
    ids = [entry["id"] for entry in entries]
    assert len(ids) == len(set(ids)), "segment identifiers should be unique"
    assert any(
        entry["metadata"].get("language") == "markdown" for entry in entries
    )

    results = index.search("task bus queued", k=2)
    assert results, "expected at least one search result"
    top = results[0]
    assert top["path"].endswith("tasks.py")
    assert top["metadata"]["kind"] in {"function", "class"}

    summary_again = index.rebuild()
    assert summary_again["segments"] == summary["segments"]

    cached = list(index.iter_segments())
    assert cached, "expected cached segments"
    assert any(segment["path"].endswith("tasks.md") for segment in cached)


def test_repository_index_tracks_extra_roots(tmp_path):
    repo_root = tmp_path / "repo"
    repo_root.mkdir()
    (repo_root / "README.md").write_text("root", encoding="utf-8")

    extra_root = tmp_path / "shared"
    extra_root.mkdir()
    (extra_root / "notes.txt").write_text("shared", encoding="utf-8")

    data_root = tmp_path / "datasets"
    index = RepositoryIndex(repo_root=repo_root, data_root=data_root, extra_roots=[extra_root])
    summary = index.rebuild()

    assert summary["files_indexed"] == 2

    segments = list(index.iter_segments())
    assert any(segment["metadata"].get("scan_root") == str(repo_root.resolve()) for segment in segments)
    assert any(
        segment["metadata"].get("scan_root") == str(extra_root.resolve())
        for segment in segments
    )
```

**Functions:** _write_file(path, content), test_repository_index_rebuild_and_query(tmp_path), test_repository_index_tracks_extra_roots(tmp_path)


## Module `tests\test_repo_reference_helper.py`

```python
from pathlib import Path

import pytest

from memory_manager import RepositoryIndex
from repo_reference_helper import RepoReferenceIndex


class DummyRepositoryIndex:
    def __init__(self, segments: list[dict[str, str]]):
        self._segments = segments
        self.loaded = 0
        self.rebuilt = 0

    def load(self) -> None:
        self.loaded += 1

    def iter_segments(self):
        for segment in self._segments:
            yield segment

    def rebuild(self):
        self.rebuilt += 1
        return {"files_indexed": len(self._segments)}


class EmptyRepositoryIndex(DummyRepositoryIndex):
    def __init__(self):
        super().__init__([])

    def iter_segments(self):
        return iter(())


def test_repo_reference_index_collects_files_and_directories(tmp_path: Path):
    repo_root = tmp_path / "repo"
    (repo_root / "src").mkdir(parents=True)
    (repo_root / "src" / "main.py").write_text("print('hi')", encoding="utf-8")
    (repo_root / "README.md").write_text("hello", encoding="utf-8")

    stub = DummyRepositoryIndex([
        {"path": "src/main.py"},
        {"path": "README.md"},
    ])

    index = RepoReferenceIndex(repo_root, repository_index=stub)
    index.refresh()
    entries = index.entries()

    kinds = {(entry.relative_path, entry.kind) for entry in entries}
    assert ("src/main.py", "file") in kinds
    assert ("README.md", "file") in kinds
    assert ("src", "directory") in kinds
    assert stub.loaded >= 1
    assert stub.rebuilt == 0


def test_repo_reference_index_falls_back_to_filesystem(tmp_path: Path):
    repo_root = tmp_path / "repo"
    (repo_root / "docs").mkdir(parents=True)
    (repo_root / "docs" / "index.md").write_text("notes", encoding="utf-8")

    empty_stub = EmptyRepositoryIndex()
    index = RepoReferenceIndex(repo_root, repository_index=empty_stub)
    index.refresh()
    entries = index.entries()

    kinds = {(entry.relative_path, entry.kind) for entry in entries}
    assert ("docs/index.md", "file") in kinds
    assert ("docs", "directory") in kinds
    assert empty_stub.rebuilt >= 1


def test_repo_reference_index_includes_extra_roots_when_allowed(tmp_path: Path):
    repo_root = tmp_path / "workspace"
    extra_root = tmp_path / "external"
    (repo_root / "src").mkdir(parents=True)
    (repo_root / "src" / "main.py").write_text("print('hi')", encoding="utf-8")
    extra_root.mkdir()
    extra_file = extra_root / "notes.txt"
    extra_file.write_text("extra", encoding="utf-8")

    data_root = tmp_path / "datasets"
    index = RepositoryIndex(repo_root=repo_root, data_root=data_root, extra_roots=[extra_root])
    index.rebuild()

    allowed_index = RepoReferenceIndex(
        repo_root,
        repository_index=index,
        extra_roots=[extra_root],
    )
    allowed_index.refresh()
    allowed_paths = {entry.absolute_path for entry in allowed_index.entries()}
    assert extra_file.resolve() in allowed_paths

    restricted_index = RepoReferenceIndex(repo_root, repository_index=index)
    restricted_index.refresh()
    restricted_paths = {entry.absolute_path for entry in restricted_index.entries()}
    assert extra_file.resolve() not in restricted_paths
```

**Classes:** DummyRepositoryIndex, EmptyRepositoryIndex
**Functions:** test_repo_reference_index_collects_files_and_directories(tmp_path), test_repo_reference_index_falls_back_to_filesystem(tmp_path), test_repo_reference_index_includes_extra_roots_when_allowed(tmp_path)


## Module `tests\test_safety.py`

```python
from __future__ import annotations

from pathlib import Path

import pytest

from Codex_Terminal import run_checked
from safety import SafetyViolation, manager as safety_manager


def test_protected_file_overwrite_blocked(tmp_path: Path):
    protected = tmp_path / "Agent.md"
    protected.write_text("initial", encoding="utf-8")
    safety_manager.add_protected_path(protected)
    try:
        with pytest.raises(SafetyViolation):
            protected.write_text("overwrite", encoding="utf-8")
        with protected.open("a", encoding="utf-8") as handle:
            handle.write("\nappend")
        contents = protected.read_text(encoding="utf-8")
        assert "initial" in contents
        assert "append" in contents
    finally:
        safety_manager.remove_protected_path(protected)


def test_run_checked_blocks_risky_command(tmp_path: Path):
    messages: list[str] = []
    token = safety_manager.add_notifier(messages.append)
    try:
        rc, out, err = run_checked(["rm", "-rf", "/"], cwd=tmp_path)
    finally:
        safety_manager.remove_notifier(token)
    assert rc != 0
    assert not out
    assert "Blocked command" in err
    assert any("Blocked command" in msg for msg in messages)


def test_run_checked_executes_when_confirmed(tmp_path: Path):
    victim = tmp_path / "victim"
    victim.mkdir()
    (victim / "file.txt").write_text("data", encoding="utf-8")

    messages: list[str] = []
    token = safety_manager.add_notifier(messages.append)
    safety_manager.set_confirmer(lambda prompt, command: True)
    try:
        rc, out, err = run_checked(
            ["rm", "-rf", victim.as_posix()],
            cwd=tmp_path,
        )
    finally:
        safety_manager.set_confirmer(None)
        safety_manager.remove_notifier(token)

    assert rc == 0
    assert victim.exists() is False
    assert any("Approved" in msg for msg in messages)
    assert err == ""
```

**Functions:** test_protected_file_overwrite_blocked(tmp_path), test_run_checked_blocks_risky_command(tmp_path), test_run_checked_executes_when_confirmed(tmp_path)


## Module `tests\test_send_to_codex.py`

```python
import copy
import json
import types

import Codex_Terminal as sct


def test_task_command_creation_uses_conversation_id(monkeypatch):
    captured = {}

    def _capture_task(task):
        captured["task"] = task

    monkeypatch.setattr(sct, "append_task", _capture_task)
    monkeypatch.setattr(sct, "append_event", lambda event: None)
    monkeypatch.setattr(sct, "publish", lambda topic, payload: None)

    dummy = types.SimpleNamespace(
        session_id="term_test_123",
        _emit_system_notice=lambda message: None,
    )

    bound = types.MethodType(sct.ChatCard._command_task_create, dummy)
    bound("Resume task flow")

    assert "task" in captured
    assert captured["task"].codex_conversation_id == "term_test_123"


def test_send_to_codex_records_before_enter(monkeypatch):
    events = []

    class DummyBridge:
        def __init__(self):
            self.pid = 1

        def running(self):
            return True

        def busy(self):
            return False

        def send_text(self, txt):
            events.append(("send_text", txt))
            return True

        def press_enter_async(self, hwnd):
            events.append("enter")

    dummy = types.SimpleNamespace(
        bridge=DummyBridge(),
        input=types.SimpleNamespace(
            toPlainText=lambda: "echo hi",
            clear=lambda: events.append("clear"),
        ),
        view=types.SimpleNamespace(
            append_message=lambda role, text, **kwargs: events.append(
                ("append_message", role, text)
            )
        ),
        _ui_hwnd=lambda: 0,
        conv=types.SimpleNamespace(
            append=lambda role, text, images: events.append(
                ("conv", role, text)
            ),
            recent=lambda k: [],
            retrieve=lambda q, k: [],
        ),
        lex=types.SimpleNamespace(auto_tags=lambda text: []),
        dataset=types.SimpleNamespace(
            add_entry=lambda *a, **k: events.append(("dataset", a[0], a[1]))
        ),
        share_context=False,
        share_limit=1,
        settings={"enable_semantic": False},
        codex_interpreter=types.SimpleNamespace(
            observe_user=lambda text: None,
            observe_codex_output=lambda text: None,
        ),
    )
    dummy._store_session_note = lambda *a, **k: None
    dummy._record_message = types.MethodType(
        sct.ChatCard._record_message, dummy
    )

    sct.ChatCard._send_to_codex(dummy)

    assert events == [
        ("send_text", "echo hi"),
        ("conv", "user", "echo hi"),
        ("dataset", "user", "echo hi"),
        ("append_message", "system", "→ Codex: echo hi ✓"),
        "clear",
        "enter",
    ]


def test_codex_output_logged_before_render():
    events = []

    conv = types.SimpleNamespace(
        append=lambda role, text, images: events.append(("conv", role, text))
    )
    dataset = types.SimpleNamespace(
        add_entry=lambda *a, **k: events.append(("dataset", a[0], a[1]))
    )
    append_signal = types.SimpleNamespace(
        emit=lambda msg: events.append(("append", msg))
    )
    view = types.SimpleNamespace(append_message=lambda *a, **k: None)

    def _dismiss(reason):
        events.append(("dismiss", reason))

    dummy = types.SimpleNamespace(
        conv=conv,
        lex=types.SimpleNamespace(auto_tags=lambda text: []),
        dataset=dataset,
        append_signal=append_signal,
        _dismiss_active_approvals=_dismiss,
        view=view,
        codex_interpreter=types.SimpleNamespace(
            observe_codex_output=lambda text: None,
        ),
    )
    dummy._parse_codex_approval_events = (
        sct.ChatCard._parse_codex_approval_events
    )
    dummy._record_message = types.MethodType(
        sct.ChatCard._record_message, dummy
    )

    sct.ChatCard._on_codex_output(dummy, "hi out")

    assert events[0] == ("conv", "assistant", "hi out")
    assert events[1] == ("dataset", "assistant", "hi out")
    kind, message = events[2]
    assert kind == "append"
    assert isinstance(message, sct.ChatMessage)
    assert message.role == "assistant"
    assert message.text == "hi out"
    assert message.kind == "text"


def test_codex_output_ignores_bare_approval_tokens():
    events = []

    conv = types.SimpleNamespace(
        append=lambda role, text, images: events.append(("conv", role, text))
    )
    dataset = types.SimpleNamespace(
        add_entry=lambda *a, **k: events.append(("dataset", a[0], a[1]))
    )
    append_signal = types.SimpleNamespace(
        emit=lambda msg: events.append(("append", msg))
    )
    view = types.SimpleNamespace(append_message=lambda *a, **k: None)

    dummy = types.SimpleNamespace(
        conv=conv,
        lex=types.SimpleNamespace(auto_tags=lambda text: []),
        dataset=dataset,
        append_signal=append_signal,
        _dismiss_active_approvals=lambda reason: events.append(("dismiss", reason)),
        view=view,
        codex_interpreter=types.SimpleNamespace(
            observe_codex_output=lambda text: events.append(("observe", text)),
        ),
    )
    dummy._parse_codex_approval_events = (
        sct.ChatCard._parse_codex_approval_events
    )
    dummy._record_message = types.MethodType(
        sct.ChatCard._record_message, dummy
    )

    tokens = ["always", "YES", "n", "feedback"]
    for token in tokens:
        sct.ChatCard._on_codex_output(dummy, token)

    assert events == []


def test_codex_bridge_drops_injected_token_delta(monkeypatch):
    outputs = []

    bridge = sct.CodexBridge(lambda s: None, lambda c: None, outputs.append)
    bridge.attach(42)

    monkeypatch.setattr(sct, "write_console_input_text", lambda pid, text: True)
    monkeypatch.setattr(sct, "codex_ready_banner", lambda snap: False)
    monkeypatch.setattr(sct.time, "sleep", lambda *a, **k: None)

    snapshots = ["", "Always", ""]

    def _snapshot(pid):
        assert pid == 42
        value = snapshots.pop(0)
        if not snapshots:
            bridge._stop_evt.set()
        return value

    monkeypatch.setattr(sct, "read_console_snapshot", _snapshot)

    assert bridge.send_text("Always")
    bridge._busy_evt.clear()
    bridge._stop_evt.clear()

    bridge._idle_loop()

    assert outputs == []
    assert bridge._last_injected is None


def test_send_to_codex_prepends_context(monkeypatch):
    events = []

    class DummyBridge:
        def __init__(self):
            self.pid = 1

        def running(self):
            return True

        def busy(self):
            return False

        def send_text(self, txt):
            events.append(("send_text", txt))
            return True

        def press_enter_async(self, hwnd):
            events.append("enter")

    conv = types.SimpleNamespace(
        append=lambda *a, **k: None,
        recent=lambda k: [{"role": "user", "text": "ctx"}],
        retrieve=lambda q, k: [],
    )
    dummy = types.SimpleNamespace(
        bridge=DummyBridge(),
        input=types.SimpleNamespace(
            toPlainText=lambda: "echo hi",
            clear=lambda: events.append("clear"),
        ),
        view=types.SimpleNamespace(append_message=lambda *a, **k: None),
        _ui_hwnd=lambda: 0,
        conv=conv,
        lex=types.SimpleNamespace(auto_tags=lambda text: []),
        dataset=types.SimpleNamespace(add_entry=lambda *a, **k: None),
        share_context=True,
        share_limit=1,
        settings={"enable_semantic": False},
        codex_interpreter=types.SimpleNamespace(
            observe_user=lambda text: None,
            observe_codex_output=lambda text: None,
        ),
    )
    dummy._store_session_note = lambda *a, **k: None
    dummy._record_message = types.MethodType(
        sct.ChatCard._record_message, dummy
    )

    sct.ChatCard._send_to_codex(dummy)

    assert events[0] == ("send_text", "user: ctx\necho hi")


def test_send_to_codex_respects_share_toggle(monkeypatch):
    events = []

    class DummyBridge:
        def __init__(self):
            self.pid = 1

        def running(self):
            return True

        def busy(self):
            return False

        def send_text(self, txt):
            events.append(("send_text", txt))
            return True

        def press_enter_async(self, hwnd):
            events.append("enter")

    dummy = types.SimpleNamespace(
        bridge=DummyBridge(),
        input=types.SimpleNamespace(
            toPlainText=lambda: "echo hi",
            clear=lambda: None,
        ),
        view=types.SimpleNamespace(append_message=lambda *a, **k: None),
        _ui_hwnd=lambda: 0,
        conv=types.SimpleNamespace(
            append=lambda *a, **k: None,
            recent=lambda k: [],
            retrieve=lambda q, k: [],
        ),
        lex=types.SimpleNamespace(auto_tags=lambda text: []),
        dataset=types.SimpleNamespace(add_entry=lambda *a, **k: None),
        share_context=False,
        share_limit=1,
        settings={"enable_semantic": False},
        codex_interpreter=types.SimpleNamespace(
            observe_user=lambda text: None,
            observe_codex_output=lambda text: None,
        ),
    )
    dummy._store_session_note = lambda *a, **k: None
    dummy._record_message = types.MethodType(
        sct.ChatCard._record_message, dummy
    )

    sct.ChatCard._send_to_codex(dummy)

    assert events[0] == ("send_text", "echo hi")


def test_send_to_codex_skips_large_reference(monkeypatch, tmp_path):
    events = []

    class DummyBridge:
        def __init__(self):
            self.pid = 1

        def running(self):
            return True

        def busy(self):
            return False

        def send_text(self, txt):
            events.append(("send_text", txt))
            return True

        def press_enter_async(self, hwnd):
            events.append(("enter", hwnd))

    monkeypatch.setattr(sct.token_budget, "count_tokens", lambda text, model=None: len(text))
    monkeypatch.setattr(sct.token_budget, "prompt_token_budget", lambda model, headroom: 50)

    ref_path = tmp_path / "big.txt"
    ref_path.write_text("x" * 200, encoding="utf-8")

    class DummyInput:
        def __init__(self, references):
            self._text = "echo hi"
            self._accepted_references = [dict(r) for r in references]

        def toPlainText(self):
            return self._text

        def clear(self):
            events.append("clear")

        def consume_references(self):
            refs = self._accepted_references
            self._accepted_references = []
            return refs

    references = [{"path": ref_path.name, "type": "file"}]

    dummy = types.SimpleNamespace(
        bridge=DummyBridge(),
        input=DummyInput(references),
        view=types.SimpleNamespace(
            append_message=lambda role, text, **kwargs: events.append(("append_message", role, text))
        ),
        _ui_hwnd=lambda: 0,
        conv=types.SimpleNamespace(recent=lambda k: [], retrieve=lambda q, k: []),
        share_context=False,
        share_limit=1,
        settings={
            "enable_semantic": False,
            "reference_embed_contents": True,
            "reference_token_guard": True,
            "reference_token_headroom": 50,
            "chat_model": "tiny",
        },
        workspace=tmp_path,
        codex_interpreter=types.SimpleNamespace(
            observe_user=lambda text: None,
            observe_codex_output=lambda text: None,
        ),
    )
    dummy._emit_system_notice = lambda message: events.append(("notice", message))
    dummy._record_message = types.MethodType(sct.ChatCard._record_message, dummy)

    sct.ChatCard._send_to_codex(dummy)

    assert events[0] == ("send_text", "echo hi")
    notices = [msg for kind, msg in events if kind == "notice"]
    assert any("Skipped 1 reference" in msg for msg in notices)


def _dummy_bridge(events):
    class DummyBridge:
        def __init__(self):
            self.auto_events = []

        def running(self):
            return True

        def busy(self):
            return False

        def send_text(self, txt):
            events.append(("send", txt))
            return True

        def press_enter_async(self, hwnd):
            events.append(("enter", hwnd))

    return DummyBridge()


def _make_interpreter(bridge, enabled=True):
    return sct.CodexInterpreter(
        bridge=bridge,
        get_busy=lambda: False,
        get_hwnd=lambda: 99,
        on_auto=lambda cmd: bridge.auto_events.append(cmd),
        enabled=enabled,
    )


def test_interpreter_auto_continue_on_prompt():
    events = []
    bridge = _dummy_bridge(events)
    interpreter = _make_interpreter(bridge, enabled=True)
    interpreter.observe_user("update settings dialog labels")
    continue_prompt = "Working... Would you like me to continue?"
    interpreter.observe_codex_output(continue_prompt)

    expected = "continue, focusing on update settings dialog labels"
    assert ("send", expected) in events
    assert ("enter", 99) in events
    assert expected in bridge.auto_events


def test_interpreter_reacts_to_repeated_plan_once():
    events = []
    bridge = _dummy_bridge(events)
    interpreter = _make_interpreter(bridge, enabled=True)
    interpreter.observe_user("refactor the codex interpreter helper")

    plan_text = "Plan:\n1. Prep\n2. Apply"
    interpreter.observe_codex_output(plan_text)
    assert events == []

    interpreter.observe_codex_output(plan_text)
    expected = "continue, focusing on refactor the codex interpreter helper"
    assert events[0] == ("send", expected)
    assert events[1] == ("enter", 99)


def test_interpreter_halts_after_completion_until_new_user_instruction():
    events = []
    bridge = _dummy_bridge(events)
    interpreter = _make_interpreter(bridge, enabled=False)
    interpreter.observe_user("add new workflow")
    interpreter.observe_codex_output("Would you like me to continue?")
    assert events == []

    interpreter.enabled = True
    interpreter.observe_codex_output("Would you like me to continue?")
    first_expected = "continue, focusing on add new workflow"
    assert events[0] == ("send", first_expected)
    events.clear()

    interpreter.observe_codex_output("Completed file change main.py")
    interpreter.observe_codex_output("Would you like me to continue?")
    assert events == []

    interpreter.observe_user("write regression tests")
    interpreter.observe_codex_output("Would you like me to continue?")
    second_expected = "continue, focusing on write regression tests"
    assert events[0] == ("send", second_expected)


def test_refresh_interpreter_toggle_disabled_when_bridge_offline():
    events = []

    class DummyToggle:
        def __init__(self):
            self.enabled_state = None
            self.tooltip_text = ""
            self.checked = False

        def setEnabled(self, value):
            self.enabled_state = bool(value)

        def setToolTip(self, text):
            self.tooltip_text = text

        def isChecked(self):
            return self.checked

    class OfflineBridge:
        def running(self):
            return False

    toggle = DummyToggle()

    def capture_caption(enabled):
        events.append(("caption", enabled))

    dummy = types.SimpleNamespace(
        bridge=OfflineBridge(),
        interpreter_toggle=toggle,
        _interpreter_tooltip="Auto follow-ups.",
        _led_state="red",
        _update_interpreter_caption=capture_caption,
    )

    sct.ChatCard._refresh_interpreter_toggle_enabled(dummy)

    assert toggle.enabled_state is False
    assert "Bridge offline" in toggle.tooltip_text
    assert events == [("caption", False)]


def test_refresh_interpreter_toggle_enabled_when_bridge_live():
    events = []

    class DummyToggle:
        def __init__(self):
            self.enabled_state = None
            self.tooltip_text = ""
            self.checked = True

        def setEnabled(self, value):
            self.enabled_state = bool(value)

        def setToolTip(self, text):
            self.tooltip_text = text

        def isChecked(self):
            return self.checked

    class LiveBridge:
        def running(self):
            return True

    toggle = DummyToggle()

    def capture_caption(enabled):
        events.append(("caption", enabled))

    dummy = types.SimpleNamespace(
        bridge=LiveBridge(),
        interpreter_toggle=toggle,
        _interpreter_tooltip="Auto follow-ups.",
        _led_state="green",
        _update_interpreter_caption=capture_caption,
    )

    sct.ChatCard._refresh_interpreter_toggle_enabled(dummy)

    assert toggle.enabled_state is True
    assert toggle.tooltip_text == "Auto follow-ups."
    assert events == [("caption", True)]


def test_load_codex_settings_defaults_to_workspace(monkeypatch, tmp_path):
    settings_file = tmp_path / "settings.json"
    workspace = tmp_path / "workspace"
    target = workspace / "Terminal Desktop"

    monkeypatch.setenv("CODEX_WORKSPACE", str(workspace))
    monkeypatch.setattr(sct, "SETTINGS_JSON", settings_file)
    monkeypatch.setattr(sct, "_legacy_transit_candidates", lambda: [])
    monkeypatch.setitem(sct.DEFAULT_SETTINGS, "working_folder", "legacy")

    result = sct.load_codex_settings()

    assert result["working_folder"] == str(target)
    saved = json.loads(settings_file.read_text(encoding="utf-8"))
    assert saved["working_folder"] == str(target)


def test_load_codex_settings_migrates_transit_default(monkeypatch, tmp_path):
    settings_file = tmp_path / "settings.json"
    workspace = tmp_path / "workspace"
    legacy = tmp_path / "Codex-Transit"
    legacy.mkdir()
    (legacy / "keep.txt").write_text("legacy", encoding="utf-8")

    monkeypatch.setenv("CODEX_WORKSPACE", str(workspace))
    monkeypatch.setattr(sct, "SETTINGS_JSON", settings_file)
    monkeypatch.setattr(sct, "_legacy_transit_candidates", lambda: [legacy])
    monkeypatch.setitem(sct.DEFAULT_SETTINGS, "working_folder", "legacy")

    settings_file.write_text(json.dumps({"working_folder": str(legacy)}), encoding="utf-8")

    result = sct.load_codex_settings()

    target = workspace / "Terminal Desktop"
    assert result["working_folder"] == str(target)
    saved = json.loads(settings_file.read_text(encoding="utf-8"))
    assert saved["working_folder"] == str(target)
    assert (target / "keep.txt").read_text(encoding="utf-8") == "legacy"
    assert not legacy.exists() or not any(legacy.iterdir())


def test_reference_settings_round_trip(monkeypatch, tmp_path):
    settings_file = tmp_path / "settings.json"
    workspace = tmp_path / "workspace"
    target = workspace / "Terminal Desktop"

    monkeypatch.setenv("CODEX_WORKSPACE", str(workspace))
    monkeypatch.setattr(sct, "SETTINGS_JSON", settings_file)
    monkeypatch.setattr(sct, "_legacy_transit_candidates", lambda: [])
    monkeypatch.setitem(sct.DEFAULT_SETTINGS, "working_folder", str(target))

    initial = copy.deepcopy(sct.DEFAULT_SETTINGS)
    initial["reference_embed_contents"] = not bool(
        sct.DEFAULT_SETTINGS["reference_embed_contents"]
    )
    initial["reference_case_sensitive"] = not bool(
        sct.DEFAULT_SETTINGS["reference_case_sensitive"]
    )
    initial["reference_token_guard"] = not bool(
        sct.DEFAULT_SETTINGS["reference_token_guard"]
    )
    initial["reference_token_headroom"] = (
        int(sct.DEFAULT_SETTINGS.get("reference_token_headroom", 80)) - 5
    )

    sct.save_codex_settings(initial)

    loaded = sct.load_codex_settings()

    assert loaded["reference_embed_contents"] == initial["reference_embed_contents"]
    assert loaded["reference_case_sensitive"] == initial["reference_case_sensitive"]
    assert loaded["reference_token_guard"] == initial["reference_token_guard"]
    assert loaded["reference_token_headroom"] == initial["reference_token_headroom"]

    saved = json.loads(settings_file.read_text(encoding="utf-8"))
    assert saved["reference_embed_contents"] == initial["reference_embed_contents"]
    assert saved["reference_case_sensitive"] == initial["reference_case_sensitive"]
    assert saved["reference_token_guard"] == initial["reference_token_guard"]
    assert saved["reference_token_headroom"] == initial["reference_token_headroom"]


def test_launch_codex_cmd_uses_requested_cwd(monkeypatch, tmp_path):
    captured = {}

    def fake_popen(cmd, cwd=None, creationflags=None):
        captured["cmd"] = cmd
        captured["cwd"] = cwd
        captured["creationflags"] = creationflags
        return types.SimpleNamespace(pid=999)

    monkeypatch.setattr(sct.subprocess, "Popen", fake_popen)
    monkeypatch.setattr(sct.subprocess, "CREATE_NEW_CONSOLE", 0x10, raising=False)

    bootstrap = sct.CodexBootstrap(types.SimpleNamespace())
    exe = tmp_path / "codex.exe"

    proc = bootstrap.launch_codex_cmd(exe, "codex-model", tmp_path)

    assert proc.pid == 999
    assert captured["cwd"] == str(tmp_path)
    assert captured["cmd"][:3] == ["cmd", "/k", "title"]
    assert captured["cmd"][3].startswith("CODEX_CMD_")
    assert captured["cmd"][4:] == ["&&", str(exe), "--model", "codex-model"]
    assert captured["creationflags"] == sct.subprocess.CREATE_NEW_CONSOLE


def test_start_codex_bridge_uses_saved_working_folder(monkeypatch, tmp_path):
    launches = {}

    def fake_launch(exe, model, cwd):
        launches["exe"] = exe
        launches["model"] = model
        launches["cwd"] = cwd
        return types.SimpleNamespace(pid=321)

    codex = types.SimpleNamespace(
        ensure_ollama=lambda: None,
        ensure_release=lambda: tmp_path / "codex.exe",
        write_config_toml=lambda model: launches.setdefault("config_model", model),
        launch_codex_cmd=fake_launch,
    )

    messages = []
    dummy = types.SimpleNamespace(
        codex=codex,
        settings={"chat_model": "fallback-model"},
        view=types.SimpleNamespace(append_message=lambda role, text: messages.append((role, text))),
        bridge=types.SimpleNamespace(
            attach=lambda pid: None,
            start=lambda: None,
        ),
        codex_led_signal=types.SimpleNamespace(emit=lambda state: None),
        btn_codex_start=types.SimpleNamespace(setEnabled=lambda value: None),
        btn_codex_stop=types.SimpleNamespace(setEnabled=lambda value: None),
        _refresh_interpreter_toggle_enabled=lambda: None,
    )

    bound = types.MethodType(sct.ChatCard._start_codex_bridge, dummy)
    monkeypatch.setattr(
        sct,
        "load_codex_settings",
        lambda: {"model": "setting-model", "working_folder": str(tmp_path)},
    )

    bound()

    assert launches["model"] == "setting-model"
    assert launches["cwd"] == tmp_path
    assert all("Working folder" not in text for _, text in messages)


def test_start_codex_bridge_falls_back_to_transit_dir(monkeypatch, tmp_path):
    launches = {}

    def fake_launch(exe, model, cwd):
        launches["cwd"] = cwd
        return types.SimpleNamespace(pid=654)

    codex = types.SimpleNamespace(
        ensure_ollama=lambda: None,
        ensure_release=lambda: tmp_path / "codex.exe",
        write_config_toml=lambda model: None,
        launch_codex_cmd=fake_launch,
    )

    messages = []
    dummy = types.SimpleNamespace(
        codex=codex,
        settings={"chat_model": "fallback-model"},
        view=types.SimpleNamespace(append_message=lambda role, text: messages.append((role, text))),
        bridge=types.SimpleNamespace(attach=lambda pid: None, start=lambda: None),
        codex_led_signal=types.SimpleNamespace(emit=lambda state: None),
        btn_codex_start=types.SimpleNamespace(setEnabled=lambda value: None),
        btn_codex_stop=types.SimpleNamespace(setEnabled=lambda value: None),
        _refresh_interpreter_toggle_enabled=lambda: None,
    )

    bound = types.MethodType(sct.ChatCard._start_codex_bridge, dummy)
    monkeypatch.setattr(
        sct,
        "load_codex_settings",
        lambda: {
            "model": "setting-model",
            "working_folder": str(tmp_path / "missing"),
        },
    )

    default_transit = tmp_path / "Terminal Desktop"

    def fake_transit_dir():
        default_transit.mkdir(parents=True, exist_ok=True)
        return default_transit

    monkeypatch.setattr(sct, "transit_dir", fake_transit_dir)
    monkeypatch.setattr(sct, "_legacy_transit_candidates", lambda: [])

    bound()

    assert launches["cwd"] == default_transit
    assert any("Using default transit folder" in text for _, text in messages)
    assert any(str(default_transit) in text for _, text in messages)
```

**Functions:** test_task_command_creation_uses_conversation_id(monkeypatch), test_send_to_codex_records_before_enter(monkeypatch), test_codex_output_logged_before_render(), test_codex_output_ignores_bare_approval_tokens(), test_codex_bridge_drops_injected_token_delta(monkeypatch), test_send_to_codex_prepends_context(monkeypatch), test_send_to_codex_respects_share_toggle(monkeypatch), test_send_to_codex_skips_large_reference(monkeypatch, tmp_path), _dummy_bridge(events), _make_interpreter(bridge, enabled), test_interpreter_auto_continue_on_prompt(), test_interpreter_reacts_to_repeated_plan_once(), test_interpreter_halts_after_completion_until_new_user_instruction(), test_refresh_interpreter_toggle_disabled_when_bridge_offline(), test_refresh_interpreter_toggle_enabled_when_bridge_live(), test_load_codex_settings_defaults_to_workspace(monkeypatch, tmp_path), test_load_codex_settings_migrates_transit_default(monkeypatch, tmp_path), test_reference_settings_round_trip(monkeypatch, tmp_path), test_launch_codex_cmd_uses_requested_cwd(monkeypatch, tmp_path), test_start_codex_bridge_uses_saved_working_folder(monkeypatch, tmp_path), test_start_codex_bridge_falls_back_to_transit_dir(monkeypatch, tmp_path)


## Module `tests\test_session_memory.py`

```python
import json

import Codex_Terminal as sct
from PySide6.QtWidgets import QApplication


class DummyOllama:
    def health(self):
        return True, "OK"

    def embeddings(self, model, text):
        return False, [], ""

    def chat(self, model, messages, images=None):
        return True, "", ""


def _ensure_app():
    app = QApplication.instance()
    if app is None:
        app = QApplication([])
    return app


def _chatcard(tmp_path, monkeypatch, memory_data=None):
    mem_path = tmp_path / "codex_memory.json"
    if memory_data is None:
        memory_data = {"sessions": [], "work_items": []}
    mem_path.write_text(json.dumps(memory_data, indent=2), encoding="utf-8")
    monkeypatch.setattr(sct, "MEMORY_PATH", mem_path)

    def _fake_agent_root():
        root = tmp_path / ".codex_agent"
        root.mkdir(parents=True, exist_ok=True)
        for name in ("images", "sessions", "logs", "archives", "data", "lexicons"):
            (root / name).mkdir(parents=True, exist_ok=True)
        return root

    monkeypatch.setattr(sct, "agent_data_root", _fake_agent_root)
    settings = {
        "context_pairs": 4,
        "share_context": False,
        "share_limit": 2,
        "enable_semantic": False,
        "enable_vision": False,
        "workspace": tmp_path,
        "data_root": str(tmp_path),
    }
    lex_dir = tmp_path / "lex"
    lex_dir.mkdir(parents=True, exist_ok=True)
    lex_mgr = sct.LexiconManager(lex_dir)
    card = sct.ChatCard(sct.Theme(), DummyOllama(), settings, lex_mgr)
    return card, mem_path


def test_session_notes_loaded_on_startup(tmp_path, monkeypatch):
    _ensure_app()
    data = {
        "sessions": [
            {
                "timestamp": "2025-09-15T00:00:00Z",
                "notes": "Prefers dark mode",
            },
            {
                "timestamp": "2025-09-16T00:00:00Z",
                "notes": "Needs keyboard shortcuts",
            },
        ],
        "work_items": [],
    }
    chat, _ = _chatcard(tmp_path, monkeypatch, data)
    try:
        assert chat.session_notes[0]["notes"] == "Prefers dark mode"
        assert chat.session_notes[1]["notes"] == "Needs keyboard shortcuts"
    finally:
        chat.deleteLater()


def test_gather_context_includes_session_notes(tmp_path, monkeypatch):
    _ensure_app()
    chat, _ = _chatcard(tmp_path, monkeypatch)
    try:
        chat.session_notes = [
            {"timestamp": "2025-09-16T00:00:00Z", "notes": "Prefers CLI tools"}
        ]
        chat.messages = []
        ctx = chat._gather_context("hello")
        assert ctx and ctx[0]["role"] == "system"
        assert "Prefers CLI tools" in ctx[0]["content"]
    finally:
        chat.deleteLater()


def test_user_turn_appends_session_note(tmp_path, monkeypatch):
    _ensure_app()
    chat, mem_path = _chatcard(tmp_path, monkeypatch)
    try:
        chat._record_message("user", "I prefer dark themes", [])
        data = json.loads(mem_path.read_text(encoding="utf-8"))
        assert data["sessions"]
        assert "dark themes" in data["sessions"][-1]["notes"]
        assert "dark themes" in chat.session_notes[-1]["notes"]
        assert data.get("work_items") == []
    finally:
        chat.deleteLater()
```

**Classes:** DummyOllama
**Functions:** _ensure_app(), _chatcard(tmp_path, monkeypatch, memory_data), test_session_notes_loaded_on_startup(tmp_path, monkeypatch), test_gather_context_includes_session_notes(tmp_path, monkeypatch), test_user_turn_appends_session_note(tmp_path, monkeypatch)


## Module `tests\test_settings_dialog.py`

```python
import Codex_Terminal as sct
from PySide6.QtWidgets import QApplication


def _ensure_app():
    app = QApplication.instance()
    if app is None:
        app = QApplication([])
    return app


def test_settings_dialog_round_trips_interpreter(monkeypatch):
    _ensure_app()

    class _StubOllama:
        def list_models(self):
            return True, ["stub-model"], "ok"

    monkeypatch.setattr(sct, "OllamaClient", lambda: _StubOllama())

    dialog = sct.SettingsDialog(sct.Theme(), None, _StubOllama(), None)
    try:
        dialog.enable_interpreter.setChecked(True)
        values = dialog.values()
        assert values["enable_interpreter"] is True

        dialog.enable_interpreter.setChecked(False)
        values = dialog.values()
        assert values["enable_interpreter"] is False
    finally:
        dialog.close()


def test_settings_dialog_scan_roots_requires_trusted(monkeypatch, tmp_path):
    _ensure_app()

    class _StubOllama:
        def list_models(self):
            return True, ["stub-model"], "ok"

    monkeypatch.setattr(sct, "OllamaClient", lambda: _StubOllama())

    dialog = sct.SettingsDialog(sct.Theme(), None, _StubOllama(), None)
    try:
        existing_root = tmp_path / "existing"
        existing_root.mkdir()
        dialog.set_scan_roots([str(existing_root)])

        assert dialog.scan_roots_list.count() == 1
        assert dialog.scan_roots_list.isEnabled() is False

        values = dialog.values()
        assert values["codex"]["scan_roots"] == []

        dialog.apply_sandbox_settings({"level": "trusted", "approval_policy": "require_approval"})
        assert dialog.scan_roots_list.isEnabled() is True

        new_root = tmp_path / "other"
        new_root.mkdir()
        monkeypatch.setattr(
            sct.QFileDialog,
            "getExistingDirectory",
            lambda *args, **kwargs: str(new_root),
        )
        dialog._on_add_scan_root()

        values = dialog.values()
        normalized = str(new_root.resolve())
        assert values["codex"]["scan_roots"] == [normalized]
        assert values["scan_roots"] == [normalized]
    finally:
        dialog.close()
```

**Functions:** _ensure_app(), test_settings_dialog_round_trips_interpreter(monkeypatch), test_settings_dialog_scan_roots_requires_trusted(monkeypatch, tmp_path)


## Module `tests\test_start_panel_icons.py`

```python
import pytest
from PySide6.QtGui import QColor, QIcon, QPixmap
from PySide6.QtWidgets import QApplication, QStyle

from Virtual_Desktop import VirtualDesktopCore


def _ensure_app() -> QApplication:
    app = QApplication.instance()
    if app is None:
        app = QApplication([])
    return app


def test_start_panel_prefers_helper_icon(monkeypatch, tmp_path):
    _ensure_app()
    core = VirtualDesktopCore(workspace=str(tmp_path))
    panel = core.start_panel

    blend_path = tmp_path / "scene.blend"
    blend_path.write_text("blend data")

    pixmap = QPixmap(32, 32)
    pixmap.fill(QColor("orange"))
    blender_icon = QIcon(pixmap)

    call_count = 0

    def fake_helper(path_obj):
        nonlocal call_count
        call_count += 1
        return blender_icon, True

    monkeypatch.setattr("Virtual_Desktop._ICON_FOR_PATH_HELPER", fake_helper, raising=False)

    item = {"title": "Scene", "kind": "doc", "path": str(blend_path)}
    icon = panel._icon_for_item("Recent", item)
    assert icon.cacheKey() == blender_icon.cacheKey()

    icon_again = panel._icon_for_item("Recent", item)
    assert icon_again.cacheKey() == blender_icon.cacheKey()
    assert call_count == 1, "Expected path icon helper to be cached per absolute path"


def test_start_panel_falls_back_when_helper_null(monkeypatch, tmp_path):
    _ensure_app()
    core = VirtualDesktopCore(workspace=str(tmp_path))
    panel = core.start_panel

    doc_path = tmp_path / "notes.txt"
    doc_path.write_text("notes")

    call_count = 0

    def fake_helper(_):
        nonlocal call_count
        call_count += 1
        return QIcon(), True

    monkeypatch.setattr("Virtual_Desktop._ICON_FOR_PATH_HELPER", fake_helper, raising=False)

    item = {"title": "Notes", "kind": "doc", "path": str(doc_path)}
    icon = panel._icon_for_item("Files", item)
    expected = QApplication.style().standardIcon(QStyle.SP_FileDialogDetailedView)
    assert icon.cacheKey() == expected.cacheKey()

    icon_again = panel._icon_for_item("Files", item)
    assert icon_again.cacheKey() == expected.cacheKey()
    assert call_count == 1
```

**Functions:** _ensure_app(), test_start_panel_prefers_helper_icon(monkeypatch, tmp_path), test_start_panel_falls_back_when_helper_null(monkeypatch, tmp_path)


## Module `tests\test_system_metrics.py`

```python
import json
from pathlib import Path

import pytest

from metrics_manager import fetch_metrics
from tools import system_metrics


def _write_jsonl(path: Path, items: list[dict]) -> None:
    path.parent.mkdir(parents=True, exist_ok=True)
    with path.open("w", encoding="utf-8") as handle:
        for item in items:
            handle.write(json.dumps(item) + "\n")


def test_collect_metrics_aggregates_files(tmp_path: Path) -> None:
    script = tmp_path / "module.py"
    script.write_text("print('hello')\nprint('world')\n", encoding="utf-8")

    datasets_root = tmp_path / "datasets"
    _write_jsonl(
        datasets_root / "tasks.jsonl",
        [
            {
                "id": "tsk_1",
                "updated_ts": 123.0,
                "files": [str(script)],
            }
        ],
    )
    _write_jsonl(
        datasets_root / "errors.jsonl",
        [
            {
                "ts": 120.0,
                "level": "ERROR",
                "kind": "RuntimeError",
                "msg": "boom",
                "path": str(script),
            },
            {
                "ts": 100.0,
                "level": "WARNING",
                "kind": "UserWarning",
                "msg": "heads up",
                "path": str(script),
            },
        ],
    )

    summary = system_metrics.collect_metrics(
        targets=[script],
        datasets_root=datasets_root,
        store=False,
        error_limit=1,
    )

    assert "generated_at" in summary
    assert summary["runtime_ms"] >= 0
    components = summary["components"]
    assert isinstance(components, dict)
    assert components

    component_data = next(iter(components.values()))
    assert component_data["file_count"] == 1
    assert component_data["total_lines"] == 2
    assert component_data["error_count"] == 1

    script_metrics = next(iter(component_data["scripts"].values()))
    assert script_metrics["line_count"] == 2
    assert script_metrics["last_run_ts"] == pytest.approx(123.0)
    assert script_metrics["error_count"] == 1
    errors = script_metrics["errors"]
    assert errors
    assert errors[0]["msg"] == "boom"


def test_collect_metrics_persists_via_manager(tmp_path: Path) -> None:
    script = tmp_path / "app.py"
    script.write_text("print('x')\n", encoding="utf-8")
    datasets_root = tmp_path / "datasets"
    db_path = tmp_path / "metrics.db"

    summary = system_metrics.collect_metrics(
        targets=[script],
        datasets_root=datasets_root,
        db_path=db_path,
        store=True,
    )

    assert db_path.exists()

    rows = fetch_metrics(scope="local", db_paths={"local": db_path})
    assert rows, "expected at least one metrics row"
    row = rows[0]
    assert row["timestamp"] == pytest.approx(summary["generated_at"])
    assert row["runtime_ms"] == pytest.approx(summary["runtime_ms"])
    assert row["score"] == pytest.approx(1.0)
    assert row["script_path"].endswith("app.py")
    assert row["component"].endswith("app.py")
    metadata = row["metadata"]
    assert isinstance(metadata, dict)
    assert metadata["line_count"] == 1
```

**Functions:** _write_jsonl(path, items), test_collect_metrics_aggregates_files(tmp_path), test_collect_metrics_persists_via_manager(tmp_path)


## Module `tests\test_system_overview.py`

```python
import time

from Virtual_Desktop import (
    _filter_metrics_rows,
    _flatten_metrics_summary,
    _last_run_bucket,
    _score_bucket_key,
    _score_distribution,
    _script_type_label,
)


def test_script_type_label_variants():
    assert _script_type_label("tests/test_demo.py") == "Tests"
    assert _script_type_label("tasks/card.py") == "Tasks"
    assert _script_type_label("tools/helper.py") == "Tools"
    assert _script_type_label("Virtual_Desktop.py") == "Desktop"
    assert _script_type_label("Codex_Terminal.py") == "Terminal"
    assert _script_type_label("scripts/runner.py") == "Python"
    assert _script_type_label("") == "Unknown"


def test_score_bucket_key_thresholds():
    assert _score_bucket_key(0.9) == "healthy"
    assert _score_bucket_key(0.65) == "watch"
    assert _score_bucket_key(0.25) == "critical"
    assert _score_bucket_key(None) == "unknown"


def test_last_run_bucket_thresholds():
    now = time.time()
    assert _last_run_bucket(None, now=now) == "never"
    assert _last_run_bucket(now - 10, now=now) == "recent"
    assert _last_run_bucket(now - 90000, now=now) == "stale"


def test_flatten_metrics_summary_and_filters():
    now = time.time()
    summary = {
        "generated_at": now,
        "components": {
            "tasks": {
                "scripts": {
                    "tasks/card.py": {
                        "line_count": 120,
                        "error_count": 2,
                        "last_run_ts": now - 3600,
                        "last_modified": now - 7200,
                    },
                    "tests/test_card.py": {
                        "line_count": 50,
                        "error_count": 0,
                        "last_run_ts": None,
                        "last_modified": now - 3600,
                    },
                }
            }
        },
    }
    rows = _flatten_metrics_summary(summary, now=now)
    assert len(rows) == 2

    critical_rows = [
        row for row in rows if row["script_path"] == "tasks/card.py"
    ]
    assert critical_rows
    assert critical_rows[0]["score_bucket"] == "critical"
    assert critical_rows[0]["last_run_bucket"] == "recent"

    filtered = _filter_metrics_rows(
        rows,
        script_type="Tasks",
        last_run="recent",
        score_bucket="critical",
    )
    assert len(filtered) == 1
    assert filtered[0]["script_path"] == "tasks/card.py"

    none_match = _filter_metrics_rows(
        rows,
        script_type="Tests",
        score_bucket="critical",
    )
    assert none_match == []


def test_score_distribution_counts():
    rows = [
        {"score_bucket": "healthy"},
        {"score_bucket": "healthy"},
        {"score_bucket": "watch"},
        {"score_bucket": "critical"},
        {"score_bucket": "unknown"},
        {},
    ]
    counts = _score_distribution(rows)
    assert counts["healthy"] == 2
    assert counts["watch"] == 1
    assert counts["critical"] == 1
    assert counts["unknown"] == 2
```

**Functions:** test_script_type_label_variants(), test_score_bucket_key_thresholds(), test_last_run_bucket_thresholds(), test_flatten_metrics_summary_and_filters(), test_score_distribution_counts()


## Module `tests\test_taskbar_geometry.py`

```python
import os

import pytest
from PySide6.QtCore import QPoint, QRect, QSize, QEvent
from PySide6.QtGui import QCursor
from PySide6.QtWidgets import QApplication

import Virtual_Desktop as vd


def _ensure_app():
    app = QApplication.instance()
    if app is None:
        app = QApplication([])
    return app


def _remove_state():
    if os.path.isfile(vd.STATE_PATH):
        os.remove(vd.STATE_PATH)


def test_taskbar_insets_by_side():
    _remove_state()
    app = _ensure_app()
    core = vd.VirtualDesktopCore()
    try:
        for side in ("bottom", "top", "left", "right"):
            core.set_taskbar_side(side, persist=False)
            app.processEvents()
            assert core.taskbar_side() == side
            insets = core.taskbar_insets()
            for key, value in insets.items():
                if key == side:
                    assert value > 0
                else:
                    assert value == 0
    finally:
        core.deleteLater()
        _remove_state()


def test_windows_taskbar_offset_helper(monkeypatch):
    _remove_state()
    app = _ensure_app()
    core = vd.VirtualDesktopCore()
    try:
        core.set_taskbar_side("bottom", persist=False)
        app.processEvents()
        core._last_synced_size = None
        monkeypatch.setattr(
            core,
            "_current_screen_size",
            lambda: QSize(1920, 1080),
        )
        class DummyScreen:
            def __init__(self, avail_height: int):
                self._avail_height = avail_height

            def geometry(self):
                return QRect(0, 0, 1920, 1080)

            def availableGeometry(self):
                return QRect(0, 0, 1920, self._avail_height)

        dummy_screen = DummyScreen(1032)
        monkeypatch.setattr(core, "_current_screen", lambda: dummy_screen)

        monkeypatch.setattr(core, "_is_window_maximized", lambda: True)
        monkeypatch.setattr(core, "_is_borderless_fullscreen", lambda: False)
        monkeypatch.setattr(
            type(core),
            "_native_windows_taskbar_height",
            staticmethod(lambda: 48),
        )
        core._sync_canvas_to_screen()
        assert core.canvas.height() == 1032

        core._last_synced_size = None
        dummy_screen._avail_height = 1040
        monkeypatch.setattr(
            type(core),
            "_native_windows_taskbar_height",
            staticmethod(lambda: 0),
        )
        core._sync_canvas_to_screen()
        assert core.canvas.height() == 1040

        core._last_synced_size = None
        monkeypatch.setattr(core, "_is_window_maximized", lambda: False)
        core._sync_canvas_to_screen()
        assert core.canvas.height() == 1080

        core._last_synced_size = None
        core.set_taskbar_side("top", persist=False)
        app.processEvents()
        monkeypatch.setattr(core, "_is_window_maximized", lambda: True)
        monkeypatch.setattr(core, "_is_borderless_fullscreen", lambda: True)
        core._sync_canvas_to_screen()
        assert core.canvas.height() == 1080
    finally:
        core.deleteLater()
        _remove_state()


def test_start_panel_geometry_all_sides():
    core_rect = QRect(0, 0, 1200, 900)
    thickness = 50
    panel_size = QSize(400, 300)
    taskbar_rects = {
        "bottom": QRect(
            0,
            core_rect.height() - thickness,
            core_rect.width(),
            thickness,
        ),
        "top": QRect(0, 0, core_rect.width(), thickness),
        "left": QRect(0, 0, thickness, core_rect.height()),
        "right": QRect(
            core_rect.width() - thickness,
            0,
            thickness,
            core_rect.height(),
        ),
    }
    start_rects = {
        "bottom": QRect(20, core_rect.height() - thickness + 5, 120, 40),
        "top": QRect(20, 5, 120, 40),
        "left": QRect(5, 60, 120, 40),
        "right": QRect(
            core_rect.width() - thickness + 5,
            60,
            120,
            40,
        ),
    }

    geom_bottom = vd.VirtualDesktopCore._start_panel_geometry_for_side(
        "bottom",
        core_rect,
        taskbar_rects["bottom"],
        start_rects["bottom"],
        panel_size,
    )
    # sanity for QRect creation
    assert geom_bottom.topLeft() == geom_bottom.topLeft()
    assert (
        geom_bottom.y()
        == core_rect.height() - thickness - panel_size.height() + 2
    )

    geom_top = vd.VirtualDesktopCore._start_panel_geometry_for_side(
        "top",
        core_rect,
        taskbar_rects["top"],
        start_rects["top"],
        panel_size,
    )
    assert geom_top.y() == taskbar_rects["top"].bottom() + 2

    geom_left = vd.VirtualDesktopCore._start_panel_geometry_for_side(
        "left",
        core_rect,
        taskbar_rects["left"],
        start_rects["left"],
        panel_size,
    )
    assert geom_left.x() == taskbar_rects["left"].right() + 2

    geom_right = vd.VirtualDesktopCore._start_panel_geometry_for_side(
        "right",
        core_rect,
        taskbar_rects["right"],
        start_rects["right"],
        panel_size,
    )
    expected_x = taskbar_rects["right"].left() - panel_size.width() - 2
    assert geom_right.x() == expected_x
    assert geom_right.width() == panel_size.width()
    assert geom_right.height() == panel_size.height()


def test_start_panel_auto_hides_when_cursor_leaves(monkeypatch):
    _remove_state()
    app = _ensure_app()
    core = vd.VirtualDesktopCore()
    try:
        core.set_taskbar_side("bottom", persist=False)
        app.processEvents()
        core._toggle_start_panel()
        app.processEvents()
        panel = core.start_panel
        assert panel.isVisible()

        panel.enterEvent(QEvent(QEvent.Enter))
        outside = panel.mapToGlobal(QPoint(panel.width() + 50, panel.height() + 50))
        monkeypatch.setattr(QCursor, "pos", staticmethod(lambda: outside))

        panel.leaveEvent(QEvent(QEvent.Leave))
        app.processEvents()
        assert not panel.isVisible()
    finally:
        core.deleteLater()
        _remove_state()


@pytest.mark.parametrize("side", ["bottom", "top", "left", "right"])
def test_start_panel_geometry_matches_taskbar_side(side):
    _remove_state()
    app = _ensure_app()
    core = vd.VirtualDesktopCore()
    try:
        core.set_taskbar_side(side, persist=False)
        app.processEvents()
        core._toggle_start_panel()
        app.processEvents()
        panel = core.start_panel
        assert panel.property("side") == side
        expected = core._compute_start_panel_rect(panel.size())
        assert panel.geometry() == expected

        core._hide_start_panel()
        app.processEvents()
        assert not panel.isVisible()
    finally:
        core.deleteLater()
        _remove_state()
```

**Functions:** _ensure_app(), _remove_state(), test_taskbar_insets_by_side(), test_windows_taskbar_offset_helper(monkeypatch), test_start_panel_geometry_all_sides(), test_start_panel_auto_hides_when_cursor_leaves(monkeypatch), test_start_panel_geometry_matches_taskbar_side(side)


## Module `tests\test_tasks_bus.py`

```python
import importlib

import pytest

from tasks import bus


@pytest.fixture(autouse=True)
def reset_bus():
    importlib.reload(bus)
    yield
    importlib.reload(bus)


def test_publish_notifies_subscribers(reset_bus):
    received: list[dict] = []
    handle = bus.subscribe("task.created", received.append)

    bus.publish("task.created", {"id": "tsk_1"})

    assert received == [{"id": "tsk_1"}]
    handle.unsubscribe()


def test_publish_notifies_multiple_subscribers(reset_bus):
    results: list[str] = []

    def recorder(label: str):
        def _record(payload: dict) -> None:
            results.append(f"{label}:{payload['id']}")

        return _record

    handle_a = bus.subscribe("task.updated", recorder("a"))
    handle_b = bus.subscribe("task.updated", recorder("b"))

    bus.publish("task.updated", {"id": "tsk_1", "status": "open"})

    assert sorted(results) == ["a:tsk_1", "b:tsk_1"]
    handle_a.unsubscribe()
    handle_b.unsubscribe()


def test_unsubscribe_stops_notifications(reset_bus):
    calls: list[dict] = []
    handle = bus.subscribe("task.status", calls.append)

    handle.unsubscribe()
    bus.publish("task.status", {"id": "tsk_2", "status": "merged"})

    assert calls == []


def test_invalid_topics_raise(reset_bus):
    with pytest.raises(ValueError):
        bus.subscribe("task.invalid", lambda payload: None)

    with pytest.raises(ValueError):
        bus.publish("task.invalid", {})


def test_system_metrics_topic(reset_bus):
    received: list[dict] = []
    handle = bus.subscribe("system.metrics", received.append)

    bus.publish("system.metrics", {"generated_at": 123.0})

    assert received == [{"generated_at": 123.0}]
    handle.unsubscribe()


def test_wildcard_receives_all(reset_bus):
    topics: list[str] = []

    def _capture(payload: dict) -> None:
        topics.append(payload["topic"])

    handle = bus.subscribe("task.*", _capture)

    bus.publish("task.created", {"topic": "task.created"})
    bus.publish("task.deleted", {"topic": "task.deleted"})

    assert topics == ["task.created", "task.deleted"]
    handle.unsubscribe()


def test_subscribe_requires_callable(reset_bus):
    with pytest.raises(TypeError):
        bus.subscribe("task.created", None)


def test_publish_requires_dict(reset_bus):
    with pytest.raises(TypeError):
        bus.publish("task.created", object())
```

**Functions:** reset_bus(), test_publish_notifies_subscribers(reset_bus), test_publish_notifies_multiple_subscribers(reset_bus), test_unsubscribe_stops_notifications(reset_bus), test_invalid_topics_raise(reset_bus), test_system_metrics_topic(reset_bus), test_wildcard_receives_all(reset_bus), test_subscribe_requires_callable(reset_bus), test_publish_requires_dict(reset_bus)


## Module `tests\test_tasks_diffs.py`

```python
import json
import subprocess
from pathlib import Path

import pytest

from tasks import diffs as task_diffs
from tasks import models as task_models
from tasks.bus import subscribe
from tasks.models import Task, TaskDiffSummary, append_task


@pytest.fixture(autouse=True)
def _isolate_datasets(tmp_path, monkeypatch):
    dataset_root = tmp_path / "datasets"
    replacements = {
        "DATASETS_DIR": dataset_root,
        "TASKS_FILE": dataset_root / "tasks.jsonl",
        "EVENTS_FILE": dataset_root / "task_events.jsonl",
        "DIFFS_FILE": dataset_root / "diffs.jsonl",
    }
    for attr, value in replacements.items():
        monkeypatch.setattr(task_models, attr, value, raising=False)

    diff_replacements = {
        "DATASETS_DIR": dataset_root,
        "DIFFS_FILE": dataset_root / "diffs.jsonl",
        "_SNAPSHOT_ROOT": dataset_root / "runs",
    }
    for attr, value in diff_replacements.items():
        monkeypatch.setattr(task_diffs, attr, value, raising=False)
    yield


@pytest.fixture(autouse=True)
def _reset_bus(monkeypatch):
    from collections import defaultdict

    from tasks import bus

    fresh = defaultdict(list)
    monkeypatch.setattr(bus, "_SUBSCRIBERS", fresh, raising=False)
    yield
    monkeypatch.setattr(bus, "_SUBSCRIBERS", defaultdict(list), raising=False)


def _read_jsonl(path: Path) -> list[dict]:
    if not path.exists():
        return []
    contents = path.read_text(encoding="utf-8")
    lines = (line for line in contents.splitlines() if line)
    return [json.loads(line) for line in lines]


def _create_task(task_id: str) -> Task:
    task = Task(
        id=task_id,
        title="Task",
        status="open",
        created_ts=1.0,
        updated_ts=1.0,
        session_id="sess",
        source="terminal",
        diffs=TaskDiffSummary(),
    )
    append_task(task)
    return task


def test_record_diff_uses_git_numstat_when_available(tmp_path):
    repo = tmp_path / "repo"
    repo.mkdir()

    subprocess.run(
        ["git", "init"],
        cwd=repo,
        check=True,
        stdout=subprocess.PIPE,
    )
    subprocess.run(
        ["git", "config", "user.email", "codex@example.com"],
        cwd=repo,
        check=True,
    )
    subprocess.run(
        ["git", "config", "user.name", "Codex"],
        cwd=repo,
        check=True,
    )

    sample = repo / "sample.txt"
    sample.write_text("alpha\nbeta\n", encoding="utf-8")
    subprocess.run(["git", "add", "sample.txt"], cwd=repo, check=True)
    subprocess.run(["git", "commit", "-m", "init"], cwd=repo, check=True)

    sample.write_text("alpha\nbeta updated\ncharlie\n", encoding="utf-8")

    _create_task("tsk_git")

    events: list[dict] = []
    handle = subscribe("task.diff", lambda payload: events.append(payload))

    snapshot = task_diffs.record_diff("tsk_git", workspace_root=repo)

    handle.unsubscribe()

    assert snapshot is not None
    assert snapshot.added == 2
    assert snapshot.removed == 1
    assert snapshot.files == ["sample.txt"]

    diff_records = _read_jsonl(task_models.DIFFS_FILE)
    assert diff_records == [
        {
            "ts": pytest.approx(snapshot.ts, rel=0, abs=0.001),
            "task_id": "tsk_git",
            "added": 2,
            "removed": 1,
            "files": ["sample.txt"],
        }
    ]

    task_records = _read_jsonl(task_models.TASKS_FILE)
    stored = next(item for item in task_records if item["id"] == "tsk_git")
    assert stored["diffs"] == {"added": 2, "removed": 1}

    expected_event = {
        "id": "tsk_git",
        "added": 2,
        "removed": 1,
        "files": ["sample.txt"],
    }
    assert events == [expected_event]


def test_record_diff_falls_back_to_snapshots_for_non_git_files(tmp_path):
    workspace = tmp_path / "workspace"
    workspace.mkdir()

    target = workspace / "notes.txt"
    target.write_text("first\nsecond\n", encoding="utf-8")

    _create_task("tsk_snap")

    events: list[dict] = []
    handle = subscribe("task.diff", lambda payload: events.append(payload))

    first = task_diffs.record_diff(
        "tsk_snap",
        files=["notes.txt"],
        workspace_root=workspace,
    )
    assert first is not None
    assert first.added == 2
    assert first.removed == 0
    assert first.files == ["notes.txt"]

    target.write_text("first\nthird\n", encoding="utf-8")

    second = task_diffs.record_diff(
        "tsk_snap",
        files=["notes.txt"],
        workspace_root=workspace,
    )

    handle.unsubscribe()

    assert second is not None
    assert second.added == 1
    assert second.removed == 1
    assert second.files == ["notes.txt"]

    diff_records = _read_jsonl(task_models.DIFFS_FILE)
    assert len(diff_records) == 2
    assert diff_records[0]["added"] == 2
    assert diff_records[0]["removed"] == 0
    assert diff_records[1]["added"] == 1
    assert diff_records[1]["removed"] == 1

    task_records = _read_jsonl(task_models.TASKS_FILE)
    stored = next(item for item in task_records if item["id"] == "tsk_snap")
    assert stored["diffs"] == {"added": 1, "removed": 1}

    snapshot_path = task_diffs._snapshot_file("tsk_snap", "notes.txt")
    assert snapshot_path.exists()
    assert snapshot_path.read_text(encoding="utf-8") == "first\nthird"

    assert events[0]["added"] == 2
    assert events[1]["added"] == 1
```

**Functions:** _isolate_datasets(tmp_path, monkeypatch), _reset_bus(monkeypatch), _read_jsonl(path), _create_task(task_id), test_record_diff_uses_git_numstat_when_available(tmp_path), test_record_diff_falls_back_to_snapshots_for_non_git_files(tmp_path)


## Module `tests\test_tasks_models.py`

```python
from __future__ import annotations

import json
from pathlib import Path

import pytest

from tasks import models as task_models
from tasks.models import (
    DiffSnapshot,
    ErrorRecord,
    Task,
    TaskDiffSummary,
    TaskEvent,
    append_error_record,
    append_event,
    append_run_log,
    append_run_output,
    append_task,
    load_run_log_tail,
    update_task,
)


@pytest.fixture(autouse=True)
def _isolate_datasets(tmp_path, monkeypatch):
    monkeypatch.setattr(task_models, "DATASETS_DIR", tmp_path, raising=False)
    monkeypatch.setattr(
        task_models,
        "TASKS_FILE",
        tmp_path / "tasks.jsonl",
        raising=False,
    )
    monkeypatch.setattr(
        task_models,
        "EVENTS_FILE",
        tmp_path / "task_events.jsonl",
        raising=False,
    )
    monkeypatch.setattr(
        task_models,
        "DIFFS_FILE",
        tmp_path / "diffs.jsonl",
        raising=False,
    )
    monkeypatch.setattr(
        task_models,
        "ERRORS_FILE",
        tmp_path / "errors.jsonl",
        raising=False,
    )
    yield


def read_jsonl(path: Path) -> list[dict]:
    if not path.exists():
        return []
    lines = path.read_text(encoding="utf-8").splitlines()
    return [json.loads(line) for line in lines if line]


def test_append_error_record_appends_jsonl():
    record = ErrorRecord(
        ts=123.456,
        level="ERROR",
        kind="UI",
        msg="Widget failed",
        path="/tmp/example.py",
        task_id="tsk_7",
    )

    append_error_record(record)

    records = read_jsonl(task_models.ERRORS_FILE)
    assert records == [
        {
            "ts": record.ts,
            "level": "ERROR",
            "kind": "UI",
            "msg": "Widget failed",
            "path": "/tmp/example.py",
            "task_id": "tsk_7",
        }
    ]


def test_append_task_writes_jsonl():
    task = Task(
        id="tsk_1",
        title="Initial setup",
        status="open",
        created_ts=1.0,
        updated_ts=1.0,
        session_id="sess",
        source="terminal",
        labels=["bootstrap"],
        diffs=TaskDiffSummary(
            added=10,
            removed=2,
        ),
        files=["README.md"],
        run_log_path="runs/tsk_1.log",
    )

    append_task(task)

    records = read_jsonl(task_models.TASKS_FILE)
    assert records == [
        {
            "id": "tsk_1",
            "title": "Initial setup",
            "status": "open",
            "created_ts": 1.0,
            "updated_ts": 1.0,
            "session_id": "sess",
            "source": "terminal",
            "labels": ["bootstrap"],
            "diffs": {"added": 10, "removed": 2},
            "files": ["README.md"],
            "run_log_path": "runs/tsk_1.log",
            "codex_conversation_id": None,
            "parent_id": None,
        }
    ]


def test_update_task_rewrites_atomically():
    first = Task(
        id="tsk_1",
        title="Initial setup",
        status="open",
        created_ts=1.0,
        updated_ts=1.0,
        session_id="sess",
        source="terminal",
    )
    second = Task(
        id="tsk_2",
        title="Follow-up",
        status="open",
        created_ts=2.0,
        updated_ts=2.0,
        session_id="sess",
        source="terminal",
    )
    append_task(first)
    append_task(second)

    updated = update_task("tsk_2", status="merged", updated_ts=3.0)

    assert updated.status == "merged"
    assert updated.updated_ts == 3.0

    records = read_jsonl(task_models.TASKS_FILE)
    statuses = {item["id"]: item["status"] for item in records}
    assert statuses == {"tsk_1": "open", "tsk_2": "merged"}
    assert not any(
        path.name.endswith(".tmp")
        for path in task_models.TASKS_FILE.parent.iterdir()
    )


def test_update_task_missing_id_raises():
    append_task(
        Task(
            id="tsk_1",
            title="Initial",
            status="open",
            created_ts=1.0,
            updated_ts=1.0,
            session_id="sess",
            source="terminal",
        )
    )

    with pytest.raises(ValueError):
        update_task("missing", status="closed")


def test_append_event_appends_line():
    event = TaskEvent(ts=5.0, task_id="tsk_1", event="created", by="terminal")
    append_event(event)

    records = read_jsonl(task_models.EVENTS_FILE)
    assert records == [
        {"ts": 5.0, "task_id": "tsk_1", "event": "created", "by": "terminal"}
    ]


def test_diff_snapshot_to_dict_includes_files():
    snapshot = DiffSnapshot(
        ts=10.0,
        task_id="tsk_1",
        added=5,
        removed=1,
        files=["a.py"],
    )
    assert snapshot.to_dict() == {
        "ts": 10.0,
        "task_id": "tsk_1",
        "added": 5,
        "removed": 1,
        "files": ["a.py"],
    }


def test_append_run_log_creates_directory(tmp_path):
    task = Task(
        id="tsk_run",
        title="Capture output",
        status="open",
        created_ts=1.0,
        updated_ts=1.0,
        session_id="sess",
        source="terminal",
    )

    path, relative, created = append_run_log(
        task,
        "first line",
        dataset_root=tmp_path,
    )

    assert created is True
    assert relative == f"runs/{task.id}/run.log"
    assert path == tmp_path / relative
    assert path.read_text(encoding="utf-8").splitlines() == ["first line"]

    _, _, created_again = append_run_log(
        task,
        ["second line"],
        dataset_root=tmp_path,
    )
    assert created_again is False
    assert path.read_text(encoding="utf-8").splitlines() == [
        "first line",
        "second line",
    ]


def test_append_run_output_labels_streams(tmp_path):
    task = Task(
        id="tsk_output",
        title="Stream capture",
        status="open",
        created_ts=1.0,
        updated_ts=1.0,
        session_id="sess",
        source="terminal",
    )

    append_run_output(
        task,
        stdout="hello\nworld\n",
        stderr="oops\n",
        dataset_root=tmp_path,
    )

    log_path = tmp_path / Path(task.run_log_path)
    lines = log_path.read_text(encoding="utf-8").splitlines()
    assert "[stdout] hello" in lines
    assert "[stdout] world" in lines
    assert "[stderr] oops" in lines


def test_load_run_log_tail_returns_recent_lines(tmp_path):
    run_rel = "runs/tsk_tail/run.log"
    task = Task(
        id="tsk_tail",
        title="Tail check",
        status="open",
        created_ts=1.0,
        updated_ts=1.0,
        session_id="sess",
        source="terminal",
        run_log_path=run_rel,
    )

    run_path = tmp_path / Path(run_rel)
    run_path.parent.mkdir(parents=True, exist_ok=True)
    lines = [f"line {idx}" for idx in range(10)]
    run_path.write_text("\n".join(lines) + "\n", encoding="utf-8")

    tail = load_run_log_tail(task, tmp_path, max_lines=3)

    assert tail == lines[-3:]
```

**Functions:** _isolate_datasets(tmp_path, monkeypatch), read_jsonl(path), test_append_error_record_appends_jsonl(), test_append_task_writes_jsonl(), test_update_task_rewrites_atomically(), test_update_task_missing_id_raises(), test_append_event_appends_line(), test_diff_snapshot_to_dict_includes_files(), test_append_run_log_creates_directory(tmp_path), test_append_run_output_labels_streams(tmp_path), test_load_run_log_tail_returns_recent_lines(tmp_path)


## Module `tests\test_task_panel.py`

```python
import json
from pathlib import Path

import pytest
from PySide6.QtCore import Qt
from PySide6.QtWidgets import QApplication, QMainWindow

from tasks.task_panel import TaskPanel


STATUSES = ["Open", "Merged", "Closed", "Cancelled", "Failed", "Deleted"]


def _ensure_app():
    app = QApplication.instance()
    if app is None:
        app = QApplication([])
    return app


def _write_task(path: Path, **overrides):
    payload = {
        "id": overrides.get("id", "tsk_1"),
        "title": overrides.get("title", "Task"),
        "status": overrides.get("status", "open"),
        "created_ts": overrides.get("created_ts", 1_695_000_000.0),
        "updated_ts": overrides.get("updated_ts", 1_695_000_000.0),
        "session_id": overrides.get("session_id", "sess"),
        "source": overrides.get("source", "terminal"),
        "labels": overrides.get("labels", []),
        "diffs": overrides.get("diffs", {"added": 1, "removed": 0}),
        "files": overrides.get("files", []),
        "run_log_path": overrides.get("run_log_path"),
        "codex_conversation_id": overrides.get("codex_conversation_id"),
        "parent_id": overrides.get("parent_id"),
    }
    with path.open("a", encoding="utf-8") as fh:
        fh.write(json.dumps(payload) + "\n")


def test_refresh_and_filtering(tmp_path):
    _ensure_app()
    dataset = tmp_path / "tasks.jsonl"
    _write_task(
        dataset,
        id="tsk_open",
        title="Investigate render glitch",
        status="open",
    )
    _write_task(
        dataset,
        id="tsk_merge",
        title="Refactor panel logic",
        status="merged",
        labels=["ui"],
    )
    _write_task(dataset, id="tsk_fail", title="Nightly build", status="failed")

    win = QMainWindow()
    panel = TaskPanel(dataset, win)
    win.addDockWidget(Qt.RightDockWidgetArea, panel)

    assert panel.list.count() == 3

    panel.filter_combo.setCurrentText("Merged")
    assert panel.list.count() == 1

    panel.filter_combo.setCurrentText("All")
    panel.search_edit.setText("panel")
    assert panel.list.count() == 1
    item = panel.list.item(0)
    assert item.data(Qt.UserRole) == "tsk_merge"


@pytest.mark.parametrize("status_label", STATUSES)
def test_status_change_signal(tmp_path, status_label):
    _ensure_app()
    dataset = tmp_path / "tasks.jsonl"
    _write_task(dataset, id="tsk_edit", title="Editable", status="open")

    win = QMainWindow()
    panel = TaskPanel(dataset, win)
    win.addDockWidget(Qt.RightDockWidgetArea, panel)

    # Select first row to populate detail view
    panel.list.setCurrentRow(0)
    emitted: list[tuple[str, str]] = []

    def _capture(task_id: str, status: str) -> None:
        emitted.append((task_id, status))

    panel.status_changed.connect(_capture)

    if status_label == "Open":
        pytest.skip("No change emitted when status remains identical")

    index = panel.status_combo.findText(status_label)
    assert index >= 0
    panel.status_combo.setCurrentIndex(index)
    panel.status_apply.click()

    assert emitted == [("tsk_edit", status_label.lower())]


def test_new_task_signal(tmp_path):
    _ensure_app()
    dataset = tmp_path / "tasks.jsonl"
    _write_task(dataset, id="tsk_edit", title="Editable", status="open")

    win = QMainWindow()
    panel = TaskPanel(dataset, win)
    win.addDockWidget(Qt.RightDockWidgetArea, panel)

    payloads: list[str] = []
    panel.new_taskRequested.connect(payloads.append)

    panel.new_task_input.setText("Document architecture")
    panel.new_task_input.returnPressed.emit()

    assert payloads == ["Document architecture"]


def test_detail_populates_run_log_tail(tmp_path):
    _ensure_app()
    dataset = tmp_path / "tasks.jsonl"
    run_rel = "runs/tsk_log/run.log"
    run_path = tmp_path / run_rel
    run_path.parent.mkdir(parents=True, exist_ok=True)
    run_path.write_text("first\nsecond\nthird\n", encoding="utf-8")
    _write_task(
        dataset,
        id="tsk_log",
        title="Review",
        status="open",
        run_log_path=run_rel,
    )

    win = QMainWindow()
    panel = TaskPanel(dataset, win)
    win.addDockWidget(Qt.RightDockWidgetArea, panel)

    panel.list.setCurrentRow(0)

    log_text = panel.detail_log.toPlainText()
    assert "second" in log_text
    assert "third" in log_text


def test_load_conversation_button_emits_signal(tmp_path):
    _ensure_app()
    dataset = tmp_path / "tasks.jsonl"
    _write_task(
        dataset,
        id="tsk_linked",
        title="Linked",
        status="open",
        codex_conversation_id="conv_123",
    )
    _write_task(dataset, id="tsk_plain", title="Plain", status="open", session_id="")

    win = QMainWindow()
    panel = TaskPanel(dataset, win)
    win.addDockWidget(Qt.RightDockWidgetArea, panel)

    captured: list[tuple[str, str]] = []

    def _capture(task_id: str, conversation_id: str) -> None:
        captured.append((task_id, conversation_id))

    panel.load_conversationRequested.connect(_capture)

    panel.list.setCurrentRow(0)
    QApplication.processEvents()
    assert panel.load_conversation_btn.isEnabled()
    panel.load_conversation_btn.click()
    assert captured == [("tsk_linked", "conv_123")]

    panel.list.setCurrentRow(1)
    QApplication.processEvents()
    assert not panel.load_conversation_btn.isEnabled()
```

**Functions:** _ensure_app(), _write_task(path), test_refresh_and_filtering(tmp_path), test_status_change_signal(tmp_path, status_label), test_new_task_signal(tmp_path), test_detail_populates_run_log_tail(tmp_path), test_load_conversation_button_emits_signal(tmp_path)


## Module `tests\test_terminal_desktop_context_menu.py`

```python
import json

import Codex_Terminal as sct


def _ensure_app():
    app = sct.QApplication.instance()
    if app is None:
        app = sct.QApplication([])
    return app


def test_terminal_desktop_context_menu_creates_entries(monkeypatch, tmp_path):
    app = _ensure_app()
    monkeypatch.setattr(sct.OllamaClient, "health", lambda self: (True, "OK"))

    workspace = tmp_path / "Terminal Desktop"
    settings_path = tmp_path / "settings.json"

    monkeypatch.setattr(sct, "terminal_desktop_dir", lambda: workspace)
    monkeypatch.setattr(sct, "SETTINGS_JSON", settings_path)

    workspace.mkdir(parents=True, exist_ok=True)

    window, _ = sct.build_widget(embedded=False)
    try:
        desktop = window.desktop
        assert isinstance(desktop, sct.TerminalDesktop)
        canvas = desktop.canvas

        canvas._refresh_icons()
        app.processEvents()

        expectations = [
            (canvas._new_folder_desktop, workspace / "New Folder"),
            (canvas._new_text_desktop, workspace / "New Text File.txt"),
            (canvas._new_markdown_desktop, workspace / "New Markdown File.md"),
            (canvas._new_json_desktop, workspace / "New JSON File.json"),
            (canvas._new_python_desktop, workspace / "New Python File.py"),
            (
                canvas._new_powershell_desktop,
                workspace / "New PowerShell Script.ps1",
            ),
            (canvas._new_zip_desktop, workspace / "New Archive.zip"),
            (
                canvas._new_shortcut_desktop,
                workspace / "New Shortcut.shortcut.json",
            ),
        ]

        for action, expected_path in expectations:
            action()
            for _ in range(5):
                app.processEvents()
            assert expected_path.exists()
            assert str(expected_path) in canvas._icons
    finally:
        window.close()


def test_terminal_desktop_background_persistence_and_fallback(
    monkeypatch, tmp_path
):
    app = _ensure_app()
    monkeypatch.setattr(sct.OllamaClient, "health", lambda self: (True, "OK"))

    workspace = tmp_path / "Terminal Desktop"
    workspace.mkdir(parents=True, exist_ok=True)
    settings_path = tmp_path / "settings.json"

    monkeypatch.setattr(sct, "terminal_desktop_dir", lambda: workspace)
    monkeypatch.setattr(sct, "SETTINGS_JSON", settings_path)

    window, _ = sct.build_widget(embedded=False)
    try:
        desktop = window.desktop
        assert isinstance(desktop, sct.TerminalDesktop)
        image_path = workspace / "wall.png"
        img = sct.QImage(8, 8, sct.QImage.Format_ARGB32)
        img.fill(sct.Qt.white)
        assert img.save(str(image_path))

        cfg = sct.BackgroundConfig(
            mode=sct.BackgroundMode.STATIC,
            source=str(image_path),
            fit=sct.BackgroundFit.FIT,
        )
        desktop.set_background_config(cfg)
        app.processEvents()

        stored = json.loads(settings_path.read_text(encoding="utf-8"))
        node = stored.get("terminal_desktop", {})
        background = node.get("background", {})
        assert background.get("source") == str(image_path)
        assert background.get("mode") == sct.BackgroundMode.STATIC.value
        assert background.get("fit") == sct.BackgroundFit.FIT.value

        missing = workspace / "missing.png"
        desktop.set_background_config(
            sct.BackgroundConfig(
                mode=sct.BackgroundMode.STATIC,
                source=str(missing),
            )
        )
        app.processEvents()
        assert desktop.canvas._bg_manager.active_mode is None
    finally:
        window.close()
```

**Functions:** _ensure_app(), test_terminal_desktop_context_menu_creates_entries(monkeypatch, tmp_path), test_terminal_desktop_background_persistence_and_fallback(monkeypatch, tmp_path)


## Module `tests\test_user_guided_notes_layout.py`

```python
import shutil

import pytest
from PySide6.QtWidgets import QApplication

from User_Guided_Notes import NoteTab, UserGuidedNotesWidget, UserGuidedNotesWindow


def _ensure_app() -> QApplication:
    app = QApplication.instance()
    if app is None:
        app = QApplication([])
    return app


def _cleanup_widget_notes(widget: UserGuidedNotesWidget) -> None:
    tab = widget.tabs.widget(0)
    if isinstance(tab, NoteTab):
        shutil.rmtree(tab.meta.paths.root, ignore_errors=True)


def _assert_font_is_smaller(original_font, new_font) -> None:
    app_point = original_font.pointSizeF()
    widget_point = new_font.pointSizeF()
    if app_point > 0 and widget_point > 0:
        assert widget_point == pytest.approx(max(app_point - 1.0, 1.0))
    else:
        app_pixel = original_font.pixelSize()
        widget_pixel = new_font.pixelSize()
        if app_pixel > 0 and widget_pixel > 0:
            assert widget_pixel == max(app_pixel - 1, 1)


def test_embedded_widget_uses_compact_metrics():
    app = _ensure_app()
    baseline_font = app.font()
    widget = UserGuidedNotesWidget(embedded=True)
    try:
        min_size = widget.minimumSize()
        assert min_size.width() == 520
        assert min_size.height() == 360

        _assert_font_is_smaller(baseline_font, widget.font())

        tab = widget.tabs.widget(0)
        assert isinstance(tab, NoteTab)
        style = tab.styleSheet()
        assert "#010409" in style
        assert "#f6f8fa" in style
    finally:
        _cleanup_widget_notes(widget)
        widget.deleteLater()


def test_standalone_window_uses_compact_defaults():
    app = _ensure_app()
    baseline_font = app.font()
    window = UserGuidedNotesWindow()
    try:
        size = window.size()
        assert size.width() == 1100
        assert size.height() == 700

        _assert_font_is_smaller(baseline_font, window.font())

        tab = window.widget.tabs.widget(0)
        assert isinstance(tab, NoteTab)
        style = tab.styleSheet()
        assert "#010409" in style
        assert "#f6f8fa" in style
    finally:
        _cleanup_widget_notes(window.widget)
        window.close()
        window.deleteLater()


def test_detach_toggle_updates_text_state():
    _ensure_app()
    widget = UserGuidedNotesWidget(embedded=True)
    try:
        button = widget.top_strip.detach_btn
        assert button.text() == "Pop Out"
        widget.apply_embedded_state(False)
        assert button.text() == "Dock"
        widget.apply_embedded_state(True)
        assert button.text() == "Pop Out"
    finally:
        _cleanup_widget_notes(widget)
        widget.deleteLater()


def test_detach_and_redock_signals_emit_per_mode():
    _ensure_app()
    widget = UserGuidedNotesWidget(embedded=True)
    detach_events = []
    redock_events = []
    widget.request_detach.connect(lambda payload: detach_events.append(payload))
    widget.request_redock.connect(lambda payload: redock_events.append(payload))
    try:
        widget.top_strip.detach_btn.click()
        assert detach_events == [widget]
        assert redock_events == []

        widget.apply_embedded_state(False)
        widget.top_strip.detach_btn.click()
        assert detach_events == [widget]
        assert redock_events == [widget]
    finally:
        _cleanup_widget_notes(widget)
        widget.deleteLater()
```

**Functions:** _ensure_app(), _cleanup_widget_notes(widget), _assert_font_is_smaller(original_font, new_font), test_embedded_widget_uses_compact_metrics(), test_standalone_window_uses_compact_defaults(), test_detach_toggle_updates_text_state(), test_detach_and_redock_signals_emit_per_mode()


## Module `tests\test_virtual_desktop_card_scale.py`

```python
import math
import os

from PySide6.QtWidgets import QApplication, QWidget

import Virtual_Desktop as vd


def _ensure_app():
    app = QApplication.instance()
    if app is None:
        app = QApplication([])
    return app


def _remove_state():
    if os.path.isfile(vd.STATE_PATH):
        os.remove(vd.STATE_PATH)


def test_card_scale_resizes_existing_cards(tmp_path):
    _remove_state()
    app = _ensure_app()
    core = vd.VirtualDesktopCore(workspace=str(tmp_path))
    try:
        card = core.add_card(QWidget(), "Sample")
        app.processEvents()
        expected_default = max(
            vd.MIN_CARD_WIDTH,
            int(round(vd.BASE_CARD_WIDTH * core.card_scale())),
        )
        assert math.isclose(card.width(), expected_default, abs_tol=3)
        scale_target = 0.75
        core.set_card_scale(scale_target)
        app.processEvents()
        scaled_width = max(
            vd.MIN_CARD_WIDTH,
            int(round(vd.BASE_CARD_WIDTH * scale_target)),
        )
        assert math.isclose(card.width(), scaled_width, abs_tol=3)
    finally:
        core.deleteLater()
        _remove_state()


def test_restore_geometry_respects_scale(tmp_path):
    _remove_state()
    app = _ensure_app()
    core = vd.VirtualDesktopCore(workspace=str(tmp_path))
    try:
        first = core.add_card(QWidget(), "One")
        first.set_persist_tag("test-tag")
        vd._save_card_geom(first, "pytest", "test-tag")
        app.processEvents()
        core.set_card_scale(0.7)
        second = core.add_card(QWidget(), "Two")
        second.set_persist_tag("test-tag")
        vd._restore_card_geom(second, "pytest", "test-tag")
        app.processEvents()
        expected_width = max(
            vd.MIN_CARD_WIDTH,
            int(round(vd.BASE_CARD_WIDTH * 0.7)),
        )
        assert math.isclose(second.width(), expected_width, abs_tol=3)
    finally:
        core.deleteLater()
        _remove_state()
```

**Functions:** _ensure_app(), _remove_state(), test_card_scale_resizes_existing_cards(tmp_path), test_restore_geometry_respects_scale(tmp_path)


## Module `tests\test_virtual_desktop_codex_workspace.py`

```python
import os

from PySide6.QtWidgets import QApplication

import Virtual_Desktop as vd


def _ensure_app() -> QApplication:
    app = QApplication.instance()
    if app is None:
        app = QApplication([])
    return app


class _DummySignal:
    def __init__(self):
        self._callbacks = []

    def connect(self, callback):
        self._callbacks.append(callback)

    def emit(self, *args, **kwargs):
        for callback in list(self._callbacks):
            callback(*args, **kwargs)


class _DummyCard:
    def __init__(self):
        self.closed = _DummySignal()


def test_open_codex_terminal_sets_workspace_during_load(tmp_path, monkeypatch):
    _ensure_app()
    script = tmp_path / "Codex_Terminal.py"
    script.write_text("print('codex terminal stub')\n")
    monkeypatch.setenv("CODEX_TERMINAL_PATH", str(script))

    recorded = {}

    def fake_loader(self, path, **kwargs):
        recorded["path"] = path
        recorded["workspace_env"] = os.environ.get("CODEX_WORKSPACE")
        return object()

    monkeypatch.setattr(
        vd.VirtualDesktopCore,
        "_load_python_as_card",
        fake_loader,
        raising=False,
    )

    core = vd.VirtualDesktopCore(workspace=str(tmp_path))
    expected_workspace = vd.workspace_root()

    monkeypatch.setenv("CODEX_WORKSPACE", "before-env")

    core.open_codex_terminal()

    assert recorded["path"] == str(script)
    assert recorded["workspace_env"] == expected_workspace
    assert os.environ.get("CODEX_WORKSPACE") == "before-env"


def test_start_panel_new_agent_selection_restores_environment(
    tmp_path, monkeypatch
):
    _ensure_app()
    script = tmp_path / "Codex_Terminal.py"
    script.write_text("print('codex terminal stub')\n")
    monkeypatch.setenv("CODEX_TERMINAL_PATH", str(script))

    new_workspace = tmp_path / "workspace"
    new_workspace.mkdir()

    monkeypatch.setattr(
        "Virtual_Desktop._non_native_open_dir",
        lambda parent, caption, start_dir: str(new_workspace),
        raising=False,
    )

    card = _DummyCard()
    recorded = {}

    def fake_loader(self, path, **kwargs):
        recorded["path"] = path
        recorded["env"] = os.environ.get("CODEX_WORKSPACE")
        recorded["kwargs"] = kwargs
        return card

    monkeypatch.setattr(
        vd.VirtualDesktopCore,
        "_load_python_as_card",
        fake_loader,
        raising=False,
    )

    core = vd.VirtualDesktopCore(workspace=str(tmp_path))
    panel = core.start_panel

    baseline_env = "baseline-env"
    monkeypatch.setenv("CODEX_WORKSPACE", baseline_env)

    entries = {entry["id"]: entry for entry in panel._app_entries}
    entries["codex-terminal-new"]["callback"]()

    expected_workspace = os.path.abspath(str(new_workspace))
    assert recorded["path"] == str(script)
    assert recorded["env"] == expected_workspace
    expected_key = f"{script}:{expected_workspace}"
    assert recorded["kwargs"]["persist_key"] == expected_key
    expected_tooltip = f"Workspace: {expected_workspace}"
    assert recorded["kwargs"]["task_tooltip"] == expected_tooltip
    assert os.environ.get("CODEX_WORKSPACE") == expected_workspace

    card.closed.emit(card)
    assert os.environ.get("CODEX_WORKSPACE") == baseline_env
```

**Classes:** _DummySignal, _DummyCard
**Functions:** _ensure_app(), test_open_codex_terminal_sets_workspace_during_load(tmp_path, monkeypatch), test_start_panel_new_agent_selection_restores_environment(tmp_path, monkeypatch)


## Module `tests\test_virtual_desktop_drop_import.py`

```python
import shutil
import uuid
from pathlib import Path

from PySide6.QtCore import QPointF, QSize, Qt
from PySide6.QtGui import QDropEvent, QMimeData, QUrl
from PySide6.QtWidgets import QApplication

import Virtual_Desktop as vd


def _ensure_app() -> QApplication:
    app = QApplication.instance()
    if app is None:
        app = QApplication([])
    return app


def test_drop_local_file_imports_into_workspace(tmp_path):
    _ensure_app()

    src_dir = tmp_path / "source"
    src_dir.mkdir()
    src_file = src_dir / f"dropped_{uuid.uuid4().hex}.txt"
    src_file.write_text("sample drop contents", encoding="utf-8")

    dest_root = Path(vd.workspace_root())
    dest_root.mkdir(parents=True, exist_ok=True)

    canvas = vd.DesktopCanvas(vd.Theme(), QSize(400, 300))

    refresh_calls = []

    def _record_refresh():
        refresh_calls.append(True)

    canvas._refresh_icons = _record_refresh  # type: ignore[assignment]

    mime = QMimeData()
    mime.setUrls([QUrl.fromLocalFile(str(src_file))])
    event = QDropEvent(QPointF(20, 20), Qt.CopyAction, mime, Qt.LeftButton, Qt.NoModifier)

    canvas.dropEvent(event)

    expected_path = dest_root / src_file.name
    assert expected_path.exists()
    assert expected_path.read_text(encoding="utf-8") == src_file.read_text(encoding="utf-8")
    assert refresh_calls, "drop should trigger icon refresh"
    assert event.isAccepted()
    assert event.dropAction() == Qt.CopyAction

    # Cleanup the copied file to keep the workspace tidy for other tests
    if expected_path.is_dir():
        shutil.rmtree(expected_path, ignore_errors=True)
    else:
        expected_path.unlink(missing_ok=True)
```

**Functions:** _ensure_app(), test_drop_local_file_imports_into_workspace(tmp_path)


## Module `tests\test_virtual_desktop_external_launch.py`

```python
from __future__ import annotations

import os
import sys
import time
from unittest.mock import Mock

import pytest
from PySide6.QtCore import QEvent, QPointF, Qt
from PySide6.QtGui import QMouseEvent
from PySide6.QtWidgets import QApplication

import Virtual_Desktop as vd
import external_app_card as eac


def _ensure_app() -> QApplication:
    app = QApplication.instance()
    if app is None:
        app = QApplication([])
    return app


def test_external_shortcut_fallback_permits_user_approved_exec(tmp_path, monkeypatch):
    _ensure_app()

    workspace = tmp_path / "workspace"
    workspace.mkdir()

    external_root = tmp_path / "external"
    external_root.mkdir()
    external_exec = external_root / "tool.exe"
    external_exec.write_text("echo external\n", encoding="utf-8")

    monkeypatch.setattr(vd, "VDSK_ROOT", str(workspace))
    monkeypatch.setattr(vd, "ALLOWLIST", set())

    core = vd.VirtualDesktopCore(workspace=str(workspace))

    shortcut = tmp_path / "app.lnk"
    spec = vd.LaunchSpec(
        argv=[str(external_exec)],
        cwd=str(workspace),
        target_path=str(external_exec),
        original_path=str(shortcut),
    )

    monkeypatch.setattr(vd, "build_launch_spec", lambda path, script_dir: spec, raising=False)
    monkeypatch.setattr(vd, "should_embed_external_app", lambda s, allow: True, raising=False)

    class _StubExternalApp:
        def __init__(self, *args, **kwargs):
            pass

        def start(self) -> bool:
            return False

        def deleteLater(self) -> None:
            pass

    monkeypatch.setattr(vd, "ExternalAppCard", _StubExternalApp, raising=False)

    recorded: dict[str, object] = {}

    def _fake_open(self, launch_spec, title, persist_key, *, allow_external_exec=False):
        recorded["allow_external_exec"] = allow_external_exec
        recorded["spec"] = launch_spec
        recorded["title"] = title
        recorded["persist"] = persist_key
        return None

    monkeypatch.setattr(vd.VirtualDesktopCore, "_open_process_error_card", _fake_open, raising=False)

    try:
        core._load_process_card(str(shortcut), "Test Shortcut")
    finally:
        core.deleteLater()

    assert recorded["allow_external_exec"] is True

    assert isinstance(recorded["spec"], vd.LaunchSpec)
    allow_flag = bool(recorded["allow_external_exec"])

    allowed, detail = vd._validate_process_request(
        recorded["spec"].argv,
        recorded["spec"].cwd,
        allow_flag,
    )
    assert allowed, detail

    blocked, reason = vd._validate_process_request(
        recorded["spec"].argv,
        recorded["spec"].cwd,
        False,
    )
    assert not blocked
    assert "Blocked" in reason


@pytest.mark.skipif(not sys.platform.startswith("win"), reason="Windows only")
def test_external_blend_launch_resolves_association(tmp_path, monkeypatch):
    _ensure_app()

    workspace = tmp_path / "workspace"
    workspace.mkdir()

    blend_path = tmp_path / "scene.blend"
    blend_path.write_text("fake", encoding="utf-8")

    blender_dir = tmp_path / "blender"
    blender_dir.mkdir()
    blender_exe = blender_dir / "blender.exe"
    blender_exe.write_text("", encoding="utf-8")

    monkeypatch.setattr(vd, "VDSK_ROOT", str(workspace), raising=False)
    monkeypatch.setattr(vd, "ALLOWLIST", set(), raising=False)

    core = vd.VirtualDesktopCore(workspace=str(workspace))

    monkeypatch.setattr(eac, "_resolve_associated_executable", lambda _path: str(blender_exe), raising=False)

    observed: dict[str, object] = {}

    def _fake_should_embed(spec, allow):
        observed["embed_spec"] = spec
        assert spec.argv[0] == str(blender_exe)
        assert spec.argv[1] == str(blend_path)
        assert spec.target_path == str(blender_exe)
        return False

    monkeypatch.setattr(vd, "should_embed_external_app", _fake_should_embed, raising=False)

    def _fake_open(self, spec, title, persist_key, *, allow_external_exec=False):
        observed["open_spec"] = spec
        observed["title"] = title
        observed["persist"] = persist_key
        observed["allow_external_exec"] = allow_external_exec
        return None

    monkeypatch.setattr(vd.VirtualDesktopCore, "_open_process_error_card", _fake_open, raising=False)

    try:
        core._load_process_card(str(blend_path), "Scene")
    finally:
        core.deleteLater()

    assert "embed_spec" in observed
    assert "open_spec" in observed

    spec = observed["open_spec"]
    assert isinstance(spec, vd.LaunchSpec)
    assert spec.argv[0] == str(blender_exe)
    assert spec.argv[1] == str(blend_path)
    assert spec.target_path == str(blender_exe)
    assert spec.original_path == str(blend_path)
    assert spec.cwd == str(blender_dir)


@pytest.mark.skipif(not sys.platform.startswith("win"), reason="Windows only")
def test_external_app_card_adopts_child_window(monkeypatch, tmp_path):
    _ensure_app()

    launcher = tmp_path / "launcher.exe"
    child = tmp_path / "child.exe"

    spec = eac.LaunchSpec(
        argv=[str(launcher)],
        cwd=str(tmp_path),
        target_path=str(child),
        original_path=str(launcher),
    )

    monkeypatch.setattr(eac, "_enum_top_level_windows", lambda: [0x1000], raising=False)
    monkeypatch.setattr(eac, "_enum_windows_for_pid", lambda _pid: [], raising=False)

    fallback_hwnd = 0x2000
    fallback_pid = 4242

    def _fake_window_scan(paths, ignored):
        assert 0x1000 in ignored
        normalized = {os.path.normcase(os.path.abspath(p)) for p in paths}
        assert os.path.normcase(os.path.abspath(child)) in normalized
        return fallback_hwnd, fallback_pid

    monkeypatch.setattr(eac, "_find_window_for_executables", _fake_window_scan, raising=False)

    class _ProcessStub:
        def __init__(self, pid: int) -> None:
            self._pid = pid

        def state(self):
            return eac.QProcess.Running

        def processId(self):
            return self._pid

    recorded: dict[str, object] = {}

    def _fake_embed(self, hwnd, *, owner_pid=None):
        recorded["hwnd"] = hwnd
        recorded["pid"] = owner_pid
        self._embedded_hwnd = hwnd
        self._tracked_pid = owner_pid

    monkeypatch.setattr(eac.ExternalAppCard, "_embed_window", _fake_embed, raising=False)

    theme = type("_Theme", (), {})()
    card = eac.ExternalAppCard(theme, spec)
    try:
        card._process = _ProcessStub(1337)
        monkeypatch.setattr(card._watchdog, "start", lambda: recorded.setdefault("watchdog", True), raising=False)

        card._poll_for_window()
    finally:
        card.deleteLater()

    assert recorded.get("hwnd") == fallback_hwnd
    assert recorded.get("pid") == fallback_pid
    assert recorded.get("watchdog") is True
    assert not card._fallback_emitted


@pytest.mark.skipif(not sys.platform.startswith("win"), reason="Windows only")
def test_external_app_card_adopts_after_launcher_exit(monkeypatch, tmp_path):
    _ensure_app()

    launcher = tmp_path / "launcher.exe"
    child = tmp_path / "child.exe"

    spec = eac.LaunchSpec(
        argv=[str(launcher)],
        cwd=str(tmp_path),
        target_path=str(child),
        original_path=str(launcher),
    )

    fallback_hwnd = 0x5000
    fallback_pid = 4243

    monkeypatch.setattr(eac, "_find_main_hwnd", lambda _pid: 0, raising=False)

    def _fake_window_scan(paths, ignored):
        normalized = {os.path.normcase(os.path.abspath(p)) for p in paths}
        assert os.path.normcase(os.path.abspath(child)) in normalized
        return fallback_hwnd, fallback_pid

    monkeypatch.setattr(eac, "_find_window_for_executables", _fake_window_scan, raising=False)

    class _ProcessStub:
        def __init__(self, pid: int) -> None:
            self._pid = pid

        def state(self):
            return eac.QProcess.NotRunning

        def processId(self):
            return self._pid

    recorded: dict[str, object] = {}

    def _fake_embed(self, hwnd, *, owner_pid=None):
        recorded["hwnd"] = hwnd
        recorded["pid"] = owner_pid
        self._embedded_hwnd = hwnd
        self._tracked_pid = owner_pid

    monkeypatch.setattr(eac.ExternalAppCard, "_embed_window", _fake_embed, raising=False)

    theme = type("_Theme", (), {})()
    card = eac.ExternalAppCard(theme, spec)

    try:
        card._process = _ProcessStub(1337)
        card._embed_deadline = time.monotonic() + 5
        finishes: list[tuple[int, str]] = []
        closed: list[bool] = []

        card.process_finished.connect(lambda code, detail: finishes.append((code, detail)))
        card.request_close.connect(lambda: closed.append(True))

        card._on_finished(0, eac.QProcess.ExitStatus.NormalExit)
        assert card._poll_timer.isActive()
        assert card._pending_exit_detail == (0, "Process exited.")

        monkeypatch.setattr(card._watchdog, "start", lambda: recorded.setdefault("watchdog", True), raising=False)

        card._poll_for_window()
        assert recorded.get("watchdog") is True
        assert card._pending_exit_detail == (0, "Process exited.")

        monkeypatch.setattr(card._watchdog, "stop", lambda: recorded.setdefault("watchdog_stop", True), raising=False)

        def _fake_release() -> None:
            recorded.setdefault("released", True)
            card._embedded_hwnd = 0
            card._tracked_pid = None

        monkeypatch.setattr(card, "_release_window", _fake_release, raising=False)
        monkeypatch.setattr(eac._user32, "IsWindow", lambda _hwnd: False, raising=False)
        monkeypatch.setattr(card, "_window_pid", lambda _hwnd: fallback_pid, raising=False)

        card._check_window_alive()
        assert recorded.get("watchdog_stop") is True
        assert recorded.get("released") is True
        assert finishes == [(0, "Process exited.")]
        assert closed and closed[0] is True
        assert card._pending_exit_detail is None
        assert not card._poll_timer.isActive()
    finally:
        card.deleteLater()

    assert recorded.get("hwnd") == fallback_hwnd
    assert recorded.get("pid") == fallback_pid
    assert not card._fallback_emitted


@pytest.mark.skipif(not sys.platform.startswith("win"), reason="Windows only")
def test_external_app_card_shutdown_waits_for_process(monkeypatch, tmp_path):
    _ensure_app()

    launcher = tmp_path / "launcher.exe"
    launcher.write_text("", encoding="utf-8")

    spec = eac.LaunchSpec(
        argv=[str(launcher)],
        cwd=str(tmp_path),
        target_path=str(launcher),
        original_path=str(launcher),
    )

    class _ProcessStub:
        def __init__(self) -> None:
            self.state_value = eac.QProcess.Running
            self.terminate_calls: list[int] = []
            self.kill_calls: list[int] = []
            self.wait_calls: list[int] = []

        def state(self):
            return self.state_value

        def terminate(self):
            self.terminate_calls.append(1)

        def kill(self):
            self.kill_calls.append(1)

        def waitForFinished(self, msec: int) -> bool:
            self.wait_calls.append(msec)
            return self.state_value == eac.QProcess.NotRunning

        def set_state(self, value) -> None:
            self.state_value = value

        def processId(self):
            return 4242

    theme = type("_Theme", (), {})()
    card = eac.ExternalAppCard(theme, spec)

    process = _ProcessStub()
    card._process = process
    card._embedded_hwnd = 0
    card._window_released = False

    release_calls: list[bool] = []
    original_release = card._release_window

    def _tracking_release() -> None:
        release_calls.append(True)
        original_release()

    monkeypatch.setattr(card, "_release_window", _tracking_release, raising=False)

    try:
        card.shutdown()
        assert process.terminate_calls
        assert process.wait_calls
        assert release_calls == []
        assert card._window_released is False

        process.set_state(eac.QProcess.NotRunning)
        card._window_released = False
        card._on_finished(0, eac.QProcess.ExitStatus.NormalExit)
        assert release_calls == [True]
    finally:
        card.deleteLater()


@pytest.mark.skipif(not sys.platform.startswith("win"), reason="Windows only")
def test_external_app_card_discovers_descendant_gui(monkeypatch, tmp_path):
    _ensure_app()

    launcher = tmp_path / "launcher.exe"
    launcher.write_text("", encoding="utf-8")
    gui = tmp_path / "gui.exe"
    gui.write_text("", encoding="utf-8")

    spec = eac.LaunchSpec(
        argv=[str(launcher)],
        cwd=str(tmp_path),
        target_path=str(launcher),
        original_path=str(launcher),
    )

    existing_hwnd = 0x3000
    child_hwnd = 0x4000
    launcher_pid = 4242
    child_pid = 5252

    monkeypatch.setattr(eac, "_enum_top_level_windows", lambda: [existing_hwnd], raising=False)

    theme = type("_Theme", (), {})()
    card = eac.ExternalAppCard(theme, spec)

    recorded_scan: dict[str, object] = {}

    try:
        monkeypatch.setattr(eac, "_enum_top_level_windows", lambda: [existing_hwnd, child_hwnd], raising=False)
        monkeypatch.setattr(eac, "_find_main_hwnd", lambda _pid: 0, raising=False)

        def _fake_window_scan(paths, ignored):
            recorded_scan["paths"] = {os.path.normcase(os.path.abspath(p)) for p in paths}
            recorded_scan["ignored"] = set(ignored)
            return None

        monkeypatch.setattr(eac, "_find_window_for_executables", _fake_window_scan, raising=False)
        monkeypatch.setattr(eac, "_enum_descendant_processes", lambda _pid: {child_pid}, raising=False)

        def _fake_image_path(pid: int) -> str | None:
            if pid == child_pid:
                return str(gui)
            if pid == launcher_pid:
                return str(launcher)
            return None

        monkeypatch.setattr(eac, "_query_process_image_path", _fake_image_path, raising=False)

        def _fake_window_pid(self, hwnd: int) -> int:
            if hwnd == child_hwnd:
                return child_pid
            if hwnd == existing_hwnd:
                return launcher_pid
            return 0

        monkeypatch.setattr(eac.ExternalAppCard, "_window_pid", _fake_window_pid, raising=False)

        class _ProcessStub:
            def __init__(self, pid: int) -> None:
                self._pid = pid

            def state(self):
                return eac.QProcess.Running

            def processId(self):
                return self._pid

        card._process = _ProcessStub(launcher_pid)

        recorded: dict[str, object] = {}

        def _fake_embed(self, hwnd, *, owner_pid=None):
            recorded["hwnd"] = hwnd
            recorded["pid"] = owner_pid
            self._embedded_hwnd = hwnd
            self._tracked_pid = owner_pid

        monkeypatch.setattr(eac.ExternalAppCard, "_embed_window", _fake_embed, raising=False)
        monkeypatch.setattr(card._watchdog, "start", lambda: recorded.setdefault("watchdog", True), raising=False)

        card._poll_for_window()
    finally:
        card.deleteLater()

    assert recorded.get("hwnd") == child_hwnd
    assert recorded.get("pid") == child_pid
    assert recorded.get("watchdog") is True

    gui_path = os.path.normcase(os.path.abspath(str(gui)))
    assert gui_path not in recorded_scan.get("paths", set())
    assert gui_path in card._candidate_executables
    assert not card._fallback_emitted


@pytest.mark.skipif(not sys.platform.startswith("win"), reason="Windows only")
def test_external_app_card_sync_geometry_updates_during_drag(monkeypatch, tmp_path):
    _ensure_app()

    theme = vd.Theme()
    display_card = vd.Card(theme, "Drag Test")
    display_card.resize(320, 220)

    spec = eac.LaunchSpec(
        argv=["tool.exe"],
        cwd=str(tmp_path),
        target_path=str(tmp_path / "tool.exe"),
        original_path=str(tmp_path / "tool.exe"),
    )

    external_card = eac.ExternalAppCard(theme, spec)
    geometry_spy = Mock()
    position_spy = Mock()
    external_card._sync_geometry = geometry_spy  # type: ignore[assignment]
    external_card._sync_embedded_position = position_spy  # type: ignore[assignment]

    external_card.attach_card(display_card)
    geometry_spy.reset_mock()
    position_spy.reset_mock()

    try:
        press = QMouseEvent(
            QEvent.MouseButtonPress,
            QPointF(16, 16),
            Qt.LeftButton,
            Qt.LeftButton,
            Qt.NoModifier,
        )
        move_a = QMouseEvent(
            QEvent.MouseMove,
            QPointF(48, 38),
            Qt.NoButton,
            Qt.LeftButton,
            Qt.NoModifier,
        )
        move_b = QMouseEvent(
            QEvent.MouseMove,
            QPointF(72, 64),
            Qt.NoButton,
            Qt.LeftButton,
            Qt.NoModifier,
        )
        release = QMouseEvent(
            QEvent.MouseButtonRelease,
            QPointF(72, 64),
            Qt.LeftButton,
            Qt.NoButton,
            Qt.NoModifier,
        )

        display_card.mousePressEvent(press)
        display_card.mouseMoveEvent(move_a)
        display_card.mouseMoveEvent(move_b)
        display_card.mouseReleaseEvent(release)
    finally:
        for widget in (display_card, external_card):
            widget.deleteLater()
    # The release event schedules one geometry sync after the move completes,
    # and the drag path should already be covered by the mid-drag position
    # sync calls.
    assert geometry_spy.call_count == 1
    assert position_spy.call_count >= 1
```

**Functions:** _ensure_app(), test_external_shortcut_fallback_permits_user_approved_exec(tmp_path, monkeypatch), test_external_blend_launch_resolves_association(tmp_path, monkeypatch), test_external_app_card_adopts_child_window(monkeypatch, tmp_path), test_external_app_card_adopts_after_launcher_exit(monkeypatch, tmp_path), test_external_app_card_shutdown_waits_for_process(monkeypatch, tmp_path), test_external_app_card_discovers_descendant_gui(monkeypatch, tmp_path), test_external_app_card_sync_geometry_updates_during_drag(monkeypatch, tmp_path)


## Module `tests\test_virtual_desktop_native_icons.py`

```python
import os
import shutil
import sys
from pathlib import Path

import pytest
from PySide6.QtWidgets import QApplication

from Virtual_Desktop import (
    _fallback_icon_for_path,
    _icon_for_path,
    Card,
    Taskbar,
    Theme,
)


def _ensure_app() -> QApplication:
    app = QApplication.instance()
    if app is None:
        app = QApplication([])
    return app


@pytest.mark.skipif(sys.platform != "win32", reason="Windows-specific icon extraction")
def test_windows_executable_icon_native():
    _ensure_app()
    source = Path(sys.executable)
    if not source.exists():
        pytest.skip("Python executable unavailable")
    workspace = Path(os.environ["CODEX_WORKSPACE"]) / "icon_tests"
    workspace.mkdir(parents=True, exist_ok=True)
    exe_path = workspace / "sample_launch.exe"
    shutil.copyfile(source, exe_path)
    try:
        icon, native = _icon_for_path(exe_path)
        assert native is True
        assert icon is not None and not icon.isNull()
    finally:
        exe_path.unlink(missing_ok=True)


def test_shortcut_icon_fallback():
    _ensure_app()
    workspace = Path(os.environ["CODEX_WORKSPACE"]) / "icon_tests"
    workspace.mkdir(parents=True, exist_ok=True)
    shortcut = workspace / "workspace_link.lnk"
    shortcut.write_bytes(b"dummy shortcut payload")
    try:
        icon, native = _icon_for_path(shortcut)
        assert icon is not None and not icon.isNull()
        if sys.platform != "win32":
            fallback = _fallback_icon_for_path(shortcut)
            assert icon.cacheKey() == fallback.cacheKey()
            assert native is False
    finally:
        shortcut.unlink(missing_ok=True)


def test_taskbar_uses_card_icon_metadata():
    _ensure_app()
    theme = Theme()
    card = Card(theme, "Process")
    icon, _ = _icon_for_path(Path(__file__))
    card.set_task_metadata("process-card", icon, "Process card")
    taskbar = Taskbar(theme)
    try:
        taskbar.add_task(card)
        group = taskbar._groups.get("process-card")
        assert group is not None
        btn_icon = group.button.icon()
        assert not btn_icon.isNull()
        assert btn_icon.cacheKey() == icon.cacheKey()
    finally:
        card.deleteLater()
        taskbar.deleteLater()
        QApplication.processEvents()
```

**Functions:** _ensure_app(), test_windows_executable_icon_native(), test_shortcut_icon_fallback(), test_taskbar_uses_card_icon_metadata()


## Module `tests\test_virtual_desktop_search.py`

```python
import threading
import time

import pytest
from PySide6.QtCore import QSize
from PySide6.QtWidgets import QApplication

from Virtual_Desktop import StartPanel, VirtualDesktopCore


def _ensure_app() -> QApplication:
    app = QApplication.instance()
    if app is None:
        app = QApplication([])
    return app


def _wait_for(condition, *, timeout: float = 1.0) -> bool:
    app = _ensure_app()
    deadline = time.time() + timeout
    while time.time() < deadline:
        if condition():
            return True
        app.processEvents()
        time.sleep(0.01)
    return condition()


@pytest.mark.parametrize("filename", ["alpha.txt", "beta.txt"])
def test_search_warm_index_prevents_rescan(tmp_path, monkeypatch, filename):
    _ensure_app()
    (tmp_path / filename).write_text("sample data")

    call_count = 0
    lock = threading.Lock()
    original_index = StartPanel._index_workspace

    def counting(self, root):
        nonlocal call_count
        with lock:
            call_count += 1
        return original_index(self, root)

    monkeypatch.setattr(StartPanel, "_index_workspace", counting, raising=False)

    core = VirtualDesktopCore(workspace=str(tmp_path))
    panel = core.start_panel

    assert _wait_for(lambda: call_count >= 1)
    _wait_for(lambda: getattr(panel, "_warm_thread", None) is None)

    with lock:
        initial_calls = call_count

    result = core.search(filename.split(".")[0])
    assert result["Files"], "Expected warmed search to return indexed file"

    with lock:
        assert call_count == initial_calls, "Search should use warmed index without rescanning"


def test_focus_refresh_runs_once_until_marked_stale(tmp_path, monkeypatch):
    _ensure_app()
    (tmp_path / "gamma.txt").write_text("focus data")

    call_count = 0
    lock = threading.Lock()
    original_index = StartPanel._index_workspace

    def counting(self, root):
        nonlocal call_count
        with lock:
            call_count += 1
        return original_index(self, root)

    monkeypatch.setattr(StartPanel, "_index_workspace", counting, raising=False)

    core = VirtualDesktopCore(workspace=str(tmp_path))
    panel = core.start_panel

    assert _wait_for(lambda: call_count >= 1)
    _wait_for(lambda: getattr(panel, "_warm_thread", None) is None)

    panel._refresh_index_if_pending()
    assert _wait_for(lambda: call_count >= 2)
    assert not panel._focus_refresh_pending

    with lock:
        after_first_focus = call_count

    panel._refresh_index_if_pending()
    with lock:
        assert call_count == after_first_focus

    core.mark_start_index_stale()
    assert panel._focus_refresh_pending

    panel._refresh_index_if_pending()
    assert _wait_for(lambda: call_count >= after_first_focus + 1)
    assert not panel._focus_refresh_pending


def test_search_result_buttons_use_compact_icon_size(tmp_path):
    _ensure_app()
    (tmp_path / "doc.txt").write_text("data")

    core = VirtualDesktopCore(workspace=str(tmp_path))
    panel = core.start_panel

    item = {"title": "Doc Item", "kind": "doc", "path": str(tmp_path / "doc.txt")}
    btn = panel._make_result_button("Files", item)

    assert not btn.icon().isNull(), "Expected search result button to have an icon"
    assert btn.iconSize() == QSize(20, 20)
```

**Functions:** _ensure_app(), _wait_for(condition), test_search_warm_index_prevents_rescan(tmp_path, monkeypatch, filename), test_focus_refresh_runs_once_until_marked_stale(tmp_path, monkeypatch), test_search_result_buttons_use_compact_icon_size(tmp_path)


## Module `tests\test_virtual_desktop_single_card.py`

```python
import os

from PySide6.QtWidgets import QApplication, QWidget

import Virtual_Desktop as vd


def _ensure_app():
    app = QApplication.instance()
    if app is None:
        app = QApplication([])
    return app


def _remove_state():
    if os.path.isfile(vd.STATE_PATH):
        os.remove(vd.STATE_PATH)


def _drain_events(app: QApplication) -> None:
    for _ in range(5):
        app.processEvents()


def test_add_card_replaces_previous_card(tmp_path):
    _remove_state()
    app = _ensure_app()
    core = vd.VirtualDesktopCore(workspace=str(tmp_path))
    try:
        first = core.add_card(QWidget(), "First")
        _drain_events(app)
        second = core.add_card(QWidget(), "Second")
        _drain_events(app)
        remaining = core._iter_cards()
        assert remaining == [second]
        assert first not in remaining
    finally:
        core.deleteLater()
        _remove_state()


def test_template_card_reference_cleared_when_replaced(tmp_path):
    _remove_state()
    app = _ensure_app()
    core = vd.VirtualDesktopCore(workspace=str(tmp_path))
    try:
        core.toggle_template_terminal(True)
        _drain_events(app)
        template = core._template_card
        assert template is not None
        replacement = core.add_card(QWidget(), "Replacement")
        _drain_events(app)
        assert core._template_card is None
        assert template not in core._iter_cards()
        assert replacement in core._iter_cards()
    finally:
        core.deleteLater()
        _remove_state()
```

**Functions:** _ensure_app(), _remove_state(), _drain_events(app), test_add_card_replaces_previous_card(tmp_path), test_template_card_reference_cleared_when_replaced(tmp_path)


## Module `tests\test_vision_toggle.py`

```python
import types

import Codex_Terminal as sct


def test_disable_vision_skips_pipeline(tmp_path):
    img = tmp_path / "img.png"
    img.write_bytes(b"\x89PNG\r\n\x1a\n")
    events = []
    dummy = types.SimpleNamespace(
        settings={
            "enable_vision": False,
            "chat_model": sct.DEFAULT_CHAT_MODEL,
        },
        dataset=types.SimpleNamespace(add_entry=lambda *a, **k: None),
        lex=types.SimpleNamespace(auto_tags=lambda text: []),
        append_signal=types.SimpleNamespace(
            emit=lambda msg: events.append(msg.text)
        ),
        conv=types.SimpleNamespace(append=lambda *a, **k: None),
        state_signal=types.SimpleNamespace(emit=lambda *a, **k: None),
        messages=[],
        context_pairs=0,
        ollama=types.SimpleNamespace(
            chat=lambda *a, **k: (True, "ok", None)
        ),
    )

    def fake_sum(self, imgs, text):
        events.append("summarized")
        return [], [], ""

    dummy._summarize_images_dual = types.MethodType(fake_sum, dummy)
    dummy._gather_context = lambda q: []
    dummy._system_prompt = types.MethodType(sct.ChatCard._system_prompt, dummy)
    dummy._record_message = lambda *a, **k: None

    sct.ChatCard._infer_thread(dummy, "hello", [img])

    assert "summarized" not in events
```

**Functions:** test_disable_vision_skips_pipeline(tmp_path)


## Module `tests\test_workspace_config.py`

```python
from pathlib import Path
import os
import Codex_Terminal as ct
import Virtual_Desktop as vd


def test_modules_share_workspace(monkeypatch):
    ws = Path(os.environ["CODEX_WORKSPACE"])
    monkeypatch.setattr(ct, "_legacy_transit_candidates", lambda: [])
    assert ct.workspace_root() == ws
    assert ct.transit_dir() == ws / "Terminal Desktop"
    assert Path(vd.workspace_root()) == ws
    data_root = ct.agent_data_root()
    assert data_root == ws / ".codex_agent"
    assert data_root.is_dir()
    assert ct.agent_images_dir() == data_root / "images"
    assert ct.agent_sessions_dir() == data_root / "sessions"
    assert ct.agent_archives_dir() == data_root / "archives"
```

**Functions:** test_modules_share_workspace(monkeypatch)


## Module `tests\test_write_console_line.py`

```python
import types
import threading
import ctypes
from ctypes import wintypes

import pytest
import Codex_Terminal as sct

if not hasattr(sct, "write_console_line"):
    pytest.skip("write_console_line not available", allow_module_level=True)


def test_write_console_line_atomic(monkeypatch):
    writes = []
    monkeypatch.setattr(sct, "_attach", lambda pid: True)
    monkeypatch.setattr(sct, "_open_conin_write", lambda: 42)

    def fake_writefile(h, data, length, written, overlapped):
        assert h == 42
        writes.append(data[:length])
        ctypes.cast(written, ctypes.POINTER(wintypes.DWORD))[0] = length
        return 1

    monkeypatch.setattr(sct, "WriteFile", fake_writefile)
    monkeypatch.setattr(sct, "CloseHandle", lambda h: None)
    monkeypatch.setattr(sct, "FreeConsole", lambda: None)

    ok, err = sct.write_console_line(1, "hello")
    assert (ok, err) == (True, 0)
    assert writes == [("hello\r\n").encode("utf-16le")]


def test_write_console_line_failure_exposes_error(monkeypatch):
    monkeypatch.setattr(sct, "_attach", lambda pid: False)
    monkeypatch.setattr(ctypes, "get_last_error", lambda: 5, raising=False)
    ok, err = sct.write_console_line(1, "hello")
    assert ok is False and err == 5


def test_send_uses_write_console_line(monkeypatch):
    called = {}

    def fake_write_console_line(pid, text):
        called["args"] = (pid, text)
        return True, 0

    monkeypatch.setattr(sct, "write_console_line", fake_write_console_line)

    after_calls = []

    def fake_after(*args, **kwargs):
        after_calls.append((args, kwargs))

    class FakeInput:
        def __init__(self):
            self.text = "hi"

        def get(self, start, end):
            return self.text + "\n"

        def delete(self, start, end):
            self.text = ""

    dummy = types.SimpleNamespace(
        cmd_pid=111,
        _busy=threading.Event(),
        input=FakeInput(),
        log_status=lambda msg: None,
        _watch_until_settled=lambda: None,
        after=fake_after,
    )

    class FakeThread:
        def __init__(self, target, daemon=True):
            self.target = target

        def start(self):
            self.target()

    monkeypatch.setattr(threading, "Thread", FakeThread)
    sct.BridgeGUI._send(dummy)
    assert called["args"] == (111, "hi")
    assert after_calls == []
```

**Functions:** test_write_console_line_atomic(monkeypatch), test_write_console_line_failure_exposes_error(monkeypatch), test_send_uses_write_console_line(monkeypatch)


## Module `tests\__init__.py`

```python

```



## Module `tools\codex_pr_sentinel.py`

```python
"""Codex PR sentinel canonical comment handler (placeholder)."""


def main() -> None:
    print("Codex PR sentinel placeholder")


if __name__ == "__main__":  # pragma: no cover
    main()
```

Codex PR sentinel canonical comment handler (placeholder).
**Functions:** main()


## Module `tools\index_repo.py`

```python
"""CLI entry point for building and querying the repository text index."""

from __future__ import annotations

import argparse
import json
from pathlib import Path
from typing import Any, List, Optional, Sequence

from memory_manager import RepositoryIndex


def _default_repo_root() -> Path:
    return Path(__file__).resolve().parents[1]


def build_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument(
        "--repo-root",
        type=Path,
        default=_default_repo_root(),
        help="Repository root to index (defaults to project root).",
    )
    parser.add_argument(
        "--data-root",
        type=Path,
        default=None,
        help="Optional datasets directory (defaults to <repo>/datasets).",
    )
    parser.add_argument(
        "--no-embed",
        action="store_true",
        help="Skip embedding generation (querying will be disabled).",
    )

    subparsers = parser.add_subparsers(dest="command")

    subparsers.add_parser("rebuild", help="Rebuild the repository index (default).")

    query_parser = subparsers.add_parser("query", help="Query the repository index.")
    query_parser.add_argument("--text", required=True, help="Text to search for.")
    query_parser.add_argument(
        "--limit", type=int, default=5, help="Maximum number of results to display (default: 5)."
    )

    return parser


def _print_json(data: Any) -> None:
    print(json.dumps(data, ensure_ascii=False, indent=2, default=str))


def _resolve_path(value: Optional[Path]) -> Optional[Path]:
    if value is None:
        return None
    return value.expanduser().resolve()


def main(argv: Optional[Sequence[str]] = None) -> int:
    parser = build_parser()
    args = parser.parse_args(argv)

    repo_root = _resolve_path(args.repo_root)
    data_root = _resolve_path(args.data_root)

    index = RepositoryIndex(
        repo_root=repo_root,
        data_root=data_root,
        enable_embeddings=not args.no_embed,
    )

    command = args.command or "rebuild"

    if command == "rebuild":
        summary = index.rebuild()
        payload = {
            "files_indexed": summary.get("files_indexed", 0),
            "segments": summary.get("segments", 0),
            "timestamp": summary.get("timestamp"),
            "index_path": str(summary.get("index_path")),
        }
        _print_json(payload)
        return 0

    if command == "query":
        if args.no_embed:
            parser.error("--no-embed cannot be used when querying the index.")
        results: List[dict[str, Any]] = index.search(args.text, k=args.limit)
        _print_json(results)
        return 0

    parser.error(f"Unknown command: {command}")
    return 2


if __name__ == "__main__":
    raise SystemExit(main())
```

CLI entry point for building and querying the repository text index.
**Functions:** _default_repo_root(), build_parser(), _print_json(data), _resolve_path(value), main(argv)


## Module `tools\logic_inbox.py`

```python
"""CLI for managing logic inbox entries."""

from __future__ import annotations

import argparse
import json
import sys
from pathlib import Path

INBOX_PATH = Path(__file__).resolve().parent.parent / "memory" / "logic_inbox.jsonl"


def validate() -> bool:
    if not INBOX_PATH.exists():
        print("logic_inbox.jsonl not found", file=sys.stderr)
        return False
    ok = True
    with INBOX_PATH.open("r", encoding="utf-8") as f:
        for idx, line in enumerate(f, 1):
            line = line.strip()
            if not line:
                continue
            try:
                obj = json.loads(line)
            except json.JSONDecodeError as e:
                print(f"Line {idx}: invalid JSON: {e}", file=sys.stderr)
                ok = False
                continue
            status = obj.get("status")
            if status not in {"pending", "done"}:
                print(f"Line {idx}: invalid status '{status}'", file=sys.stderr)
                ok = False
    return ok


def main() -> None:
    parser = argparse.ArgumentParser(description="Logic inbox utilities")
    parser.add_argument("--validate", action="store_true", help="Validate inbox entries")
    args = parser.parse_args()
    if args.validate:
        ok = validate()
        sys.exit(0 if ok else 1)
    parser.print_help()


if __name__ == "__main__":  # pragma: no cover
    main()
```

CLI for managing logic inbox entries.
**Functions:** validate(), main()


## Module `tools\manage_tests.py`

```python
"""Run Codex-Local test suites through a single entry point."""

from __future__ import annotations

import argparse
import os
import shlex
import subprocess
import sys
from pathlib import Path
from typing import Optional, Sequence

REPO_ROOT = Path(__file__).resolve().parents[1]


def build_pytest_command(pytest_args: Sequence[str]) -> list[str]:
    """Construct the pytest command using the active Python interpreter."""

    return [sys.executable, "-m", "pytest", *pytest_args]


def run_pytest(pytest_args: Sequence[str]) -> int:
    """Execute pytest with the provided arguments and return the exit code."""

    env = os.environ.copy()
    env.setdefault("QT_QPA_PLATFORM", "offscreen")
    command = build_pytest_command(pytest_args)
    printable = " ".join(shlex.quote(part) for part in command)
    print(f"Running tests via pytest: {printable}")
    try:
        result = subprocess.run(command, cwd=REPO_ROOT, env=env)
    except FileNotFoundError as exc:  # pragma: no cover - defensive guard
        print(f"pytest invocation failed: {exc}")
        return 1
    return result.returncode


def main(argv: Optional[Sequence[str]] = None) -> int:
    """Parse arguments and invoke pytest."""

    parser = argparse.ArgumentParser(description="Run Codex-Local test suites")
    parser.add_argument(
        "pytest_args",
        nargs="*",
        help="Arguments forwarded to pytest (e.g. -k pattern)",
    )
    options = parser.parse_args(argv)
    return run_pytest(options.pytest_args)


if __name__ == "__main__":  # pragma: no cover
    raise SystemExit(main())
```

Run Codex-Local test suites through a single entry point.
**Functions:** build_pytest_command(pytest_args), run_pytest(pytest_args), main(argv)


## Module `tools\system_metrics.py`

```python
"""Utilities for collecting repository system metrics."""
from __future__ import annotations

import json
import logging
import os
import threading
import time
from dataclasses import dataclass
from pathlib import Path
from typing import Callable, Dict, Iterable, Iterator, List, Mapping, MutableMapping, Optional, Sequence

from metrics_manager import record_metrics

REPO_ROOT = Path(__file__).resolve().parents[1]
DEFAULT_TARGETS: Sequence[Path] = (
    REPO_ROOT / "Virtual_Desktop.py",
    REPO_ROOT / "Codex_Terminal.py",
    REPO_ROOT / "tasks",
    REPO_ROOT / "tools",
)
DATASETS_ROOT = REPO_ROOT / "datasets"
DEFAULT_DB_NAME = "system_metrics.db"
TASKS_FILENAME = "tasks.jsonl"
ERRORS_FILENAME = "errors.jsonl"

logger = logging.getLogger(__name__)


@dataclass(slots=True)
class ErrorSummary:
    """Container describing error counts and recent entries."""

    count: int
    recent: List[Dict[str, object]]


def _normalize_repo_path(path: str | os.PathLike[str]) -> str:
    """Return a POSIX-style path relative to the repository when possible."""

    raw = str(path).strip()
    if not raw:
        return ""
    # Normalise Windows separators.
    candidate = raw.replace("\\", "/")
    path_obj = Path(candidate)

    # Handle drive letters on Windows-like paths (`C:/...`).
    drive, _ = os.path.splitdrive(candidate)
    if drive:
        try:
            path_obj = Path(candidate)
        except Exception:
            return candidate
    try:
        resolved = path_obj.resolve()
    except FileNotFoundError:
        resolved = (REPO_ROOT / path_obj).resolve() if not path_obj.is_absolute() else path_obj
    except RuntimeError:
        resolved = path_obj

    try:
        relative = resolved.relative_to(REPO_ROOT)
    except ValueError:
        return resolved.as_posix()
    return relative.as_posix()


def _iter_python_files(target: Path) -> Iterator[Path]:
    if target.is_file() and target.suffix == ".py":
        yield target
        return
    if target.is_dir():
        for path in sorted(target.rglob("*.py")):
            if "__pycache__" in path.parts:
                continue
            yield path


def _count_lines(path: Path) -> int:
    try:
        with path.open("r", encoding="utf-8", errors="ignore") as handle:
            return sum(1 for _ in handle)
    except OSError:
        return 0


def _load_task_updates(tasks_file: Path) -> Mapping[str, float]:
    updates: MutableMapping[str, float] = {}
    if not tasks_file.exists():
        return updates
    try:
        with tasks_file.open("r", encoding="utf-8") as handle:
            for line in handle:
                line = line.strip()
                if not line:
                    continue
                try:
                    payload = json.loads(line)
                except json.JSONDecodeError:
                    continue
                ts = float(payload.get("updated_ts") or payload.get("created_ts") or 0.0)
                for file_path in payload.get("files", []) or []:
                    key = _normalize_repo_path(file_path)
                    current = updates.get(key, 0.0)
                    updates[key] = max(current, ts)
    except OSError:
        return updates
    return updates


def _load_error_map(errors_file: Path, limit: int = 5) -> Mapping[str, ErrorSummary]:
    grouped: Dict[str, ErrorSummary] = {}
    if not errors_file.exists():
        return grouped
    try:
        with errors_file.open("r", encoding="utf-8") as handle:
            for line in handle:
                line = line.strip()
                if not line:
                    continue
                try:
                    payload = json.loads(line)
                except json.JSONDecodeError:
                    continue
                raw_path = payload.get("path")
                if not raw_path:
                    continue
                key = _normalize_repo_path(raw_path)
                summary = grouped.setdefault(key, ErrorSummary(count=0, recent=[]))
                summary.count += 1
                summary.recent.append(
                    {
                        "ts": float(payload.get("ts", 0.0)),
                        "level": payload.get("level"),
                        "kind": payload.get("kind"),
                        "msg": payload.get("msg"),
                    }
                )
    except OSError:
        return grouped

    for summary in grouped.values():
        summary.recent.sort(key=lambda entry: float(entry.get("ts", 0.0)), reverse=True)
        if limit > 0:
            del summary.recent[limit:]
    return grouped


def _prepare_component(
    target: Path,
    *,
    updates: Mapping[str, float],
    errors: Mapping[str, ErrorSummary],
) -> Optional[Dict[str, object]]:
    scripts: Dict[str, Dict[str, object]] = {}
    for script in _iter_python_files(target):
        try:
            rel = script.resolve().relative_to(REPO_ROOT)
            component_key = rel.as_posix()
        except ValueError:
            component_key = script.resolve().as_posix()
        line_count = _count_lines(script)
        last_modified = script.stat().st_mtime if script.exists() else None
        error_summary = errors.get(component_key, ErrorSummary(count=0, recent=[]))
        scripts[component_key] = {
            "line_count": line_count,
            "last_modified": last_modified,
            "last_run_ts": updates.get(component_key),
            "error_count": error_summary.count,
            "errors": list(error_summary.recent),
        }

    if not scripts:
        return None

    try:
        component_name = target.resolve().relative_to(REPO_ROOT).as_posix()
    except ValueError:
        component_name = target.resolve().as_posix()

    total_lines = sum(entry["line_count"] for entry in scripts.values())
    last_run = max((entry["last_run_ts"] or 0.0) for entry in scripts.values()) if scripts else 0.0
    last_modified = max((entry["last_modified"] or 0.0) for entry in scripts.values())
    error_count = sum(int(entry["error_count"]) for entry in scripts.values())

    return {
        "component": component_name,
        "file_count": len(scripts),
        "total_lines": total_lines,
        "last_run_ts": last_run or None,
        "last_modified": last_modified or None,
        "error_count": error_count,
        "scripts": scripts,
    }

def _compute_score(payload: Mapping[str, object]) -> float:
    try:
        errors = int(payload.get("error_count") or 0)
    except (TypeError, ValueError):
        errors = 0
    if errors <= 0:
        return 1.0
    return 1.0 / (1.0 + float(errors))


def _store_metrics(
    summary: Mapping[str, object],
    *,
    db_path: Path,
    runtime_ms: Optional[float] = None,
) -> None:
    components = summary.get("components")
    if not isinstance(components, dict) or not components:
        return

    entries: List[Dict[str, object]] = []
    generated_at = float(summary.get("generated_at", time.time()))
    for component_name, component_data in components.items():
        scripts = component_data.get("scripts", {})
        if not isinstance(scripts, dict):
            continue
        file_count = int(component_data.get("file_count", 0))
        total_lines = int(component_data.get("total_lines", 0))
        for script_name, payload in scripts.items():
            metadata = {
                "file_count": file_count,
                "total_lines": total_lines,
                "line_count": payload.get("line_count"),
                "last_modified": payload.get("last_modified"),
                "last_run_ts": payload.get("last_run_ts"),
                "error_count": payload.get("error_count"),
                "errors": payload.get("errors"),
            }
            entries.append(
                {
                    "timestamp": generated_at,
                    "script_path": script_name,
                    "score": _compute_score(payload),
                    "runtime_ms": runtime_ms,
                    "component": component_name,
                    "metadata": metadata,
                }
            )

    if not entries:
        return

    record_metrics(entries, scopes=("local",), db_paths={"local": db_path})


def collect_metrics(
    targets: Optional[Iterable[os.PathLike[str] | str]] = None,
    *,
    store: bool = False,
    db_path: Optional[os.PathLike[str] | str] = None,
    datasets_root: Optional[os.PathLike[str] | str] = None,
    error_limit: int = 5,
) -> Dict[str, object]:
    """Collect filesystem, task, and error metrics for selected targets."""

    start_time = time.perf_counter()
    resolved_targets: List[Path] = []
    if targets is None:
        resolved_targets.extend(Path(path) for path in DEFAULT_TARGETS)
    else:
        for target in targets:
            resolved_targets.append(Path(target))

    dataset_root = Path(datasets_root) if datasets_root else DATASETS_ROOT
    tasks_file = dataset_root / TASKS_FILENAME
    errors_file = dataset_root / ERRORS_FILENAME

    updates = _load_task_updates(tasks_file)
    error_map = _load_error_map(errors_file, limit=error_limit)

    components: Dict[str, Dict[str, object]] = {}
    for target in resolved_targets:
        component = _prepare_component(target, updates=updates, errors=error_map)
        if component is None:
            continue
        components[component["component"]] = component

    summary: Dict[str, object] = {
        "generated_at": time.time(),
        "components": components,
    }

    runtime_ms = (time.perf_counter() - start_time) * 1000.0
    summary["runtime_ms"] = runtime_ms

    if store:
        database_path = Path(db_path) if db_path else dataset_root / DEFAULT_DB_NAME
        _store_metrics(summary, db_path=database_path, runtime_ms=runtime_ms)

    return summary


class SystemMetricsJob:
    """Background helper that refreshes metrics on a fixed cadence."""

    def __init__(
        self,
        *,
        interval: float,
        targets: Optional[Iterable[os.PathLike[str] | str]] = None,
        datasets_root: Optional[os.PathLike[str] | str] = None,
        db_path: Optional[os.PathLike[str] | str] = None,
        publish_callback: Optional[Callable[[Dict[str, object]], None]] = None,
    ) -> None:
        if interval <= 0:
            raise ValueError("interval must be positive")
        self._interval = float(interval)
        self._targets = list(targets) if targets is not None else None
        self._datasets_root = Path(datasets_root) if datasets_root else None
        self._db_path = Path(db_path) if db_path else None
        self._publish_callback = publish_callback
        self._timer: Optional[threading.Timer] = None
        self._lock = threading.Lock()
        self._stopped = False

    def start(self) -> None:
        with self._lock:
            self._stopped = False
        self._run_now()

    def stop(self) -> None:
        with self._lock:
            self._stopped = True
            timer = self._timer
            self._timer = None
        if timer:
            timer.cancel()

    def _schedule(self) -> None:
        with self._lock:
            if self._stopped:
                return
            timer = threading.Timer(self._interval, self._run_now)
            timer.daemon = True
            self._timer = timer
            timer.start()

    def _run_now(self) -> None:
        with self._lock:
            if self._stopped:
                return
        summary: Optional[Dict[str, object]] = None
        try:
            summary = collect_metrics(
                targets=self._targets,
                store=True,
                db_path=self._db_path,
                datasets_root=self._datasets_root,
            )
        except Exception:  # pragma: no cover - defensive logging
            logger.exception("System metrics collection failed")
        else:
            if self._publish_callback is not None and summary is not None:
                try:
                    self._publish_callback(summary)
                except Exception:
                    logger.exception("System metrics publish callback failed")
        self._schedule()


__all__ = [
    "collect_metrics",
    "SystemMetricsJob",
]
```

Utilities for collecting repository system metrics.
**Classes:** ErrorSummary, SystemMetricsJob
**Functions:** _normalize_repo_path(path), _iter_python_files(target), _count_lines(path), _load_task_updates(tasks_file), _load_error_map(errors_file, limit), _prepare_component(target), _compute_score(payload), _store_metrics(summary), collect_metrics(targets)


## Module `Virtual_Desktop\game_creator.py`

```python
"""Game Creator GUI for scaffolding new Panda3D projects.

This tool is meant to live at the root of the template repository. It gives
artists and designers a point-and-click workflow for duplicating the starter
kit into a fresh folder, renaming metadata, scaffolding scenes, and importing
assets without needing to touch the command line.
"""
from __future__ import annotations

import copy
import contextlib
import json
import os
import queue
import re
import shutil
import string
import subprocess
import sys
import tempfile
import textwrap
import threading
import wave
from datetime import UTC, datetime
from pathlib import Path
from typing import Any, Dict, Iterable, List, Optional, Set, Tuple, TypedDict

from archetypes import (
    DEFAULT_ARCHETYPES,
    coerce_archetype,
    iter_default_scenes,
    load_archetypes,
)
from devlogic.chat_panel import ChatPanel
from Dev_Logic.ImagePipeline import generate_logo, remix_texture

try:
    import tkinter as tk
    from tkinter import filedialog, messagebox, scrolledtext, simpledialog, ttk
except Exception as exc:  # pragma: no cover - tkinter may be missing on CI
    raise RuntimeError(
        "Tkinter is required to run the game creator GUI."
    ) from exc

try:  # pragma: no cover - optional Pillow dependency
    from PIL import Image, ImageTk  # type: ignore
except Exception:  # pragma: no cover - fallback when Pillow is missing
    Image = ImageTk = None

try:  # pragma: no cover - Panda3D may be absent in CI
    from panda3d.core import Filename, PNMImage
    from panda3d.core import loadPrcFileData  # type: ignore
    from direct.showbase.ShowBase import ShowBase  # type: ignore
except Exception:  # pragma: no cover - importer should degrade gracefully
    Filename = None  # type: ignore
    PNMImage = None  # type: ignore
    ShowBase = None  # type: ignore


ROOT = Path(__file__).resolve().parent
BLENDER_ADDON_ROOT = ROOT / "Dev_Logic" / "blender_addon"
BLENDER_PROJECT_ENV = "PY_GAME_CREATOR_PROJECT_PATH"
BLENDER_SCENES_ENV = "PY_GAME_CREATOR_SCENES"
BLENDER_DESTINATIONS_ENV = "PY_GAME_CREATOR_ASSET_DESTINATIONS"
BLENDER_ACTION_ENV = "PY_GAME_CREATOR_ACTION"
BLENDER_RESULT_ENV = "PY_GAME_CREATOR_RESULT_PATH"
CHATBOT_CLI = ROOT / "Dev_Logic" / "LocalChatBot" / "bootstrap_cli.py"
IMPLEMENTED_LOGIC_DIR = ROOT / "Dev_Logic" / "Implemented_logic"
PROMPT_CACHE_DIR = IMPLEMENTED_LOGIC_DIR / "ai_bootstrap"
REGISTRY_PATH = ROOT / "game_creator_registry.json"
DEFAULT_DESCRIPTION = (
    "Project scaffold generated by the Py-Game-Creator Game Creator. "
    "Use this space to describe the high-level concept, target platform, "
    "and any unique mechanics you plan to implement."
)
DEFAULT_INITIAL_SCENE = "MainMenu"
IGNORED_TEMPLATE_ITEMS = {
    ".git",
    "__pycache__",
    "dev_cmd",
    "launcher.log",
    "game_creator_registry.json",
    "memory",
    "Agent.md",
    "Dev_Logic",
    "logic_notes",
    "Archived Conversations",
}
COPY_RESOURCE_GROUPS = [
    {
        "key": "assets",
        "label": "Include project assets (assets/)",
        "paths": {"assets"},
        "tooltip": (
            "Copies the template's assets/ directory containing sample models, textures, "
            "audio, fonts, and miscellaneous resources. Uncheck to start with an empty "
            "assets/ folder."
        ),
    },
    {
        "key": "docs",
        "label": "Include documentation (README.md, design_docs/, CHANGELOG.md)",
        "paths": {"README.md", "Readme.md", "design_docs", "CHANGELOG.md"},
        "tooltip": (
            "Copies the repository documentation including README.md, the design_docs/ "
            "folder, and CHANGELOG.md. Uncheck to omit these reference materials from "
            "the new project."
        ),
    },
    {
        "key": "tools",
        "label": "Include tooling helpers (tools/, launcher.py, panel_creator.py)",
        "paths": {"tools", "launcher.py", "panel_creator.py"},
        "tooltip": (
            "Copies development helpers like tools/, launcher.py, and panel_creator.py. "
            "Uncheck if you only want the runtime game files without the optional "
            "tooling scripts."
        ),
    },
]

try:
    _ARCHETYPE_REGISTRY = load_archetypes()
except RuntimeError:
    _ARCHETYPE_REGISTRY = list(DEFAULT_ARCHETYPES)

ARCHETYPES: List[Dict[str, Any]] = sorted(
    _ARCHETYPE_REGISTRY,
    key=lambda item: str(item.get("name") or item.get("id") or "").lower(),
)

ACCESSIBILITY_CONTRAST_BANNER = (
    "# =============================================================\n"
    "# ACCESSIBILITY: Scenes and panels must maintain either a dark-on-light\n"
    "# or light-on-dark palette that meets WCAG AA (4.5:1 body, 3:1 large text)\n"
    "# across default, hover, and disabled states. Reference Primary #1d4ed8,\n"
    "# Surface #f4f6fb, and Disabled #94a3b8 when tuning custom colors.\n"
    "# =============================================================\n"
    "\n"
)
class SceneTemplateSpec(TypedDict):
    description: str
    template: str


SCENE_TEMPLATES: Dict[str, SceneTemplateSpec] = {
    "Blank Scene": {
        "description": (
            "Minimal BaseScene scaffold with a logger hook for custom startup logic. "
            "Use this when you plan to build all systems manually."
        ),
        "template": '''Create a barebones scene module.


class {class_name}(BaseScene):
    """Starter scene generated by the Py-Game-Creator tools.

    The Game Creator automatically registers this class in
    ``schemas/default_schema.json`` so triggers defined there can load it. Import
    helpers such as ``core.settings.Settings`` when you need to persist or read
    player options, and call ``self.app.load_scene`` to transition elsewhere.
    """

    scene_name = "{scene_name}"

    def on_start(self):
        super().on_start()
        self.logger.info("%s has started. Add your logic here!", self.scene_name)
''',
    },
    "Menu Scene": {
        "description": (
            "Simple DirectGUI menu mirroring scenes/mainmenu.py with placeholder "
            "buttons wired for load_scene and quit actions."
        ),
        "template": '''Create a simple menu scene with placeholder buttons.

from direct.gui.DirectGui import DirectButton, DirectFrame


class {class_name}(BaseScene):
    """Menu scaffold with Play/Quit buttons and schema integration notes.

    Register additional triggers in ``schemas/default_schema.json`` so the engine can
    resolve the destinations referenced by these button callbacks.
    """

    scene_name = "{scene_name}"

    def on_start(self):
        super().on_start()
        DirectFrame(frameColor=(0, 0, 0, 0.6), frameSize=(-1.3, 1.3, -1, 1))
        DirectButton(
            text="Play",
            scale=0.08,
            pos=(0, 0, 0.2),
            command=lambda: self.app.load_scene("GameState"),
        )
        DirectButton(
            text="Quit",
            scale=0.08,
            pos=(0, 0, -0.1),
            command=self.engine.request_exit,
        )
        self.logger.info(
            "Register additional triggers in schemas/default_schema.json to match "
            "these button callbacks."
        )
''',
    },
    "Loading Scene": {
        "description": (
            "Displays a loading banner and reminds you to transition once assets are "
            "ready."
        ),
        "template": '''Create a placeholder loading screen scene.

from direct.gui.DirectGui import OnscreenText


class {class_name}(BaseScene):
    """Loading screen stub that logs schema-driven transitions.

    Call ``self.app.load_scene`` once assets are ready and ensure the destination is
    listed in ``schemas/default_schema.json`` so the engine can import it.
    """

    scene_name = "{scene_name}"

    def on_start(self):
        super().on_start()
        OnscreenText(
            text="Loading...",
            pos=(0, 0),
            scale=0.1,
            fg=(1, 1, 1, 1),
        )
        self.logger.info("Swap to the real scene when assets are ready.")
''',
    },
    "Combat Encounter": {
        "description": (
            "Turn-based combat loop scaffold that reads core.settings.Settings and "
            "demonstrates load_scene transitions."
        ),
        "template": '''Scaffold a placeholder combat encounter scene.

from direct.gui.DirectGui import DirectButton, DirectFrame
from direct.gui.OnscreenText import OnscreenText
from panda3d.core import TextNode

from core.settings import Settings


class {class_name}(BaseScene):
    """Turn-based combat stub with schema and settings integration.

    Scenes generated here are registered in ``schemas/default_schema.json`` with a
    trigger so ``self.app.load_scene`` can resume story beats when combat ends.
    The template shows how to read values from ``core.settings.Settings`` for
    persisted player preferences such as audio levels.
    """

    scene_name = "{scene_name}"

    def on_start(self):
        super().on_start()
        self.logger.info(
            "Combat encounter loading with SFX volume %s",
            Settings.sfx_volume,
        )
        self.app.win.setClearColor((0.05, 0.05, 0.08, 1.0))

        self.hud = DirectFrame(
            frameColor=(0, 0, 0, 0.65),
            frameSize=(-1.4, 1.4, -0.9, 0.9),
        )
        self.status_text = OnscreenText(
            text="Heroes HP: 100\\nEnemies HP: 80",
            pos=(0, 0.6),
            scale=0.06,
            align=TextNode.ACenter,
            mayChange=True,
        )
        self.action_buttons = [
            DirectButton(
                text=label,
                scale=0.06,
                pos=pos,
                command=self._on_action,
                extraArgs=[label.lower()],
                frameColor=(0.3, 0.15, 0.1, 1),
                text_fg=(1, 1, 1, 1),
                rolloverSound=None,
                clickSound=None,
            )
            for label, pos in [
                ("Attack", (-0.4, 0, -0.6)),
                ("Defend", (0.0, 0, -0.6)),
                ("Flee", (0.4, 0, -0.6)),
            ]
        ]

    def _on_action(self, action: str):
        if action == "flee":
            self.logger.info("Retreating from combat.")
            self.app.load_scene("MainMenu")
            return
        self.logger.info("Queued combat action: %s", action)
        self.status_text.setText("Heroes strike with %s!" % action.capitalize())

    def cleanup(self):
        self.status_text.destroy()
        for button in self.action_buttons:
            button.destroy()
        self.hud.destroy()
''',
    },
    "Merchant Stall": {
        "description": (
            "Shop interaction inspired by settings menu patterns with buy/leave "
            "callbacks and Settings-backed preferences."
        ),
        "template": '''Create a merchant interaction scene scaffold.

from direct.gui.DirectGui import DirectButton, DirectFrame
from direct.gui.OnscreenText import OnscreenText
from panda3d.core import TextNode

from core.settings import Settings


class {class_name}(BaseScene):
    """Shop scene stub showing persisted settings and schema triggers.

    The Game Creator wires this scene into ``schemas/default_schema.json`` so a
    trigger like ``open_shop`` can summon it. Use ``core.settings.Settings`` to
    reflect player preferences (audio volume, accessibility toggles) and
    ``self.app.load_scene`` to return to the previous area.
    """

    scene_name = "{scene_name}"

    def on_start(self):
        super().on_start()
        self.logger.info("Opening merchant stall with master volume %s", Settings.master_volume)
        self.app.win.setClearColor((0.08, 0.05, 0.02, 1.0))

        self.panel = DirectFrame(
            frameColor=(0.1, 0.07, 0.04, 0.85),
            frameSize=(-1.2, 1.2, -0.8, 0.8),
        )
        self.header = OnscreenText(
            text="Merchant Inventory",
            pos=(0, 0.6),
            scale=0.07,
            align=TextNode.ACenter,
            mayChange=False,
        )
        self.stock = ["Potion", "Hi-Potion", "Antidote"]
        self.stock_text = OnscreenText(
            text="\n".join("- " + item for item in self.stock),
            pos=(-0.6, 0.3),
            align=TextNode.ALeft,
            scale=0.055,
            mayChange=True,
        )

        self.buy_button = DirectButton(
            text="Buy First Item",
            scale=0.06,
            pos=(-0.4, 0, -0.5),
            command=self._buy_first_item,
            frameColor=(0.2, 0.3, 0.2, 1),
            text_fg=(1, 1, 1, 1),
            rolloverSound=None,
            clickSound=None,
        )
        self.leave_button = DirectButton(
            text="Leave Shop",
            scale=0.06,
            pos=(0.4, 0, -0.5),
            command=lambda: self.app.load_scene("MainMenu"),
            frameColor=(0.3, 0.1, 0.1, 1),
            text_fg=(1, 1, 1, 1),
            rolloverSound=None,
            clickSound=None,
        )

    def _buy_first_item(self):
        if not self.stock:
            self.logger.info("Merchant is sold out.")
            return
        item = self.stock.pop(0)
        self.logger.info("Purchased %%s from merchant.", item)
        self.stock_text.setText("\n".join("- " + entry for entry in self.stock) or "(Sold out)")

    def cleanup(self):
        for widget in [
            self.header,
            self.stock_text,
            self.buy_button,
            self.leave_button,
            self.panel,
        ]:
            widget.destroy()
''',
    },
    "Dialogue Scene": {
        "description": (
            "Conversation flow that cycles scripted lines and demonstrates scene "
            "transitions once dialogue is exhausted."
        ),
        "template": '''Generate a dialogue-driven narrative scene.

from direct.gui.DirectGui import DirectButton
from direct.gui.OnscreenText import OnscreenText
from panda3d.core import TextNode


class {class_name}(BaseScene):
    """Dialogue sequence scaffold with schema and transition guidance.

    Register this scene under a trigger in ``schemas/default_schema.json`` (the
    Game Creator handles the initial entry) so narrative scripts can invoke it.
    Use ``self.app.load_scene`` or schema-triggered transitions to branch after
    the final line.
    """

    scene_name = "{scene_name}"

    def on_start(self):
        super().on_start()
        self.lines = [
            "Narrator: The party approaches a mysterious figure...",
            "Merchant: Welcome, travelers. Care to trade?",
            "Hero: Perhaps after we learn more about this place.",
        ]
        self.index = 0
        self.dialogue_text = OnscreenText(
            text=self.lines[self.index],
            pos=(0, 0.4),
            scale=0.06,
            align=TextNode.ACenter,
            wordwrap=1.4,
            mayChange=True,
        )
        self.advance_button = DirectButton(
            text="Next",
            scale=0.065,
            pos=(0, 0, -0.6),
            command=self._advance,
            frameColor=(0.2, 0.2, 0.3, 1),
            text_fg=(1, 1, 1, 1),
            rolloverSound=None,
            clickSound=None,
        )

    def _advance(self):
        self.index += 1
        if self.index >= len(self.lines):
            self.logger.info("Dialogue finished; returning to main menu trigger.")
            self.app.load_scene("MainMenu")
            return
        self.dialogue_text.setText(self.lines[self.index])

    def cleanup(self):
        self.dialogue_text.destroy()
        self.advance_button.destroy()
''',
    },
}
ASSET_DESTINATIONS = {
    "Models": "assets/models",
    "Textures": "assets/textures",
    "Audio": "assets/audio",
    "Fonts": "assets/fonts",
    "Misc": "assets/misc",
}

ASSET_INDEX_FILENAME = "index.json"
ASSET_TAG_SB_NAME = "asset_tags.sb"
GLOBAL_SCENE_TAG = "__global__"
THUMBNAIL_SIZE = (64, 64)

IMAGE_EXTENSIONS = {".png", ".jpg", ".jpeg", ".bmp", ".gif", ".tiff", ".tga"}
MODEL_EXTENSIONS = {".bam", ".egg", ".gltf", ".glb", ".obj"}
TEXT_EXTENSIONS = {".txt", ".json", ".md", ".cfg", ".ini", ".py", ".toml", ".yaml", ".yml"}
AUDIO_EXTENSIONS = {".wav", ".ogg", ".mp3", ".flac", ".aac"}


class Worker:
    """Small helper to offload blocking work to a background thread."""

    def __init__(self, owner: tk.Misc, callback):
        self._owner = owner
        self._callback = callback
        self._queue: "queue.Queue[str]" = queue.Queue()
        self._thread: Optional[threading.Thread] = None

    def start(self, target, *args, **kwargs):
        if self._thread and self._thread.is_alive():
            raise RuntimeError("Another task is currently running")

        def _runner():
            try:
                target(*args, **kwargs)
                self._queue.put(None)
            except Exception as err:  # pragma: no cover - GUI feedback path
                self._queue.put(err)

        self._thread = threading.Thread(target=_runner, daemon=True)
        self._thread.start()
        self._process_queue()

    def _process_queue(self):
        try:
            message = self._queue.get_nowait()
        except queue.Empty:
            self._owner.after(100, self._process_queue)
            return

        if message is None:
            self._callback()
        else:  # pragma: no cover - GUI feedback path
            self._callback(error=message)


class Tooltip:
    """Simple tooltip that appears when hovering over a widget."""

    def __init__(self, widget: tk.Widget, text: str, *, delay: int = 400):
        self.widget = widget
        self.text = text
        self.delay = delay
        self._after_id: Optional[str] = None
        self._tip_window: Optional[tk.Toplevel] = None

        self.widget.bind("<Enter>", self._schedule)
        self.widget.bind("<Leave>", self._hide)
        self.widget.bind("<ButtonPress>", self._hide)

    def _schedule(self, _event=None):
        self._cancel_scheduled()
        self._after_id = self.widget.after(self.delay, self._show)

    def _show(self):
        if self._tip_window or not self.text:
            return
        x = self.widget.winfo_rootx() + 16
        y = self.widget.winfo_rooty() + self.widget.winfo_height() + 8
        self._tip_window = tk.Toplevel(self.widget)
        self._tip_window.wm_overrideredirect(True)
        self._tip_window.wm_geometry(f"+{x}+{y}")
        label = tk.Label(
            self._tip_window,
            text=self.text,
            justify=tk.LEFT,
            background="#ffffe0",
            relief=tk.SOLID,
            borderwidth=1,
            wraplength=260,
            padx=6,
            pady=4,
        )
        label.pack()

    def _hide(self, _event=None):
        self._cancel_scheduled()
        if self._tip_window is not None:
            self._tip_window.destroy()
            self._tip_window = None

    def _cancel_scheduled(self):
        if self._after_id is not None:
            self.widget.after_cancel(self._after_id)
            self._after_id = None


class GameCreatorApp(tk.Tk):
    """Tkinter orchestrator used to spin up and manage new projects."""

    def __init__(self):
        super().__init__()
        self.title("Py-Game-Creator Game Creator")
        self.geometry("960x640")
        self.minsize(860, 580)

        self.style = ttk.Style(self)
        self.current_theme = "light"

        self.registry = self._load_registry()
        self.registry.setdefault("projects", {})
        self.registry.setdefault("meta", {})
        self.selected_project: Optional[Dict[str, str]] = None
        self._restoring_projects = True
        self.worker = Worker(self, self._on_worker_finished)
        self._current_task = ""
        self._asset_preview_image = None
        self.asset_thumbnail_cache: Dict[str, tk.PhotoImage] = {}
        self.asset_tree_images: Dict[str, tk.PhotoImage] = {}
        self.asset_metadata: Dict[str, Dict[str, Any]] = {}
        self.asset_scene_vars: Dict[str, tk.BooleanVar] = {}
        self.asset_tag_checkbuttons: Dict[str, ttk.Checkbutton] = {}
        self._scene_list: List[str] = []
        self._suppress_tag_updates = False
        self._model_thumbnailer: Optional[ShowBase] = None
        self.ai_initial_scene: Optional[str] = None
        self._pending_project: Optional[Dict[str, Any]] = None
        self._last_bootstrap_brief: Optional[Dict[str, Any]] = None
        self._last_bootstrap_plan: Optional[Dict[str, Any]] = None
        self._last_prompt_cache: Optional[Dict[str, str]] = None
        self._current_asset_path: Optional[Path] = None
        self.chat_panel: Optional[ChatPanel] = None
        self.logic_note_widgets: Dict[str, scrolledtext.ScrolledText] = {}
        self.logic_note_jobs: Dict[str, str] = {}
        self.logic_transition_vars: Dict[str, tk.StringVar] = {}
        self.dev_start_var = tk.StringVar(value="")
        self._current_theme_colors: Dict[str, str] = {}

        blender_defaults = self._load_blender_settings_from_registry()
        self.blender_path_var = tk.StringVar(value=blender_defaults.get("executable", ""))
        self.blender_addon_var = tk.StringVar(
            value=blender_defaults.get("addon_path", str(BLENDER_ADDON_ROOT))
        )
        self.blender_status_var = tk.StringVar(value="Configure Blender to enable quick actions.")
        self.blender_project_var = tk.StringVar(value="No project selected.")
        self.blender_quick_action_buttons: Dict[str, ttk.Button] = {}
        self.blender_project_details: Optional[ttk.Label] = None
        self.blender_launch_button: Optional[ttk.Button] = None
        self.blender_path_var.trace_add("write", lambda *_: self._refresh_blender_tab_state())
        self.blender_addon_var.trace_add("write", lambda *_: self._refresh_blender_tab_state())

        self._build_ui()
        self._apply_theme(self.current_theme)
        self._refresh_project_list()
        self._restoring_projects = False

    # ------------------------------------------------------------------
    # Registry helpers
    # ------------------------------------------------------------------
    def _load_registry(self) -> Dict[str, Any]:
        if not REGISTRY_PATH.exists():
            return {"projects": {}, "meta": {}}

        with REGISTRY_PATH.open("r", encoding="utf8") as fp:
            try:
                data = json.load(fp)
            except json.JSONDecodeError:  # pragma: no cover - manual fix
                return {"projects": {}, "meta": {}}

        if not isinstance(data, dict):
            return {"projects": {}, "meta": {}}

        projects = data.get("projects")
        meta = data.get("meta", {})

        if not isinstance(projects, dict):
            # Legacy flat mapping: treat every dict entry with a path as a project.
            projects = {
                key: value
                for key, value in data.items()
                if isinstance(value, dict) and value.get("path")
            }
            meta = {}

        if not isinstance(meta, dict):
            meta = {}

        return {"projects": projects, "meta": meta}

    def _save_registry(self):
        payload = {
            "projects": self.registry.get("projects", {}),
            "meta": self.registry.get("meta", {}),
        }
        with REGISTRY_PATH.open("w", encoding="utf8") as fp:
            json.dump(payload, fp, indent=2)
        self.registry["projects"] = payload["projects"]
        self.registry["meta"] = payload["meta"]

    def _refresh_project_list(self, *, log_selection: bool = False):
        projects: Dict[str, Dict[str, str]] = self.registry.get("projects", {})
        titles = sorted(projects)

        if hasattr(self, "project_selector"):
            self.project_selector["values"] = titles

        if not titles:
            self._set_selected_project(None, persist=True)
            return

        meta = self.registry.get("meta", {})
        last_opened = meta.get("last_opened")

        if last_opened not in projects:
            if last_opened:
                meta.pop("last_opened", None)
            selected_title = titles[0]
            if meta.get("last_opened") != selected_title:
                meta["last_opened"] = selected_title
                self._save_registry()
        else:
            selected_title = last_opened

        self._set_selected_project(selected_title, log_selection=log_selection, persist=False)

    def _set_selected_project(
        self,
        title: Optional[str],
        *,
        log_selection: bool = False,
        persist: bool = True,
    ):
        projects: Dict[str, Dict[str, str]] = self.registry.get("projects", {})
        meta = self.registry.setdefault("meta", {})

        if not title or title not in projects:
            self.selected_project = None
            if hasattr(self, "project_selector_var"):
                self.project_selector_var.set("")
            if persist and meta.pop("last_opened", None) is not None:
                self._save_registry()
            if self.chat_panel:
                self.chat_panel.set_project_path(None)
            self._refresh_asset_browser()
            self._refresh_logic_tab()
            self._refresh_blender_tab_state()
            return

        project = projects[title]
        self.selected_project = project

        if hasattr(self, "project_selector_var") and self.project_selector_var.get() != title:
            self.project_selector_var.set(title)

        if persist and meta.get("last_opened") != title:
            meta["last_opened"] = title
            self._save_registry()

        if log_selection and not self._restoring_projects:
            self.log(f"Selected project '{title}'")

        if self.chat_panel:
            try:
                project_path = Path(project["path"]).expanduser()
            except KeyError:
                self.chat_panel.set_project_path(None)
            else:
                self.chat_panel.set_project_path(project_path)

        self._refresh_asset_browser()
        self._refresh_logic_tab()
        self._refresh_blender_tab_state()

    def _focus_creation_tab(self):
        if hasattr(self, "notebook"):
            self.notebook.select(self.project_tab)
        if hasattr(self, "project_name_entry"):
            self.project_name_entry.focus_set()

    # ------------------------------------------------------------------
    # UI construction
    # ------------------------------------------------------------------
    def _build_ui(self):
        toolbar = ttk.Frame(self, padding=(12, 12, 12, 0))
        toolbar.pack(fill=tk.X)
        self.theme_button = ttk.Button(
            toolbar,
            text="Switch to Dark Mode",
            command=self._toggle_theme,
        )
        self.theme_button.pack(side=tk.LEFT)

        main = ttk.PanedWindow(self, orient=tk.HORIZONTAL)
        main.pack(fill=tk.BOTH, expand=True)

        # Left panel: project selector and metadata controls
        list_frame = ttk.Frame(main, padding=10)
        main.add(list_frame, weight=1)

        ttk.Label(list_frame, text="Saved Projects", font=("Segoe UI", 12, "bold")).pack(anchor=tk.W)
        selector_row = ttk.Frame(list_frame)
        selector_row.pack(fill=tk.X, pady=(4, 8))

        self.project_selector_var = tk.StringVar()
        self.project_selector = ttk.Combobox(
            selector_row,
            textvariable=self.project_selector_var,
            state="readonly",
            width=1,
        )
        self.project_selector.pack(side=tk.LEFT, fill=tk.X, expand=True)
        self.project_selector.bind("<<ComboboxSelected>>", self._handle_project_select)

        ttk.Button(selector_row, text="New Project", command=self._focus_creation_tab).pack(side=tk.LEFT, padx=(8, 0))

        button_bar = ttk.Frame(list_frame)
        button_bar.pack(fill=tk.X)
        ttk.Button(button_bar, text="Open Folder", command=self._open_selected_folder).pack(side=tk.LEFT)
        ttk.Button(button_bar, text="Forget", command=self._forget_selected_project).pack(side=tk.LEFT, padx=(6, 0))

        # Right panel: notebook with detailed actions
        notebook = ttk.Notebook(main)
        main.add(notebook, weight=3)
        self.notebook = notebook

        self.project_tab = ttk.Frame(notebook, padding=12)
        notebook.add(self.project_tab, text="New Project")
        self.scene_tab = ttk.Frame(notebook, padding=12)
        notebook.add(self.scene_tab, text="Scenes")
        self.logic_tab = ttk.Frame(notebook, padding=12)
        notebook.add(self.logic_tab, text="Game Logic")
        self.asset_tab = ttk.Frame(notebook, padding=12)
        notebook.add(self.asset_tab, text="Assets")
        self.blender_tab = ttk.Frame(notebook, padding=12)
        notebook.add(self.blender_tab, text="Blender Controller")
        self.ai_tab = ttk.Frame(notebook, padding=12)
        notebook.add(self.ai_tab, text="AI Assistant")

        log_frame = ttk.Frame(self, padding=(12, 0, 12, 12))
        ttk.Label(log_frame, text="Activity Log", font=("Segoe UI", 11, "bold")).pack(anchor=tk.W)
        self.log_text = tk.Text(log_frame, height=8, state=tk.DISABLED)
        self.log_text.pack(fill=tk.BOTH, expand=True)
        
        self._build_project_tab()
        self._build_scene_tab()
        self._build_logic_tab()
        self._build_asset_tab()
        self._build_blender_tab()
        self._build_ai_tab()

        log_frame.pack(fill=tk.BOTH)

    def _get_theme_background(self, widget: tk.Widget) -> str:
        """Return a theme-aware background color for Tk widgets."""

        style = getattr(self, "style", None) or ttk.Style(widget)
        for style_name in ("TFrame", "TLabelframe", "TLabel"):
            color = style.lookup(style_name, "background")
            if color:
                return color

        for candidate in (widget, getattr(widget, "master", None), self):
            if candidate is None:
                continue
            try:
                bg = candidate.cget("background")
            except tk.TclError:
                continue
            if bg:
                return bg

        return "SystemButtonFace"

    def _toggle_theme(self):
        self.current_theme = "dark" if self.current_theme == "light" else "light"
        self._apply_theme(self.current_theme)

    def _apply_theme(self, theme: str):
        palettes = {
            "light": {
                "bg": "#f4f6fb",
                "fg": "#111827",
                "accent": "#d0d5dd",
                "border": "#98a2b3",
                "button_bg": "#e0e7ff",
                "button_active": "#c7d2fe",
                "button_pressed": "#a5b4fc",
                "button_disabled_bg": "#cbd5f5",
                "button_disabled_fg": "#475569",
                "entry_bg": "#ffffff",
                "text_bg": "#ffffff",
                "listbox_bg": "#ffffff",
                "select_bg": "#1d4ed8",
                "select_fg": "#ffffff",
                "tab_bg": "#d9e0ff",
                "tab_selected_bg": "#ffffff",
                "paned_bg": "#e5e7eb",
            },
            "dark": {
                "bg": "#0f172a",
                "fg": "#e2e8f0",
                "accent": "#1e293b",
                "border": "#334155",
                "button_bg": "#1e293b",
                "button_active": "#2b3b58",
                "button_pressed": "#3b4a67",
                "button_disabled_bg": "#273449",
                "button_disabled_fg": "#94a3b8",
                "entry_bg": "#16213d",
                "text_bg": "#0b1220",
                "listbox_bg": "#0b1220",
                "select_bg": "#2563eb",
                "select_fg": "#f8fafc",
                "tab_bg": "#1e293b",
                "tab_selected_bg": "#0f172a",
                "paned_bg": "#111c30",
            },
        }

        colors = palettes.get(theme, palettes["light"])
        self._current_theme_colors = colors

        self.style.theme_use("clam")
        self.configure(background=colors["bg"])

        self.style.configure("TFrame", background=colors["bg"], foreground=colors["fg"])
        self.style.configure("TLabelframe", background=colors["bg"], foreground=colors["fg"])
        self.style.configure("TLabelframe.Label", background=colors["bg"], foreground=colors["fg"])
        self.style.configure("TLabel", background=colors["bg"], foreground=colors["fg"])
        self.style.configure("TCheckbutton", background=colors["bg"], foreground=colors["fg"])
        self.style.configure("TRadiobutton", background=colors["bg"], foreground=colors["fg"])
        self.style.configure("TPanedwindow", background=colors["paned_bg"], foreground=colors["fg"])
        self.style.configure("TNotebook", background=colors["bg"], foreground=colors["fg"])
        self.style.configure("TNotebook.Tab", background=colors["tab_bg"], foreground=colors["fg"])
        self.style.map(
            "TNotebook.Tab",
            background=[("selected", colors["tab_selected_bg"])],
            foreground=[("selected", colors["fg"])],
        )

        self.style.configure(
            "TButton",
            background=colors["button_bg"],
            foreground=colors["fg"],
            bordercolor=colors["border"],
            focusthickness=2,
        )
        self.style.map(
            "TButton",
            background=[
                ("active", colors["button_active"]),
                ("pressed", colors["button_pressed"]),
                ("disabled", colors["button_disabled_bg"]),
            ],
            foreground=[("disabled", colors["button_disabled_fg"])],
        )

        self.style.configure(
            "TEntry",
            fieldbackground=colors["entry_bg"],
            foreground=colors["fg"],
        )
        self.style.configure(
            "TCombobox",
            fieldbackground=colors["entry_bg"],
            background=colors["entry_bg"],
            foreground=colors["fg"],
        )

        self.style.configure(
            "Treeview",
            background=colors["listbox_bg"],
            fieldbackground=colors["listbox_bg"],
            foreground=colors["fg"],
            bordercolor=colors["border"],
        )
        self.style.configure(
            "Treeview.Heading",
            background=colors["accent"],
            foreground=colors["fg"],
            bordercolor=colors["border"],
        )
        self.style.map(
            "Treeview",
            background=[("selected", colors["select_bg"])],
            foreground=[("selected", colors["select_fg"])],
        )

        self.theme_button.configure(
            text="Switch to Light Mode" if theme == "dark" else "Switch to Dark Mode"
        )

        for text_widget in (self.project_description, self.log_text):
            text_widget.configure(
                bg=colors["text_bg"],
                fg=colors["fg"],
                insertbackground=colors["fg"],
                highlightbackground=colors["border"],
                highlightcolor=colors["border"],
            )

        for note_widget in self.logic_note_widgets.values():
            self._update_logic_note_theme(note_widget)


    def _scene_header(self, summary: Optional[str] = None) -> str:
        """Compose the standardized header for generated scene modules."""
        parts: List[str] = []
        # Always start scene modules with accessibility guidance.
        parts.append(ACCESSIBILITY_CONTRAST_BANNER.rstrip())
        if summary:
            parts.append(summary.rstrip())
        parts.append("# Auto-generated by the Game Creator.")
        parts.append("from core.scenes.base_scene import BaseScene")
        return "\n".join(parts) + "\n\n"


    def _build_project_tab(self):
        entry_frame = ttk.LabelFrame(self.project_tab, text="Project Details", padding=12)
        entry_frame.pack(fill=tk.X, pady=(0, 12))

        self.project_name_var = tk.StringVar()
        self.project_slug_var = tk.StringVar()
        self.project_location_var = tk.StringVar(value=str(ROOT.parent))
        self.project_description = tk.Text(entry_frame, height=4, wrap=tk.WORD)
        self.project_description.insert("1.0", DEFAULT_DESCRIPTION)

        ttk.Label(entry_frame, text="Game Title").grid(row=0, column=0, sticky=tk.W)
        self.project_name_entry = ttk.Entry(entry_frame, textvariable=self.project_name_var)
        self.project_name_entry.grid(row=1, column=0, sticky=tk.EW, padx=(0, 8))

        ttk.Label(entry_frame, text="Identifier (slug)").grid(row=0, column=1, sticky=tk.W)
        ttk.Entry(entry_frame, textvariable=self.project_slug_var).grid(row=1, column=1, sticky=tk.EW)
        ttk.Label(
            entry_frame,
            text=(
                "The slug becomes the folder name and internal identifier. "
                "Stick to lowercase letters, numbers, and hyphens."
            ),
            wraplength=240,
        ).grid(row=2, column=0, columnspan=2, sticky=tk.W, pady=(2, 0))

        ttk.Label(entry_frame, text="Destination Folder").grid(row=4, column=0, columnspan=2, sticky=tk.W, pady=(8, 0))
        location_row = ttk.Frame(entry_frame)
        location_row.grid(row=5, column=0, columnspan=2, sticky=tk.EW)
        ttk.Entry(location_row, textvariable=self.project_location_var).pack(side=tk.LEFT, fill=tk.X, expand=True)
        ttk.Button(location_row, text="Browse", command=self._browse_destination).pack(side=tk.LEFT, padx=(6, 0))

        ttk.Label(entry_frame, text="Description").grid(row=6, column=0, columnspan=2, sticky=tk.W, pady=(8, 0))
        self.project_description.grid(row=7, column=0, columnspan=2, sticky=tk.EW)

        entry_frame.columnconfigure(0, weight=1)
        entry_frame.columnconfigure(1, weight=1)

        copy_frame = ttk.LabelFrame(self.project_tab, text="Copy Options", padding=12)
        copy_frame.pack(fill=tk.X, pady=(0, 12))
        self.copy_option_vars: Dict[str, tk.BooleanVar] = {}
        for group in COPY_RESOURCE_GROUPS:
            row = ttk.Frame(copy_frame)
            row.pack(fill=tk.X, anchor=tk.W, pady=2)
            var = tk.BooleanVar(value=True)
            self.copy_option_vars[group["key"]] = var
            check = ttk.Checkbutton(row, text=group["label"], variable=var)
            check.pack(side=tk.LEFT, anchor=tk.W)
            info = ttk.Label(row, text="ℹ", foreground="#555555")
            info.pack(side=tk.LEFT, padx=(6, 0))
            Tooltip(info, group["tooltip"])

        button_row = ttk.Frame(self.project_tab)
        button_row.pack(anchor=tk.E, pady=8)
        self.retry_bootstrap_btn = ttk.Button(
            button_row,
            text="Retry AI Bootstrap",
            command=self._handle_retry_bootstrap,
            state=tk.DISABLED,
        )
        self.retry_bootstrap_btn.pack(side=tk.LEFT, padx=(0, 8))
        ttk.Button(button_row, text="Create Project", command=self._handle_create_project).pack(side=tk.LEFT)

    def _build_scene_tab(self):
        form = ttk.LabelFrame(self.scene_tab, text="Scene Generator", padding=12)
        form.pack(fill=tk.X)

        self.scene_name_var = tk.StringVar()
        default_template = next(iter(SCENE_TEMPLATES))
        self.scene_template_var = tk.StringVar(value=default_template)

        ttk.Label(form, text="Scene Name").grid(row=0, column=0, sticky=tk.W)
        ttk.Entry(form, textvariable=self.scene_name_var).grid(row=1, column=0, sticky=tk.EW, padx=(0, 8))

        ttk.Label(form, text="Template").grid(row=0, column=1, sticky=tk.W)
        template_combo = ttk.Combobox(
            form,
            values=list(SCENE_TEMPLATES),
            textvariable=self.scene_template_var,
            state="readonly",
        )
        template_combo.grid(row=1, column=1, sticky=tk.EW)

        ttk.Label(form, text="Template Details").grid(row=2, column=0, columnspan=2, sticky=tk.W, pady=(12, 0))
        bg = self._get_theme_background(form)
        self.scene_description = tk.Text(
            form,
            height=6,
            wrap=tk.WORD,
            relief=tk.FLAT,
            state=tk.DISABLED,
            background=bg,
        )
        self.scene_description.grid(row=3, column=0, columnspan=2, sticky=tk.EW)
        self.scene_description.configure(cursor="arrow")

        ttk.Button(form, text="Create Scene", command=self._handle_create_scene).grid(row=4, column=0, columnspan=2, pady=(12, 0))

        form.columnconfigure(0, weight=1)
        form.columnconfigure(1, weight=1)

        self.scene_template_var.trace_add("write", self._update_scene_description)
        self._update_scene_description()

        info = ttk.LabelFrame(self.scene_tab, text="Instructions", padding=12)
        info.pack(fill=tk.BOTH, expand=True, pady=(12, 0))
        text = (
            "Generated files are saved under the project's scenes/ package. "
            "The creator calls _update_schema_with_scene to register the module "
            "and class inside schemas/default_schema.json so schema triggers can "
            "load it. Engine shortcuts like the console toggle live in "
            "schemas/engine_schema.json, and scenes can import core.settings.Settings "
            "to respect the persisted options defined in core/config.py."
        )
        ttk.Label(info, text=text, wraplength=420, justify=tk.LEFT).pack(anchor=tk.W)

    def _build_logic_tab(self):
        self.logic_tab.columnconfigure(0, weight=1)

        intro = ttk.Label(
            self.logic_tab,
            text=(
                "Track scene notes, collaborate with the AI assistant, and "
                "adjust schema transitions without leaving the creator."
            ),
            wraplength=520,
            justify=tk.LEFT,
        )
        intro.pack(anchor=tk.W)

        self.logic_empty_label = ttk.Label(
            self.logic_tab,
            text="Select a project to review game logic.",
            wraplength=520,
            justify=tk.LEFT,
            foreground="#555555",
        )
        self.logic_empty_label.pack(fill=tk.X, pady=(8, 12))

        self.logic_scene_container = ttk.Frame(self.logic_tab)
        self.logic_scene_container.pack(fill=tk.BOTH, expand=True)
        self.logic_scene_container.columnconfigure(0, weight=1)

        ttk.Separator(self.logic_tab, orient=tk.HORIZONTAL).pack(fill=tk.X, pady=12)

        trigger_frame = ttk.LabelFrame(self.logic_tab, text="Trigger Destinations", padding=12)
        trigger_frame.pack(fill=tk.X)
        trigger_frame.columnconfigure(0, weight=1)

        self.logic_transition_container = ttk.Frame(trigger_frame)
        self.logic_transition_container.pack(fill=tk.X)

        self.logic_transition_message = ttk.Label(
            trigger_frame,
            text="Select a project to relabel trigger destinations.",
            wraplength=520,
            justify=tk.LEFT,
            foreground="#555555",
        )
        self.logic_transition_message.pack(fill=tk.X, pady=(8, 0))

        control_row = ttk.Frame(trigger_frame)
        control_row.pack(fill=tk.X, pady=(8, 0))

        self.reset_dev_start_button = ttk.Button(
            control_row,
            text="Use Schema Initial Scene",
            command=self._clear_dev_start_scene,
            state=tk.DISABLED,
        )
        self.reset_dev_start_button.pack(side=tk.LEFT)

        self._refresh_logic_tab()

    def _update_scene_description(self, *_):
        template_key = self.scene_template_var.get()
        template = SCENE_TEMPLATES.get(template_key)
        description = template["description"] if template else ""
        if not hasattr(self, "scene_description"):
            return
        self.scene_description.configure(state=tk.NORMAL)
        self.scene_description.delete("1.0", tk.END)
        self.scene_description.insert(tk.END, description)
        self.scene_description.configure(state=tk.DISABLED)

    def _refresh_logic_tab(self):
        if not hasattr(self, "logic_scene_container"):
            return

        for job in list(self.logic_note_jobs.values()):
            with contextlib.suppress(Exception):
                self.after_cancel(job)
        self.logic_note_jobs.clear()

        for widget in self.logic_scene_container.winfo_children():
            widget.destroy()
        self.logic_note_widgets.clear()

        for widget in self.logic_transition_container.winfo_children():
            widget.destroy()
        self.logic_transition_vars.clear()

        if not self.selected_project:
            self.logic_empty_label.configure(text="Select a project to review game logic.")
            if not self.logic_empty_label.winfo_ismapped():
                self.logic_empty_label.pack(fill=tk.X, pady=(8, 12))
            self.logic_transition_message.configure(
                text="Select a project to relabel trigger destinations."
            )
            self.reset_dev_start_button.configure(state=tk.DISABLED)
            return

        if self.logic_empty_label.winfo_ismapped():
            self.logic_empty_label.pack_forget()

        try:
            project_path = Path(self.selected_project["path"]).expanduser()
        except KeyError:
            self.logic_transition_message.configure(text="Project path missing from registry entry.")
            self.reset_dev_start_button.configure(state=tk.DISABLED)
            return

        schema = self._load_project_schema(project_path)
        scenes = self._extract_schema_scenes(schema)

        engine_data = self._load_engine_schema_data(project_path)
        dev_scene, _ = self._resolve_dev_start_scene(engine_data)
        self.dev_start_var.set(dev_scene)
        self.reset_dev_start_button.configure(state=tk.NORMAL if dev_scene else tk.DISABLED)

        if scenes:
            for scene_name in scenes:
                self._create_scene_editor(project_path, scene_name)
        else:
            ttk.Label(
                self.logic_scene_container,
                text="No scenes registered in schemas/default_schema.json.",
                wraplength=520,
                justify=tk.LEFT,
                foreground="#b3261e",
            ).pack(anchor=tk.W)

        transitions = self._extract_transitions(schema.get("transitions"), scenes)
        if transitions:
            header = ttk.Frame(self.logic_transition_container)
            header.pack(fill=tk.X, pady=(0, 4))
            ttk.Label(header, text="Trigger", font=("Segoe UI", 10, "bold")).grid(row=0, column=0, sticky=tk.W)
            ttk.Label(header, text="Destination", font=("Segoe UI", 10, "bold")).grid(
                row=0, column=1, sticky=tk.W, padx=(12, 0)
            )
            header.columnconfigure(1, weight=1)

            for trigger, destination, options in transitions:
                row = ttk.Frame(self.logic_transition_container)
                row.pack(fill=tk.X, pady=2)
                ttk.Label(row, text=trigger).grid(row=0, column=0, sticky=tk.W)
                var = tk.StringVar(value=destination)
                self.logic_transition_vars[trigger] = var
                combo = ttk.Combobox(row, values=options, textvariable=var, state="readonly")
                combo.grid(row=0, column=1, sticky=tk.EW, padx=(12, 0))
                combo.bind(
                    "<<ComboboxSelected>>",
                    lambda _event, trig=trigger: self._update_transition_destination(trig),
                )
                row.columnconfigure(1, weight=1)

            self.logic_transition_message.configure(
                text="Changes are saved immediately to schemas/default_schema.json."
            )
        else:
            self.logic_transition_message.configure(
                text=(
                    "No transitions defined in schemas/default_schema.json. Add a "
                    "'transitions' section to relabel destinations."
                )
            )

        colors = getattr(self, "_current_theme_colors", {})
        if colors:
            for widget in self.logic_note_widgets.values():
                self._update_logic_note_theme(widget)

    def _load_project_schema(self, project_path: Path) -> Dict[str, Any]:
        schema_path = project_path / "schemas" / "default_schema.json"
        try:
            data = json.loads(schema_path.read_text(encoding="utf8"))
        except (OSError, json.JSONDecodeError):
            return {}
        return data if isinstance(data, dict) else {}

    def _extract_schema_scenes(self, schema: Dict[str, Any]) -> List[str]:
        scenes_field = schema.get("scenes")
        names: List[str] = []

        if isinstance(scenes_field, list):
            for item in scenes_field:
                if isinstance(item, dict):
                    candidate = item.get("scene_name") or item.get("scene") or item.get("name")
                else:
                    candidate = item
                if isinstance(candidate, str) and candidate and candidate not in names:
                    names.append(candidate)
        elif isinstance(scenes_field, dict):
            for key in scenes_field.keys():
                if isinstance(key, str) and key and key not in names:
                    names.append(key)

        initial = schema.get("initial_scene")
        if isinstance(initial, str) and initial and initial not in names:
            names.insert(0, initial)

        return names

    def _scene_note_path(self, project_path: Path, scene_name: str) -> Path:
        slug = self._auto_slug(scene_name)
        return project_path / "logic_notes" / f"{slug}.md"

    def _create_scene_editor(self, project_path: Path, scene_name: str):
        frame = ttk.LabelFrame(self.logic_scene_container, text=scene_name, padding=12)
        frame.pack(fill=tk.BOTH, expand=True, pady=(0, 12))

        actions = ttk.Frame(frame)
        actions.pack(fill=tk.X)

        ttk.Radiobutton(
            actions,
            text="Play from Here",
            variable=self.dev_start_var,
            value=scene_name,
            command=lambda name=scene_name: self._set_dev_start_scene(name),
        ).pack(side=tk.LEFT)

        ai_state = tk.NORMAL if self.chat_panel else tk.DISABLED
        ttk.Button(
            actions,
            text="AI Suggest",
            command=lambda name=scene_name: self._send_scene_notes_to_ai(name),
            state=ai_state,
        ).pack(side=tk.LEFT, padx=(12, 0))

        ttk.Button(
            actions,
            text="Apply Diff",
            command=self._apply_scene_diff,
            state=ai_state,
        ).pack(side=tk.LEFT, padx=(12, 0))

        ttk.Button(
            actions,
            text="Open Scene File",
            command=lambda name=scene_name: self._open_scene_source(project_path, name),
        ).pack(side=tk.LEFT, padx=(12, 0))

        notes = scrolledtext.ScrolledText(frame, height=10, wrap=tk.WORD)
        notes.pack(fill=tk.BOTH, expand=True, pady=(8, 0))

        self.logic_note_widgets[scene_name] = notes
        self._load_logic_note(project_path, scene_name, notes)
        notes.bind(
            "<<Modified>>",
            lambda _event, name=scene_name: self._on_logic_note_modified(name),
        )
        self._update_logic_note_theme(notes)

    def _load_logic_note(
        self,
        project_path: Path,
        scene_name: str,
        widget: scrolledtext.ScrolledText,
    ):
        note_path = self._scene_note_path(project_path, scene_name)
        try:
            content = note_path.read_text(encoding="utf8")
        except OSError:
            content = ""
        widget.configure(state=tk.NORMAL)
        widget.delete("1.0", tk.END)
        widget.insert("1.0", content)
        widget.edit_modified(False)

    def _on_logic_note_modified(self, scene_name: str):
        widget = self.logic_note_widgets.get(scene_name)
        if not widget or not widget.edit_modified():
            return

        widget.edit_modified(False)

        job = self.logic_note_jobs.pop(scene_name, None)
        if job is not None:
            with contextlib.suppress(Exception):
                self.after_cancel(job)

        handle = self.after(750, lambda name=scene_name: self._save_logic_note(name))
        self.logic_note_jobs[scene_name] = handle

    def _save_logic_note(self, scene_name: str):
        job = self.logic_note_jobs.pop(scene_name, None)
        if job is not None:
            with contextlib.suppress(Exception):
                self.after_cancel(job)

        if not self.selected_project:
            return

        widget = self.logic_note_widgets.get(scene_name)
        if not widget:
            return

        try:
            project_path = Path(self.selected_project["path"]).expanduser()
        except KeyError:
            return

        note_path = self._scene_note_path(project_path, scene_name)
        text = widget.get("1.0", tk.END).rstrip()

        try:
            note_path.parent.mkdir(parents=True, exist_ok=True)
            if text:
                note_path.write_text(text + "\n", encoding="utf8")
            elif note_path.exists():
                note_path.unlink()
        except OSError as exc:
            self.log(f"Failed to save logic notes for {scene_name}: {exc}")
            return

        self.log(f"Saved logic notes for {scene_name}")

    def _send_scene_notes_to_ai(self, scene_name: str):
        if not self.chat_panel or not self.selected_project:
            messagebox.showinfo("Game Creator", "Connect the AI assistant before requesting suggestions.")
            return

        self._save_logic_note(scene_name)

        widget = self.logic_note_widgets.get(scene_name)
        if not widget:
            return

        notes = widget.get("1.0", tk.END).strip()

        try:
            project_path = Path(self.selected_project["path"]).expanduser()
        except KeyError:
            return

        scene_path = project_path / "scenes" / f"{self._auto_slug(scene_name)}.py"
        rel_path = scene_path.relative_to(project_path).as_posix() if scene_path.exists() else None

        summary = notes if notes else "(No designer notes provided.)"
        context_line = (
            f"Scene source file: {rel_path}" if rel_path else "Scene source file not found alongside the schema entry."
        )
        prompt = textwrap.dedent(
            f"""
            Please review the Panda3D scene "{scene_name}".

            {context_line}

            Designer notes:
            {summary}

            Suggest gameplay improvements and, when code updates are required, reply with a unified diff for the scene module.
            """
        ).strip()

        self.chat_panel.send_message(prompt, context=rel_path)
        self.log(f"Requested AI suggestions for {scene_name}")

    def _apply_scene_diff(self):
        if not self.chat_panel:
            messagebox.showinfo("Game Creator", "No AI conversation available to apply a diff.")
            return
        self.chat_panel.apply_last_patch()

    def _open_scene_source(self, project_path: Path, scene_name: str):
        scene_path = project_path / "scenes" / f"{self._auto_slug(scene_name)}.py"
        if not scene_path.exists():
            messagebox.showerror("Game Creator", f"Scene file for '{scene_name}' not found.")
            return

        try:
            if sys.platform.startswith("win"):
                os.startfile(scene_path)  # type: ignore[attr-defined]
            elif sys.platform == "darwin":
                subprocess.run(["open", str(scene_path)], check=False)
            else:
                subprocess.run(["xdg-open", str(scene_path)], check=False)
        except Exception as exc:  # pragma: no cover - platform dependent
            messagebox.showerror("Game Creator", f"Failed to open scene file: {exc}")

    def _load_engine_schema_data(self, project_path: Path) -> Dict[str, Any]:
        engine_path = project_path / "schemas" / "engine_schema.json"
        try:
            data = json.loads(engine_path.read_text(encoding="utf8"))
        except (OSError, json.JSONDecodeError):
            return {}
        return data if isinstance(data, dict) else {}

    def _resolve_dev_start_scene(self, engine_data: Dict[str, Any]) -> Tuple[str, str]:
        for key in ("dev_initial_scene", "dev_start_scene"):
            value = engine_data.get(key)
            if isinstance(value, str) and value:
                return value, key
        return "", "dev_initial_scene"

    def _set_dev_start_scene(self, scene_name: str):
        if not self.selected_project:
            return

        try:
            project_path = Path(self.selected_project["path"]).expanduser()
        except KeyError:
            return

        engine_path = project_path / "schemas" / "engine_schema.json"
        engine_data = self._load_engine_schema_data(project_path)

        keys_to_update = [key for key in ("dev_initial_scene", "dev_start_scene") if key in engine_data]
        if not keys_to_update:
            keys_to_update = ["dev_initial_scene"]

        for key in keys_to_update:
            engine_data[key] = scene_name

        try:
            engine_path.write_text(json.dumps(engine_data, indent=2), encoding="utf8")
        except OSError as exc:
            messagebox.showerror("Game Creator", f"Failed to update engine schema: {exc}")
            return

        self.dev_start_var.set(scene_name)
        self.reset_dev_start_button.configure(state=tk.NORMAL)
        self.log(f"Play from Here set to '{scene_name}'")

    def _clear_dev_start_scene(self):
        if not self.selected_project:
            return

        try:
            project_path = Path(self.selected_project["path"]).expanduser()
        except KeyError:
            return

        engine_path = project_path / "schemas" / "engine_schema.json"
        engine_data = self._load_engine_schema_data(project_path)
        modified = False
        for key in ("dev_initial_scene", "dev_start_scene"):
            if key in engine_data:
                engine_data.pop(key, None)
                modified = True

        if not modified:
            self.dev_start_var.set("")
            self.reset_dev_start_button.configure(state=tk.DISABLED)
            return

        try:
            engine_path.write_text(json.dumps(engine_data, indent=2), encoding="utf8")
        except OSError as exc:
            messagebox.showerror("Game Creator", f"Failed to update engine schema: {exc}")
            return

        self.dev_start_var.set("")
        self.reset_dev_start_button.configure(state=tk.DISABLED)
        self.log("Play from Here cleared")

    def _extract_transitions(
        self, transitions_data: Any, scene_names: Iterable[str]
    ) -> List[Tuple[str, str, List[str]]]:
        options_template = list(dict.fromkeys([""] + list(scene_names)))
        results: List[Tuple[str, str, List[str]]] = []

        if isinstance(transitions_data, dict):
            for trigger, destination in transitions_data.items():
                if not isinstance(trigger, str):
                    continue
                dest = destination if isinstance(destination, str) else ""
                options = options_template.copy()
                if dest and dest not in options:
                    options.append(dest)
                results.append((trigger, dest, options))
        elif isinstance(transitions_data, list):
            for item in transitions_data:
                if not isinstance(item, dict):
                    continue
                trigger = item.get("trigger") or item.get("event") or item.get("id")
                if not isinstance(trigger, str):
                    continue
                destination = item.get("destination") or item.get("scene") or item.get("target") or ""
                dest = destination if isinstance(destination, str) else ""
                options = options_template.copy()
                if dest and dest not in options:
                    options.append(dest)
                results.append((trigger, dest, options))

        return results

    def _update_transition_destination(self, trigger: str):
        if not self.selected_project:
            return

        var = self.logic_transition_vars.get(trigger)
        if not var:
            return

        try:
            project_path = Path(self.selected_project["path"]).expanduser()
        except KeyError:
            return

        schema_path = project_path / "schemas" / "default_schema.json"
        try:
            data = json.loads(schema_path.read_text(encoding="utf8"))
        except (OSError, json.JSONDecodeError) as exc:
            messagebox.showerror("Game Creator", f"Failed to load schema: {exc}")
            return

        if not isinstance(data, dict):
            data = {}

        transitions = data.get("transitions")
        destination = var.get()
        updated = False

        if isinstance(transitions, dict):
            transitions[trigger] = destination
            updated = True
        elif isinstance(transitions, list):
            for item in transitions:
                if not isinstance(item, dict):
                    continue
                item_trigger = item.get("trigger") or item.get("event") or item.get("id")
                if item_trigger != trigger:
                    continue
                for key in ("destination", "scene", "target"):
                    if key in item:
                        item[key] = destination
                        updated = True
                        break
                if not updated:
                    item["scene"] = destination
                    updated = True
                break
            else:
                transitions.append({"trigger": trigger, "scene": destination})
                updated = True
        else:
            data["transitions"] = {trigger: destination}
            updated = True

        if not updated:
            return

        try:
            schema_path.write_text(json.dumps(data, indent=2), encoding="utf8")
        except OSError as exc:
            messagebox.showerror("Game Creator", f"Failed to update schema: {exc}")
            return

        self.log(
            f"Transition '{trigger}' now routes to '{destination or 'None'}'"
        )
        self.after(200, self._refresh_logic_tab)

    def _update_logic_note_theme(self, widget: scrolledtext.ScrolledText):
        colors = getattr(self, "_current_theme_colors", {})
        bg = colors.get("text_bg") if colors else None
        fg = colors.get("fg") if colors else None
        if not bg:
            bg = self._get_theme_background(widget)
        if not fg:
            fg = widget.cget("foreground")
        widget.configure(background=bg, foreground=fg, insertbackground=fg)

    def _build_asset_tab(self):
        form = ttk.LabelFrame(self.asset_tab, text="Asset Importer", padding=12)
        form.pack(fill=tk.BOTH, expand=True)

        ttk.Label(form, text="Destination Type").grid(row=0, column=0, sticky=tk.W)
        self.asset_destination_var = tk.StringVar(value="Models")
        ttk.Combobox(
            form,
            values=list(ASSET_DESTINATIONS),
            textvariable=self.asset_destination_var,
            state="readonly",
        ).grid(row=1, column=0, sticky=tk.EW)

        ttk.Button(form, text="Add Files", command=self._handle_import_assets).grid(row=1, column=1, padx=(12, 0))

        ttk.Label(
            form,
            text="Tip: select multiple files to batch copy them into the project.",
            wraplength=400,
        ).grid(row=2, column=0, columnspan=2, pady=(12, 0))

        browser = ttk.Frame(form)
        browser.grid(row=3, column=0, columnspan=2, sticky=tk.NSEW, pady=(12, 0))

        tree_frame = ttk.Frame(browser)
        tree_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

        columns = ("fullpath", "kind", "relpath", "scenes")
        self.asset_tree = ttk.Treeview(
            tree_frame,
            columns=columns,
            displaycolumns=("scenes",),
            show="tree headings",
            selectmode="browse",
        )
        self.asset_tree.heading("scenes", text="Scenes")
        self.asset_tree.column("scenes", width=180, anchor=tk.W)
        self.asset_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

        tree_scroll = ttk.Scrollbar(tree_frame, orient=tk.VERTICAL, command=self.asset_tree.yview)
        tree_scroll.pack(side=tk.RIGHT, fill=tk.Y)
        self.asset_tree.configure(yscrollcommand=tree_scroll.set)
        self.asset_tree.bind("<<TreeviewSelect>>", self._on_asset_selected)

        preview_frame = ttk.LabelFrame(browser, text="Preview", padding=8)
        preview_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=(12, 0))

        self.asset_preview_title = ttk.Label(preview_frame, text="Select an asset to preview", font=("Segoe UI", 10, "bold"))
        self.asset_preview_title.grid(row=0, column=0, sticky=tk.W)

        self.asset_preview_canvas = tk.Label(preview_frame, borderwidth=1, relief=tk.SOLID)
        self.asset_preview_canvas.grid(row=1, column=0, sticky=tk.NSEW, pady=(8, 0))

        self.asset_preview_text = tk.Text(preview_frame, height=10, wrap=tk.WORD, state=tk.DISABLED)
        self.asset_preview_text.grid(row=2, column=0, sticky=tk.NSEW, pady=(8, 0))

        self.asset_preview_meta = ttk.Label(preview_frame, text="", wraplength=260, justify=tk.LEFT)
        self.asset_preview_meta.grid(row=3, column=0, sticky=tk.W, pady=(8, 0))

        remix_row = ttk.Frame(preview_frame)
        remix_row.grid(row=4, column=0, sticky=tk.EW, pady=(4, 0))
        remix_row.columnconfigure(0, weight=1)
        self.ai_remix_button = ttk.Button(
            remix_row,
            text="AI Remix",
            command=self._handle_ai_remix,
            state=tk.DISABLED,
        )
        self.ai_remix_button.grid(row=0, column=1, sticky=tk.E, padx=(8, 0))

        tag_frame = ttk.LabelFrame(preview_frame, text="Scene Tags", padding=8)
        tag_frame.grid(row=5, column=0, sticky=tk.NSEW, pady=(12, 0))
        tag_frame.columnconfigure(0, weight=1)
        self.asset_tag_container = ttk.Frame(tag_frame)
        self.asset_tag_container.grid(row=0, column=0, sticky=tk.NSEW)
        self.asset_tag_hint = ttk.Label(
            tag_frame,
            text="Toggle scenes to immediately save tag metadata.",
            wraplength=240,
            justify=tk.LEFT,
            foreground="#555555",
        )
        self.asset_tag_hint.grid(row=1, column=0, sticky=tk.W, pady=(6, 0))
        self.asset_tag_status = ttk.Label(tag_frame, text="", foreground="#2d7a2d")
        self.asset_tag_status.grid(row=2, column=0, sticky=tk.W, pady=(6, 0))

        preview_frame.rowconfigure(1, weight=3)
        preview_frame.rowconfigure(2, weight=2)
        preview_frame.columnconfigure(0, weight=1)

        form.columnconfigure(0, weight=1)
        form.rowconfigure(3, weight=1)

        self._clear_asset_preview("Select a project to browse assets.")
        self._refresh_asset_browser()

    def _build_blender_tab(self):
        config = ttk.LabelFrame(self.blender_tab, text="Blender Setup", padding=12)
        config.pack(fill=tk.X)

        exec_row = ttk.Frame(config)
        exec_row.grid(row=0, column=0, columnspan=3, sticky=tk.EW)
        ttk.Label(exec_row, text="Blender Executable").grid(row=0, column=0, sticky=tk.W)
        ttk.Entry(exec_row, textvariable=self.blender_path_var).grid(row=1, column=0, sticky=tk.EW, pady=(2, 0))
        ttk.Button(exec_row, text="Browse", command=self._browse_blender_executable).grid(
            row=1, column=1, padx=(8, 0)
        )
        exec_row.columnconfigure(0, weight=1)

        addon_row = ttk.Frame(config)
        addon_row.grid(row=1, column=0, columnspan=3, sticky=tk.EW, pady=(12, 0))
        ttk.Label(addon_row, text="Add-on Folder").grid(row=0, column=0, sticky=tk.W)
        ttk.Entry(addon_row, textvariable=self.blender_addon_var).grid(row=1, column=0, sticky=tk.EW, pady=(2, 0))
        ttk.Button(addon_row, text="Browse", command=self._browse_blender_addon_path).grid(
            row=1, column=1, padx=(8, 0)
        )
        addon_row.columnconfigure(0, weight=1)

        ttk.Button(config, text="Save Settings", command=self._save_blender_settings).grid(
            row=2, column=0, sticky=tk.W, pady=(12, 0)
        )
        self.blender_launch_button = ttk.Button(
            config,
            text="Launch Blender",
            command=self._launch_blender,
        )
        self.blender_launch_button.grid(row=2, column=1, sticky=tk.W, padx=(8, 0), pady=(12, 0))

        ttk.Label(
            config,
            textvariable=self.blender_status_var,
            wraplength=420,
            foreground="#555555",
        ).grid(row=3, column=0, columnspan=3, sticky=tk.W, pady=(12, 0))

        project_frame = ttk.LabelFrame(self.blender_tab, text="Project Context", padding=12)
        project_frame.pack(fill=tk.X, pady=(12, 0))
        ttk.Label(project_frame, textvariable=self.blender_project_var).pack(anchor=tk.W)
        self.blender_project_details = ttk.Label(
            project_frame,
            text="",
            justify=tk.LEFT,
            wraplength=420,
        )
        self.blender_project_details.pack(anchor=tk.W, pady=(6, 0))

        quick_frame = ttk.LabelFrame(self.blender_tab, text="Quick Actions", padding=12)
        quick_frame.pack(fill=tk.BOTH, expand=True, pady=(12, 0))
        actions = [
            ("New UI Panel", "new_ui_panel"),
            ("Export Sprite Sheet", "export_sprite_sheet"),
            ("Export Mesh", "export_mesh"),
        ]
        for index, (label, action) in enumerate(actions):
            button = ttk.Button(
                quick_frame,
                text=label,
                command=lambda name=action: self._run_blender_quick_action(name),
            )
            button.grid(row=index, column=0, sticky=tk.EW, pady=4)
            self.blender_quick_action_buttons[action] = button
        quick_frame.columnconfigure(0, weight=1)

        self._refresh_blender_tab_state()

    def _build_ai_tab(self):
        self.chat_panel = ChatPanel(self.ai_tab, log_callback=self.log)
        self.chat_panel.pack(fill=tk.BOTH, expand=True)
        self.chat_panel.append_system_message(
            "Select a project and choose a context file before chatting with the assistant."
        )
        self._refresh_logic_tab()

    # ------------------------------------------------------------------
    # Utility methods
    # ------------------------------------------------------------------
    def log(self, message: str):
        timestamp = datetime.now().strftime("%H:%M:%S")
        self.log_text.configure(state=tk.NORMAL)
        self.log_text.insert(tk.END, f"[{timestamp}] {message}\n")
        self.log_text.configure(state=tk.DISABLED)
        self.log_text.see(tk.END)

    def _auto_slug(self, title: str) -> str:
        allowed = string.ascii_lowercase + string.digits + "-"
        slug = (
            title.lower()
            .replace("_", "-")
            .replace(" ", "-")
        )
        slug = "".join(ch for ch in slug if ch in allowed)
        return slug or "new-game"

    def _scene_class_name(self, label: str) -> str:
        slug = self._auto_slug(label)
        return "".join(part.capitalize() for part in slug.split("-") if part) + "Scene"

    def _handle_project_select(self, event=None):
        title = self.project_selector_var.get().strip()
        if not title:
            self._set_selected_project(None, persist=True)
            return

        current_title = (self.selected_project or {}).get("title")
        if current_title == title:
            return

        self._set_selected_project(title, log_selection=True, persist=True)

    def _open_selected_folder(self):  # pragma: no cover - opens file explorer
        if not self.selected_project:
            messagebox.showinfo("Game Creator", "Select a project first")
            return
        path = Path(self.selected_project["path"]).expanduser()
        if not path.exists():
            messagebox.showerror("Game Creator", "Project folder no longer exists.")
            return
        os.startfile(path) if os.name == "nt" else os.system(f"xdg-open '{path}'")

    def _forget_selected_project(self):
        if not self.selected_project:
            messagebox.showinfo("Game Creator", "Nothing selected")
            return
        key = self.selected_project["title"]
        if messagebox.askyesno("Game Creator", f"Forget project '{key}'?"):
            projects = self.registry.get("projects", {})
            projects.pop(key, None)
            meta = self.registry.get("meta", {})
            if meta.get("last_opened") == key:
                meta.pop("last_opened", None)
            self._save_registry()
            self.log(f"Forgot project '{key}'")
            self._refresh_project_list()

    def _browse_destination(self):
        folder = filedialog.askdirectory()
        if folder:
            self.project_location_var.set(folder)

    # ------------------------------------------------------------------
    # Project creation workflow
    # ------------------------------------------------------------------
    def _handle_create_project(self):
        title = self.project_name_var.get().strip()
        if not title:
            messagebox.showerror("Game Creator", "Please provide a game title.")
            return

        slug = self.project_slug_var.get().strip() or self._auto_slug(title)
        dest_root = Path(self.project_location_var.get()).expanduser()
        if not dest_root.exists():
            messagebox.showerror("Game Creator", "Destination folder does not exist.")
            return

        project_path = dest_root / slug
        if project_path.exists():
            messagebox.showerror(
                "Game Creator",
                (
                    "A project with this slug already exists. The slug is "
                    "used for both the project folder name and its internal "
                    "identifier, so it must be unique. Please choose a "
                    "different slug."
                ),
            )
            return

        description = self.project_description.get("1.0", tk.END).strip()
        description = description or DEFAULT_DESCRIPTION

        copy_options = {key: var.get() for key, var in self.copy_option_vars.items()}

        dialog = AIBootstrapDialog(
            self,
            archetypes=ARCHETYPES,
            initial_brief=self._last_bootstrap_brief,
        )
        brief = dialog.show()
        if brief is None:
            self.log("AI bootstrap canceled; project creation aborted.")
            self._pending_project = None
            self._update_retry_state()
            return

        archetype_id = brief.get("archetype_id")
        archetype_data: Optional[Dict[str, Any]] = None
        if archetype_id:
            try:
                archetype_data = coerce_archetype(ARCHETYPES, str(archetype_id))
            except KeyError:
                archetype_data = None
        if archetype_data is None and ARCHETYPES:
            archetype_data = copy.deepcopy(ARCHETYPES[0])
        if archetype_data:
            brief["archetype"] = archetype_data
            brief.setdefault("archetype_id", archetype_data.get("id"))
            brief.setdefault("archetype_label", archetype_data.get("name"))

        brief.update({"title": title, "slug": slug})
        self._pending_project = {
            "title": title,
            "slug": slug,
            "project_path": project_path,
            "description": description,
            "copy_options": copy_options,
        }
        self._update_retry_state()
        self._last_bootstrap_brief = brief
        plan = self._invoke_ai_bootstrap(brief)
        if not plan:
            self.log("AI bootstrap failed. Adjust the brief or retry.")
            self._update_retry_state()
            return

        self._last_bootstrap_plan = plan
        self._start_project_creation(plan)

    def _handle_retry_bootstrap(self):
        if not self._pending_project or not self._last_bootstrap_brief:
            messagebox.showinfo(
                "Game Creator",
                "Retry is only available immediately after a failed bootstrap.",
            )
            return

        self.log("Retrying AI bootstrap with the last brief...")
        plan = self._invoke_ai_bootstrap(self._last_bootstrap_brief, is_retry=True)
        if not plan:
            self.log("Retry attempt failed. Check logs for details.")
            self._update_retry_state()
            return

        self._last_bootstrap_plan = plan
        self._start_project_creation(plan)

    def _update_retry_state(self):
        if hasattr(self, "retry_bootstrap_btn"):
            state = tk.NORMAL if (self._pending_project and self._last_bootstrap_brief) else tk.DISABLED
            self.retry_bootstrap_btn.configure(state=state)

    def _build_repo_map(self, max_entries: int = 18) -> str:
        entries: List[str] = []
        for path in sorted(ROOT.iterdir(), key=lambda item: item.name.lower()):
            if path.name.startswith("."):
                continue
            if path.name in {"__pycache__", "venv", "env", "build"}:
                continue
            if path.is_dir():
                try:
                    children = sorted(child.name for child in path.iterdir())[:4]
                except OSError:
                    children = []
                label = f"{path.name}/"
                if children:
                    label += " -> " + ", ".join(children)
                entries.append(label)
            else:
                entries.append(path.name)
            if len(entries) >= max_entries:
                break
        return "\n".join(entries)

    def _invoke_ai_bootstrap(
        self,
        brief: Dict[str, Any],
        *,
        is_retry: bool = False,
    ) -> Optional[Dict[str, Any]]:
        payload = {
            "brief": brief,
            "archetypes": ARCHETYPES,
            "repo_map": self._build_repo_map(),
            "timestamp": datetime.now(UTC).isoformat(),
        }

        if not CHATBOT_CLI.exists():
            messagebox.showerror("Game Creator", f"Chatbot CLI not found at {CHATBOT_CLI}.")
            return None

        context_note = " (retry)" if is_retry else ""
        self.log(f"Contacting local chatbot for bootstrap plan{context_note}...")
        try:
            completed = subprocess.run(
                [sys.executable, str(CHATBOT_CLI)],
                input=json.dumps(payload).encode("utf8"),
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                check=True,
            )
        except subprocess.CalledProcessError as exc:
            stderr = exc.stderr.decode("utf8", errors="ignore") if exc.stderr else exc.stderr
            self.log(f"Chatbot call failed: {stderr or exc}")
            return None
        except OSError as exc:  # pragma: no cover - environment failure
            self.log(f"Unable to launch chatbot CLI: {exc}")
            return None

        output = completed.stdout.decode("utf8", errors="ignore")
        try:
            plan = json.loads(output)
        except json.JSONDecodeError as exc:
            snippet = output[:200].strip().replace("\n", " ")
            self.log(f"Invalid chatbot response: {exc}. Output: {snippet}")
            return None

        self._last_prompt_cache = self._cache_prompt_response(payload, plan)
        if self._last_prompt_cache:
            cache_prompt_path = Path(self._last_prompt_cache.get("prompt", ""))
            try:
                cache_prompt = cache_prompt_path.relative_to(ROOT)
            except ValueError:
                cache_prompt = cache_prompt_path
            self.log(f"AI bootstrap completed successfully. Cached prompt at {cache_prompt}.")
        else:
            self.log("AI bootstrap completed successfully.")
        return plan

    def _cache_prompt_response(
        self,
        payload: Dict[str, Any],
        response: Dict[str, Any],
    ) -> Dict[str, str]:
        PROMPT_CACHE_DIR.mkdir(parents=True, exist_ok=True)
        IMPLEMENTED_LOGIC_DIR.mkdir(parents=True, exist_ok=True)
        timestamp = datetime.now(UTC).strftime("%Y%m%dT%H%M%S")
        prompt_path = PROMPT_CACHE_DIR / f"bootstrap_{timestamp}.prompt.json"
        response_path = PROMPT_CACHE_DIR / f"bootstrap_{timestamp}.response.json"
        prompt_path.write_text(json.dumps(payload, indent=2), encoding="utf8")
        response_path.write_text(json.dumps(response, indent=2), encoding="utf8")

        index_entry = {
            "timestamp": datetime.now(UTC).isoformat(),
            "prompt": str(prompt_path.relative_to(ROOT)),
            "response": str(response_path.relative_to(ROOT)),
        }
        index_path = IMPLEMENTED_LOGIC_DIR / "index.jsonl"
        with index_path.open("a", encoding="utf8") as handle:
            handle.write(json.dumps(index_entry) + "\n")

        return {"prompt": str(prompt_path), "response": str(response_path)}

    def _start_project_creation(self, plan: Dict[str, Any]):
        if not self._pending_project:
            return

        title = self._pending_project["title"]
        slug = self._pending_project["slug"]
        project_path = self._pending_project["project_path"]
        description = self._pending_project["description"]
        copy_options = self._pending_project["copy_options"]
        self.ai_initial_scene = (
            plan.get("initial_schema_overrides", {}).get("initial_scene") if isinstance(plan, dict) else None
        )
        if self.ai_initial_scene is None and self._last_bootstrap_brief:
            archetype = self._last_bootstrap_brief.get("archetype")
            if isinstance(archetype, dict):
                defaults = list(iter_default_scenes(archetype))
                if defaults:
                    preferred = next((item for item in defaults if item.get("initial")), defaults[0])
                    scene_name = preferred.get("scene_name")
                    if scene_name:
                        self.ai_initial_scene = self._scene_class_name(scene_name)

        self._current_task = f"Creating project '{title}'"
        self.log(self._current_task)
        try:
            self.worker.start(
                self._create_project_task,
                title,
                slug,
                project_path,
                description,
                copy_options,
                plan,
                self._last_bootstrap_brief,
            )
        except RuntimeError as exc:
            messagebox.showerror("Game Creator", str(exc))
            self.log(f"Task failed: {exc}")
            self._update_retry_state()
            return

        self._pending_project = None
        self._update_retry_state()

        self._current_task = f"Creating project '{title}'"
        self.log(self._current_task)

        self.worker.start(
            self._create_project_task,
            title,
            slug,
            project_path,
            description,
            copy_options,
            plan,
            self._last_bootstrap_brief,
        )

    def _create_project_task(
        self,
        title: str,
        slug: str,
        target: Path,
        description: str,
        options: Dict[str, bool],
        ai_plan: Optional[Dict[str, Any]],
        ai_brief: Optional[Dict[str, Any]],
    ):
        target.mkdir(parents=True, exist_ok=False)
        replacements = self._build_replacement_map(title, slug)
        self._copy_template(target, options, replacements)
        self._write_metadata(
            target,
            title,
            slug,
            description,
            initial_scene=self.ai_initial_scene,
            expanded_narrative=(ai_plan or {}).get("expanded_narrative") if ai_plan else None,
            bootstrap_brief=ai_brief,
        )
        if ai_plan or (ai_brief and isinstance(ai_brief, dict) and ai_brief.get("archetype")):
            self._apply_ai_plan(target, ai_plan or {}, slug, ai_brief=ai_brief)
        self._register_project(target, title)
        self.ai_initial_scene = None

    def _build_replacement_map(self, title: str, slug: str) -> Dict[str, str]:
        camel = self._camel_case_identifier(title, slug)
        return {
            "Py-Game-Creator": title,
            "py_game_creator": slug,
            "PyGameCreator": camel,
        }

    def _camel_case_identifier(self, title: str, slug: str) -> str:
        source = slug or self._auto_slug(title)
        cleaned = re.sub(r"[^0-9a-zA-Z]+", " ", source)
        parts = [part for part in cleaned.replace("-", " ").replace("_", " ").split() if part]
        if not parts:
            fallback = re.sub(r"[^0-9a-zA-Z]+", "", title)
            return fallback or "Project"
        return "".join(part.capitalize() for part in parts)

    def _copy_template(self, target: Path, options: Dict[str, bool], replacements: Dict[str, str]):
        disabled_paths = {
            path
            for group in COPY_RESOURCE_GROUPS
            if not options.get(group["key"], True)
            for path in group["paths"]
        }

        def _ignore(_: str, names: List[str]):
            filtered = []
            for name in names:
                if name in IGNORED_TEMPLATE_ITEMS:
                    filtered.append(name)
                    continue
                if name in disabled_paths:
                    filtered.append(name)
            return set(filtered)

        def _copy_with_tokens(src: str, dst: str, *, follow_symlinks: bool = True):
            src_path = Path(src)
            dst_path = Path(dst)
            if not src_path.is_file():
                return shutil.copy2(src, dst, follow_symlinks=follow_symlinks)
            try:
                text = src_path.read_text(encoding="utf8")
            except (UnicodeDecodeError, OSError):
                return shutil.copy2(src, dst, follow_symlinks=follow_symlinks)
            updated = self._apply_replacements(text, replacements)
            dst_path.write_text(updated, encoding="utf8")
            shutil.copystat(src, dst, follow_symlinks=follow_symlinks)
            return dst

        shutil.copytree(
            ROOT,
            target,
            dirs_exist_ok=True,
            ignore=_ignore,
            copy_function=_copy_with_tokens,
        )

        # Remove self and registry from the new project to avoid confusion
        for extra in ["game_creator.py", "game_creator_registry.json"]:
            extra_path = target / extra
            if extra_path.exists():
                if extra_path.is_dir():
                    shutil.rmtree(extra_path)
                else:
                    extra_path.unlink()

    def _apply_ai_plan(
        self,
        target: Path,
        plan: Dict[str, Any],
        slug: str,
        *,
        ai_brief: Optional[Dict[str, Any]] = None,
    ):
        scenes = plan.get("scenes_to_create") or []
        if not scenes and ai_brief:
            archetype = ai_brief.get("archetype") if isinstance(ai_brief, dict) else None
            if isinstance(archetype, dict):
                normalized: List[Dict[str, Any]] = []
                for spec in iter_default_scenes(archetype):
                    entry = dict(spec)
                    scene_name = entry.get("scene_name")
                    if scene_name and "name" not in entry:
                        entry["name"] = scene_name
                    normalized.append(entry)
                scenes = normalized

        initial_scene_from_archetype: Optional[str] = None
        for spec in scenes:
            if not isinstance(spec, dict):
                continue
            name = str(spec.get("name") or "Scene")
            template_key = str(spec.get("template") or "")
            if template_key not in SCENE_TEMPLATES:
                template_key = next(iter(SCENE_TEMPLATES))
            template_spec = SCENE_TEMPLATES[template_key]
            class_name = self._scene_class_name(name)
            file_path = target / "scenes" / f"{self._auto_slug(name)}.py"
            file_path.parent.mkdir(parents=True, exist_ok=True)
            if file_path.exists():
                continue

            summary_text = str(spec.get("summary") or "").strip()
            summary_doc = (
                f'"""{textwrap.fill(summary_text, width=88)}"""' if summary_text else None
            )
            header = self._scene_header(summary_doc)
            content = header + template_spec["template"].format(class_name=class_name, scene_name=name)
            file_path.write_text(content, encoding="utf8")
            self._update_schema_with_scene(target, class_name, file_path)
            if spec.get("initial") and not initial_scene_from_archetype:
                initial_scene_from_archetype = class_name

        overrides = plan.get("initial_schema_overrides")
        if isinstance(overrides, dict):
            self._merge_schema_overrides(target, overrides)
        elif initial_scene_from_archetype:
            self._update_initial_scene(target, initial_scene_from_archetype)
            if not self.ai_initial_scene:
                self.ai_initial_scene = initial_scene_from_archetype

        placeholders = plan.get("asset_placeholders")
        if isinstance(placeholders, list) and placeholders:
            self._seed_asset_placeholders(target, placeholders, slug)

    def _apply_replacements(self, text: str, replacements: Dict[str, str]) -> str:
        updated = text
        for token, value in replacements.items():
            updated = updated.replace(token, value)
        return updated

    def _write_metadata(
        self,
        target: Path,
        title: str,
        slug: str,
        description: str,
        *,
        initial_scene: Optional[str] = None,
        expanded_narrative: Optional[str] = None,
        bootstrap_brief: Optional[Dict[str, Any]] = None,
    ):
        metadata_path = target / "game_metadata.json"
        if metadata_path.exists():
            data = json.loads(metadata_path.read_text(encoding="utf8"))
        else:
            data = {}
        data.update(
            {
                "title": title,
                "identifier": slug,
                "description": description,
                "long_description": description,
                "created": datetime.now(UTC).isoformat(timespec="seconds"),
            }
        )
        if expanded_narrative:
            data["expanded_narrative"] = expanded_narrative
        if bootstrap_brief:
            data["ai_bootstrap_brief"] = bootstrap_brief
        metadata_path.write_text(json.dumps(data, indent=2), encoding="utf8")
        self._update_readme_headings(target, title)
        self._update_launcher_titles(target, title)
        if initial_scene and initial_scene != DEFAULT_INITIAL_SCENE:
            self._update_initial_scene(target, initial_scene)

    def _update_readme_headings(self, target: Path, title: str):
        for name in ("README.md", "Readme.md"):
            path = target / name
            if not path.exists():
                continue
            try:
                content = path.read_text(encoding="utf8")
            except (OSError, UnicodeDecodeError):  # pragma: no cover - manual repair path
                continue
            lines = content.splitlines()
            if not lines:
                continue
            if lines[0].startswith("# "):
                heading = f"# {title}"
                if lines[0] != heading:
                    lines[0] = heading
                updated_content = "\n".join(lines)
                if content.endswith("\n"):
                    updated_content += "\n"
            else:
                updated_content = self._apply_replacements(
                    content,
                    {"Py-Game-Creator": title},
                )
            if updated_content != content:
                path.write_text(updated_content, encoding="utf8")

    def _update_launcher_titles(self, target: Path, title: str):
        launcher_path = target / "launcher.py"
        if not launcher_path.exists():
            return
        try:
            content = launcher_path.read_text(encoding="utf8")
        except (OSError, UnicodeDecodeError):  # pragma: no cover - manual repair path
            return
        replacements = {
            "Py-Game-Creator Launcher": f"{title} Launcher",
            "Py-Game-Creator": title,
        }
        updated = self._apply_replacements(content, replacements)
        if updated != content:
            launcher_path.write_text(updated, encoding="utf8")

    def _update_initial_scene(self, target: Path, initial_scene: str):
        schema_path = target / "schemas" / "default_schema.json"
        if not schema_path.exists():
            return
        try:
            data = json.loads(schema_path.read_text(encoding="utf8"))
        except (OSError, json.JSONDecodeError):  # pragma: no cover - manual repair path
            return
        if not isinstance(data, dict):
            return
        if data.get("initial_scene") == initial_scene:
            return
        data["initial_scene"] = initial_scene
        schema_path.write_text(json.dumps(data, indent=2), encoding="utf8")

    def _register_project(self, target: Path, title: str):
        projects = self.registry.setdefault("projects", {})
        projects[title] = {
            "title": title,
            "path": str(target),
            "created": datetime.now(UTC).isoformat(timespec="seconds"),
        }
        self.registry.setdefault("meta", {})["last_opened"] = title
        self._save_registry()

    # ------------------------------------------------------------------
    # Scene creation workflow
    # ------------------------------------------------------------------
    def _handle_create_scene(self):
        if not self._ensure_project_selected():
            return
        name = self.scene_name_var.get().strip()
        if not name:
            messagebox.showerror("Game Creator", "Provide a scene name.")
            return

        template_key = self.scene_template_var.get()
        template_spec = SCENE_TEMPLATES[template_key]
        template = template_spec["template"]
        project_path = Path(self.selected_project["path"]).expanduser()
        scenes_dir = project_path / "scenes"
        scenes_dir.mkdir(exist_ok=True)
        class_name = "".join(part.capitalize() for part in self._auto_slug(name).split("-")) + "Scene"
        file_path = scenes_dir / f"{self._auto_slug(name)}.py"
        if file_path.exists():
            messagebox.showerror("Game Creator", "Scene file already exists.")
            return

        header = self._scene_header()
        content = header + template.format(class_name=class_name, scene_name=name)
        file_path.write_text(content, encoding="utf8")

        self._update_schema_with_scene(project_path, class_name, file_path)
        self.log(f"Created scene '{name}' at {file_path.relative_to(project_path)}")

    def _update_schema_with_scene(self, project_path: Path, class_name: str, file_path: Path):
        schema_path = project_path / "schemas" / "default_schema.json"
        if not schema_path.exists():
            return
        data = json.loads(schema_path.read_text(encoding="utf8"))
        scenes = data.setdefault("scenes", {})
        scene_key = class_name
        scenes[scene_key] = {
            "module": f"scenes.{file_path.stem}",
            "class": class_name,
        }
        data.setdefault("initial_scene", scene_key)
        schema_path.write_text(json.dumps(data, indent=2), encoding="utf8")

    def _merge_schema_overrides(self, project_path: Path, overrides: Dict[str, Any]):
        schema_path = project_path / "schemas" / "default_schema.json"
        if not schema_path.exists():
            return
        try:
            data = json.loads(schema_path.read_text(encoding="utf8"))
        except (OSError, json.JSONDecodeError):
            return
        if not isinstance(data, dict):
            return

        def _merge(target: Dict[str, Any], updates: Dict[str, Any]):
            for key, value in updates.items():
                if isinstance(value, dict) and isinstance(target.get(key), dict):
                    _merge(target[key], value)
                else:
                    target[key] = value

        _merge(data, overrides)
        schema_path.write_text(json.dumps(data, indent=2), encoding="utf8")

    def _seed_asset_placeholders(
        self,
        project_path: Path,
        placeholders: List[Dict[str, Any]],
        slug: str,
    ):
        if not placeholders:
            return

        output_dir = project_path / "assets" / "textures" / "ui"
        output_dir.mkdir(parents=True, exist_ok=True)

        records: List[Dict[str, Any]] = []
        index = self._load_asset_index(project_path)
        existing_assets = index.get("assets", {})

        for asset in placeholders:
            if not isinstance(asset, dict):
                continue

            scenes = asset.get("scenes")
            if isinstance(scenes, list):
                scene_tags = [str(tag) for tag in scenes if str(tag).strip()]
            else:
                scene_tags = []
            if not scene_tags:
                scene_tags = [GLOBAL_SCENE_TAG]

            label = str(asset.get("label") or f"{slug.title()} UI")
            prompt = str(asset.get("description") or f"Placeholder art for {label}")

            try:
                result = generate_logo(
                    label,
                    scene_tags=scene_tags,
                    prompt=prompt,
                    output_dir=output_dir,
                )
            except Exception as exc:  # pragma: no cover - environment dependent
                self.log(f"Failed to generate placeholder art: {exc}")
                continue

            base_rel = result.base_path.relative_to(project_path).as_posix()
            version_rel = result.version_path.relative_to(project_path).as_posix()
            existing_entry = existing_assets.get(base_rel, {})
            versions = list(existing_entry.get("versions") or [])
            if version_rel not in versions:
                versions.append(version_rel)

            existing_scenes = set(existing_entry.get("scenes") or [])
            updated_scenes = sorted(existing_scenes.union(scene_tags))

            records.append(
                {
                    "relative_path": base_rel,
                    "destination": asset.get("category") or "ui",
                    "label": label,
                    "description": prompt,
                    "scenes": updated_scenes,
                    "source_path": str(result.base_path),
                    "latest_version": version_rel,
                    "versions": versions,
                    "timestamp": result.metadata.get("generated_at"),
                    "cache": result.cache_entry,
                }
            )

        if records:
            self._update_asset_metadata(project_path, records)

    # ------------------------------------------------------------------
    # Asset metadata helpers
    # ------------------------------------------------------------------
    def _asset_index_path(self, project_path: Path) -> Path:
        return project_path / "assets" / ASSET_INDEX_FILENAME

    def _load_asset_index(self, project_path: Path) -> Dict[str, Any]:
        index_path = self._asset_index_path(project_path)
        if not index_path.exists():
            return {"assets": {}}
        try:
            data = json.loads(index_path.read_text(encoding="utf8"))
        except (OSError, json.JSONDecodeError):  # pragma: no cover - malformed manual edit
            return {"assets": {}}
        assets = data.get("assets")
        if not isinstance(assets, dict):
            assets = {}
        return {"assets": assets}

    def _save_asset_index(self, project_path: Path, data: Dict[str, Any]):
        index_path = self._asset_index_path(project_path)
        index_path.parent.mkdir(parents=True, exist_ok=True)
        payload = {"assets": data.get("assets", {})}
        index_path.write_text(json.dumps(payload, indent=2), encoding="utf8")

    def _update_asset_metadata(self, project_path: Path, records: Iterable[Dict[str, Any]]):
        index = self._load_asset_index(project_path)
        assets = index.setdefault("assets", {})
        now = datetime.now(UTC).isoformat()
        changed = False
        for record in records:
            relative_path = record.get("relative_path")
            if not relative_path:
                continue
            relative_path = relative_path.replace("\\", "/")
            entry = assets.get(relative_path, {}).copy()
            entry.setdefault("imported_at", record.get("imported_at", now))
            if record.get("destination"):
                entry["destination"] = record["destination"]
            if record.get("source_path"):
                entry["source_path"] = record["source_path"]
            if record.get("label"):
                entry["label"] = record["label"]
            if record.get("description"):
                entry["description"] = record["description"]
            scenes = record.get("scenes")
            if scenes is not None:
                existing = set(entry.get("scenes") or [])
                existing.update(scene for scene in scenes if scene)
                entry["scenes"] = sorted(existing)
            versions = record.get("versions")
            if isinstance(versions, list):
                existing_versions = list(entry.get("versions") or [])
                for version in versions:
                    if version and version not in existing_versions:
                        existing_versions.append(version)
                entry["versions"] = existing_versions
            if record.get("latest_version"):
                entry["latest_version"] = record["latest_version"]
            if record.get("cache"):
                history = list(entry.get("cache_history") or [])
                history.append(record["cache"])
                entry["cache_history"] = history
                entry["cache"] = record["cache"]
            timestamp_value = record.get("timestamp")
            if timestamp_value:
                entry["timestamp"] = timestamp_value
            else:
                entry.setdefault("timestamp", now)
            entry["updated_at"] = now
            assets[relative_path] = entry
            changed = True
        if changed:
            index["assets"] = assets
            self._save_asset_index(project_path, index)
            self.asset_metadata = assets
            self._surface_asset_metadata(project_path, assets)
        return assets

    def _surface_asset_metadata(self, project_path: Path, asset_map: Dict[str, Dict[str, Any]]):
        self._write_asset_schema(project_path, asset_map)
        self._write_asset_sb_manifest(project_path, asset_map)

    def _write_asset_schema(self, project_path: Path, asset_map: Dict[str, Dict[str, Any]]):
        schema_path = project_path / "schemas" / "default_schema.json"
        if not schema_path.exists():
            return
        try:
            data = json.loads(schema_path.read_text(encoding="utf8"))
        except (OSError, json.JSONDecodeError):  # pragma: no cover - manual repair path
            return
        serialised = {}
        for rel_path, meta in sorted(asset_map.items()):
            scenes = list(meta.get("scenes", []))
            serialised[rel_path] = {
                "destination": meta.get("destination"),
                "scenes": scenes,
                "updated_at": meta.get("updated_at"),
            }
        data["asset_mappings"] = serialised
        schema_path.write_text(json.dumps(data, indent=2), encoding="utf8")

    def _write_asset_sb_manifest(self, project_path: Path, asset_map: Dict[str, Dict[str, Any]]):
        sb_path = project_path / "assets" / ASSET_TAG_SB_NAME
        lines = []
        for rel_path, meta in sorted(asset_map.items()):
            scenes = meta.get("scenes") or []
            scene_labels = self._format_scene_label(scenes) or "(untagged)"
            lines.append(f"{rel_path}: {scene_labels}")
        sb_path.write_text("\n".join(lines), encoding="utf8")

    def _format_scene_label(self, scenes: Optional[Iterable[str]]) -> str:
        if not scenes:
            return ""
        labels: List[str] = []
        for scene in scenes:
            if scene == GLOBAL_SCENE_TAG:
                labels.append("All Scenes")
            else:
                labels.append(scene)
        return ", ".join(labels)

    def _relative_from_project(self, path: Path) -> Optional[str]:
        if not self.selected_project:
            return None
        try:
            project_root = Path(self.selected_project["path"]).expanduser()
            return path.relative_to(project_root).as_posix()
        except (KeyError, ValueError, OSError):
            return None

    def _destination_for_relative(self, relative_path: str) -> str:
        normalized = relative_path.replace("\\", "/")
        for label, folder in ASSET_DESTINATIONS.items():
            prefix = folder.replace("\\", "/")
            if normalized.startswith(prefix):
                return label
        return "Misc"

    def _is_asset_ai_remixable(self, path: Path) -> bool:
        if not self.selected_project:
            return False
        if not path.exists() or not path.is_file():
            return False
        if path.suffix.lower() not in IMAGE_EXTENSIONS:
            return False
        relative = self._relative_from_project(path)
        return bool(relative and relative.startswith("assets/"))

    def _default_scenes_for_asset(
        self,
        relative_path: str,
        destination_key: str,
        available_scenes: Iterable[str],
    ) -> List[str]:
        lower_name = relative_path.lower()
        if any(token in lower_name for token in ("player", "hero", "shared", "global")):
            return [GLOBAL_SCENE_TAG]
        scenes = list(available_scenes)
        if not scenes:
            return [GLOBAL_SCENE_TAG]
        if destination_key == "Models" and any(token in lower_name for token in ("npc", "enemy", "boss")):
            return [scenes[0]]
        return []

    def _gather_project_scenes(self, project_path: Path) -> List[str]:
        scene_names: Set[str] = set()
        schema_path = project_path / "schemas" / "default_schema.json"
        if schema_path.exists():
            try:
                data = json.loads(schema_path.read_text(encoding="utf8"))
            except (OSError, json.JSONDecodeError):  # pragma: no cover - corrupted manual edit
                data = {}
            scenes = data.get("scenes")
            if isinstance(scenes, dict):
                scene_names.update(scenes.keys())
            elif isinstance(scenes, list):
                for item in scenes:
                    if isinstance(item, dict):
                        name = item.get("scene_name")
                        if isinstance(name, str):
                            scene_names.add(name)
        scenes_dir = project_path / "scenes"
        if scenes_dir.exists():
            for file in scenes_dir.glob("*.py"):
                scene_names.add(file.stem)
        ordered = sorted(scene_names)
        return ordered

    def _refresh_scene_tag_controls(self, scenes: Iterable[str]):
        if not hasattr(self, "asset_tag_container"):
            return
        for widget in self.asset_tag_container.winfo_children():
            widget.destroy()
        self.asset_scene_vars.clear()
        self.asset_tag_checkbuttons.clear()
        options = [GLOBAL_SCENE_TAG]
        for scene in scenes:
            if scene not in options:
                options.append(scene)
        if not options:
            options.append(GLOBAL_SCENE_TAG)
        num_columns = 2
        for index, scene in enumerate(options):
            var = tk.BooleanVar(value=False)
            self.asset_scene_vars[scene] = var
            label = "All Scenes" if scene == GLOBAL_SCENE_TAG else scene
            check = ttk.Checkbutton(
                self.asset_tag_container,
                text=label,
                variable=var,
                command=lambda key=scene: self._on_scene_tag_toggle(key),
            )
            row, col = divmod(index, num_columns)
            check.grid(row=row, column=col, sticky=tk.W, padx=4, pady=2)
            self.asset_tag_checkbuttons[scene] = check
        for col in range(num_columns):
            self.asset_tag_container.columnconfigure(col, weight=1)

    def _populate_scene_tags(self, scenes: Optional[Iterable[str]]):
        self._suppress_tag_updates = True
        active = set(scenes or [])
        for key, var in self.asset_scene_vars.items():
            if key == GLOBAL_SCENE_TAG:
                var.set(GLOBAL_SCENE_TAG in active or (not active))
            else:
                var.set(key in active)
        state = tk.NORMAL if scenes is not None else tk.DISABLED
        for check in self.asset_tag_checkbuttons.values():
            check.configure(state=state)
        self._suppress_tag_updates = False

    def _set_tag_status(self, message: str, *, error: bool = False):
        if not hasattr(self, "asset_tag_status"):
            return
        color = "#b3261e" if error else "#2d7a2d"
        self.asset_tag_status.configure(text=message, foreground=color)

    def _get_tree_thumbnail(self, path: Path) -> Optional[tk.PhotoImage]:
        if not path.exists() or not path.is_file():
            return None
        try:
            stat = path.stat()
            cache_key = f"{path}:{stat.st_mtime_ns}"
        except OSError:
            cache_key = str(path)
        if cache_key in self.asset_thumbnail_cache:
            return self.asset_thumbnail_cache[cache_key]
        extension = path.suffix.lower()
        image_obj: Optional[tk.PhotoImage] = None
        if extension in IMAGE_EXTENSIONS and Image is not None and ImageTk is not None:
            try:
                with Image.open(path) as image:
                    image = image.copy()
                image.thumbnail(THUMBNAIL_SIZE)
                image_obj = ImageTk.PhotoImage(image)
            except Exception:  # pragma: no cover - invalid image formats are skipped
                image_obj = None
        elif extension in MODEL_EXTENSIONS:
            image_obj = self._render_model_thumbnail(path)
        if image_obj is None:
            image_obj = self._placeholder_thumbnail()
        self.asset_thumbnail_cache[cache_key] = image_obj
        return image_obj

    def _placeholder_thumbnail(self) -> tk.PhotoImage:
        if Image is not None and ImageTk is not None:
            image = Image.new("RGBA", THUMBNAIL_SIZE, (52, 52, 68, 255))
            return ImageTk.PhotoImage(image)
        placeholder = tk.PhotoImage(width=THUMBNAIL_SIZE[0], height=THUMBNAIL_SIZE[1])
        return placeholder

    def _render_model_thumbnail(self, path: Path, size: Tuple[int, int] = THUMBNAIL_SIZE) -> Optional[tk.PhotoImage]:
        if ShowBase is None or Filename is None or PNMImage is None:
            return None
        try:
            base = self._ensure_thumbnailer()
        except Exception:  # pragma: no cover - Panda3D initialisation failure
            return None
        if base is None:
            return None
        try:
            model = base.loader.loadModel(str(path))
        except Exception:
            return None
        if model is None:
            return None
        root = base.render.attachNewNode("asset-thumb-root")
        model.reparentTo(root)
        model.setHpr(30, -10, 0)
        try:
            bounds = model.getTightBounds()
        except Exception:
            bounds = None
        center_x = center_y = center_z = 0.0
        radius = 2.0
        if bounds and len(bounds) == 2 and bounds[0] is not None and bounds[1] is not None:
            min_pt, max_pt = bounds
            center_x = (min_pt.x + max_pt.x) / 2.0
            center_y = (min_pt.y + max_pt.y) / 2.0
            center_z = (min_pt.z + max_pt.z) / 2.0
            radius = max(max_pt.x - min_pt.x, max_pt.y - min_pt.y, max_pt.z - min_pt.z) or 2.0
        base.cam.setPos(center_x, center_y - radius * 3.0, center_z + radius * 0.6)
        base.cam.lookAt(center_x, center_y, center_z)
        base.graphicsEngine.renderFrame()
        base.graphicsEngine.renderFrame()
        image = PNMImage()
        if not base.win.getScreenshot(image):
            root.removeNode()
            model.removeNode()
            return None
        with tempfile.NamedTemporaryFile(suffix=".png", delete=False) as tmp:
            temp_path = Path(tmp.name)
        try:
            filename = Filename.from_os_specific(str(temp_path))
            image.write(filename)
            if Image is not None and ImageTk is not None:
                with Image.open(temp_path) as buffer_image:
                    buffer_image = buffer_image.copy()
                buffer_image.thumbnail(size)
                photo = ImageTk.PhotoImage(buffer_image)
            else:
                photo = tk.PhotoImage(file=str(temp_path))
        except Exception:
            photo = None
        finally:
            try:
                temp_path.unlink()
            except OSError:
                pass
            root.removeNode()
            model.removeNode()
        return photo

    def _ensure_thumbnailer(self) -> Optional[ShowBase]:
        if self._model_thumbnailer is not None:
            return self._model_thumbnailer
        if ShowBase is None:
            return None
        try:
            loadPrcFileData("", "window-type offscreen")
            loadPrcFileData("", "audio-library-name null")
            base = ShowBase(windowType="offscreen")  # type: ignore[call-arg]
            base.setBackgroundColor(0.1, 0.1, 0.1, 1)
        except Exception:
            self._model_thumbnailer = None
            return None
        self._model_thumbnailer = base
        return base

    def _on_scene_tag_toggle(self, scene_key: str):
        if self._suppress_tag_updates or not self.selected_project:
            return
        selection = self.asset_tree.selection()
        if not selection:
            return
        item = selection[0]
        if self.asset_tree.set(item, "kind") != "file":
            return
        rel_path = self.asset_tree.set(item, "relpath")
        if not rel_path:
            return
        meta = self.asset_metadata.setdefault(rel_path, {})
        scenes = set(meta.get("scenes", []))
        desired_state = self.asset_scene_vars.get(scene_key)
        if desired_state is None:
            return
        if desired_state.get():
            if scene_key == GLOBAL_SCENE_TAG:
                scenes = {GLOBAL_SCENE_TAG}
            else:
                scenes.discard(GLOBAL_SCENE_TAG)
                scenes.add(scene_key)
        else:
            scenes.discard(scene_key)
        meta["scenes"] = sorted(scenes)
        if "destination" not in meta or not meta["destination"]:
            meta["destination"] = self._destination_for_relative(rel_path)
        now = datetime.now(UTC).isoformat()
        meta["updated_at"] = now
        try:
            project_path = Path(self.selected_project["path"]).expanduser()
        except KeyError:
            return
        try:
            self._save_asset_index(project_path, {"assets": self.asset_metadata})
            self._surface_asset_metadata(project_path, self.asset_metadata)
        except OSError as exc:  # pragma: no cover - disk permission issues
            self._set_tag_status(f"Unable to save tags: {exc}", error=True)
            return
        scenes_label = self._format_scene_label(meta.get("scenes"))
        self.asset_tree.set(item, "scenes", scenes_label)
        self._set_tag_status("Scene tags updated.")
        full_path = self.asset_tree.set(item, "fullpath")
        if full_path:
            self._display_asset_preview(Path(full_path))

    # ------------------------------------------------------------------
    # Asset import workflow
    # ------------------------------------------------------------------
    def _handle_import_assets(self):
        if not self._ensure_project_selected():
            return
        files = filedialog.askopenfilenames(title="Select assets")
        if not files:
            return
        destination_key = self.asset_destination_var.get()
        subdir = ASSET_DESTINATIONS[destination_key]
        project_path = Path(self.selected_project["path"]).expanduser()
        target = project_path / subdir
        target.mkdir(parents=True, exist_ok=True)

        available_scenes = self._gather_project_scenes(project_path)
        records = []
        copied = 0
        for file in files:
            src = Path(file)
            if not src.exists():
                continue
            dest = target / src.name
            try:
                shutil.copy2(src, dest)
            except OSError as exc:
                self.log(f"Failed to import {src.name}: {exc}")
                continue
            copied += 1
            relative_path = dest.relative_to(project_path).as_posix()
            default_scenes = self._default_scenes_for_asset(relative_path, destination_key, available_scenes)
            records.append(
                {
                    "relative_path": relative_path,
                    "destination": destination_key,
                    "scenes": default_scenes,
                    "source_path": str(src),
                    "timestamp": datetime.now(UTC).isoformat(),
                }
            )
        if records:
            self._update_asset_metadata(project_path, records)
        if copied:
            self.log(f"Copied {copied} asset(s) into {subdir}")
        else:
            self.log("No assets were imported.")
        self._refresh_asset_browser()

    def _refresh_asset_browser(self):
        if not hasattr(self, "asset_tree"):
            return

        self.asset_tree.delete(*self.asset_tree.get_children())
        self.asset_tree_images.clear()
        self.asset_thumbnail_cache.clear()

        if not self.selected_project:
            self.asset_metadata = {}
            self._scene_list = []
            self._refresh_scene_tag_controls([])
            self._clear_asset_preview("Select a project to browse assets.")
            return

        project_path = Path(self.selected_project["path"]).expanduser()
        index = self._load_asset_index(project_path)
        self.asset_metadata = index.get("assets", {})
        self._scene_list = self._gather_project_scenes(project_path)
        self._refresh_scene_tag_controls(self._scene_list)

        assets_root = project_path / "assets"
        if not assets_root.exists():
            self._clear_asset_preview("The selected project does not have an assets/ directory yet.")
            return

        for label, relative in ASSET_DESTINATIONS.items():
            directory = project_path / relative
            node = self.asset_tree.insert(
                "",
                "end",
                text=label,
                values=(str(directory), "dir", str(Path(relative)), ""),
                open=True,
            )
            if not directory.exists():
                continue
            children = sorted(
                directory.iterdir(),
                key=lambda path: (not path.is_dir(), path.name.lower()),
            )
            for child in children:
                rel_path = self._relative_from_project(child) or ""
                image = self._get_tree_thumbnail(child) if child.is_file() else None
                item = self.asset_tree.insert(
                    node,
                    "end",
                    text=child.name,
                    image=image,
                    values=(
                        str(child),
                        "file" if child.is_file() else "dir",
                        rel_path,
                        self._format_scene_label(
                            self.asset_metadata.get(rel_path, {}).get("scenes"),
                        ),
                    ),
                )
                if image is not None:
                    self.asset_tree_images[item] = image

        self._clear_asset_preview("Select an asset to preview.")
        self._set_tag_status("")

    def _clear_asset_preview(self, message: str = "Select an asset to preview."):
        if not hasattr(self, "asset_preview_title"):
            return

        self.asset_preview_title.configure(text=message)
        self.asset_preview_meta.configure(text="")
        self.asset_preview_canvas.configure(image="", text="")
        self.asset_preview_canvas.image = None
        self._asset_preview_image = None
        self._set_preview_text("")
        self._populate_scene_tags(None)
        self._current_asset_path = None
        if hasattr(self, "ai_remix_button"):
            self.ai_remix_button.configure(state=tk.DISABLED)

    def _select_asset_in_tree(self, target_path: Path):
        if not hasattr(self, "asset_tree"):
            return

        target = str(target_path)
        for parent in self.asset_tree.get_children(""):
            for item in self.asset_tree.get_children(parent):
                full_path = self.asset_tree.set(item, "fullpath")
                if full_path == target:
                    self.asset_tree.selection_set(item)
                    self.asset_tree.focus(item)
                    self.asset_tree.see(item)
                    return

    def _set_preview_text(self, text: str):
        if not hasattr(self, "asset_preview_text"):
            return
        self.asset_preview_text.configure(state=tk.NORMAL)
        self.asset_preview_text.delete("1.0", tk.END)
        if text:
            self.asset_preview_text.insert(tk.END, text)
        self.asset_preview_text.configure(state=tk.DISABLED)

    def _on_asset_selected(self, _event=None):
        if not hasattr(self, "asset_tree"):
            return
        selection = self.asset_tree.selection()
        if not selection:
            self._clear_asset_preview()
            return

        item = selection[0]
        path_str = self.asset_tree.set(item, "fullpath")
        kind = self.asset_tree.set(item, "kind")

        if not path_str:
            self._clear_asset_preview()
            return

        path = Path(path_str)

        if kind != "file":
            message = f"Folder: {path.name}" if path.exists() else "Folder not found."
            self._clear_asset_preview(message)
            return

        if not path.exists():
            self._clear_asset_preview("Asset not found on disk.")
            return

        self._display_asset_preview(path)

    def _display_asset_preview(self, path: Path):
        self.asset_preview_title.configure(text=path.name)
        self._current_asset_path = path
        if hasattr(self, "ai_remix_button"):
            state = tk.NORMAL if self._is_asset_ai_remixable(path) else tk.DISABLED
            self.ai_remix_button.configure(state=state)

        try:
            stat = path.stat()
            size_text = self._format_file_size(stat.st_size)
            modified = datetime.fromtimestamp(stat.st_mtime).strftime("%Y-%m-%d %H:%M:%S")
        except OSError:
            size_text = "Unknown"
            modified = "Unknown"

        suffix = path.suffix.lower() or "Unknown"

        relative_path = path.name
        rel_key = self._relative_from_project(path)
        if rel_key:
            relative_path = rel_key
        meta_lines = [
            f"Path: {relative_path}",
            f"Type: {suffix.lstrip('.') or 'Unknown'}",
            f"Size: {size_text}",
            f"Modified: {modified}",
        ]
        metadata_key = (rel_key or relative_path).replace("\\", "/")
        metadata = self.asset_metadata.get(metadata_key, {})
        scenes = metadata.get("scenes")
        if scenes:
            meta_lines.append(f"Scenes: {self._format_scene_label(scenes)}")
        imported_at = metadata.get("imported_at") or metadata.get("timestamp")
        if imported_at:
            meta_lines.append(f"Imported: {imported_at}")
        source_path = metadata.get("source_path")
        if source_path:
            meta_lines.append(f"Source: {source_path}")
        latest_version = metadata.get("latest_version")
        if latest_version:
            meta_lines.append(f"Latest Version: {latest_version}")
        cache_entry = metadata.get("cache")
        if isinstance(cache_entry, dict) and cache_entry.get("id"):
            meta_lines.append(f"Cache ID: {cache_entry['id']}")
        self.asset_preview_meta.configure(text="\n".join(meta_lines))
        self._populate_scene_tags(scenes or [])

        extension = path.suffix.lower()

        if extension in IMAGE_EXTENSIONS:
            preview = self._load_image_preview(path)
            if preview is not None:
                self._asset_preview_image = preview
                self.asset_preview_canvas.configure(image=preview, text="")
                self.asset_preview_canvas.image = preview
                self._set_preview_text("")
                return
            self._set_preview_text("Unable to load image preview.")
            self.asset_preview_canvas.configure(image="", text="")
            self.asset_preview_canvas.image = None
            return

        if extension in MODEL_EXTENSIONS:
            preview = self._render_model_thumbnail(path, size=(320, 240))
            if preview is not None:
                self._asset_preview_image = preview
                self.asset_preview_canvas.configure(image=preview, text="")
                self.asset_preview_canvas.image = preview
                self._set_preview_text("")
                return

        self.asset_preview_canvas.configure(image="", text="")
        self.asset_preview_canvas.image = None

        if extension in TEXT_EXTENSIONS:
            try:
                text = path.read_text(encoding="utf8", errors="replace")
            except OSError as err:
                self._set_preview_text(f"Unable to read file: {err}")
                return
            snippet = text[:4000]
            if len(text) > len(snippet):
                snippet += "\n\n… (truncated)"
            self._set_preview_text(snippet)
            return

        if extension in AUDIO_EXTENSIONS:
            self._set_preview_text(self._summarize_audio(path))
            return

        self._set_preview_text("Preview not available for this file type.")

    def _handle_ai_remix(self):
        if not self._ensure_project_selected():
            return

        if not hasattr(self, "ai_remix_button"):
            return

        path = self._current_asset_path
        if not path or not Path(path).exists():
            messagebox.showerror("Game Creator", "Select an asset to remix first.")
            self.ai_remix_button.configure(state=tk.DISABLED)
            return

        source_path = Path(path)
        if not self._is_asset_ai_remixable(source_path):
            messagebox.showinfo("Game Creator", "The selected asset cannot be remixed.")
            self.ai_remix_button.configure(state=tk.DISABLED)
            return

        prompt = simpledialog.askstring(
            "AI Remix",
            "Describe how you'd like to remix this texture (leave blank for default).",
            parent=self,
        )
        if prompt is None:
            return

        project_path = Path(self.selected_project["path"]).expanduser()
        relative = self._relative_from_project(source_path) or source_path.name
        base_candidate = Path(relative)
        match = re.match(r"(?P<stem>.+)_v\d+$", base_candidate.stem)
        if match:
            base_relative = base_candidate.with_name(match.group("stem") + base_candidate.suffix).as_posix()
        else:
            base_relative = base_candidate.as_posix()

        metadata = self.asset_metadata.get(base_relative, {})
        scene_tags = metadata.get("scenes") or []
        label = metadata.get("label") or base_candidate.stem.replace("_", " ").title()
        destination = metadata.get("destination") or self._destination_for_relative(base_relative)

        self.ai_remix_button.configure(state=tk.DISABLED)
        self.log(f"Remixing asset '{base_relative}' via image pipeline...")

        try:
            result = remix_texture(
                source_path,
                prompt=prompt or metadata.get("description"),
                scene_tags=scene_tags,
            )
        except FileNotFoundError:
            messagebox.showerror("Game Creator", "The source asset was not found on disk.")
            self.log("AI remix failed: source asset missing.")
            return
        except Exception as exc:  # pragma: no cover - environment dependent
            messagebox.showerror("Game Creator", f"Failed to remix asset: {exc}")
            self.log(f"AI remix failed: {exc}")
            return

        base_path = result.base_path
        version_path = result.version_path
        base_rel = self._relative_from_project(base_path) or base_path.name
        version_rel = self._relative_from_project(version_path) or version_path.name

        versions = list(metadata.get("versions") or [])
        if version_rel not in versions:
            versions.append(version_rel)
        scenes = sorted({scene for scene in scene_tags if scene}) or [GLOBAL_SCENE_TAG]

        record = {
            "relative_path": base_rel,
            "destination": destination,
            "label": label,
            "description": metadata.get("description") or (prompt or label),
            "scenes": scenes,
            "source_path": str(base_path),
            "latest_version": version_rel,
            "versions": versions,
            "timestamp": result.metadata.get("generated_at"),
            "cache": result.cache_entry,
        }

        self._update_asset_metadata(project_path, [record])
        cache_id = (result.cache_entry or {}).get("id") if result.cache_entry else None
        if cache_id:
            self.log(
                f"AI remix saved as {version_rel}. Cache entry: {cache_id}."
            )
        else:
            self.log(f"AI remix saved as {version_rel}.")

        self._refresh_asset_browser()
        self.after(200, lambda: self._select_asset_in_tree(base_path))

    def _load_image_preview(self, path: Path):
        try:
            if Image is not None and ImageTk is not None:
                with Image.open(path) as image:
                    image = image.copy()
                image.thumbnail((320, 240))
                return ImageTk.PhotoImage(image)
            return tk.PhotoImage(file=str(path))
        except Exception:
            return None

    def _format_file_size(self, size: int) -> str:
        step = 1024.0
        units = ["B", "KB", "MB", "GB", "TB"]
        value = float(size)
        for unit in units:
            if value < step or unit == units[-1]:
                return f"{value:.1f} {unit}"
            value /= step
        return f"{size} B"

    def _summarize_audio(self, path: Path) -> str:
        if path.suffix.lower() != ".wav":
            return (
                "Audio preview not available. Use an external player to audition this file."
            )
        try:
            with contextlib.closing(wave.open(str(path), "rb")) as wav_file:
                frames = wav_file.getnframes()
                rate = wav_file.getframerate() or 1
                duration = frames / float(rate)
                channels = wav_file.getnchannels()
                sample_width = wav_file.getsampwidth() * 8
        except (wave.Error, OSError) as err:
            return f"Unable to read WAV metadata: {err}"

        return (
            "Audio preview not available.\n"
            f"Duration: {duration:.2f} s\n"
            f"Sample rate: {rate} Hz\n"
            f"Channels: {channels}\n"
            f"Bit depth: {sample_width}-bit"
        )

    # ------------------------------------------------------------------
    # Helpers
    # ------------------------------------------------------------------
    def _ensure_project_selected(self) -> bool:
        if not self.selected_project:
            messagebox.showinfo("Game Creator", "Select a project on the left first.")
            return False
        path = Path(self.selected_project["path"]).expanduser()
        if not path.exists():
            messagebox.showerror(
                "Game Creator",
                "The selected project folder cannot be found. Remove it from the registry and create it again.",
            )
            return False
        return True

    def _load_blender_settings_from_registry(self) -> Dict[str, str]:
        meta = self.registry.get("meta", {})
        if not isinstance(meta, dict):
            meta = {}
        stored = meta.get("blender") if isinstance(meta, dict) else {}
        if not isinstance(stored, dict):
            stored = {}
        executable = stored.get("executable") or os.environ.get("BLENDER_PATH", "")
        addon_path = stored.get("addon_path") or str(BLENDER_ADDON_ROOT)
        return {"executable": str(executable or ""), "addon_path": str(addon_path or "")}

    def _browse_blender_executable(self):  # pragma: no cover - opens file dialog
        path = filedialog.askopenfilename(title="Select Blender Executable")
        if path:
            self.blender_path_var.set(path)

    def _browse_blender_addon_path(self):  # pragma: no cover - opens file dialog
        path = filedialog.askdirectory(title="Select Add-on Folder")
        if path:
            self.blender_addon_var.set(path)

    def _save_blender_settings(self):
        meta = self.registry.setdefault("meta", {})
        if not isinstance(meta, dict):
            meta = {}
            self.registry["meta"] = meta
        meta["blender"] = {
            "executable": self.blender_path_var.get().strip(),
            "addon_path": self.blender_addon_var.get().strip(),
        }
        self._save_registry()
        self.log("Blender settings saved.")
        self._refresh_blender_tab_state()

    def _refresh_blender_tab_state(self):
        has_project = bool(self.selected_project)
        project_details = "Choose a project to enable Blender integration."
        scenes: List[str] = []
        if self.selected_project:
            try:
                project_path = Path(self.selected_project["path"]).expanduser()
            except KeyError:
                project_path = None
            else:
                if project_path.exists():
                    scenes = self._gather_project_scenes(project_path)
                    dest_lines = [f"{label}: {folder}" for label, folder in ASSET_DESTINATIONS.items()]
                    scene_text = ", ".join(scenes) if scenes else "None discovered"
                    project_details = f"Scenes: {scene_text}\nDestinations: {', '.join(dest_lines)}"
                    self.blender_project_var.set(
                        f"{self.selected_project.get('title', 'Project')} — {project_path}"
                    )
                else:
                    project_details = "Project path is missing on disk."
                    self.blender_project_var.set("Project path unavailable.")
                    has_project = False
        else:
            self.blender_project_var.set("No project selected.")

        if self.blender_project_details is not None:
            self.blender_project_details.configure(text=project_details)

        blender_exec = self.blender_path_var.get().strip()
        addon_path = Path(self.blender_addon_var.get().strip() or "")
        quick_script = addon_path / "quick_actions.py"
        has_exec = bool(blender_exec)
        has_addon = addon_path.exists() and quick_script.exists()

        if self.blender_launch_button is not None:
            self.blender_launch_button.configure(
                state=tk.NORMAL if has_project and has_exec else tk.DISABLED
            )

        for button in self.blender_quick_action_buttons.values():
            button.configure(
                state=tk.NORMAL if has_project and has_exec and has_addon else tk.DISABLED
            )

        messages: List[str] = []
        if not has_exec:
            messages.append("Set the Blender executable path.")
        if not has_addon:
            messages.append("Select a folder containing quick_actions.py.")
        if not has_project:
            messages.append("Choose a project to enable exports.")
        if messages:
            self.blender_status_var.set(" • ".join(messages))
        else:
            self.blender_status_var.set("Ready to launch Blender or run quick actions.")

    def _build_blender_environment(self, project_path: Path, addon_path: Path) -> Dict[str, str]:
        env = os.environ.copy()
        env["BLENDER_ADDON_PATH"] = str(addon_path)
        env[BLENDER_PROJECT_ENV] = str(project_path)
        env[BLENDER_SCENES_ENV] = json.dumps(self._gather_project_scenes(project_path))
        env[BLENDER_DESTINATIONS_ENV] = json.dumps(ASSET_DESTINATIONS)
        return env

    def _launch_blender(self):  # pragma: no cover - launches external application
        if not self._ensure_project_selected():
            return
        blender_exec = self.blender_path_var.get().strip()
        if not blender_exec:
            messagebox.showerror("Game Creator", "Set the Blender executable path first.")
            return
        addon_path = Path(self.blender_addon_var.get().strip() or str(BLENDER_ADDON_ROOT))
        project_path = Path(self.selected_project["path"]).expanduser()
        env = self._build_blender_environment(project_path, addon_path)
        try:
            subprocess.Popen([blender_exec], env=env, cwd=project_path)
        except FileNotFoundError:
            messagebox.showerror("Game Creator", "Blender executable was not found.")
            self.log("Failed to launch Blender; executable missing.")
            return
        except Exception as exc:  # pragma: no cover - external process failure
            messagebox.showerror("Game Creator", f"Failed to launch Blender: {exc}")
            self.log(f"Failed to launch Blender: {exc}")
            return
        self.log("Launched Blender with project context.")

    def _run_blender_quick_action(self, action: str):
        if not self._ensure_project_selected():
            return
        blender_exec = self.blender_path_var.get().strip()
        if not blender_exec:
            messagebox.showerror("Game Creator", "Set the Blender executable path first.")
            return
        addon_path = Path(self.blender_addon_var.get().strip() or str(BLENDER_ADDON_ROOT))
        script_path = addon_path / "quick_actions.py"
        if not script_path.exists():
            messagebox.showerror("Game Creator", "quick_actions.py was not found in the add-on folder.")
            return
        project_path = Path(self.selected_project["path"]).expanduser()
        env = self._build_blender_environment(project_path, addon_path)
        env[BLENDER_ACTION_ENV] = action
        with tempfile.NamedTemporaryFile(delete=False, suffix=".json") as tmp:
            result_path = Path(tmp.name)
        env[BLENDER_RESULT_ENV] = str(result_path)
        command = [blender_exec, "--background", "--factory-startup", "--python", str(script_path)]
        try:
            subprocess.run(
                command,
                check=True,
                capture_output=True,
                text=True,
                cwd=project_path,
                env=env,
            )
        except FileNotFoundError:
            messagebox.showerror("Game Creator", "Blender executable was not found.")
            self.log("Quick action failed; Blender executable missing.")
            try:
                result_path.unlink()
            except OSError:
                pass
            return
        except subprocess.CalledProcessError as exc:
            stderr = exc.stderr.strip() if exc.stderr else ""
            stdout = exc.stdout.strip() if exc.stdout else ""
            error_text = stderr or stdout or str(exc)
            messagebox.showerror("Game Creator", f"Blender quick action failed: {error_text}")
            self.log(f"Quick action '{action}' failed: {error_text}")
            try:
                result_path.unlink()
            except OSError:
                pass
            return

        try:
            raw = result_path.read_text(encoding="utf8") if result_path.exists() else ""
        except OSError:
            raw = ""
        finally:
            try:
                result_path.unlink()
            except OSError:
                pass

        payload: Dict[str, Any] = {}
        if raw:
            try:
                payload = json.loads(raw)
            except json.JSONDecodeError:
                payload = {}

        error_text = payload.get("error") if isinstance(payload, dict) else None
        assets = payload.get("assets") if isinstance(payload, dict) else None
        if error_text:
            messagebox.showerror("Game Creator", f"Blender quick action reported an error: {error_text}")
            self.log(f"Quick action '{action}' error: {error_text}")
            self._refresh_blender_tab_state()
            return

        records: List[Dict[str, Any]] = []
        if isinstance(assets, list):
            for entry in assets:
                if isinstance(entry, dict):
                    records.append(entry)

        if records:
            self._update_asset_metadata(project_path, records)
            self.log(
                f"Blender quick action '{action}' completed and registered {len(records)} asset(s)."
            )
        else:
            self.log(f"Blender quick action '{action}' completed with no new assets.")
        self._refresh_asset_browser()
        self._refresh_blender_tab_state()

    # ------------------------------------------------------------------
    # Background worker callback
    # ------------------------------------------------------------------
    def _on_worker_finished(self, error: Optional[Exception] = None):
        if error:
            messagebox.showerror("Game Creator", str(error))
            self.log(f"Task failed: {error}")
        else:
            self.log(f"{self._current_task} — done")
            self._refresh_project_list()
        self._current_task = ""


def main():  # pragma: no cover - interactive entry point
    app = GameCreatorApp()
    app.mainloop()


if __name__ == "__main__":  # pragma: no cover - interactive entry point
    main()
class AIBootstrapDialog(tk.Toplevel):
    """Modal dialog that captures AI bootstrap briefing details."""

    def __init__(
        self,
        parent: tk.Misc,
        *,
        archetypes: List[Dict[str, Any]],
        initial_brief: Optional[Dict[str, Any]] = None,
    ):
        super().__init__(parent)
        self.title("AI Bootstrap")
        self.resizable(False, False)
        self.transient(parent)
        self.grab_set()
        self.result: Optional[Dict[str, Any]] = None
        self._archetypes = archetypes

        container = ttk.Frame(self, padding=16)
        container.grid(row=0, column=0, sticky=tk.NSEW)

        ttk.Label(container, text="Concept Summary").grid(row=0, column=0, sticky=tk.W)
        self.summary_text = tk.Text(container, width=52, height=4, wrap=tk.WORD)
        self.summary_text.grid(row=1, column=0, columnspan=2, sticky=tk.EW)

        ttk.Label(container, text="Tone / Mood").grid(row=2, column=0, sticky=tk.W, pady=(12, 0))
        self.tone_var = tk.StringVar()
        ttk.Entry(container, textvariable=self.tone_var).grid(row=3, column=0, sticky=tk.EW)

        ttk.Label(container, text="Key Pillars (one per line)").grid(row=2, column=1, sticky=tk.W, pady=(12, 0))
        self.features_text = tk.Text(container, width=28, height=5, wrap=tk.WORD)
        self.features_text.grid(row=3, column=1, rowspan=2, sticky=tk.EW)

        ttk.Label(container, text="Archetype").grid(row=4, column=0, sticky=tk.W, pady=(12, 0))
        self.archetype_var = tk.StringVar()
        combo = ttk.Combobox(
            container,
            values=[item["name"] for item in archetypes],
            textvariable=self.archetype_var,
            state="readonly",
        )
        combo.grid(row=5, column=0, sticky=tk.EW)
        combo.bind("<<ComboboxSelected>>", self._on_archetype_change)

        self.guidance_label = ttk.Label(
            container,
            text="Select an archetype to tailor the generated plan.",
            wraplength=320,
            justify=tk.LEFT,
        )
        self.guidance_label.grid(row=6, column=0, columnspan=2, sticky=tk.W, pady=(12, 0))

        button_row = ttk.Frame(container)
        button_row.grid(row=7, column=0, columnspan=2, sticky=tk.E, pady=(16, 0))
        ttk.Button(button_row, text="Cancel", command=self._on_cancel).pack(side=tk.RIGHT)
        ttk.Button(button_row, text="Continue", command=self._on_continue).pack(side=tk.RIGHT, padx=(0, 8))

        container.columnconfigure(0, weight=1)
        container.columnconfigure(1, weight=1)

        self.protocol("WM_DELETE_WINDOW", self._on_cancel)
        self._populate_defaults(initial_brief)

    def _populate_defaults(self, brief: Optional[Dict[str, Any]]):
        summary = (brief or {}).get("summary") or ""
        tone = (brief or {}).get("tone") or ""
        features = brief.get("features") if brief else []
        archetype_id = (brief or {}).get("archetype_id")

        if summary:
            self.summary_text.insert("1.0", summary)
        if tone:
            self.tone_var.set(tone)
        if features:
            self.features_text.insert("1.0", "\n".join(features))

        archetype_name = None
        if archetype_id:
            for item in self._archetypes:
                if item.get("id") == archetype_id:
                    archetype_name = item.get("name")
                    break
        if not archetype_name and self._archetypes:
            archetype_name = self._archetypes[0]["name"]
        if archetype_name:
            self.archetype_var.set(archetype_name)
        self._update_guidance(archetype_name)

    def _on_continue(self):
        features = [line.strip() for line in self.features_text.get("1.0", tk.END).splitlines() if line.strip()]
        archetype_name = self.archetype_var.get()
        archetype_id = None
        archetype_data: Optional[Dict[str, Any]] = None
        for item in self._archetypes:
            if item.get("name") == archetype_name:
                archetype_id = item.get("id")
                archetype_data = copy.deepcopy(item)
                break
        if archetype_id is None and self._archetypes:
            archetype_id = self._archetypes[0]["id"]
            archetype_data = copy.deepcopy(self._archetypes[0])

        self.result = {
            "summary": self.summary_text.get("1.0", tk.END).strip(),
            "tone": self.tone_var.get().strip(),
            "features": features,
            "archetype_id": archetype_id,
            "archetype": archetype_data,
        }
        self.destroy()

    def _on_cancel(self):
        self.result = None
        self.destroy()

    def _on_archetype_change(self, _event=None):
        self._update_guidance(self.archetype_var.get())

    def _update_guidance(self, archetype_name: Optional[str]):
        if not archetype_name:
            self.guidance_label.configure(text="Select an archetype to tailor the generated plan.")
            return
        selected = None
        for item in self._archetypes:
            if item.get("name") == archetype_name:
                selected = item
                break
        if not isinstance(selected, dict):
            self.guidance_label.configure(text="Select an archetype to tailor the generated plan.")
            return

        details: List[str] = []
        description = str(selected.get("description") or "").strip()
        if description:
            details.append(description)
        scenes = list(iter_default_scenes(selected))
        if scenes:
            scene_names = ", ".join(spec["scene_name"] for spec in scenes)
            details.append(f"Default scenes: {scene_names}.")
        toggles = selected.get("config_toggles")
        if isinstance(toggles, dict) and toggles:
            enabled = [key.replace("_", " ").title() for key, value in toggles.items() if value]
            disabled = [key.replace("_", " ").title() for key, value in toggles.items() if not value]
            if enabled:
                details.append("Enables: " + ", ".join(sorted(enabled)) + ".")
            if disabled:
                details.append("Disables: " + ", ".join(sorted(disabled)) + ".")
        tags = selected.get("asset_tags")
        if isinstance(tags, Iterable) and not isinstance(tags, (str, bytes)) and tags:
            details.append("Asset tags: " + ", ".join(str(tag) for tag in tags) + ".")

        if not details:
            details.append("Select an archetype to tailor the generated plan.")
        self.guidance_label.configure(text="\n".join(details))

    def show(self) -> Optional[Dict[str, Any]]:
        self.wait_window(self)
        return self.result
```

Game Creator GUI for scaffolding new Panda3D projects.

This tool is meant to live at the root of the template repository. It gives
artists and designers a point-and-click workflow for duplicating the starter
kit into a fresh folder, renaming metadata, scaffolding scenes, and importing
assets without needing to touch the command line.
**Classes:** SceneTemplateSpec, Worker, Tooltip, GameCreatorApp, AIBootstrapDialog
**Functions:** main()



---
**Generation Parameters**


```text

You are an expert software engineer.  Carefully read every
file under the target directory (skipping any virtual environment
folders) and produce a comprehensive, well‑structured README in
Markdown.  Focus most of your attention on Python (.py) files: parse
their module‑level docstrings, enumerate classes and functions, and
describe what each does.  Summarise the purpose of non‑Python files
(such as JSON, YAML, text, images) briefly.  Provide an overview of
the project architecture and any dependencies you can infer from the
code.  Include usage notes or examples where appropriate.  Do not
invent information – base your summary solely on the source content.
Use headings, subheadings and lists to organise the README.

```